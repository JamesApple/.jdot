priority -50

# THIS FILE IS AUTOMATED GENERATED, PLEASE DON'T MODIFY BY HAND

snippet bundler "Manage Ruby Gem dependencies with Bundler" b
bundler: >
	executable=${1:# The path to the bundler executable}
	state=${2:#present|latest}
	chdir=${3:temporary working directory}
	exclude_groups=${4:# A list of Gemfile groups to exclude during operations. This only applies when state is C(present). Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if C(exclude_groups) is not set}
	clean=${5:no}
	gemfile=${6:Gemfile in current directory}
	local=${7:no}
	deployment_mode=${8:no}
	user_install=${9:yes}
	gem_path=${10:RubyGems gem paths}
	binstub_directory=${11:# Only applies if state is C(present). Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If C(chdir) is set then this path is relative to C(chdir)}
	extra_args=${12:# A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information}

endsnippet

snippet pip_package_info "pip package information" b
pip_package_info: >
	clients=${1:['pip']}

endsnippet

snippet easy_install "Installs Python libraries" b
easy_install: >
	name=${1:# A Python library name}

	virtualenv=${2:# an optional I(virtualenv) directory path to install into. If the I(virtualenv) does not exist, it is created automatically}
	virtualenv_site_packages=${3:no}
	virtualenv_command=${4:virtualenv}
	executable=${5:# The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example C(easy_install-3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.}
	state=${6:#present|latest}

endsnippet

snippet composer "Dependency Manager for PHP" b
composer: >
	command=${1:install}
	arguments=${2:# Composer arguments like required package, version and so on.}
	executable=${3:# Path to PHP Executable on the remote host, if PHP is not in PATH.}
	working_dir=${4:# Directory of your project (see --working-dir). This is required when the command is not run globally.}
	global_command=${5:no}
	prefer_source=${6:no}
	prefer_dist=${7:no}
	no_dev=${8:yes}
	no_scripts=${9:no}
	no_plugins=${10:no}
	optimize_autoloader=${11:yes}
	classmap_authoritative=${12:no}
	apcu_autoloader=${13:no}
	ignore_platform_reqs=${14:no}

endsnippet

snippet maven_artifact "Downloads an Artifact from a Maven Repository" b
maven_artifact: >
	group_id=${1:# The Maven groupId coordinate}
	artifact_id=${2:# The maven artifactId coordinate}
	dest=${3:# The path where the artifact should be written to}

	version=${4:latest}
	classifier=${5:# The maven classifier coordinate}
	extension=${6:jar}
	repository_url=${7:http://repo1.maven.org/maven2}
	username=${8:# The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3}
	password=${9:# The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3}
	headers=${10:# Add custom HTTP headers to a request in hash/dict format.}
	state=${11:#present|absent}
	timeout=${12:10}
	validate_certs=${13:yes}
	keep_name=${14:no}
	verify_checksum=${15:never|#download|change|always}
	mode=${16:# The permissions the resulting file or directory should have.}
	owner=${17:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${18:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${19:# The user part of the SELinux file context.}
	serole=${20:# The role part of the SELinux file context.}
	setype=${21:# The type part of the SELinux file context.}
	selevel=${22:s0}
	unsafe_writes=${23:no}
	attributes=${24:# The attributes the resulting file or directory should have.}

endsnippet

snippet npm "Manage node.js packages with npm" b
npm: >
	name=${1:# The name of a node.js library to install}
	path=${2:# The base path where to install the node.js libraries}
	version=${3:# The version to be installed}
	global=${4:no}
	executable=${5:# The executable location for npm.}
	ignore_scripts=${6:no}
	unsafe_perm=${7:no}
	ci=${8:no}
	production=${9:no}
	registry=${10:# The registry to install modules from.}
	state=${11:#present|absent|latest}

endsnippet

snippet yarn "Manage node.js packages with Yarn" b
yarn: >
	name=${1:# The name of a node.js library to install}
	path=${2:# The base path where Node.js libraries will be installed.}
	version=${3:# The version of the library to be installed.}
	global=${4:no}
	executable=${5:# The executable location for yarn.}
	ignore_scripts=${6:no}
	production=${7:no}
	registry=${8:# The registry to install modules from.}
	state=${9:#present|absent|latest}

endsnippet

snippet bower "Manage bower packages with bower" b
bower: >
	path=${1:# The base path where to install the bower packages}

	name=${2:# The name of a bower package to install}
	offline=${3:no}
	production=${4:no}
	relative_execpath=${5:# Relative path to bower executable from install path}
	state=${6:#present|absent|latest}
	version=${7:# The version to be installed}

endsnippet

snippet pear "Manage pear/pecl packages" b
pear: >
	name=${1:# Name of the package to install, upgrade, or remove.}

	state=${2:#present|absent|latest}
	executable=${3:# Path to the pear executable}

endsnippet

snippet cpanm "Manages Perl library dependencies." b
cpanm: >
	name=${1:# The name of the Perl library to install. You may use the "full distribution path", e.g.  MIYAGAWA/Plack-0.99_05.tar.gz}
	from_path=${2:# The local directory from where to install}
	notest=${3:no}
	locallib=${4:# Specify the install base to install modules}
	mirror=${5:# Specifies the base URL for the CPAN mirror to use}
	mirror_only=${6:no}
	installdeps=${7:no}
	version=${8:# minimum version of perl module to consider acceptable}
	system_lib=${9:no}
	executable=${10:# Override the path to the cpanm executable}

endsnippet

snippet pip "Manages Python library dependencies" b
pip: >
	name=${1:# The name of a Python library to install or the url(bzr+,hg+,git+,svn+) of the remote package.}
	version=${2:# The version number to install of the Python library specified in the I(name) parameter.}
	requirements=${3:# The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.}
	virtualenv=${4:# An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.}
	virtualenv_site_packages=${5:no}
	virtualenv_command=${6:virtualenv}
	virtualenv_python=${7:# The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module.}
	state=${8:absent|forcereinstall|latest|#present}
	extra_args=${9:# Extra arguments passed to pip.}
	editable=${10:no}
	chdir=${11:# cd into this directory before running the command}
	executable=${12:# The explicit executable or pathname for the pip executable, if different from the Ansible Python interpreter. For example C(pip3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation.}
	umask=${13:# The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., "0077") and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode as an octal string, (e.g., "0022").}

endsnippet

snippet gem "Manage Ruby gems" b
gem: >
	name=${1:# The name of the gem to be managed.}

	state=${2:#present|absent|latest}
	gem_source=${3:# The path to a local gem used as installation source.}
	include_dependencies=${4:yes}
	repository=${5:# The repository from which the gem will be installed}
	user_install=${6:yes}
	executable=${7:# Override the path to the gem executable}
	install_dir=${8:# Install the gems into a specific directory. These gems will be independent from the global installed ones. Specifying this requires user_install to be false.}
	env_shebang=${9:no}
	version=${10:# Version of the gem to be installed/removed.}
	pre_release=${11:no}
	include_doc=${12:no}
	build_flags=${13:# Allow adding build flags for gem compilation}
	force=${14:no}

endsnippet

snippet package "Generic OS package manager" b
package: >
	name=${1:# Package name, or package specifier with version.}
	state=${2:# Whether to install (C(present)), or remove (C(absent)) a package.}

	use=${3:auto}

endsnippet

snippet xbps "Manage packages with XBPS" b
xbps: >
	name=${1:# Name of the package to install, upgrade, or remove.}
	state=${2:#present|absent|latest}
	recurse=${3:no}
	update_cache=${4:yes}
	upgrade=${5:no}

endsnippet

snippet pkgutil "Manage CSW-Packages on Solaris" b
pkgutil: >
	name=${1:# Package name, e.g. (C(CSWnrpe))}
	state=${2:present|absent|latest}

	site=${3:# Specifies the repository path to install the package from.}
	update_catalog=${4:no}

endsnippet

snippet pacman "Manage packages with I(pacman)" b
pacman: >
	name=${1:# Name or list of names of the package(s) or file(s) to install, upgrade, or remove. Can't be used in combination with C(upgrade).}
	state=${2:absent|latest|#present}
	recurse=${3:no}
	force=${4:no}
	extra_args=${5:# Additional option to pass to pacman when enforcing C(state).}
	update_cache=${6:no}
	update_cache_extra_args=${7:# Additional option to pass to pacman when enforcing C(update_cache).}
	upgrade=${8:no}
	upgrade_extra_args=${9:# Additional option to pass to pacman when enforcing C(upgrade).}

endsnippet

snippet pulp_repo "Add or remove Pulp repos from a remote host." b
pulp_repo: >
	name=${1:# Name of the repo to add or remove. This correlates to repo-id in Pulp.}
	relative_url=${2:# Relative URL for the local repository.}

	add_export_distributor=${3:no}
	feed=${4:# Upstream feed URL to receive updates from.}
	force_basic_auth=${5:no}
	generate_sqlite=${6:no}
	feed_ca_cert=${7:# CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file. The ca_cert alias will be removed in Ansible 2.14.}
	feed_client_cert=${8:# Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.}
	feed_client_key=${9:# Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.}
	proxy_host=${10:# Proxy url setting for the pulp repository importer. This is in the format scheme://host.}
	proxy_port=${11:# Proxy port setting for the pulp repository importer.}
	proxy_username=${12:# Proxy username for the pulp repository importer.}
	proxy_password=${13:# Proxy password for the pulp repository importer.}
	publish_distributor=${14:# Distributor to use when state is C(publish). The default is to publish all distributors.}
	pulp_host=${15:http://127.0.0.1}
	repo_type=${16:rpm}
	repoview=${17:no}
	serve_http=${18:no}
	serve_https=${19:yes}
	state=${20:#present|absent|sync|publish}
	url_password=${21:# The password for use in HTTP basic authentication to the pulp API. If the I(url_username) parameter is not specified, the I(url_password) parameter will not be used.}
	url_username=${22:# The username for use in HTTP basic authentication to the pulp API.}
	validate_certs=${23:yes}
	wait_for_completion=${24:no}
	url=${25:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	force=${26:no}
	http_agent=${27:ansible-httpget}
	use_proxy=${28:yes}
	client_cert=${29:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${30:# PEM formatted file that contains your private key to be used for SSL client authentication.}

endsnippet

snippet pkgng "Package manager for FreeBSD >= 9.0" b
pkgng: >
	name=${1:# Name or list of names of packages to install/remove.}

	state=${2:#present|latest|absent}
	cached=${3:no}
	annotation=${4:# A comma-separated list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A C(+) denotes adding an annotation, a C(-) denotes removing an annotation, and C(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided.}
	pkgsite=${5:# For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).}
	rootdir=${6:# For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.}
	chroot=${7:# Pkg will chroot in the specified environment.}
	jail=${8:# Pkg will execute in the given jail name or id.}
	autoremove=${9:no}

endsnippet

snippet zypper "Manage packages on SUSE and openSUSE" b
zypper: >
	name=${1:# Package name C(name) or package specifier or a list of either.}

	state=${2:#present|latest|absent|dist-upgrade}
	type=${3:#package|patch|pattern|product|srcpackage|application}
	extra_args_precommand=${4:# Add additional global target options to C(zypper).}
	disable_gpg_check=${5:no}
	disable_recommends=${6:yes}
	force=${7:no}
	update_cache=${8:no}
	oldpackage=${9:no}
	extra_args=${10:# Add additional options to C(zypper) command.}

endsnippet

snippet apt_repo "Manage APT repositories via apt-repo" b
apt_repo: >
	repo=${1:# Name of the repository to add or remove.}

	state=${2:absent|#present}
	remove_others=${3:no}
	update=${4:no}

endsnippet

snippet apt_repository "Add and remove APT repositories" b
apt_repository: >
	repo=${1:# A source string for the repository.}

	state=${2:absent|#present}
	mode=${3:0644}
	update_cache=${4:yes}
	validate_certs=${5:yes}
	filename=${6:# Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.}
	codename=${7:# Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (e.g. Debian or Mint)}

endsnippet

snippet swdepot "Manage packages with swdepot package manager (HP-UX)" b
swdepot: >
	name=${1:# package name.}
	state=${2:present|latest|absent}

	depot=${3:# The source repository from which install or upgrade a package.}

endsnippet

snippet flatpak_remote "Manage flatpak repository remotes" b
flatpak_remote: >
	name=${1:# The desired name for the flatpak remote to be registered under on the managed host.}

	executable=${2:flatpak}
	flatpakrepo_url=${3:# The URL to the I(flatpakrepo) file representing the repository remote to add.}
	method=${4:#system|user}
	state=${5:absent|#present}

endsnippet

snippet yum_repository "Add or remove YUM repositories" b
yum_repository: >
	name=${1:# Unique repository ID. This option builds the section name of the repository in the repo file.}

	async=${2:yes}
	bandwidth=${3:0}
	baseurl=${4:# URL to the directory where the yum repository's 'repodata' directory lives.}
	cost=${5:1000}
	deltarpm_metadata_percentage=${6:100}
	deltarpm_percentage=${7:75}
	description=${8:# A human readable string describing the repository. This option corresponds to the "name" property in the repo file.}
	enabled=${9:yes}
	enablegroups=${10:yes}
	exclude=${11:# List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.}
	failovermethod=${12:#roundrobin|priority}
	file=${13:# File name without the C(.repo) extension to save the repo in. Defaults to the value of I(name).}
	gpgcakey=${14:# A URL pointing to the ASCII-armored CA key file for the repository.}
	gpgcheck=${15:# Tells yum whether or not it should perform a GPG signature check on packages.}
	gpgkey=${16:# A URL pointing to the ASCII-armored GPG key file for the repository.}
	http_caching=${17:#all|packages|none}
	include=${18:# Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.}
	includepkgs=${19:# List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.}
	ip_resolve=${20:4|6|IPv4|IPv6|#whatever}
	keepalive=${21:no}
	keepcache=${22:0|#1}
	metadata_expire=${23:21600}
	metadata_expire_filter=${24:never|read-only:past|#read-only:present|read-only:future}
	metalink=${25:# Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).}
	mirrorlist=${26:# Specifies a URL to a file containing a list of baseurls.}
	mirrorlist_expire=${27:21600}
	password=${28:# Password to use with the username for basic authentication.}
	priority=${29:99}
	protect=${30:no}
	proxy=${31:# URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.}
	proxy_password=${32:# Password for this proxy.}
	proxy_username=${33:# Username to use for proxy.}
	repo_gpgcheck=${34:no}
	reposdir=${35:/etc/yum.repos.d}
	retries=${36:10}
	s3_enabled=${37:no}
	skip_if_unavailable=${38:no}
	ssl_check_cert_permissions=${39:no}
	sslcacert=${40:# Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.}
	sslclientcert=${41:# Path to the SSL client certificate yum should use to connect to repos/remote sites.}
	sslclientkey=${42:# Path to the SSL client key yum should use to connect to repos/remote sites.}
	sslverify=${43:yes}
	state=${44:absent|#present}
	throttle=${45:# Enable bandwidth throttling for downloads.}
	timeout=${46:30}
	ui_repoid_vars=${47:releasever basearch}
	username=${48:# Username to use for basic authentication to a repo or really any url.}
	mode=${49:# The permissions the resulting file or directory should have.}
	owner=${50:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${51:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${52:# The user part of the SELinux file context.}
	serole=${53:# The role part of the SELinux file context.}
	setype=${54:# The type part of the SELinux file context.}
	selevel=${55:s0}
	unsafe_writes=${56:no}
	attributes=${57:# The attributes the resulting file or directory should have.}

endsnippet

snippet package_facts "package information as facts" b
package_facts: >
	manager=${1:[#'auto', 'rpm', 'apt', 'portage', 'pkg'}
	strategy=${2:#first|all}

endsnippet

snippet layman "Manage Gentoo overlays" b
layman: >
	name=${1:# The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when C(state=updated)).}

	list_url=${2:# An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration.}
	state=${3:#present|absent|updated}
	validate_certs=${4:yes}

endsnippet

snippet portage "Package manager for Gentoo" b
portage: >
	package=${1:# Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)}
	state=${2:#present|installed|emerged|absent|removed|unmerged|latest}
	update=${3:no}
	deep=${4:no}
	newuse=${5:no}
	changed_use=${6:no}
	oneshot=${7:no}
	noreplace=${8:yes}
	nodeps=${9:no}
	onlydeps=${10:no}
	depclean=${11:no}
	quiet=${12:no}
	verbose=${13:no}
	sync=${14:web|yes|no}
	getbinpkg=${15:no}
	usepkgonly=${16:no}
	keepgoing=${17:no}
	jobs=${18:# Specifies the number of packages to build simultaneously.}
	loadavg=${19:# Specifies that no new builds should be started if there are}
	quietbuild=${20:no}
	quietfail=${21:no}

endsnippet

snippet apk "Manages apk packages" b
apk: >
	available=${1:no}
	name=${2:# A package name, like C(foo), or multiple packages, like C(foo, bar).}
	repository=${3:# A package repository or multiple repositories. Unlike with the underlying apk command, this list will override the system repositories rather than supplement them.}
	state=${4:#present|absent|latest}
	update_cache=${5:no}
	upgrade=${6:no}

endsnippet

snippet snap "Manages snaps" b
snap: >
	name=${1:# Name of the snap to install or remove. Can be a list of snaps.}

	state=${2:absent|#present}
	classic=${3:no}
	channel=${4:stable}

endsnippet

snippet homebrew "Package manager for Homebrew" b
homebrew: >
	name=${1:# list of names of packages to install/remove}
	path=${2:/usr/local/bin}
	state=${3:head|latest|#present|absent|linked|unlinked}
	update_homebrew=${4:no}
	upgrade_all=${5:no}
	install_options=${6:# options flags to install a package}

endsnippet

snippet redhat_subscription "Manage registration and subscriptions to RHSM using the C(subscription-manager) command" b
redhat_subscription: >
	state=${1:#present|absent}
	username=${2:# access.redhat.com or Sat6  username}
	password=${3:# access.redhat.com or Sat6 password}
	server_hostname=${4:# Specify an alternative Red Hat Subscription Management or Sat6 server}
	server_insecure=${5:# Enable or disable https server certificate verification when connecting to C(server_hostname)}
	rhsm_baseurl=${6:# Specify CDN baseurl}
	rhsm_repo_ca_cert=${7:# Specify an alternative location for a CA certificate for CDN}
	server_proxy_hostname=${8:# Specify a HTTP proxy hostname}
	server_proxy_port=${9:# Specify a HTTP proxy port}
	server_proxy_user=${10:# Specify a user for HTTP proxy with basic authentication}
	server_proxy_password=${11:# Specify a password for HTTP proxy with basic authentication}
	auto_attach=${12:no}
	activationkey=${13:# supply an activation key for use with registration}
	org_id=${14:# Organization ID to use in conjunction with activationkey}
	environment=${15:# Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello}
	pool=${16:^$}
	pool_ids=${17:[]}
	consumer_type=${18:# The type of unit to register, defaults to system}
	consumer_name=${19:# Name of the system to register, defaults to the hostname}
	consumer_id=${20:# References an existing consumer ID to resume using a previous registration
for this system. If the  system's identity certificate is lost or corrupted,
this option allows it to resume using its previous identity and subscriptions.
The default is to not specify a consumer ID so a new ID is created.
}
	force_register=${21:no}
	release=${22:# Set a release version}
	syspurpose=${23:{}}

endsnippet

snippet openbsd_pkg "Manage packages on OpenBSD" b
openbsd_pkg: >
	name=${1:# A name or a list of names of the packages.}

	state=${2:absent|latest|#present}
	build=${3:no}
	ports_dir=${4:/usr/ports}
	clean=${5:no}
	quick=${6:no}

endsnippet

snippet zypper_repository "Add and remove Zypper repositories" b
zypper_repository: >
	name=${1:# A name for the repository. Not required when adding repofiles.}
	repo=${2:# URI of the repository or .repo file. Required when state=present.}
	state=${3:absent|#present}
	description=${4:# A description of the repository}
	disable_gpg_check=${5:no}
	autorefresh=${6:yes}
	priority=${7:# Set priority of repository. Packages will always be installed from the repository with the smallest priority number.}
	overwrite_multiple=${8:no}
	auto_import_keys=${9:no}
	runrefresh=${10:no}
	enabled=${11:yes}

endsnippet

snippet urpmi "Urpmi manager" b
urpmi: >
	name=${1:# A list of package names to install, upgrade or remove.}

	state=${2:absent|#present}
	update_cache=${3:no}
	no-recommends=${4:yes}
	force=${5:yes}
	root=${6:/}

endsnippet

snippet apt_key "Add or remove an apt key" b
apt_key: >
	id=${1:# The identifier of the key.}
	data=${2:# The keyfile contents to add to the keyring.}
	file=${3:# The path to a keyfile on the remote server to add to the keyring.}
	keyring=${4:# The full path to specific keyring file in /etc/apt/trusted.gpg.d/}
	url=${5:# The URL to retrieve key from.}
	keyserver=${6:# The keyserver to retrieve key from.}
	state=${7:absent|#present}
	validate_certs=${8:yes}

endsnippet

snippet swupd "Manages updates and bundles in ClearLinux systems." b
swupd: >
	contenturl=${1:# URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org.}
	format=${2:# The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used.}
	manifest=${3:# The manifest contains information about the bundles at certain version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version.}
	name=${4:# Name of the (I)bundle to install or remove.}
	state=${5:#present|absent}
	update=${6:# Updates the OS to the latest version.}
	url=${7:# Overrides both I(contenturl) and I(versionurl).}
	verify=${8:# Verify content for OS version.}
	versionurl=${9:# URL for version string download.}

endsnippet

snippet homebrew_tap "Tap a Homebrew repository." b
homebrew_tap: >
	name=${1:# The GitHub user/organization repository to tap.}

	url=${2:# The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.}
	state=${3:#present|absent}

endsnippet

snippet yum "Manages packages with the I(yum) package manager" b
yum: >
	use_backend=${1:#auto|yum|yum4|dnf}
	name=${2:# A package name or package specifier with version, like C(name-1.0).}
	exclude=${3:# Package name(s) to exclude when state=present, or latest}
	list=${4:# Package name to run the equivalent of yum list --show-duplicates <package> against. In addition to listing packages, use can also list the following: C(installed), C(updates), C(available) and C(repos).}
	state=${5:absent|installed|latest|present|removed}
	enablerepo=${6:# I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(",").}
	disablerepo=${7:# I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(",").}
	conf_file=${8:# The remote yum configuration file to use for the transaction.}
	disable_gpg_check=${9:no}
	skip_broken=${10:no}
	update_cache=${11:no}
	validate_certs=${12:yes}
	update_only=${13:no}
	installroot=${14:/}
	security=${15:no}
	bugfix=${16:no}
	allow_downgrade=${17:no}
	enable_plugin=${18:# I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.}
	disable_plugin=${19:# I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.}
	releasever=${20:# Specifies an alternative release from which all packages will be installed.}
	autoremove=${21:no}
	disable_excludes=${22:# Disable the excludes defined in YUM config files.}
	download_only=${23:no}
	lock_timeout=${24:30}
	install_weak_deps=${25:yes}
	download_dir=${26:# Specifies an alternate directory to store packages.}

endsnippet

snippet dnf "Manages packages with the I(dnf) package manager" b
dnf: >
	name=${1:# A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages.}

	list=${2:# Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples.}
	state=${3:absent|present|installed|removed|latest}
	enablerepo=${4:# I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
	disablerepo=${5:# I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
	conf_file=${6:# The remote dnf configuration file to use for the transaction.}
	disable_gpg_check=${7:no}
	installroot=${8:/}
	releasever=${9:# Specifies an alternative release from which all packages will be installed.}
	autoremove=${10:no}
	exclude=${11:# Package name(s) to exclude when state=present, or latest. This can be a list or a comma separated string.}
	skip_broken=${12:no}
	update_cache=${13:no}
	update_only=${14:no}
	security=${15:no}
	bugfix=${16:no}
	enable_plugin=${17:# I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.}
	disable_plugin=${18:# I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.}
	disable_excludes=${19:# Disable the excludes defined in DNF config files.}
	validate_certs=${20:yes}
	allow_downgrade=${21:no}
	install_repoquery=${22:yes}
	download_only=${23:no}
	lock_timeout=${24:30}
	install_weak_deps=${25:yes}
	download_dir=${26:# Specifies an alternate directory to store packages.}

endsnippet

snippet rhn_channel "Adds or removes Red Hat software channels" b
rhn_channel: >
	name=${1:# Name of the software channel.}
	sysname=${2:# Name of the system as it is known in RHN/Satellite.}
	url=${3:# The full URL to the RHN/Satellite API.}
	user=${4:# RHN/Satellite login.}
	password=${5:# RHN/Satellite password.}

	state=${6:present}

endsnippet

snippet pkgin "Package manager for SmartOS, NetBSD, et al." b
pkgin: >
	name=${1:# Name of package to install/remove;}
	state=${2:#present|absent}
	update_cache=${3:no}
	upgrade=${4:no}
	full_upgrade=${5:no}
	clean=${6:no}
	force=${7:no}

endsnippet

snippet svr4pkg "Manage Solaris SVR4 packages" b
svr4pkg: >
	name=${1:# Package name, e.g. C(SUNWcsr)}
	state=${2:present|absent}

	src=${3:# Specifies the location to install the package from. Required when C(state=present).}
	proxy=${4:# HTTP[s] proxy to be used if C(src) is a URL.}
	response_file=${5:# Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)}
	zone=${6:current|#all}
	category=${7:# Install/Remove category instead of a single package.}

endsnippet

snippet installp "Manage packages on AIX" b
installp: >
	name=${1:# One or more packages to install or remove.}

	accept_license=${2:no}
	repository_path=${3:# Path with AIX packages (required to install).}
	state=${4:absent|#present}

endsnippet

snippet homebrew_cask "Install/uninstall homebrew casks." b
homebrew_cask: >
	name=${1:# name of cask to install/remove}

	path=${2:/usr/local/bin}
	state=${3:#present|absent|upgraded}
	sudo_password=${4:# The sudo password to be passed to SUDO_ASKPASS.}
	update_homebrew=${5:no}
	install_options=${6:# options flags to install a package}
	accept_external_apps=${7:no}
	upgrade_all=${8:no}
	upgrade=${9:no}
	greedy=${10:no}

endsnippet

snippet sorcery "Package manager for Source Mage GNU/Linux" b
sorcery: >
	name=${1:# Name of the spell}
	state=${2:#present|latest|absent|cast|dispelled|rebuild}
	depends=${3:# Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use +/- in front of dependency to turn it on/off ('+' is optional though)}
	update=${4:no}
	update_cache=${5:no}
	cache_valid_time=${6:# Time in seconds to invalidate grimoire collection on update}

endsnippet

snippet slackpkg "Package manager for Slackware >= 12.2" b
slackpkg: >
	name=${1:# name of package to install/remove}

	state=${2:#present|absent|latest}
	update_cache=${3:no}

endsnippet

snippet rpm_key "Adds or removes a gpg key from the rpm db" b
rpm_key: >
	key=${1:# Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key already exists in the database.}

	state=${2:absent|#present}
	validate_certs=${3:yes}
	fingerprint=${4:# The long-form fingerprint of the key being imported.}

endsnippet

snippet apt "Manages apt-packages" b
apt: >
	name=${1:# A list of package names, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.}
	state=${2:absent|build-dep|latest|#present|fixed}
	update_cache=${3:no}
	cache_valid_time=${4:0}
	purge=${5:no}
	default_release=${6:# Corresponds to the C(-t) option for I(apt) and sets pin priorities}
	install_recommends=${7:# Corresponds to the C(--no-install-recommends) option for I(apt). C(yes) installs recommended packages.  C(no) does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed.}
	force=${8:no}
	allow_unauthenticated=${9:no}
	upgrade=${10:dist|full|#no|safe|yes}
	dpkg_options=${11:force-confdef,force-confold}
	deb=${12:# Path to a .deb package on the remote machine.}
	autoremove=${13:no}
	autoclean=${14:no}
	policy_rc_d=${15:# Force the exit code of /usr/sbin/policy-rc.d.}
	only_upgrade=${16:no}
	force_apt_get=${17:no}

endsnippet

snippet flatpak "Manage flatpaks" b
flatpak: >
	name=${1:# The name of the flatpak to manage.}

	executable=${2:flatpak}
	method=${3:#system|user}
	remote=${4:flathub}
	state=${5:absent|#present}

endsnippet

snippet portinstall "Installing packages from FreeBSD's ports system" b
portinstall: >
	name=${1:# name of package to install/remove}

	state=${2:#present|absent}
	use_packages=${3:yes}

endsnippet

snippet rhsm_repository "Manage RHSM repositories using the subscription-manager command" b
rhsm_repository: >
	state=${1:#present|enabled|absent|disabled}
	name=${2:# The ID of repositories to enable.}

	purge=${3:no}

endsnippet

snippet pkg5 "Manages packages with the Solaris 11 Image Packaging System" b
pkg5: >
	name=${1:# An FRMI of the package(s) to be installed/removed/updated.}

	state=${2:absent|latest|#present}
	accept_licenses=${3:no}
	be_name=${4:# Creates a new boot environment with the given name.}
	refresh=${5:yes}

endsnippet

snippet rhsm_release "Set or Unset RHSM Release version" b
rhsm_release: >
	release=${1:# RHSM release version to use (use null to unset)}

endsnippet

snippet opkg "Package manager for OpenWrt" b
opkg: >
	name=${1:# name of package to install/remove}

	state=${2:#present|absent}
	force=${3:|depends|maintainer|reinstall|overwrite|downgrade|space|postinstall|remove|checksum|removal-of-dependent-packages}
	update_cache=${4:no}

endsnippet

snippet pkg5_publisher "Manages Solaris 11 Image Packaging System publishers" b
pkg5_publisher: >
	name=${1:# The publisher's name.}

	state=${2:#present|absent}
	sticky=${3:# Packages installed from a sticky repository can only receive updates from that repository.}
	enabled=${4:# Is the repository enabled or disabled?}
	origin=${5:# A path or URL to the repository.}
	mirror=${6:# A path or URL to the repository mirror.}

endsnippet

snippet dpkg_selections "Dpkg package selection selections" b
dpkg_selections: >
	name=${1:# Name of the package}
	selection=${2:install|hold|deinstall|purge}

endsnippet

snippet rhn_register "Manage Red Hat Network registration using the C(rhnreg_ks) command" b
rhn_register: >
	state=${1:absent|#present}
	username=${2:# Red Hat Network username.}
	password=${3:# Red Hat Network password.}
	server_url=${4:# Specify an alternative Red Hat Network server URL.}
	activationkey=${5:# Supply an activation key for use with registration.}
	profilename=${6:# Supply an profilename for use with registration.}
	ca_cert=${7:# Supply a custom ssl CA certificate file for use with registration.}
	systemorgid=${8:# Supply an organizational id for use with registration.}
	channels=${9:[]}
	enable_eus=${10:no}
	nopackages=${11:no}

endsnippet

snippet apt_rpm "apt_rpm package manager" b
apt_rpm: >
	pkg=${1:# name of package to install, upgrade or remove.}

	state=${2:absent|#present}
	update_cache=${3:no}

endsnippet

snippet macports "Package manager for MacPorts" b
macports: >
	name=${1:# A list of port names.}
	selfupdate=${2:no}
	state=${3:#present|absent|active|inactive}
	upgrade=${4:no}
	variant=${5:# A port variant specification.}

endsnippet

snippet kibana_plugin "Manage Kibana plugins" b
kibana_plugin: >
	name=${1:# Name of the plugin to install.}

	state=${2:#present|absent}
	url=${3:# Set exact URL to download the plugin from.}
	timeout=${4:1m}
	plugin_bin=${5:/opt/kibana/bin/kibana}
	plugin_dir=${6:/opt/kibana/installedPlugins/}
	version=${7:# Version of the plugin to be installed.}
	force=${8:no}

endsnippet

snippet elasticsearch_plugin "Manage Elasticsearch plugins" b
elasticsearch_plugin: >
	name=${1:# Name of the plugin to install.}

	state=${2:#present|absent}
	src=${3:# Optionally set the source location to retrieve the plugin from. This can be a file:// URL to install from a local file, or a remote URL. If this is not set, the plugin location is just based on the name.}
	url=${4:# Set exact URL to download the plugin from (Only works for ES 1.x).}
	timeout=${5:1m}
	force=${6:no}
	plugin_bin=${7:# Location of the plugin binary. If this file is not found, the default plugin binaries will be used.}
	plugin_dir=${8:/usr/share/elasticsearch/plugins/}
	proxy_host=${9:# Proxy host to use during plugin installation}
	proxy_port=${10:# Proxy port to use during plugin installation}
	version=${11:# Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated}

endsnippet

snippet riak "This module handles some common Riak operations" b
riak: >
	command=${1:ping|kv_test|join|plan|commit}
	config_dir=${2:/etc/riak}
	http_conn=${3:127.0.0.1:8098}
	target_node=${4:riak@127.0.0.1}
	wait_for_handoffs=${5:# Number of seconds to wait for handoffs to complete.}
	wait_for_ring=${6:# Number of seconds to wait for all nodes to agree on the ring.}
	wait_for_service=${7:kv}
	validate_certs=${8:yes}

endsnippet

snippet redis "Various redis commands, slave and flush" b
redis: >
	command=${1:config|flush|slave}

	login_password=${2:# The password used to authenticate with (usually not used)}
	login_host=${3:localhost}
	login_port=${4:6379}
	master_host=${5:# The host of the master instance [slave command]}
	master_port=${6:# The port of the master instance [slave command]}
	slave_mode=${7:master|#slave}
	db=${8:# The database to flush (used in db mode) [flush command]}
	flush_mode=${9:#all|db}
	name=${10:# A redis config key.}
	value=${11:# A redis config value.}

endsnippet

snippet postgresql_sequence "Create, drop, or alter a PostgreSQL sequence" b
postgresql_sequence: >
	sequence=${1:# The name of the sequence.}

	state=${2:absent|#present}
	data_type=${3:bigint|integer|smallint}
	increment=${4:# Increment specifies which value is added to the current sequence value to create a new value.}
	minvalue=${5:# Minvalue determines the minimum value a sequence can generate. The default for an ascending sequence is 1. The default for a descending sequence is the minimum value of the data type.}
	maxvalue=${6:# Maxvalue determines the maximum value for the sequence. The default for an ascending sequence is the maximum value of the data type. The default for a descending sequence is -1.}
	start=${7:# Start allows the sequence to begin anywhere. The default starting value is I(minvalue) for ascending sequences and I(maxvalue) for descending ones.}
	cache=${8:# Cache specifies how many sequence numbers are to be preallocated and stored in memory for faster access. The minimum value is 1 (only one value can be generated at a time, i.e., no cache), and this is also the default.}
	cycle=${9:no}
	cascade=${10:no}
	rename_to=${11:# The new name for the I(sequence).}
	owner=${12:# Set the owner for the I(sequence).}
	schema=${13:public}
	newschema=${14:# The new schema for the I(sequence). Will be used for moving a I(sequence) to another I(schema).}
	session_role=${15:# Switch to session_role after connecting. The specified I(session_role) must be a role that the current I(login_user) is a member of.}
	db=${16:# Name of database to connect to and run queries against.}
	login_user=${17:postgres}
	login_password=${18:# The password used to authenticate with.}
	login_host=${19:# Host running the database.}
	login_unix_socket=${20:# Path to a Unix domain socket for local connections.}
	port=${21:5432}
	ssl_mode=${22:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${23:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_user "Add or remove a user (role) from a PostgreSQL server instance" b
postgresql_user: >
	name=${1:# Name of the user (role) to add or remove.}

	password=${2:# Set the user's password, before 1.4 this was required.}
	db=${3:# Name of database to connect to and where user's permissions will be granted.}
	fail_on_user=${4:yes}
	priv=${5:# Slash-separated PostgreSQL privileges string: C(priv1/priv2), where privileges can be defined for database ( allowed options - 'CREATE', 'CONNECT', 'TEMPORARY', 'TEMP', 'ALL'. For example C(CONNECT) ) or for table ( allowed options - 'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'TRUNCATE', 'REFERENCES', 'TRIGGER', 'ALL'. For example C(table:SELECT) ). Mixed example of this string: C(CONNECT/CREATE/table1:SELECT/table2:INSERT).}
	role_attr_flags=${6:[NO]SUPERUSER|[NO]CREATEROLE|[NO]CREATEDB|[NO]INHERIT|[NO]LOGIN|[NO]REPLICATION|[NO]BYPASSRLS}
	session_role=${7:# Switch to session_role after connecting.}
	state=${8:absent|#present}
	encrypted=${9:yes}
	expires=${10:# The date at which the user's password is to expire.}
	no_password_changes=${11:no}
	conn_limit=${12:# Specifies the user (role) connection limit.}
	ssl_mode=${13:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${14:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
	groups=${15:# The list of groups (roles) that need to be granted to the user.}
	login_user=${16:postgres}
	login_password=${17:# The password used to authenticate with.}
	login_host=${18:# Host running the database.}
	login_unix_socket=${19:# Path to a Unix domain socket for local connections.}
	port=${20:5432}

endsnippet

snippet postgresql_lang "Adds, removes or changes procedural languages with a PostgreSQL database" b
postgresql_lang: >
	lang=${1:# Name of the procedural language to add, remove or change.}

	trust=${2:no}
	db=${3:# Name of database to connect to and where the language will be added, removed or changed.}
	force_trust=${4:no}
	fail_on_drop=${5:yes}
	cascade=${6:no}
	session_role=${7:# Switch to session_role after connecting.}
	state=${8:absent|#present}
	login_unix_socket=${9:# Path to a Unix domain socket for local connections.}
	ssl_mode=${10:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${11:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
	login_user=${12:postgres}
	login_password=${13:# The password used to authenticate with.}
	login_host=${14:# Host running the database.}
	port=${15:5432}

endsnippet

snippet postgresql_privs "Grant or revoke privileges on PostgreSQL database objects" b
postgresql_privs: >
	database=${1:# Name of database to connect to.}
	roles=${2:# Comma separated list of role (user/group) names to set permissions for.}

	state=${3:absent|#present}
	privs=${4:# Comma separated list of privileges to grant/revoke.}
	type=${5:database|default_privs|foreign_data_wrapper|foreign_server|function|group|language|#table|tablespace|schema|sequence}
	objs=${6:# Comma separated list of database objects to set privileges on.}
	schema=${7:# Schema that contains the database objects specified via I(objs).}
	fail_on_role=${8:yes}
	session_role=${9:# Switch to session_role after connecting.}
	target_roles=${10:# A list of existing role (user/group) names to set as the default permissions for database objects subsequently created by them.}
	grant_option=${11:# Whether C(role) may grant/revoke the specified privileges/group memberships to others.}
	host=${12:# Database host address. If unspecified, connect via Unix socket.}
	port=${13:5432}
	unix_socket=${14:# Path to a Unix domain socket for local connections.}
	login=${15:postgres}
	password=${16:# The password to authenticate with.}
	ssl_mode=${17:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${18:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
	login_user=${19:postgres}
	login_password=${20:# The password used to authenticate with.}
	login_host=${21:# Host running the database.}
	login_unix_socket=${22:# Path to a Unix domain socket for local connections.}

endsnippet

snippet postgresql_publication "Add, update, or remove PostgreSQL publication" b
postgresql_publication: >
	name=${1:# Name of the publication to add, update, or remove.}

	db=${2:# Name of the database to connect to and where the publication state will be changed.}
	tables=${3:# List of tables to add to the publication.}
	state=${4:absent|#present}
	parameters=${5:# Dictionary with optional publication parameters.}
	owner=${6:# Publication owner.}
	cascade=${7:no}
	login_user=${8:postgres}
	login_password=${9:# The password used to authenticate with.}
	login_host=${10:# Host running the database.}
	login_unix_socket=${11:# Path to a Unix domain socket for local connections.}
	port=${12:5432}
	ssl_mode=${13:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${14:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_schema "Add or remove PostgreSQL schema" b
postgresql_schema: >
	name=${1:# Name of the schema to add or remove.}

	database=${2:postgres}
	owner=${3:# Name of the role to set as owner of the schema.}
	session_role=${4:# Switch to session_role after connecting.}
	state=${5:absent|#present}
	cascade_drop=${6:no}
	ssl_mode=${7:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${8:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
	login_user=${9:postgres}
	login_password=${10:# The password used to authenticate with.}
	login_host=${11:# Host running the database.}
	login_unix_socket=${12:# Path to a Unix domain socket for local connections.}
	port=${13:5432}

endsnippet

snippet postgresql_pg_hba "Add, remove or modify a rule in a pg_hba file" b
postgresql_pg_hba: >
	dest=${1:# Path to C(pg_hba) file to modify.}

	address=${2:samehost}
	backup=${3:no}
	backup_file=${4:# Write backup to a specific backupfile rather than a temp file.}
	create=${5:no}
	contype=${6:local|host|hostnossl|hostssl}
	databases=${7:all}
	method=${8:cert|gss|ident|krb5|ldap|#md5|pam|password|peer|radius|reject|scram-sha-256|sspi|trust}
	netmask=${9:# The netmask of the source address.}
	options=${10:# Additional options for the authentication I(method).}
	order=${11:#sdu|sud|dsu|dus|usd|uds}
	state=${12:absent|#present}
	users=${13:all}
	mode=${14:# The permissions the resulting file or directory should have.}
	owner=${15:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${16:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${17:# The user part of the SELinux file context.}
	serole=${18:# The role part of the SELinux file context.}
	setype=${19:# The type part of the SELinux file context.}
	selevel=${20:s0}
	unsafe_writes=${21:no}
	attributes=${22:# The attributes the resulting file or directory should have.}

endsnippet

snippet postgresql_membership "Add or remove PostgreSQL roles from groups" b
postgresql_membership: >
	groups=${1:# The list of groups (roles) that need to be granted to or revoked from I(target_roles).}
	target_roles=${2:# The list of target roles (groups will be granted to them).}

	fail_on_role=${3:yes}
	state=${4:absent|#present}
	db=${5:# Name of database to connect to.}
	session_role=${6:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	login_user=${7:postgres}
	login_password=${8:# The password used to authenticate with.}
	login_host=${9:# Host running the database.}
	login_unix_socket=${10:# Path to a Unix domain socket for local connections.}
	port=${11:5432}
	ssl_mode=${12:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${13:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_table "Create, drop, or modify a PostgreSQL table" b
postgresql_table: >
	table=${1:# Table name.}

	state=${2:absent|#present}
	tablespace=${3:# Set a tablespace for the table.}
	owner=${4:# Set a table owner.}
	unlogged=${5:no}
	like=${6:# Create a table like another table (with similar DDL). Mutually exclusive with I(columns), I(rename), and I(truncate).}
	including=${7:# Keywords that are used with like parameter, may be DEFAULTS, CONSTRAINTS, INDEXES, STORAGE, COMMENTS or ALL. Needs I(like) specified. Mutually exclusive with I(columns), I(rename), and I(truncate).}
	columns=${8:# Columns that are needed.}
	rename=${9:# New table name. Mutually exclusive with I(tablespace), I(owner), I(unlogged), I(like), I(including), I(columns), I(truncate), and I(storage_params).}
	truncate=${10:no}
	storage_params=${11:# Storage parameters like fillfactor, autovacuum_vacuum_treshold, etc. Mutually exclusive with I(rename) and I(truncate).}
	db=${12:# Name of database to connect and where the table will be created.}
	session_role=${13:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	cascade=${14:no}
	login_user=${15:postgres}
	login_password=${16:# The password used to authenticate with.}
	login_host=${17:# Host running the database.}
	login_unix_socket=${18:# Path to a Unix domain socket for local connections.}
	port=${19:5432}
	ssl_mode=${20:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${21:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_copy "Copy data between a file/program and a PostgreSQL table" b
postgresql_copy: >
	copy_to=${1:# Copy the contents of a table to a file.}
	copy_from=${2:# Copy data from a file to a table (appending the data to whatever is in the table already).}
	src=${3:# Copy data from I(copy_from) to I(src=tablename).}
	dst=${4:# Copy data to I(dst=tablename) from I(copy_from=/path/to/data.file).}
	columns=${5:# List of column names for the src/dst table to COPY FROM/TO.}
	program=${6:no}
	options=${7:# Options of COPY command.}
	db=${8:# Name of database to connect to.}
	session_role=${9:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	login_user=${10:postgres}
	login_password=${11:# The password used to authenticate with.}
	login_host=${12:# Host running the database.}
	login_unix_socket=${13:# Path to a Unix domain socket for local connections.}
	port=${14:5432}
	ssl_mode=${15:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${16:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_slot "Add or remove replication slots from a PostgreSQL database" b
postgresql_slot: >
	name=${1:# Name of the replication slot to add or remove.}

	slot_type=${2:logical|#physical}
	state=${3:absent|#present}
	immediately_reserve=${4:no}
	output_plugin=${5:test_decoding}
	db=${6:# Name of database to connect to.}
	session_role=${7:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	login_user=${8:postgres}
	login_password=${9:# The password used to authenticate with.}
	login_host=${10:# Host running the database.}
	login_unix_socket=${11:# Path to a Unix domain socket for local connections.}
	port=${12:5432}
	ssl_mode=${13:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${14:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_query "Run PostgreSQL queries" b
postgresql_query: >
	query=${1:# SQL query to run. Variables can be escaped with psycopg2 syntax U(http://initd.org/psycopg/docs/usage.html).}
	positional_args=${2:# List of values to be passed as positional arguments to the query. When the value is a list, it will be converted to PostgreSQL array.}
	named_args=${3:# Dictionary of key-value arguments to pass to the query. When the value is a list, it will be converted to PostgreSQL array.}
	path_to_script=${4:# Path to SQL script on the remote host.}
	session_role=${5:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	db=${6:# Name of database to connect to and run queries against.}
	autocommit=${7:no}
	login_user=${8:postgres}
	login_password=${9:# The password used to authenticate with.}
	login_host=${10:# Host running the database.}
	login_unix_socket=${11:# Path to a Unix domain socket for local connections.}
	port=${12:5432}
	ssl_mode=${13:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${14:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_ext "Add or remove PostgreSQL extensions from a database" b
postgresql_ext: >
	name=${1:# Name of the extension to add or remove.}
	db=${2:# Name of the database to add or remove the extension to/from.}

	schema=${3:# Name of the schema to add the extension to.}
	session_role=${4:# Switch to session_role after connecting.}
	state=${5:absent|#present}
	cascade=${6:no}
	login_unix_socket=${7:# Path to a Unix domain socket for local connections.}
	ssl_mode=${8:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${9:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
	version=${10:# Extension version to add or update to. Has effect with I(state=present) only.}
	login_user=${11:postgres}
	login_password=${12:# The password used to authenticate with.}
	login_host=${13:# Host running the database.}
	port=${14:5432}

endsnippet

snippet postgresql_set "Change a PostgreSQL server configuration parameter" b
postgresql_set: >
	name=${1:# Name of PostgreSQL server parameter.}
	value=${2:# Parameter value to set.}

	reset=${3:no}
	session_role=${4:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	db=${5:# Name of database to connect.}
	login_user=${6:postgres}
	login_password=${7:# The password used to authenticate with.}
	login_host=${8:# Host running the database.}
	login_unix_socket=${9:# Path to a Unix domain socket for local connections.}
	port=${10:5432}
	ssl_mode=${11:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${12:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_info "Gather information about PostgreSQL servers" b
postgresql_info: >
	filter=${1:# Limit the collected information by comma separated string or YAML list.}
	db=${2:# Name of database to connect.}
	session_role=${3:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	login_user=${4:postgres}
	login_password=${5:# The password used to authenticate with.}
	login_host=${6:# Host running the database.}
	login_unix_socket=${7:# Path to a Unix domain socket for local connections.}
	port=${8:5432}
	ssl_mode=${9:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${10:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_db "Add or remove PostgreSQL databases from a remote host." b
postgresql_db: >
	name=${1:# Name of the database to add or remove}

	port=${2:5432}
	owner=${3:# Name of the role to set as owner of the database}
	template=${4:# Template used to create the database}
	encoding=${5:# Encoding of the database}
	lc_collate=${6:# Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless C(template0) is used as template.}
	lc_ctype=${7:# Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless C(template0) is used as template.}
	session_role=${8:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	state=${9:absent|dump|#present|restore}
	target=${10:# File to back up or restore from.}
	target_opts=${11:# Further arguments for pg_dump or pg_restore.}
	maintenance_db=${12:postgres}
	conn_limit=${13:# Specifies the database connection limit.}
	tablespace=${14:# The tablespace to set for the database U(https://www.postgresql.org/docs/current/sql-alterdatabase.html).}
	login_user=${15:postgres}
	login_password=${16:# The password used to authenticate with.}
	login_host=${17:# Host running the database.}
	login_unix_socket=${18:# Path to a Unix domain socket for local connections.}
	ssl_mode=${19:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${20:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_idx "Create or drop indexes from a PostgreSQL database" b
postgresql_idx: >
	idxname=${1:# Name of the index to create or drop.}
	table=${2:# Table to create index on it.}

	db=${3:# Name of database to connect to and where the index will be created/dropped.}
	session_role=${4:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	schema=${5:# Name of a database schema where the index will be created.}
	state=${6:absent|#present}
	columns=${7:# List of index columns that need to be covered by index.}
	cond=${8:# Index conditions.}
	idxtype=${9:# Index type (like btree, gist, gin, etc.).}
	concurrent=${10:yes}
	tablespace=${11:# Set a tablespace for the index.}
	storage_params=${12:# Storage parameters like fillfactor, vacuum_cleanup_index_scale_factor, etc.}
	cascade=${13:no}
	login_user=${14:postgres}
	login_password=${15:# The password used to authenticate with.}
	login_host=${16:# Host running the database.}
	login_unix_socket=${17:# Path to a Unix domain socket for local connections.}
	port=${18:5432}
	ssl_mode=${19:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${20:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_owner "Change an owner of PostgreSQL database object" b
postgresql_owner: >
	new_owner=${1:# Role (user/group) to set as an I(obj_name) owner.}
	obj_type=${2:database|function|matview|sequence|schema|table|tablespace|view}

	obj_name=${3:# Name of a database object to change ownership.}
	reassign_owned_by=${4:# The list of role names. The ownership of all the objects within the current database, and of all shared objects (databases, tablespaces), owned by this role(s) will be reassigned to I(owner).}
	fail_on_role=${5:yes}
	db=${6:# Name of database to connect to.}
	session_role=${7:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	login_user=${8:postgres}
	login_password=${9:# The password used to authenticate with.}
	login_host=${10:# Host running the database.}
	login_unix_socket=${11:# Path to a Unix domain socket for local connections.}
	port=${12:5432}
	ssl_mode=${13:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${14:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_tablespace "Add or remove PostgreSQL tablespaces from remote hosts" b
postgresql_tablespace: >
	tablespace=${1:# Name of the tablespace to add or remove.}

	location=${2:# Path to the tablespace directory in the file system.}
	state=${3:absent|#present}
	owner=${4:# Name of the role to set as an owner of the tablespace.}
	set=${5:# Dict of tablespace options to set. Supported from PostgreSQL 9.0.}
	rename_to=${6:# New name of the tablespace.}
	session_role=${7:# Switch to session_role after connecting. The specified session_role must be a role that the current login_user is a member of.}
	db=${8:# Name of database to connect to and run queries against.}
	login_user=${9:postgres}
	login_password=${10:# The password used to authenticate with.}
	login_host=${11:# Host running the database.}
	login_unix_socket=${12:# Path to a Unix domain socket for local connections.}
	port=${13:5432}
	ssl_mode=${14:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${15:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet postgresql_ping "Check remote PostgreSQL server availability" b
postgresql_ping: >
	db=${1:# Name of a database to connect to.}
	login_user=${2:postgres}
	login_password=${3:# The password used to authenticate with.}
	login_host=${4:# Host running the database.}
	login_unix_socket=${5:# Path to a Unix domain socket for local connections.}
	port=${6:5432}
	ssl_mode=${7:allow|disable|#prefer|require|verify-ca|verify-full}
	ca_cert=${8:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}

endsnippet

snippet mongodb_shard "Add and remove shards from a MongoDB Cluster." b
mongodb_shard: >
	shard=${1:# The shard connection string.}

	login_user=${2:# The user to login with.}
	login_password=${3:# The password used to authenticate with.}
	login_database=${4:admin}
	login_host=${5:localhost}
	login_port=${6:27017}
	ssl=${7:no}
	ssl_cert_reqs=${8:#CERT_REQUIRED|CERT_OPTIONAL|CERT_NONE}
	state=${9:#present|absent}

endsnippet

snippet mongodb_user "Adds or removes a user from a MongoDB database." b
mongodb_user: >
	database=${1:# The name of the database to add/remove the user from}
	name=${2:# The name of the user to add or remove}

	login_user=${3:# The username used to authenticate with}
	login_password=${4:# The password used to authenticate with}
	login_host=${5:localhost}
	login_port=${6:27017}
	login_database=${7:# The database where login credentials are stored}
	replica_set=${8:# Replica set to connect to (automatically connects to primary for writes)}
	password=${9:# The password to use for the user}
	ssl=${10:# Whether to use an SSL connection when connecting to the database}
	ssl_cert_reqs=${11:#CERT_REQUIRED|CERT_OPTIONAL|CERT_NONE}
	roles=${12:# The database user roles valid values could either be one or more of the following strings: 'read', 'readWrite', 'dbAdmin', 'userAdmin', 'clusterAdmin', 'readAnyDatabase', 'readWriteAnyDatabase', 'userAdminAnyDatabase', 'dbAdminAnyDatabase'
}
	state=${13:#present|absent}
	update_password=${14:#always|on_create}

endsnippet

snippet mongodb_parameter "Change an administrative parameter on a MongoDB server." b
mongodb_parameter: >
	database=${1:# The name of the database to add/remove the user from}
	param=${2:# MongoDB administrative parameter to modify}
	value=${3:# MongoDB administrative parameter value to set}

	login_user=${4:# The username used to authenticate with}
	login_password=${5:# The password used to authenticate with}
	login_host=${6:localhost}
	login_port=${7:27017}
	login_database=${8:# The database where login credentials are stored}
	replica_set=${9:# Replica set to connect to (automatically connects to primary for writes)}
	ssl=${10:no}
	param_type=${11:str}

endsnippet

snippet mongodb_replicaset "Initialises a MongoDB replicaset." b
mongodb_replicaset: >
	login_user=${1:# The username to authenticate with.}
	login_password=${2:# The password to authenticate with.}
	login_database=${3:admin}
	login_host=${4:localhost}
	login_port=${5:27017}
	replica_set=${6:rs0}
	members=${7:# A comma-separated string or a yaml list consisting of the replicaset members.}
	validate=${8:yes}
	ssl=${9:no}
	ssl_cert_reqs=${10:CERT_NONE|CERT_OPTIONAL|#CERT_REQUIRED}
	arbiter_at_index=${11:# Identifies the position of the member in the array that is an arbiter.}
	chaining_allowed=${12:yes}
	heartbeat_timeout_secs=${13:10}
	election_timeout_millis=${14:10000}
	protocol_version=${15:0|#1}

endsnippet

snippet influxdb_user "Manage InfluxDB users" b
influxdb_user: >
	user_name=${1:# Name of the user.}

	user_password=${2:# Password to be set for the user.}
	admin=${3:no}
	state=${4:#present|absent}
	grants=${5:# Privileges to grant to this user. Takes a list of dicts containing the "database" and "privilege" keys.}
	hostname=${6:localhost}
	username=${7:root}
	password=${8:root}
	port=${9:8086}
	validate_certs=${10:yes}
	ssl=${11:# Use https instead of http to connect to InfluxDB server.}
	timeout=${12:# Number of seconds Requests will wait for client to establish a connection.}
	retries=${13:3}
	use_udp=${14:# Use UDP to connect to InfluxDB server.}
	udp_port=${15:4444}
	proxies=${16:# HTTP(S) proxy to use for Requests to connect to InfluxDB server.}

endsnippet

snippet influxdb_write "Write data points into InfluxDB." b
influxdb_write: >
	data_points=${1:# Data points as dict to write into the database.}
	database_name=${2:# Name of the database.}

	hostname=${3:localhost}
	username=${4:root}
	password=${5:root}
	port=${6:8086}
	validate_certs=${7:yes}
	ssl=${8:# Use https instead of http to connect to InfluxDB server.}
	timeout=${9:# Number of seconds Requests will wait for client to establish a connection.}
	retries=${10:3}
	use_udp=${11:# Use UDP to connect to InfluxDB server.}
	udp_port=${12:4444}
	proxies=${13:# HTTP(S) proxy to use for Requests to connect to InfluxDB server.}

endsnippet

snippet influxdb_query "Query data points from InfluxDB." b
influxdb_query: >
	query=${1:# Query to be executed.}
	database_name=${2:# Name of the database.}

	hostname=${3:localhost}
	username=${4:root}
	password=${5:root}
	port=${6:8086}
	validate_certs=${7:yes}
	ssl=${8:# Use https instead of http to connect to InfluxDB server.}
	timeout=${9:# Number of seconds Requests will wait for client to establish a connection.}
	retries=${10:3}
	use_udp=${11:# Use UDP to connect to InfluxDB server.}
	udp_port=${12:4444}
	proxies=${13:# HTTP(S) proxy to use for Requests to connect to InfluxDB server.}

endsnippet

snippet influxdb_database "Manage InfluxDB databases" b
influxdb_database: >
	database_name=${1:# Name of the database.}

	state=${2:#present|absent}
	hostname=${3:localhost}
	username=${4:root}
	password=${5:root}
	port=${6:8086}
	validate_certs=${7:yes}
	ssl=${8:# Use https instead of http to connect to InfluxDB server.}
	timeout=${9:# Number of seconds Requests will wait for client to establish a connection.}
	retries=${10:3}
	use_udp=${11:# Use UDP to connect to InfluxDB server.}
	udp_port=${12:4444}
	proxies=${13:# HTTP(S) proxy to use for Requests to connect to InfluxDB server.}

endsnippet

snippet influxdb_retention_policy "Manage InfluxDB retention policies" b
influxdb_retention_policy: >
	database_name=${1:# Name of the database.}
	policy_name=${2:# Name of the retention policy}
	duration=${3:# Determines how long InfluxDB should keep the data}
	replication=${4:# Determines how many independent copies of each point are stored in the cluster}
	default=${5:# Sets the retention policy as default retention policy}

	hostname=${6:localhost}
	username=${7:root}
	password=${8:root}
	port=${9:8086}
	validate_certs=${10:yes}
	ssl=${11:# Use https instead of http to connect to InfluxDB server.}
	timeout=${12:# Number of seconds Requests will wait for client to establish a connection.}
	retries=${13:3}
	use_udp=${14:# Use UDP to connect to InfluxDB server.}
	udp_port=${15:4444}
	proxies=${16:# HTTP(S) proxy to use for Requests to connect to InfluxDB server.}

endsnippet

snippet aerospike_migrations "Check or wait for migrations between nodes" b
aerospike_migrations: >
	local_only=${1:# Do you wish to only check for migrations on the local node before returning, or do you want all nodes in the cluster to finish before returning?}

	host=${2:localhost}
	port=${3:3000}
	connect_timeout=${4:1000}
	consecutive_good_checks=${5:3}
	sleep_between_checks=${6:60}
	tries_limit=${7:300}
	min_cluster_size=${8:1}
	fail_on_cluster_change=${9:yes}
	migrate_tx_key=${10:migrate_tx_partitions_remaining}
	migrate_rx_key=${11:migrate_rx_partitions_remaining}
	target_cluster_size=${12:# When all aerospike builds in the cluster are greater than version 4.3, then the C(cluster-stable) info command will be used. Inside this command, you can optionally specify what the target cluster size is - but it is not necessary. You can still rely on min_cluster_size if you don't want to use this option.}

endsnippet

snippet mysql_info "Gather information about MySQL servers" b
mysql_info: >
	filter=${1:# Limit the collected information by comma separated string or YAML list.}
	login_db=${2:# Database name to connect to.}
	login_user=${3:# The username used to authenticate with.}
	login_password=${4:# The password used to authenticate with.}
	login_host=${5:localhost}
	login_port=${6:3306}
	login_unix_socket=${7:# The path to a Unix domain socket for local connections.}
	connect_timeout=${8:30}
	config_file=${9:~/.my.cnf}
	ca_cert=${10:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	client_cert=${11:# The path to a client public key certificate.}
	client_key=${12:# The path to the client private key.}

endsnippet

snippet mysql_variables "Manage MySQL global variables" b
mysql_variables: >
	variable=${1:# Variable name to operate}

	value=${2:# If set, then sets variable value to this}
	login_user=${3:# The username used to authenticate with.}
	login_password=${4:# The password used to authenticate with.}
	login_host=${5:localhost}
	login_port=${6:3306}
	login_unix_socket=${7:# The path to a Unix domain socket for local connections.}
	connect_timeout=${8:30}
	config_file=${9:~/.my.cnf}
	ca_cert=${10:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	client_cert=${11:# The path to a client public key certificate.}
	client_key=${12:# The path to the client private key.}

endsnippet

snippet mysql_replication "Manage MySQL replication" b
mysql_replication: >
	mode=${1:#getslave|getmaster|changemaster|stopslave|startslave|resetslave|resetslaveall}
	master_host=${2:# Same as mysql variable.}
	master_user=${3:# Same as mysql variable.}
	master_password=${4:# Same as mysql variable.}
	master_port=${5:# Same as mysql variable.}
	master_connect_retry=${6:# Same as mysql variable.}
	master_log_file=${7:# Same as mysql variable.}
	master_log_pos=${8:# Same as mysql variable.}
	relay_log_file=${9:# Same as mysql variable.}
	relay_log_pos=${10:# Same as mysql variable.}
	master_ssl=${11:# Same as mysql variable.}
	master_ssl_ca=${12:# Same as mysql variable.}
	master_ssl_capath=${13:# Same as mysql variable.}
	master_ssl_cert=${14:# Same as mysql variable.}
	master_ssl_key=${15:# Same as mysql variable.}
	master_ssl_cipher=${16:# Same as mysql variable.}
	master_auto_position=${17:# Whether the host uses GTID based replication or not.}
	login_user=${18:# The username used to authenticate with.}
	login_password=${19:# The password used to authenticate with.}
	login_host=${20:localhost}
	login_port=${21:3306}
	login_unix_socket=${22:# The path to a Unix domain socket for local connections.}
	connect_timeout=${23:30}
	config_file=${24:~/.my.cnf}
	ca_cert=${25:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	client_cert=${26:# The path to a client public key certificate.}
	client_key=${27:# The path to the client private key.}

endsnippet

snippet mysql_db "Add or remove MySQL databases from a remote host." b
mysql_db: >
	name=${1:# name of the database to add or remove.}

	state=${2:#present|absent|dump|import}
	collation=${3:# Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.}
	encoding=${4:# Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)}
	target=${5:# Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.}
	single_transaction=${6:no}
	quick=${7:yes}
	ignore_tables=${8:[]}
	login_user=${9:# The username used to authenticate with.}
	login_password=${10:# The password used to authenticate with.}
	login_host=${11:localhost}
	login_port=${12:3306}
	login_unix_socket=${13:# The path to a Unix domain socket for local connections.}
	connect_timeout=${14:30}
	config_file=${15:~/.my.cnf}
	ca_cert=${16:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	client_cert=${17:# The path to a client public key certificate.}
	client_key=${18:# The path to the client private key.}

endsnippet

snippet mysql_user "Adds or removes a user from a MySQL database" b
mysql_user: >
	name=${1:# Name of the user (role) to add or remove.}

	password=${2:# Set the user's password..}
	encrypted=${3:no}
	host=${4:localhost}
	host_all=${5:no}
	priv=${6:# MySQL privileges string in the format: C(db.table:priv1,priv2).}
	append_privs=${7:no}
	sql_log_bin=${8:yes}
	state=${9:absent|#present}
	check_implicit_admin=${10:no}
	update_password=${11:#always|on_create}
	login_user=${12:# The username used to authenticate with.}
	login_password=${13:# The password used to authenticate with.}
	login_host=${14:localhost}
	login_port=${15:3306}
	login_unix_socket=${16:# The path to a Unix domain socket for local connections.}
	connect_timeout=${17:30}
	config_file=${18:~/.my.cnf}
	ca_cert=${19:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	client_cert=${20:# The path to a client public key certificate.}
	client_key=${21:# The path to the client private key.}

endsnippet

snippet proxysql_global_variables "Gets or sets the proxysql global variables." b
proxysql_global_variables: >
	variable=${1:# Defines which variable should be returned, or if I(value) is specified which variable should be updated.}

	value=${2:# Defines a value the variable specified using I(variable) should be set to.}
	save_to_disk=${3:yes}
	load_to_runtime=${4:yes}
	login_user=${5:# The username used to authenticate to ProxySQL admin interface.}
	login_password=${6:# The password used to authenticate to ProxySQL admin interface.}
	login_host=${7:127.0.0.1}
	login_port=${8:6032}
	config_file=${9:}

endsnippet

snippet proxysql_manage_config "Writes the proxysql configuration settings between layers." b
proxysql_manage_config: >
	action=${1:LOAD|SAVE}
	config_settings=${2:MYSQL USERS|MYSQL SERVERS|MYSQL QUERY RULES|MYSQL VARIABLES|ADMIN VARIABLES|SCHEDULER}
	direction=${3:FROM|TO}
	config_layer=${4:MEMORY|DISK|RUNTIME|CONFIG}

	login_user=${5:# The username used to authenticate to ProxySQL admin interface.}
	login_password=${6:# The password used to authenticate to ProxySQL admin interface.}
	login_host=${7:127.0.0.1}
	login_port=${8:6032}
	config_file=${9:}

endsnippet

snippet proxysql_scheduler "Adds or removes schedules from proxysql admin interface." b
proxysql_scheduler: >
	filename=${1:# Full path of the executable to be executed.}

	active=${2:yes}
	interval_ms=${3:10000}
	arg1=${4:# Argument that can be passed to the job.}
	arg2=${5:# Argument that can be passed to the job.}
	arg3=${6:# Argument that can be passed to the job.}
	arg4=${7:# Argument that can be passed to the job.}
	arg5=${8:# Argument that can be passed to the job.}
	comment=${9:# Text field that can be used for any purposed defined by the user.}
	state=${10:#present|absent}
	force_delete=${11:no}
	save_to_disk=${12:yes}
	load_to_runtime=${13:yes}
	login_user=${14:# The username used to authenticate to ProxySQL admin interface.}
	login_password=${15:# The password used to authenticate to ProxySQL admin interface.}
	login_host=${16:127.0.0.1}
	login_port=${17:6032}
	config_file=${18:}

endsnippet

snippet proxysql_backend_servers "Adds or removes mysql hosts from proxysql admin interface." b
proxysql_backend_servers: >
	hostname=${1:# The ip address at which the mysqld instance can be contacted.}

	hostgroup_id=${2:0}
	port=${3:3306}
	status=${4:ONLINE|OFFLINE_SOFT|OFFLINE_HARD}
	weight=${5:# The bigger the weight of a server relative to other weights, the higher the probability of the server being chosen from the hostgroup. If omitted the proxysql database default for I(weight) is 1.}
	compression=${6:# If the value of I(compression) is greater than 0, new connections to that server will use compression. If omitted the proxysql database default for I(compression) is 0.}
	max_connections=${7:# The maximum number of connections ProxySQL will open to this backend server. If omitted the proxysql database default for I(max_connections) is 1000.}
	max_replication_lag=${8:# If greater than 0, ProxySQL will regularly monitor replication lag. If replication lag goes above I(max_replication_lag), proxysql will temporarily shun the server until replication catches up. If omitted the proxysql database default for I(max_replication_lag) is 0.}
	use_ssl=${9:# If I(use_ssl) is set to C(True), connections to this server will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).}
	max_latency_ms=${10:# Ping time is monitored regularly. If a host has a ping time greater than I(max_latency_ms) it is excluded from the connection pool (although the server stays ONLINE). If omitted the proxysql database default for I(max_latency_ms) is 0.}
	comment=${11:}
	state=${12:#present|absent}
	save_to_disk=${13:yes}
	load_to_runtime=${14:yes}
	login_user=${15:# The username used to authenticate to ProxySQL admin interface.}
	login_password=${16:# The password used to authenticate to ProxySQL admin interface.}
	login_host=${17:127.0.0.1}
	login_port=${18:6032}
	config_file=${19:}

endsnippet

snippet proxysql_mysql_users "Adds or removes mysql users from proxysql admin interface." b
proxysql_mysql_users: >
	username=${1:# Name of the user connecting to the mysqld or ProxySQL instance.}

	password=${2:# Password of the user connecting to the mysqld or ProxySQL instance.}
	active=${3:# A user with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures. If omitted the proxysql database default for I(active) is C(True).}
	use_ssl=${4:# If I(use_ssl) is set to C(True), connections by this user will be made using SSL connections. If omitted the proxysql database default for I(use_ssl) is C(False).}
	default_hostgroup=${5:# If there is no matching rule for the queries sent by this user, the traffic it generates is sent to the specified hostgroup. If omitted the proxysql database default for I(use_ssl) is 0.}
	default_schema=${6:# The schema to which the connection should change to by default.}
	transaction_persistent=${7:# If this is set for the user with which the MySQL client is connecting to ProxySQL (thus a "frontend" user), transactions started within a hostgroup will remain within that hostgroup regardless of any other rules. If omitted the proxysql database default for I(transaction_persistent) is C(False).}
	fast_forward=${8:# If I(fast_forward) is set to C(True), I(fast_forward) will bypass the query processing layer (rewriting, caching) and pass through the query directly as is to the backend server. If omitted the proxysql database default for I(fast_forward) is C(False).}
	backend=${9:yes}
	frontend=${10:yes}
	max_connections=${11:# The maximum number of connections ProxySQL will open to the backend for this user. If omitted the proxysql database default for I(max_connections) is 10000.}
	state=${12:#present|absent}
	save_to_disk=${13:yes}
	load_to_runtime=${14:yes}
	login_user=${15:# The username used to authenticate to ProxySQL admin interface.}
	login_password=${16:# The password used to authenticate to ProxySQL admin interface.}
	login_host=${17:127.0.0.1}
	login_port=${18:6032}
	config_file=${19:}

endsnippet

snippet proxysql_query_rules "Modifies query rules using the proxysql admin interface." b
proxysql_query_rules: >
	rule_id=${1:# The unique id of the rule. Rules are processed in rule_id order.}
	active=${2:# A rule with I(active) set to C(False) will be tracked in the database, but will be never loaded in the in-memory data structures.}
	username=${3:# Filtering criteria matching username.  If I(username) is non-NULL, a query will match only if the connection is made with the correct username.}
	schemaname=${4:# Filtering criteria matching schemaname. If I(schemaname) is non-NULL, a query will match only if the connection uses schemaname as its default schema.}
	flagIN=${5:# Used in combination with I(flagOUT) and I(apply) to create chains of rules.}
	client_addr=${6:# Match traffic from a specific source.}
	proxy_addr=${7:# Match incoming traffic on a specific local IP.}
	proxy_port=${8:# Match incoming traffic on a specific local port.}
	digest=${9:# Match queries with a specific digest, as returned by stats_mysql_query_digest.digest.}
	match_digest=${10:# Regular expression that matches the query digest. The dialect of regular expressions used is that of re2 - https://github.com/google/re2}
	match_pattern=${11:# Regular expression that matches the query text. The dialect of regular expressions used is that of re2 - https://github.com/google/re2}
	negate_match_pattern=${12:# If I(negate_match_pattern) is set to C(True), only queries not matching the query text will be considered as a match. This acts as a NOT operator in front of the regular expression matching against match_pattern.}
	flagOUT=${13:# Used in combination with I(flagIN) and apply to create chains of rules. When set, I(flagOUT) signifies the I(flagIN) to be used in the next chain of rules.}
	replace_pattern=${14:# This is the pattern with which to replace the matched pattern. Note that this is optional, and when omitted, the query processor will only cache, route, or set other parameters without rewriting.}
	destination_hostgroup=${15:# Route matched queries to this hostgroup. This happens unless there is a started transaction and the logged in user has I(transaction_persistent) set to C(True) (see M(proxysql_mysql_users)).}
	cache_ttl=${16:# The number of milliseconds for which to cache the result of the query. Note in ProxySQL 1.1 I(cache_ttl) was in seconds.}
	timeout=${17:# The maximum timeout in milliseconds with which the matched or rewritten query should be executed. If a query run for longer than the specific threshold, the query is automatically killed. If timeout is not specified, the global variable mysql-default_query_timeout applies.}
	retries=${18:# The maximum number of times a query needs to be re-executed in case of detected failure during the execution of the query. If retries is not specified, the global variable mysql-query_retries_on_failure applies.}
	delay=${19:# Number of milliseconds to delay the execution of the query. This is essentially a throttling mechanism and QoS, and allows a way to give priority to queries over others. This value is added to the mysql-default_query_delay global variable that applies to all queries.}
	mirror_flagOUT=${20:# Enables query mirroring. If set I(mirror_flagOUT) can be used to evaluates the mirrored query against the specified chain of rules.}
	mirror_hostgroup=${21:# Enables query mirroring. If set I(mirror_hostgroup) can be used to mirror queries to the same or different hostgroup.}
	error_msg=${22:# Query will be blocked, and the specified error_msg will be returned to the client.}
	log=${23:# Query will be logged.}
	apply=${24:# Used in combination with I(flagIN) and I(flagOUT) to create chains of rules. Setting apply to True signifies the last rule to be applied.}
	comment=${25:# Free form text field, usable for a descriptive comment of the query rule.}
	state=${26:#present|absent}
	force_delete=${27:no}
	save_to_disk=${28:yes}
	load_to_runtime=${29:yes}
	login_user=${30:# The username used to authenticate to ProxySQL admin interface.}
	login_password=${31:# The password used to authenticate to ProxySQL admin interface.}
	login_host=${32:127.0.0.1}
	login_port=${33:6032}
	config_file=${34:}

endsnippet

snippet proxysql_replication_hostgroups "Manages replication hostgroups using the proxysql admin interface." b
proxysql_replication_hostgroups: >
	writer_hostgroup=${1:# Id of the writer hostgroup.}
	reader_hostgroup=${2:# Id of the reader hostgroup.}

	comment=${3:# Text field that can be used for any purposes defined by the user.}
	state=${4:#present|absent}
	save_to_disk=${5:yes}
	load_to_runtime=${6:yes}
	login_user=${7:# The username used to authenticate to ProxySQL admin interface.}
	login_password=${8:# The password used to authenticate to ProxySQL admin interface.}
	login_host=${9:127.0.0.1}
	login_port=${10:6032}
	config_file=${11:}

endsnippet

snippet vertica_role "Adds or removes Vertica database roles and assigns roles to them." b
vertica_role: >
	name=${1:# Name of the role to add or remove.}

	assigned_roles=${2:# Comma separated list of roles to assign to the role.}
	state=${3:#present|absent}
	db=${4:# Name of the Vertica database.}
	cluster=${5:localhost}
	port=${6:5433}
	login_user=${7:dbadmin}
	login_password=${8:# The password used to authenticate with.}

endsnippet

snippet vertica_info "Gathers Vertica database facts." b
vertica_info: >
	cluster=${1:localhost}
	port=${2:5433}
	db=${3:# Name of the database running the schema.}
	login_user=${4:dbadmin}
	login_password=${5:# The password used to authenticate with.}

endsnippet

snippet vertica_user "Adds or removes Vertica database users and assigns roles." b
vertica_user: >
	name=${1:# Name of the user to add or remove.}

	profile=${2:# Sets the user's profile.}
	resource_pool=${3:# Sets the user's resource pool.}
	password=${4:# The user's password encrypted by the MD5 algorithm.}
	expired=${5:# Sets the user's password expiration.}
	ldap=${6:# Set to true if users are authenticated via LDAP.}
	roles=${7:# Comma separated list of roles to assign to the user.}
	state=${8:#present|absent|locked}
	db=${9:# Name of the Vertica database.}
	cluster=${10:localhost}
	port=${11:5433}
	login_user=${12:dbadmin}
	login_password=${13:# The password used to authenticate with.}

endsnippet

snippet vertica_configuration "Updates Vertica configuration parameters." b
vertica_configuration: >
	name=${1:# Name of the parameter to update.}
	value=${2:# Value of the parameter to be set.}

	db=${3:# Name of the Vertica database.}
	cluster=${4:localhost}
	port=${5:5433}
	login_user=${6:dbadmin}
	login_password=${7:# The password used to authenticate with.}

endsnippet

snippet vertica_info "Gathers Vertica database facts." b
vertica_info: >
	cluster=${1:localhost}
	port=${2:5433}
	db=${3:# Name of the database running the schema.}
	login_user=${4:dbadmin}
	login_password=${5:# The password used to authenticate with.}

endsnippet

snippet vertica_schema "Adds or removes Vertica database schema and roles." b
vertica_schema: >
	name=${1:# Name of the schema to add or remove.}

	usage_roles=${2:# Comma separated list of roles to create and grant usage access to the schema.}
	create_roles=${3:# Comma separated list of roles to create and grant usage and create access to the schema.}
	owner=${4:# Name of the user to set as owner of the schema.}
	state=${5:#present|absent}
	db=${6:# Name of the Vertica database.}
	cluster=${7:localhost}
	port=${8:5433}
	login_user=${9:dbadmin}
	login_password=${10:# The password used to authenticate with.}

endsnippet

snippet mssql_db "Add or remove MSSQL databases from a remote host." b
mssql_db: >
	name=${1:# name of the database to add or remove}

	login_user=${2:# The username used to authenticate with}
	login_password=${3:# The password used to authenticate with}
	login_host=${4:# Host running the database}
	login_port=${5:1433}
	state=${6:#present|absent|import}
	target=${7:# Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) files are supported.}
	autocommit=${8:no}

endsnippet

snippet openssl_privatekey_info "Provide information for OpenSSL private keys" b
openssl_privatekey_info: >
	path=${1:# Remote absolute path where the private key file is loaded from.}

	passphrase=${2:# The passphrase for the private key.}
	return_private_key_data=${3:no}
	select_crypto_backend=${4:#auto|cryptography|pyopenssl}

endsnippet

snippet get_certificate "Get a certificate from a host:port" b
get_certificate: >
	host=${1:# The host to get the cert for (IP is fine)}
	port=${2:# The port to connect to}

	ca_cert=${3:# A PEM file containing one or more root certificates; if present, the cert will be validated against these root certs.}
	proxy_host=${4:# Proxy host used when get a certificate.}
	proxy_port=${5:8080}
	timeout=${6:10}
	select_crypto_backend=${7:#auto|cryptography|pyopenssl}

endsnippet

snippet certificate_complete_chain "Complete certificate chain given a set of untrusted and root certificates" b
certificate_complete_chain: >
	input_chain=${1:# A concatenated set of certificates in PEM format forming a chain.}
	root_certificates=${2:# A list of filenames or directories.}

	intermediate_certificates=${3:[]}

endsnippet

snippet openssl_certificate "Generate and/or check OpenSSL certificates" b
openssl_certificate: >
	path=${1:# Remote absolute path where the generated certificate file should be created or is already located.}

	state=${2:absent|#present}
	provider=${3:acme|assertonly|entrust|ownca|selfsigned}
	force=${4:no}
	csr_path=${5:# Path to the Certificate Signing Request (CSR) used to generate this certificate.}
	privatekey_path=${6:# Path to the private key to use when signing the certificate.}
	privatekey_passphrase=${7:# The passphrase for the I(privatekey_path).}
	selfsigned_version=${8:3}
	selfsigned_digest=${9:sha256}
	selfsigned_not_before=${10:+0s}
	selfsigned_not_after=${11:+3650d}
	selfsigned_create_subject_key_identifier=${12:#create_if_not_provided|always_create|never_create}
	ownca_path=${13:# Remote absolute path of the CA (Certificate Authority) certificate.}
	ownca_privatekey_path=${14:# Path to the CA (Certificate Authority) private key to use when signing the certificate.}
	ownca_privatekey_passphrase=${15:# The passphrase for the I(ownca_privatekey_path).}
	ownca_digest=${16:sha256}
	ownca_version=${17:3}
	ownca_not_before=${18:+0s}
	ownca_not_after=${19:+3650d}
	ownca_create_subject_key_identifier=${20:#create_if_not_provided|always_create|never_create}
	ownca_create_authority_key_identifier=${21:yes}
	acme_accountkey_path=${22:# The path to the accountkey for the C(acme) provider.}
	acme_challenge_path=${23:# The path to the ACME challenge directory that is served on U(http://<HOST>:80/.well-known/acme-challenge/)}
	acme_chain=${24:no}
	signature_algorithms=${25:# A list of algorithms that you would accept the certificate to be signed with (e.g. ['sha256WithRSAEncryption', 'sha512WithRSAEncryption']).}
	issuer=${26:# The key/value pairs that must be present in the issuer name field of the certificate.}
	issuer_strict=${27:no}
	subject=${28:# The key/value pairs that must be present in the subject name field of the certificate.}
	subject_strict=${29:no}
	has_expired=${30:no}
	version=${31:# The version of the certificate.}
	valid_at=${32:# The certificate must be valid at this point in time.}
	invalid_at=${33:# The certificate must be invalid at this point in time.}
	not_before=${34:# The certificate must start to become valid at this point in time.}
	not_after=${35:# The certificate must expire at this point in time.}
	valid_in=${36:# The certificate must still be valid at this relative time offset from now.}
	key_usage=${37:# The I(key_usage) extension field must contain all these values.}
	key_usage_strict=${38:no}
	extended_key_usage=${39:# The I(extended_key_usage) extension field must contain all these values.}
	extended_key_usage_strict=${40:no}
	subject_alt_name=${41:# The I(subject_alt_name) extension field must contain these values.}
	subject_alt_name_strict=${42:no}
	select_crypto_backend=${43:#auto|cryptography|pyopenssl}
	backup=${44:no}
	entrust_cert_type=${45:#STANDARD_SSL|ADVANTAGE_SSL|UC_SSL|EV_SSL|WILDCARD_SSL|PRIVATE_SSL|PD_SSL|CDS_ENT_LITE|CDS_ENT_PRO|SMIME_ENT}
	entrust_requester_email=${46:# The email of the requester of the certificate (for tracking purposes).}
	entrust_requester_name=${47:# The name of the requester of the certificate (for tracking purposes).}
	entrust_requester_phone=${48:# The phone number of the requester of the certificate (for tracking purposes).}
	entrust_api_user=${49:# The username for authentication to the Entrust Certificate Services (ECS) API.}
	entrust_api_key=${50:# The key (password) for authentication to the Entrust Certificate Services (ECS) API.}
	entrust_api_client_cert_path=${51:# The path to the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.}
	entrust_api_client_cert_key_path=${52:# The path to the private key of the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.}
	entrust_not_after=${53:+365d}
	entrust_api_specification_path=${54:https://cloud.entrust.net/EntrustCloud/documentation/cms-api-2.1.0.yaml}
	mode=${55:# The permissions the resulting file or directory should have.}
	owner=${56:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${57:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${58:# The user part of the SELinux file context.}
	serole=${59:# The role part of the SELinux file context.}
	setype=${60:# The type part of the SELinux file context.}
	selevel=${61:s0}
	unsafe_writes=${62:no}
	attributes=${63:# The attributes the resulting file or directory should have.}

endsnippet

snippet luks_device "Manage encrypted (LUKS) devices" b
luks_device: >
	device=${1:# Device to work with (e.g. C(/dev/sda1)). Needed in most cases. Can be omitted only when I(state=closed) together with I(name) is provided.}
	state=${2:#present|absent|opened|closed}
	name=${3:# Sets container name when I(state=opened). Can be used instead of I(device) when closing the existing container (i.e. when I(state=closed)).}
	keyfile=${4:# Used to unlock the container and needed for most of the operations. Parameter value is the path to the keyfile with the passphrase.}
	new_keyfile=${5:# Adds additional key to given container on I(device). Needs I(keyfile) option for authorization. LUKS container supports up to 8 keys. Parameter value is the path to the keyfile with the passphrase.}
	remove_keyfile=${6:# Removes given key from the container on I(device). Does not remove the keyfile from filesystem. Parameter value is the path to the keyfile with the passphrase.}
	force_remove_last_key=${7:no}

endsnippet

snippet openssl_publickey "Generate an OpenSSL public key from its private key." b
openssl_publickey: >
	path=${1:# Name of the file in which the generated TLS/SSL public key will be written.}

	state=${2:absent|#present}
	force=${3:no}
	format=${4:OpenSSH|#PEM}
	privatekey_path=${5:# Path to the TLS/SSL private key from which to generate the public key.}
	privatekey_passphrase=${6:# The passphrase for the private key.}
	backup=${7:no}
	select_crypto_backend=${8:#auto|cryptography|pyopenssl}
	mode=${9:# The permissions the resulting file or directory should have.}
	owner=${10:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${11:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${12:# The user part of the SELinux file context.}
	serole=${13:# The role part of the SELinux file context.}
	setype=${14:# The type part of the SELinux file context.}
	selevel=${15:s0}
	unsafe_writes=${16:no}
	attributes=${17:# The attributes the resulting file or directory should have.}

endsnippet

snippet openssl_dhparam "Generate OpenSSL Diffie-Hellman Parameters" b
openssl_dhparam: >
	path=${1:# Name of the file in which the generated parameters will be saved.}

	state=${2:absent|#present}
	size=${3:4096}
	force=${4:no}
	backup=${5:no}
	mode=${6:# The permissions the resulting file or directory should have.}
	owner=${7:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${8:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${9:# The user part of the SELinux file context.}
	serole=${10:# The role part of the SELinux file context.}
	setype=${11:# The type part of the SELinux file context.}
	selevel=${12:s0}
	unsafe_writes=${13:no}
	attributes=${14:# The attributes the resulting file or directory should have.}

endsnippet

snippet openssh_cert "Generate OpenSSH host or user certificates." b
openssh_cert: >
	path=${1:# Path of the file containing the certificate.}

	state=${2:#present|absent}
	type=${3:host|user}
	force=${4:no}
	signing_key=${5:# The path to the private openssh key that is used for signing the public key in order to generate the certificate.}
	public_key=${6:# The path to the public key that will be signed with the signing key in order to generate the certificate.}
	valid_from=${7:# The point in time the certificate is valid from. Time can be specified either as relative time or as absolute timestamp. Time will always be interpreted as UTC. Valid formats are: C([+-]timespec | YYYY-MM-DD | YYYY-MM-DDTHH:MM:SS | YYYY-MM-DD HH:MM:SS | always) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h). Note that if using relative time this module is NOT idempotent.}
	valid_to=${8:# The point in time the certificate is valid to. Time can be specified either as relative time or as absolute timestamp. Time will always be interpreted as UTC. Valid formats are: C([+-]timespec | YYYY-MM-DD | YYYY-MM-DDTHH:MM:SS | YYYY-MM-DD HH:MM:SS | forever) where timespec can be an integer + C([w | d | h | m | s]) (e.g. C(+32w1d2h). Note that if using relative time this module is NOT idempotent.}
	valid_at=${9:# Check if the certificate is valid at a certain point in time. If it is not the certificate will be regenerated. Time will always be interpreted as UTC. Mainly to be used with relative timespec for I(valid_from) and / or I(valid_to). Note that if using relative time this module is NOT idempotent.}
	principals=${10:# Certificates may be limited to be valid for a set of principal (user/host) names. By default, generated certificates are valid for all users or hosts.}
	options=${11:# Specify certificate options when signing a key. The option that are valid for user certificates are:}
	identifier=${12:# Specify the key identity when signing a public key. The identifier that is logged by the server when the certificate is used for authentication.}
	serial_number=${13:# Specify the certificate serial number. The serial number is logged by the server when the certificate is used for authentication. The certificate serial number may be used in a KeyRevocationList. The serial number may be omitted for checks, but must be specified again for a new certificate. Note: The default value set by ssh-keygen is 0.}
	mode=${14:# The permissions the resulting file or directory should have.}
	owner=${15:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${16:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${17:# The user part of the SELinux file context.}
	serole=${18:# The role part of the SELinux file context.}
	setype=${19:# The type part of the SELinux file context.}
	selevel=${20:s0}
	unsafe_writes=${21:no}
	attributes=${22:# The attributes the resulting file or directory should have.}

endsnippet

snippet openssl_csr_info "Provide information of OpenSSL Certificate Signing Requests (CSR)" b
openssl_csr_info: >
	path=${1:# Remote absolute path where the CSR file is loaded from.}

	select_crypto_backend=${2:#auto|cryptography|pyopenssl}

endsnippet

snippet openssl_privatekey "Generate OpenSSL private keys" b
openssl_privatekey: >
	path=${1:# Name of the file in which the generated TLS/SSL private key will be written. It will have 0600 mode.}

	state=${2:absent|#present}
	size=${3:4096}
	type=${4:DSA|ECC|Ed25519|Ed448|#RSA|X25519|X448}
	curve=${5:secp384r1|secp521r1|secp224r1|secp192r1|secp256r1|secp256k1|brainpoolP256r1|brainpoolP384r1|brainpoolP512r1|sect571k1|sect409k1|sect283k1|sect233k1|sect163k1|sect571r1|sect409r1|sect283r1|sect233r1|sect163r2}
	force=${6:no}
	passphrase=${7:# The passphrase for the private key.}
	cipher=${8:# The cipher to encrypt the private key. (Valid values can be found by running `openssl list -cipher-algorithms` or `openssl list-cipher-algorithms`, depending on your OpenSSL version.)}
	select_crypto_backend=${9:#auto|cryptography|pyopenssl}
	backup=${10:no}
	mode=${11:# The permissions the resulting file or directory should have.}
	owner=${12:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${13:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${14:# The user part of the SELinux file context.}
	serole=${15:# The role part of the SELinux file context.}
	setype=${16:# The type part of the SELinux file context.}
	selevel=${17:s0}
	unsafe_writes=${18:no}
	attributes=${19:# The attributes the resulting file or directory should have.}

endsnippet

snippet openssh_keypair "Generate OpenSSH private and public keys." b
openssh_keypair: >
	path=${1:# Name of the files containing the public and private key. The file containing the public key will have the extension C(.pub).}

	state=${2:#present|absent}
	size=${3:# Specifies the number of bits in the private key to create. For RSA keys, the minimum size is 1024 bits and the default is 4096 bits. Generally, 2048 bits is considered sufficient.  DSA keys must be exactly 1024 bits as specified by FIPS 186-2. For ECDSA keys, size determines the key length by selecting from one of three elliptic curve sizes: 256, 384 or 521 bits. Attempting to use bit lengths other than these three values for ECDSA keys will cause this module to fail. Ed25519 keys have a fixed length and the size will be ignored.}
	type=${4:#rsa|dsa|rsa1|ecdsa|ed25519}
	force=${5:no}
	comment=${6:# Provides a new comment to the public key. When checking if the key is in the correct state this will be ignored.}
	mode=${7:# The permissions the resulting file or directory should have.}
	owner=${8:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${9:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${10:# The user part of the SELinux file context.}
	serole=${11:# The role part of the SELinux file context.}
	setype=${12:# The type part of the SELinux file context.}
	selevel=${13:s0}
	unsafe_writes=${14:no}
	attributes=${15:# The attributes the resulting file or directory should have.}

endsnippet

snippet openssl_csr "Generate OpenSSL Certificate Signing Request (CSR)" b
openssl_csr: >
	path=${1:# The name of the file into which the generated OpenSSL certificate signing request will be written.}

	state=${2:absent|#present}
	digest=${3:sha256}
	privatekey_path=${4:# The path to the private key to use when signing the certificate signing request.}
	privatekey_passphrase=${5:# The passphrase for the private key.}
	version=${6:1}
	force=${7:no}
	subject=${8:# Key/value pairs that will be present in the subject name field of the certificate signing request.}
	country_name=${9:# The countryName field of the certificate signing request subject.}
	state_or_province_name=${10:# The stateOrProvinceName field of the certificate signing request subject.}
	locality_name=${11:# The localityName field of the certificate signing request subject.}
	organization_name=${12:# The organizationName field of the certificate signing request subject.}
	organizational_unit_name=${13:# The organizationalUnitName field of the certificate signing request subject.}
	common_name=${14:# The commonName field of the certificate signing request subject.}
	email_address=${15:# The emailAddress field of the certificate signing request subject.}
	subject_alt_name=${16:# SAN extension to attach to the certificate signing request.}
	subject_alt_name_critical=${17:# Should the subjectAltName extension be considered as critical.}
	use_common_name_for_san=${18:yes}
	key_usage=${19:# This defines the purpose (e.g. encipherment, signature, certificate signing) of the key contained in the certificate.}
	key_usage_critical=${20:# Should the keyUsage extension be considered as critical.}
	extended_key_usage=${21:# Additional restrictions (e.g. client authentication, server authentication) on the allowed purposes for which the public key may be used.}
	extended_key_usage_critical=${22:# Should the extkeyUsage extension be considered as critical.}
	basic_constraints=${23:# Indicates basic constraints, such as if the certificate is a CA.}
	basic_constraints_critical=${24:# Should the basicConstraints extension be considered as critical.}
	ocsp_must_staple=${25:# Indicates that the certificate should contain the OCSP Must Staple extension (U(https://tools.ietf.org/html/rfc7633)).}
	ocsp_must_staple_critical=${26:# Should the OCSP Must Staple extension be considered as critical}
	select_crypto_backend=${27:#auto|cryptography|pyopenssl}
	backup=${28:no}
	create_subject_key_identifier=${29:no}
	subject_key_identifier=${30:# The subject key identifier as a hex string, where two bytes are separated by colons.}
	authority_key_identifier=${31:# The authority key identifier as a hex string, where two bytes are separated by colons.}
	authority_cert_issuer=${32:# Names that will be present in the authority cert issuer field of the certificate signing request.}
	authority_cert_serial_number=${33:# The authority cert serial number.}
	mode=${34:# The permissions the resulting file or directory should have.}
	owner=${35:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${36:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${37:# The user part of the SELinux file context.}
	serole=${38:# The role part of the SELinux file context.}
	setype=${39:# The type part of the SELinux file context.}
	selevel=${40:s0}
	unsafe_writes=${41:no}
	attributes=${42:# The attributes the resulting file or directory should have.}

endsnippet

snippet openssl_pkcs12 "Generate OpenSSL PKCS#12 archive" b
openssl_pkcs12: >
	path=${1:# Filename to write the PKCS#12 file to.}

	action=${2:#export|parse}
	other_certificates=${3:# List of other certificates to include. Pre 2.8 this parameter was called C(ca_certificates)}
	certificate_path=${4:# The path to read certificates and private keys from.}
	force=${5:no}
	friendly_name=${6:# Specifies the friendly name for the certificate and private key.}
	iter_size=${7:2048}
	maciter_size=${8:1}
	passphrase=${9:# The PKCS#12 password.}
	privatekey_passphrase=${10:# Passphrase source to decrypt any input private keys with.}
	privatekey_path=${11:# File to read private key from.}
	state=${12:absent|#present}
	src=${13:# PKCS#12 file path to parse.}
	backup=${14:no}
	mode=${15:# The permissions the resulting file or directory should have.}
	owner=${16:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${17:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${18:# The user part of the SELinux file context.}
	serole=${19:# The role part of the SELinux file context.}
	setype=${20:# The type part of the SELinux file context.}
	selevel=${21:s0}
	unsafe_writes=${22:no}
	attributes=${23:# The attributes the resulting file or directory should have.}

endsnippet

snippet openssl_certificate_info "Provide information of OpenSSL X.509 certificates" b
openssl_certificate_info: >
	path=${1:# Remote absolute path where the certificate file is loaded from.}

	valid_at=${2:# A dict of names mapping to time specifications. Every time specified here will be checked whether the certificate is valid at this point. See the C(valid_at) return value for informations on the result.}
	select_crypto_backend=${3:#auto|cryptography|pyopenssl}

endsnippet

snippet acme_challenge_cert_helper "Prepare certificates required for ACME challenges such as C(tls-alpn-01)" b
acme_challenge_cert_helper: >
	challenge=${1:tls-alpn-01}
	challenge_data=${2:# The C(challenge_data) entry provided by M(acme_certificate) for the challenge.}

	private_key_src=${3:# Path to a file containing the private key file to use for this challenge certificate.}
	private_key_content=${4:# Content of the private key to use for this challenge certificate.}

endsnippet

snippet acme_account "Create, modify or delete ACME accounts" b
acme_account: >
	state=${1:present|absent|changed_key}

	allow_creation=${2:yes}
	contact=${3:[]}
	terms_agreed=${4:no}
	new_account_key_src=${5:# Path to a file containing the ACME account RSA or Elliptic Curve key to change to.}
	new_account_key_content=${6:# Content of the ACME account RSA or Elliptic Curve key to change to.}
	account_key_src=${7:# Path to a file containing the ACME account RSA or Elliptic Curve key.}
	account_key_content=${8:# Content of the ACME account RSA or Elliptic Curve key.}
	account_uri=${9:# If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.}
	acme_version=${10:#1|2}
	acme_directory=${11:https://acme-staging.api.letsencrypt.org/directory}
	validate_certs=${12:yes}
	select_crypto_backend=${13:#auto|cryptography|openssl}

endsnippet

snippet acme_account_info "Retrieves information on ACME accounts" b
acme_account_info: >
	retrieve_orders=${1:#ignore|url_list|object_list}
	account_key_src=${2:# Path to a file containing the ACME account RSA or Elliptic Curve key.}
	account_key_content=${3:# Content of the ACME account RSA or Elliptic Curve key.}
	account_uri=${4:# If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.}
	acme_version=${5:#1|2}
	acme_directory=${6:https://acme-staging.api.letsencrypt.org/directory}
	validate_certs=${7:yes}
	select_crypto_backend=${8:#auto|cryptography|openssl}

endsnippet

snippet acme_certificate_revoke "Revoke certificates with the ACME protocol" b
acme_certificate_revoke: >
	certificate=${1:# Path to the certificate to revoke.}

	account_key_src=${2:# Path to a file containing the ACME account RSA or Elliptic Curve key.}
	account_key_content=${3:# Content of the ACME account RSA or Elliptic Curve key.}
	private_key_src=${4:# Path to the certificate's private key.}
	private_key_content=${5:# Content of the certificate's private key.}
	revoke_reason=${6:# One of the revocation reasonCodes defined in L(https://tools.ietf.org/html/rfc5280#section-5.3.1, Section 5.3.1 of RFC5280).}
	account_uri=${7:# If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.}
	acme_version=${8:#1|2}
	acme_directory=${9:https://acme-staging.api.letsencrypt.org/directory}
	validate_certs=${10:yes}
	select_crypto_backend=${11:#auto|cryptography|openssl}

endsnippet

snippet acme_certificate "Create SSL/TLS certificates with the ACME protocol" b
acme_certificate: >
	csr=${1:# File containing the CSR for the new certificate.}

	account_email=${2:# The email address associated with this account.}
	agreement=${3:# URI to a terms of service document you agree to when using the ACME v1 service at C(acme_directory).}
	terms_agreed=${4:no}
	modify_account=${5:yes}
	challenge=${6:#http-01|dns-01|tls-alpn-01}
	data=${7:# The data to validate ongoing challenges. This must be specified for the second run of the module only.}
	dest=${8:# The destination file for the certificate.}
	fullchain_dest=${9:# The destination file for the full chain (i.e. certificate followed by chain of intermediate certificates).}
	chain_dest=${10:# If specified, the intermediate certificate will be written to this file.}
	remaining_days=${11:10}
	deactivate_authzs=${12:no}
	force=${13:no}
	retrieve_all_alternates=${14:no}
	account_key_src=${15:# Path to a file containing the ACME account RSA or Elliptic Curve key.}
	account_key_content=${16:# Content of the ACME account RSA or Elliptic Curve key.}
	account_uri=${17:# If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.}
	acme_version=${18:#1|2}
	acme_directory=${19:https://acme-staging.api.letsencrypt.org/directory}
	validate_certs=${20:yes}
	select_crypto_backend=${21:#auto|cryptography|openssl}

endsnippet

snippet acme_certificate "Create SSL/TLS certificates with the ACME protocol" b
acme_certificate: >
	csr=${1:# File containing the CSR for the new certificate.}

	account_email=${2:# The email address associated with this account.}
	agreement=${3:# URI to a terms of service document you agree to when using the ACME v1 service at C(acme_directory).}
	terms_agreed=${4:no}
	modify_account=${5:yes}
	challenge=${6:#http-01|dns-01|tls-alpn-01}
	data=${7:# The data to validate ongoing challenges. This must be specified for the second run of the module only.}
	dest=${8:# The destination file for the certificate.}
	fullchain_dest=${9:# The destination file for the full chain (i.e. certificate followed by chain of intermediate certificates).}
	chain_dest=${10:# If specified, the intermediate certificate will be written to this file.}
	remaining_days=${11:10}
	deactivate_authzs=${12:no}
	force=${13:no}
	retrieve_all_alternates=${14:no}
	account_key_src=${15:# Path to a file containing the ACME account RSA or Elliptic Curve key.}
	account_key_content=${16:# Content of the ACME account RSA or Elliptic Curve key.}
	account_uri=${17:# If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.}
	acme_version=${18:#1|2}
	acme_directory=${19:https://acme-staging.api.letsencrypt.org/directory}
	validate_certs=${20:yes}
	select_crypto_backend=${21:#auto|cryptography|openssl}

endsnippet

snippet acme_inspect "Send direct requests to an ACME server" b
acme_inspect: >
	url=${1:# The URL to send the request to.}
	method=${2:#get|post|directory-only}
	content=${3:# An encoded JSON object which will be sent as the content if I(method) is C(post).}
	fail_on_acme_error=${4:yes}
	account_key_src=${5:# Path to a file containing the ACME account RSA or Elliptic Curve key.}
	account_key_content=${6:# Content of the ACME account RSA or Elliptic Curve key.}
	account_uri=${7:# If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.}
	acme_version=${8:#1|2}
	acme_directory=${9:https://acme-staging.api.letsencrypt.org/directory}
	validate_certs=${10:yes}
	select_crypto_backend=${11:#auto|cryptography|openssl}

endsnippet

snippet acme_account_info "Retrieves information on ACME accounts" b
acme_account_info: >
	retrieve_orders=${1:#ignore|url_list|object_list}
	account_key_src=${2:# Path to a file containing the ACME account RSA or Elliptic Curve key.}
	account_key_content=${3:# Content of the ACME account RSA or Elliptic Curve key.}
	account_uri=${4:# If specified, assumes that the account URI is as given. If the account key does not match this account, or an account with this URI does not exist, the module fails.}
	acme_version=${5:#1|2}
	acme_directory=${6:https://acme-staging.api.letsencrypt.org/directory}
	validate_certs=${7:yes}
	select_crypto_backend=${8:#auto|cryptography|openssl}

endsnippet

snippet ecs_certificate "Request SSL/TLS certificates with the Entrust Certificate Services (ECS) API" b
ecs_certificate: >
	path=${1:# The destination path for the generated certificate as a PEM encoded cert.}
	requester_name=${2:# T}
	requester_email=${3:# T}
	requester_phone=${4:# T}
	entrust_api_user=${5:# The username for authentication to the Entrust Certificate Services (ECS) API.}
	entrust_api_key=${6:# The key (password) for authentication to the Entrust Certificate Services (ECS) API.}
	entrust_api_client_cert_path=${7:# The path to the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.}
	entrust_api_client_cert_key_path=${8:# The path to the key for the client certificate used to authenticate to the Entrust Certificate Services (ECS) API.}

	backup=${9:no}
	force=${10:no}
	full_chain_path=${11:# The destination path for the full certificate chain of the certificate, intermediates, and roots.}
	csr=${12:# Base-64 encoded Certificate Signing Request (CSR). I(csr) is accepted with or without PEM formatting around the Base-64 string.}
	tracking_id=${13:# The tracking ID of the certificate to reissue or renew.}
	remaining_days=${14:30}
	request_type=${15:#new|renew|reissue|validate_only}
	cert_type=${16:STANDARD_SSL|ADVANTAGE_SSL|UC_SSL|EV_SSL|WILDCARD_SSL|PRIVATE_SSL|PD_SSL|CODE_SIGNING|EV_CODE_SIGNING|CDS_INDIVIDUAL|CDS_GROUP|CDS_ENT_LITE|CDS_ENT_PRO|SMIME_ENT}
	subject_alt_name=${17:# The subject alternative name identifiers, as an array of values (applies to I(cert_type) with a value of C(STANDARD_SSL), C(ADVANTAGE_SSL), C(UC_SSL), C(EV_SSL), C(WILDCARD_SSL), C(PRIVATE_SSL), and C(PD_SSL)).}
	eku=${18:SERVER_AUTH|CLIENT_AUTH|SERVER_AND_CLIENT_AUTH}
	ct_log=${19:# In compliance with browser requirements, this certificate may be posted to the Certificate Transparency (CT) logs. This is a best practice technique that helps domain owners monitor certificates issued to their domains. Note that not all certificates are eligible for CT logging.}
	client_id=${20:1}
	org=${21:# Organization "O=" to include in the certificate.}
	ou=${22:# Organizational unit "OU=" to include in the certificate.}
	end_user_key_storage_agreement=${23:# The end user of the Code Signing certificate must generate and store the private key for this request on cryptographically secure hardware to be compliant with the Entrust CSP and Subscription agreement. If requesting a certificate of type C(CODE_SIGNING) or C(EV_CODE_SIGNING), you must set I(end_user_key_storage_agreement) to true if and only if you acknowledge that you will inform the user of this requirement.}
	tracking_info=${24:# F}
	additional_emails=${25:# A}
	custom_fields=${26:# Mapping of custom fields to associate with the certificate request and certificate.}
	cert_expiry=${27:# The date the certificate should be set to expire, in RFC3339 compliant date or date-time format. For example, C(2020-02-23), C(2020-02-23T15:00:00.05Z).}
	cert_lifetime=${28:P1Y|P2Y|P3Y}
	entrust_api_specification_path=${29:https://cloud.entrust.net/EntrustCloud/documentation/cms-api-2.1.0.yaml}

endsnippet

snippet onepassword_info "Gather items from 1Password" b
onepassword_info: >
	search_terms=${1:# A list of one or more search terms.}

	auto_login=${2:{}}
	cli_path=${3:op}

endsnippet

snippet onepassword_info "Gather items from 1Password" b
onepassword_info: >
	search_terms=${1:# A list of one or more search terms.}

	auto_login=${2:{}}
	cli_path=${3:op}

endsnippet

snippet ipa_role "Manage FreeIPA role" b
ipa_role: >
	cn=${1:# Role name.}
	ipa_pass=${2:# Password of administrative user.}

	description=${3:# A description of this role-group.}
	group=${4:# List of group names assign to this role.}
	host=${5:# List of host names to assign.}
	hostgroup=${6:# List of host group names to assign.}
	privilege=${7:# List of privileges granted to the role.}
	service=${8:# List of service names to assign.}
	state=${9:#present|absent}
	user=${10:# List of user names to assign.}
	ipa_port=${11:443}
	ipa_host=${12:ipa.example.com}
	ipa_user=${13:admin}
	ipa_prot=${14:http|#https}
	validate_certs=${15:yes}
	ipa_timeout=${16:10}

endsnippet

snippet ipa_hbacrule "Manage FreeIPA HBAC rule" b
ipa_hbacrule: >
	cn=${1:# Canonical name.}
	ipa_pass=${2:# Password of administrative user.}

	description=${3:# D}
	host=${4:# List of host names to assign.}
	hostcategory=${5:all}
	hostgroup=${6:# List of hostgroup names to assign.}
	service=${7:# List of service names to assign.}
	servicecategory=${8:all}
	servicegroup=${9:# List of service group names to assign.}
	sourcehost=${10:# List of source host names to assign.}
	sourcehostcategory=${11:all}
	sourcehostgroup=${12:# List of source host group names to assign.}
	state=${13:#present|absent|enabled|disabled}
	user=${14:# List of user names to assign.}
	usercategory=${15:all}
	usergroup=${16:# List of user group names to assign.}
	ipa_port=${17:443}
	ipa_host=${18:ipa.example.com}
	ipa_user=${19:admin}
	ipa_prot=${20:http|#https}
	validate_certs=${21:yes}
	ipa_timeout=${22:10}

endsnippet

snippet ipa_host "Manage FreeIPA host" b
ipa_host: >
	fqdn=${1:# Full qualified domain name.}
	ipa_pass=${2:# Password of administrative user.}

	description=${3:# A description of this host.}
	force=${4:# Force host name even if not in DNS.}
	ip_address=${5:# Add the host to DNS with this IP address.}
	mac_address=${6:# List of Hardware MAC address(es) off this host.}
	ns_host_location=${7:# Host location (e.g. "Lab 2")}
	ns_hardware_platform=${8:# Host hardware platform (e.g. "Lenovo T61")}
	ns_os_version=${9:# Host operating system and version (e.g. "Fedora 9")}
	user_certificate=${10:# List of Base-64 encoded server certificates.}
	state=${11:#present|absent|enabled|disabled}
	update_dns=${12:no}
	random_password=${13:no}
	ipa_port=${14:443}
	ipa_host=${15:ipa.example.com}
	ipa_user=${16:admin}
	ipa_prot=${17:http|#https}
	validate_certs=${18:yes}
	ipa_timeout=${19:10}

endsnippet

snippet ipa_group "Manage FreeIPA group" b
ipa_group: >
	cn=${1:# Canonical name.}
	ipa_pass=${2:# Password of administrative user.}

	description=${3:# Description of the group.}
	external=${4:# Allow adding external non-IPA members from trusted domains.}
	gidnumber=${5:# GID (use this option to set it manually).}
	group=${6:# List of group names assigned to this group.}
	nonposix=${7:# Create as a non-POSIX group.}
	user=${8:# List of user names assigned to this group.}
	state=${9:#present|absent}
	ipa_port=${10:443}
	ipa_host=${11:ipa.example.com}
	ipa_user=${12:admin}
	ipa_prot=${13:http|#https}
	validate_certs=${14:yes}
	ipa_timeout=${15:10}

endsnippet

snippet ipa_vault "Manage FreeIPA vaults" b
ipa_vault: >
	cn=${1:# Vault name.}
	ipavaulttype=${2:standard|#symmetric|asymmetric}
	ipa_pass=${3:# Password of administrative user.}

	description=${4:# Description.}
	ipavaultpublickey=${5:# Public key.}
	ipavaultsalt=${6:# Vault Salt.}
	username=${7:# Any user can own one or more user vaults.}
	service=${8:# Any service can own one or more service vaults.}
	state=${9:#present|absent}
	replace=${10:True|False}
	validate_certs=${11:yes}
	ipa_port=${12:443}
	ipa_host=${13:ipa.example.com}
	ipa_user=${14:admin}
	ipa_prot=${15:http|#https}
	ipa_timeout=${16:10}

endsnippet

snippet ipa_sudocmdgroup "Manage FreeIPA sudo command group" b
ipa_sudocmdgroup: >
	cn=${1:# Sudo Command Group.}
	ipa_pass=${2:# Password of administrative user.}

	description=${3:# Group description.}
	state=${4:#present|absent|enabled|disabled}
	sudocmd=${5:# List of sudo commands to assign to the group.}
	ipa_port=${6:443}
	ipa_host=${7:ipa.example.com}
	ipa_user=${8:admin}
	ipa_prot=${9:http|#https}
	validate_certs=${10:yes}
	ipa_timeout=${11:10}

endsnippet

snippet ipa_user "Manage FreeIPA users" b
ipa_user: >
	uid=${1:# u}
	ipa_pass=${2:# Password of administrative user.}

	displayname=${3:# D}
	update_password=${4:#always|on_create}
	givenname=${5:# F}
	krbpasswordexpiration=${6:# Date at which the user password will expire}
	loginshell=${7:# L}
	mail=${8:# List of mail addresses assigned to the user.}
	password=${9:# Password for a user. Will not be set for an existing user unless C(update_password) is set to C(always), which is the default.}
	sn=${10:# S}
	sshpubkey=${11:# List of public SSH key.}
	state=${12:#present|absent|enabled|disabled}
	telephonenumber=${13:# List of telephone numbers assigned to the user.}
	title=${14:# T}
	uidnumber=${15:# Account Settings UID/Posix User ID number}
	gidnumber=${16:# Posix Group ID}
	ipa_port=${17:443}
	ipa_host=${18:ipa.example.com}
	ipa_user=${19:admin}
	ipa_prot=${20:http|#https}
	validate_certs=${21:yes}
	ipa_timeout=${22:10}

endsnippet

snippet ipa_dnszone "Manage FreeIPA DNS Zones" b
ipa_dnszone: >
	zone_name=${1:# The DNS zone name to which needs to be managed.}
	ipa_pass=${2:# Password of administrative user.}

	state=${3:#present|absent}
	dynamicupdate=${4:#false|true}
	ipa_port=${5:443}
	ipa_host=${6:ipa.example.com}
	ipa_user=${7:admin}
	ipa_prot=${8:http|#https}
	validate_certs=${9:yes}
	ipa_timeout=${10:10}

endsnippet

snippet ipa_sudorule "Manage FreeIPA sudo rule" b
ipa_sudorule: >
	cn=${1:# Canonical name.}
	ipa_pass=${2:# Password of administrative user.}

	cmdcategory=${3:all}
	cmd=${4:# List of commands assigned to the rule.}
	description=${5:# Description of the sudo rule.}
	host=${6:# List of hosts assigned to the rule.}
	hostcategory=${7:all}
	hostgroup=${8:# List of host groups assigned to the rule.}
	runasusercategory=${9:all}
	runasgroupcategory=${10:all}
	sudoopt=${11:# List of options to add to the sudo rule.}
	user=${12:# List of users assigned to the rule.}
	usercategory=${13:all}
	usergroup=${14:# List of user groups assigned to the rule.}
	state=${15:#present|absent|enabled|disabled}
	ipa_port=${16:443}
	ipa_host=${17:ipa.example.com}
	ipa_user=${18:admin}
	ipa_prot=${19:http|#https}
	validate_certs=${20:yes}
	ipa_timeout=${21:10}

endsnippet

snippet ipa_service "Manage FreeIPA service" b
ipa_service: >
	krbcanonicalname=${1:# principal of the service}
	ipa_pass=${2:# Password of administrative user.}

	hosts=${3:# defines the list of 'ManagedBy' hosts}
	force=${4:# Force principal name even if host is not in DNS.}
	state=${5:#present|absent}
	ipa_port=${6:443}
	ipa_host=${7:ipa.example.com}
	ipa_user=${8:admin}
	ipa_prot=${9:http|#https}
	validate_certs=${10:yes}
	ipa_timeout=${11:10}

endsnippet

snippet ipa_subca "Manage FreeIPA Lightweight Sub Certificate Authorities." b
ipa_subca: >
	subca_name=${1:# The Sub Certificate Authority name which needs to be managed.}
	subca_subject=${2:# The Sub Certificate Authority's Subject. e.g., 'CN=SampleSubCA1,O=testrelm.test'}
	subca_desc=${3:# The Sub Certificate Authority's description.}
	ipa_pass=${4:# Password of administrative user.}

	state=${5:#present|absent|enabled|disabled}
	ipa_port=${6:443}
	ipa_host=${7:ipa.example.com}
	ipa_user=${8:admin}
	ipa_prot=${9:http|#https}
	validate_certs=${10:yes}
	ipa_timeout=${11:10}

endsnippet

snippet ipa_sudocmd "Manage FreeIPA sudo command" b
ipa_sudocmd: >
	sudocmd=${1:# Sudo Command.}
	ipa_pass=${2:# Password of administrative user.}

	description=${3:# A description of this command.}
	state=${4:#present|absent|enabled|disabled}
	ipa_port=${5:443}
	ipa_host=${6:ipa.example.com}
	ipa_user=${7:admin}
	ipa_prot=${8:http|#https}
	validate_certs=${9:yes}
	ipa_timeout=${10:10}

endsnippet

snippet ipa_hostgroup "Manage FreeIPA host-group" b
ipa_hostgroup: >
	cn=${1:# Name of host-group.}
	ipa_pass=${2:# Password of administrative user.}

	description=${3:# Description}
	host=${4:# List of hosts that belong to the host-group.}
	hostgroup=${5:# List of host-groups than belong to that host-group.}
	state=${6:#present|absent|enabled|disabled}
	ipa_port=${7:443}
	ipa_host=${8:ipa.example.com}
	ipa_user=${9:admin}
	ipa_prot=${10:http|#https}
	validate_certs=${11:yes}
	ipa_timeout=${12:10}

endsnippet

snippet ipa_dnsrecord "Manage FreeIPA DNS records" b
ipa_dnsrecord: >
	zone_name=${1:# The DNS zone name to which DNS record needs to be managed.}
	record_name=${2:# The DNS record name to manage.}
	record_value=${3:# Manage DNS record name with this value.}
	ipa_pass=${4:# Password of administrative user.}

	record_type=${5:#A|AAAA|A6|CNAME|DNAME|PTR|TXT|SRV|MX}
	record_ttl=${6:# Set the TTL for the record.}
	state=${7:#present|absent}
	ipa_port=${8:443}
	ipa_host=${9:ipa.example.com}
	ipa_user=${10:admin}
	ipa_prot=${11:http|#https}
	validate_certs=${12:yes}
	ipa_timeout=${13:10}

endsnippet

snippet ipa_config "Manage Global FreeIPA Configuration Settings" b
ipa_config: >
	ipa_pass=${1:# Password of administrative user.}

	ipadefaultloginshell=${2:# D}
	ipadefaultemaildomain=${3:# D}
	ipa_port=${4:443}
	ipa_host=${5:ipa.example.com}
	ipa_user=${6:admin}
	ipa_prot=${7:http|#https}
	validate_certs=${8:yes}
	ipa_timeout=${9:10}

endsnippet

snippet cyberark_user "Module for CyberArk User Management using PAS Web Services SDK" b
cyberark_user: >
	username=${1:# The name of the user who will be queried (for details), added, updated or deleted.}
	cyberark_session=${2:# Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session, please see M(cyberark_authentication) module for an example of cyberark_session.}

	state=${3:absent|#present}
	initial_password=${4:# The password that the new user will use to log on the first time.}
	new_password=${5:# The user updated password. Make sure that this password meets the password policy requirements.}
	email=${6:# The user email address.}
	first_name=${7:# The user first name.}
	last_name=${8:# The user last name.}
	change_password_on_the_next_logon=${9:no}
	expiry_date=${10:# The date and time when the user account will expire and become disabled.}
	user_type_name=${11:# The type of user.}
	disabled=${12:no}
	location=${13:# The Vault Location for the user.}
	group_name=${14:# The name of the group the user will be added to.}

endsnippet

snippet cyberark_authentication "Module for CyberArk Vault Authentication using PAS Web Services SDK" b
cyberark_authentication: >
	state=${1:#present|absent}
	username=${2:# The name of the user who will logon to the Vault.}
	password=${3:# The password of the user.}
	new_password=${4:# The new password of the user. This parameter is optional, and enables you to change a password.}
	api_base_url=${5:# A string containing the base URL of the server hosting CyberArk's Privileged Account Security Web Services SDK.}
	validate_certs=${6:yes}
	use_shared_logon_authentication=${7:no}
	use_radius_authentication=${8:no}
	cyberark_session=${9:# Dictionary set by a CyberArk authentication containing the different values to perform actions on a logged-on CyberArk session.}

endsnippet

snippet keycloak_group "Allows administration of Keycloak groups via Keycloak API" b
keycloak_group: >
	state=${1:#present|absent}
	auth_keycloak_url=${2:# URL to the Keycloak instance.}
	auth_client_id=${3:admin-cli}
	auth_realm=${4:# Keycloak realm name to authenticate to for API access.}
	auth_username=${5:# Username to authenticate for API access with.}
	auth_password=${6:# Password to authenticate for API access with.}

	name=${7:# Name of the group.}
	realm=${8:master}
	id=${9:# The unique identifier for this group.}
	attributes=${10:# A dict of key/value pairs to set as custom attributes for the group.}
	auth_client_secret=${11:# Client Secret to use in conjunction with I(auth_client_id) (if required).}
	validate_certs=${12:yes}

endsnippet

snippet keycloak_client "Allows administration of Keycloak clients via Keycloak API" b
keycloak_client: >
	auth_keycloak_url=${1:# URL to the Keycloak instance.}
	auth_client_id=${2:admin-cli}
	auth_realm=${3:# Keycloak realm name to authenticate to for API access.}
	auth_username=${4:# Username to authenticate for API access with.}
	auth_password=${5:# Password to authenticate for API access with.}

	state=${6:#present|absent}
	realm=${7:# The realm to create the client in.}
	client_id=${8:# Client id of client to be worked on. This is usually an alphanumeric name chosen by you. Either this or I(id) is required. If you specify both, I(id) takes precedence. This is 'clientId' in the Keycloak REST API.}
	id=${9:# Id of client to be worked on. This is usually an UUID. Either this or I(client_id) is required. If you specify both, this takes precedence.}
	name=${10:# Name of the client (this is not the same as I(client_id))}
	description=${11:# Description of the client in Keycloak}
	root_url=${12:# Root URL appended to relative URLs for this client This is 'rootUrl' in the Keycloak REST API.}
	admin_url=${13:# URL to the admin interface of the client This is 'adminUrl' in the Keycloak REST API.}
	base_url=${14:# Default URL to use when the auth server needs to redirect or link back to the client This is 'baseUrl' in the Keycloak REST API.}
	enabled=${15:# Is this client enabled or not?}
	client_authenticator_type=${16:client-secret|client-jwt}
	secret=${17:# When using I(client_authenticator_type) C(client-secret) (the default), you can specify a secret here (otherwise one will be generated if it does not exit). If changing this secret, the module will not register a change currently (but the changed secret will be saved).}
	registration_access_token=${18:# The registration access token provides access for clients to the client registration service. This is 'registrationAccessToken' in the Keycloak REST API.}
	default_roles=${19:# list of default roles for this client. If the client roles referenced do not exist yet, they will be created. This is 'defaultRoles' in the Keycloak REST API.}
	redirect_uris=${20:# Acceptable redirect URIs for this client. This is 'redirectUris' in the Keycloak REST API.}
	web_origins=${21:# List of allowed CORS origins. This is 'webOrigins' in the Keycloak REST API.}
	not_before=${22:# Revoke any tokens issued before this date for this client (this is a UNIX timestamp). This is 'notBefore' in the Keycloak REST API.}
	bearer_only=${23:# The access type of this client is bearer-only. This is 'bearerOnly' in the Keycloak REST API.}
	consent_required=${24:# If enabled, users have to consent to client access. This is 'consentRequired' in the Keycloak REST API.}
	standard_flow_enabled=${25:# Enable standard flow for this client or not (OpenID connect). This is 'standardFlowEnabled' in the Keycloak REST API.}
	implicit_flow_enabled=${26:# Enable implicit flow for this client or not (OpenID connect). This is 'implicitFlowEnabled' in the Keycloak REST API.}
	direct_access_grants_enabled=${27:# Are direct access grants enabled for this client or not (OpenID connect). This is 'directAccessGrantsEnabled' in the Keycloak REST API.}
	service_accounts_enabled=${28:# Are service accounts enabled for this client or not (OpenID connect). This is 'serviceAccountsEnabled' in the Keycloak REST API.}
	authorization_services_enabled=${29:# Are authorization services enabled for this client or not (OpenID connect). This is 'authorizationServicesEnabled' in the Keycloak REST API.}
	public_client=${30:# Is the access type for this client public or not. This is 'publicClient' in the Keycloak REST API.}
	frontchannel_logout=${31:# Is frontchannel logout enabled for this client or not. This is 'frontchannelLogout' in the Keycloak REST API.}
	protocol=${32:openid-connect|saml}
	full_scope_allowed=${33:# Is the "Full Scope Allowed" feature set for this client or not. This is 'fullScopeAllowed' in the Keycloak REST API.}
	node_re_registration_timeout=${34:# Cluster node re-registration timeout for this client. This is 'nodeReRegistrationTimeout' in the Keycloak REST API.}
	registered_nodes=${35:# dict of registered cluster nodes (with C(nodename) as the key and last registration time as the value). This is 'registeredNodes' in the Keycloak REST API.}
	client_template=${36:# Client template to use for this client. If it does not exist this field will silently be dropped. This is 'clientTemplate' in the Keycloak REST API.}
	use_template_config=${37:# Whether or not to use configuration from the I(client_template). This is 'useTemplateConfig' in the Keycloak REST API.}
	use_template_scope=${38:# Whether or not to use scope configuration from the I(client_template). This is 'useTemplateScope' in the Keycloak REST API.}
	use_template_mappers=${39:# Whether or not to use mapper configuration from the I(client_template). This is 'useTemplateMappers' in the Keycloak REST API.}
	surrogate_auth_required=${40:# Whether or not surrogate auth is required. This is 'surrogateAuthRequired' in the Keycloak REST API.}
	authorization_settings=${41:# a data structure defining the authorization settings for this client. For reference, please see the Keycloak API docs at U(http://www.keycloak.org/docs-api/3.3/rest-api/index.html#_resourceserverrepresentation). This is 'authorizationSettings' in the Keycloak REST API.}
	protocol_mappers=${42:# a list of dicts defining protocol mappers for this client. This is 'protocolMappers' in the Keycloak REST API.}
	attributes=${43:# A dict of further attributes for this client. This can contain various configuration settings; an example is given in the examples section. While an exhaustive list of permissible options is not available; possible options as of Keycloak 3.4 are listed below. The Keycloak API does not validate whether a given option is appropriate for the protocol used; if specified anyway, Keycloak will simply not use it.}
	auth_client_secret=${44:# Client Secret to use in conjunction with I(auth_client_id) (if required).}
	validate_certs=${45:yes}

endsnippet

snippet keycloak_clienttemplate "Allows administration of Keycloak client templates via Keycloak API" b
keycloak_clienttemplate: >
	auth_keycloak_url=${1:# URL to the Keycloak instance.}
	auth_client_id=${2:admin-cli}
	auth_realm=${3:# Keycloak realm name to authenticate to for API access.}
	auth_username=${4:# Username to authenticate for API access with.}
	auth_password=${5:# Password to authenticate for API access with.}

	state=${6:#present|absent}
	id=${7:# Id of client template to be worked on. This is usually a UUID.}
	realm=${8:# Realm this client template is found in.}
	name=${9:# Name of the client template}
	description=${10:# Description of the client template in Keycloak}
	protocol=${11:openid-connect|saml}
	full_scope_allowed=${12:# Is the "Full Scope Allowed" feature set for this client template or not. This is 'fullScopeAllowed' in the Keycloak REST API.}
	protocol_mappers=${13:# a list of dicts defining protocol mappers for this client template. This is 'protocolMappers' in the Keycloak REST API.}
	attributes=${14:# A dict of further attributes for this client template. This can contain various configuration settings, though in the default installation of Keycloak as of 3.4, none are documented or known, so this is usually empty.}
	auth_client_secret=${15:# Client Secret to use in conjunction with I(auth_client_id) (if required).}
	validate_certs=${16:yes}

endsnippet

snippet opendj_backendprop "Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command." b
opendj_backendprop: >
	hostname=${1:# The hostname of the OpenDJ server.}
	port=${2:# The Admin port on which the OpenDJ instance is available.}
	backend=${3:# The name of the backend on which the property needs to be updated.}
	name=${4:# The configuration setting to update.}
	value=${5:# The value for the configuration item.}

	opendj_bindir=${6:/opt/opendj/bin}
	username=${7:cn=Directory Manager}
	password=${8:# The password for the cn=Directory Manager user.}
	passwordfile=${9:# Location to the password file which holds the password for the cn=Directory Manager user.}
	state=${10:present}

endsnippet

snippet mail "Send an email" b
mail: >
	subject=${1:# The subject of the email being sent.}

	from=${2:root}
	to=${3:root}
	cc=${4:# The email-address(es) the mail is being copied to.}
	bcc=${5:# The email-address(es) the mail is being 'blind' copied to.}
	body=${6:$subject}
	username=${7:# If SMTP requires username.}
	password=${8:# If SMTP requires password.}
	host=${9:localhost}
	port=${10:25}
	attach=${11:[]}
	headers=${12:[]}
	charset=${13:utf-8}
	subtype=${14:html|#plain}
	secure=${15:always|never|starttls|#try}
	timeout=${16:20}

endsnippet

snippet matrix "Send notifications to matrix" b
matrix: >
	msg_plain=${1:# Plain text form of the message to send to matrix, usually markdown}
	msg_html=${2:# HTML form of the message to send to matrix}
	room_id=${3:# ID of the room to send the notification to}
	hs_url=${4:# URL of the homeserver, where the CS-API is reachable}

	token=${5:# Authentication token for the API call. If provided, user_id and password are not required}
	user_id=${6:# The user id of the user}
	password=${7:# The password to log in with}

endsnippet

snippet grove "Sends a notification to a grove.io channel" b
grove: >
	channel_token=${1:# Token of the channel to post to.}
	message=${2:# Message content}

	service=${3:ansible}
	url=${4:# Service URL for the web client}
	icon_url=${5:# Icon for the service}
	validate_certs=${6:yes}

endsnippet

snippet jabber "Send a message to jabber user or chat room" b
jabber: >
	user=${1:# User as which to connect}
	password=${2:# password for user to connect}
	to=${3:# user ID or name of the room, when using room use a slash to indicate your nick.}
	msg=${4:# The message body.}

	host=${5:# host to connect, overrides user info}
	port=${6:5222}
	encoding=${7:# message encoding}

endsnippet

snippet hipchat "Send a message to Hipchat." b
hipchat: >
	token=${1:# API token.}
	room=${2:# ID or name of the room.}
	msg=${3:# The message body.}

	from=${4:Ansible}
	color=${5:#yellow|red|green|purple|gray|random}
	msg_format=${6:#text|html}
	notify=${7:yes}
	validate_certs=${8:yes}
	api=${9:https://api.hipchat.com/v1}

endsnippet

snippet bearychat "Send BearyChat notifications" b
bearychat: >
	url=${1:# BearyChat WebHook URL. This authenticates you to the bearychat service. It looks like C(https://hook.bearychat.com/=ae2CF/incoming/e61bd5c57b164e04b11ac02e66f47f60).}

	text=${2:# Message to send.}
	markdown=${3:yes}
	channel=${4:# Channel to send the message to. If absent, the message goes to the default channel selected by the I(url).}
	attachments=${5:# Define a list of attachments. For more information, see https://github.com/bearyinnovative/bearychat-tutorial/blob/master/robots/incoming.md#attachments}

endsnippet

snippet rabbitmq_publish "Publish a message to a RabbitMQ queue." b
rabbitmq_publish: >
	url=${1:# An URL connection string to connect to the RabbitMQ server.}
	proto=${2:amqps|amqp}
	host=${3:# The RabbitMQ server hostname or IP.}
	port=${4:# The RabbitMQ server port.}
	username=${5:# The RabbitMQ username.}
	password=${6:# The RabbitMQ password.}
	vhost=${7:# The virtual host to target.}
	queue=${8:# The queue to publish a message to.  If no queue is specified, RabbitMQ will return a random queue name.}
	exchange=${9:# The exchange to publish a message to.}
	routing_key=${10:# The routing key.}
	body=${11:# The body of the message.}
	src=${12:# A file to upload to the queue.  Automatic mime type detection is attempted if content_type is not defined (left as default).}
	content_type=${13:text/plain}
	durable=${14:no}
	exclusive=${15:no}
	auto_delete=${16:no}
	headers=${17:{}}

endsnippet

snippet telegram "module for sending notifications via telegram" b
telegram: >
	msg=${1:# What message you wish to send.}
	token=${2:# Token identifying your telegram bot.}
	chat_id=${3:# Telegram group or user chat_id}

	msg_format=${4:#plain|markdown|html}

endsnippet

snippet say "Makes a computer to speak." b
say: >
	msg=${1:# W}

	voice=${2:# W}

endsnippet

snippet pushover "Send notifications via U(https://pushover.net)" b
pushover: >
	msg=${1:# What message you wish to send.}
	app_token=${2:# Pushover issued token identifying your pushover app.}
	user_key=${3:# Pushover issued authentication key for your user.}

	title=${4:# Message title.}
	pri=${5:# Message priority (see U(https://pushover.net) for details).}

endsnippet

snippet irc "Send a message to an IRC channel" b
irc: >
	msg=${1:# The message body.}
	channel=${2:# Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them.}

	server=${3:localhost}
	port=${4:6667}
	nick=${5:ansible}
	topic=${6:# Set the channel topic}
	color=${7:#none|white|black|blue|green|red|brown|purple|orange|yellow|light_green|teal|light_cyan|light_blue|pink|gray|light_gray}
	nick_to=${8:# A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.}
	key=${9:# Channel key}
	passwd=${10:# Server password}
	timeout=${11:30}
	use_ssl=${12:no}
	part=${13:yes}
	style=${14:bold|underline|reverse|italic}

endsnippet

snippet mattermost "Send Mattermost notifications" b
mattermost: >
	url=${1:# Mattermost url (i.e. http://mattermost.yourcompany.com).}
	api_key=${2:# Mattermost webhook api key. Log into your mattermost site, go to Menu -> Integration -> Incoming Webhook -> Add Incoming Webhook. This will give you full URL. api_key is the last part. http://mattermost.example.com/hooks/C(API_KEY)}
	text=${3:# Text to send. Note that the module does not handle escaping characters.}

	channel=${4:# Channel to send the message to. If absent, the message goes to the channel selected for the I(api_key).}
	username=${5:Ansible}
	icon_url=${6:https://www.ansible.com/favicon.ico}
	validate_certs=${7:yes}

endsnippet

snippet nexmo "Send a SMS via nexmo" b
nexmo: >
	api_key=${1:# Nexmo API Key}
	api_secret=${2:# Nexmo API Secret}
	src=${3:# Nexmo Number to send from}
	dest=${4:# Phone number(s) to send SMS message to}
	msg=${5:# Message to text to send. Messages longer than 160 characters will be split into multiple messages}

	validate_certs=${6:yes}
	url=${7:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	force=${8:no}
	http_agent=${9:ansible-httpget}
	use_proxy=${10:yes}
	url_username=${11:# The username for use in HTTP basic authentication.}
	url_password=${12:# The password for use in HTTP basic authentication.}
	force_basic_auth=${13:no}
	client_cert=${14:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${15:# PEM formatted file that contains your private key to be used for SSL client authentication.}

endsnippet

snippet snow_record "Manage records in ServiceNow" b
snow_record: >
	state=${1:present|absent}

	table=${2:incident}
	data=${3:# key, value pairs of data to load into the record. See Examples.}
	number=${4:# Record number to update.}
	lookup_field=${5:number}
	attachment=${6:# Attach a file to the record.}
	instance=${7:# The ServiceNow instance name, without the domain, service-now.com.}
	username=${8:# Name of user for connection to ServiceNow.}
	password=${9:# Password for username.}
	client_id=${10:# Client ID generated by ServiceNow.}
	client_secret=${11:# Client Secret associated with client id.}

endsnippet

snippet typetalk "Send a message to typetalk" b
typetalk: >
	client_id=${1:# OAuth2 client ID}
	client_secret=${2:# OAuth2 client secret}
	topic=${3:# topic id to post message}
	msg=${4:# message body}

endsnippet

snippet mqtt "Publish a message on an MQTT topic for the IoT" b
mqtt: >
	topic=${1:# MQTT topic name}
	payload=${2:# Payload. The special string C("None") may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the I(topic) or to clear previously retained messages.}

	server=${3:localhost}
	port=${4:1883}
	username=${5:# Username to authenticate against the broker.}
	password=${6:# Password for C(username) to authenticate against the broker.}
	client_id=${7:hostname + pid}
	qos=${8:0|1|2}
	retain=${9:no}
	ca_cert=${10:# The path to the Certificate Authority certificate files that are to be treated as trusted by this client. If this is the only option given then the client will operate in a similar manner to a web browser. That is to say it will require the broker to have a certificate signed by the Certificate Authorities in ca_certs and will communicate using TLS v1, but will not attempt any form of authentication. This provides basic network encryption but may not be sufficient depending on how the broker is configured.}
	client_cert=${11:# The path pointing to the PEM encoded client certificate. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.}
	client_key=${12:# The path pointing to the PEM encoded client private key. If this is not None it will be used as client information for TLS based authentication. Support for this feature is broker dependent.}
	tls_version=${13:tlsv1.1|tlsv1.2}

endsnippet

snippet office_365_connector_card "Use webhooks to create Connector Card messages within an Office 365 group" b
office_365_connector_card: >
	webhook=${1:# The webhook URL is given to you when you create a new Connector.}

	summary=${2:# A string used for summarizing card content.}
	color=${3:# Accent color used for branding or indicating status in the card.}
	title=${4:# A title for the Connector message. Shown at the top of the message.}
	text=${5:# The main text of the card.}
	actions=${6:# This array of objects will power the action links}
	sections=${7:# Contains a list of sections to display in the card.}

endsnippet

snippet syslogger "Log messages in the syslog" b
syslogger: >
	msg=${1:# This is the message to place in syslog}

	priority=${2:emerg|alert|crit|err|warning|notice|#info|debug}
	facility=${3:kern|user|mail|#daemon|auth|lpr|news|uucp|cron|syslog|local0|local1|local2|local3|local4|local5|local6|local7}
	log_pid=${4:no}

endsnippet

snippet campfire "Send a message to Campfire" b
campfire: >
	subscription=${1:# The subscription name to use.}
	token=${2:# API token.}
	room=${3:# Room number to which the message should be sent.}
	msg=${4:# The message body.}

	notify=${5:56k|bell|bezos|bueller|clowntown|cottoneyejoe|crickets|dadgummit|dangerzone|danielsan|deeper|drama|greatjob|greyjoy|guarantee|heygirl|horn|horror|inconceivable|live|loggins|makeitso|noooo|nyan|ohmy|ohyeah|pushit|rimshot|rollout|rumble|sax|secret|sexyback|story|tada|tmyk|trololo|trombone|unix|vuvuzela|what|whoomp|yeah|yodel}

endsnippet

snippet flowdock "Send a message to a flowdock" b
flowdock: >
	token=${1:# API token.}
	type=${2:inbox|chat}
	msg=${3:# Content of the message}

	tags=${4:# tags of the message, separated by commas}
	external_user_name=${5:# (chat only - required) Name of the "user" sending the message}
	from_address=${6:# (inbox only - required) Email address of the message sender}
	source=${7:# (inbox only - required) Human readable identifier of the application that uses the Flowdock API}
	subject=${8:# (inbox only - required) Subject line of the message}
	from_name=${9:# (inbox only) Name of the message sender}
	reply_to=${10:# (inbox only) Email address for replies}
	project=${11:# (inbox only) Human readable identifier for more detailed message categorization}
	link=${12:# (inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.}
	validate_certs=${13:yes}

endsnippet

snippet sendgrid "Sends an email with the SendGrid API" b
sendgrid: >
	from_address=${1:# the address in the "from" field for the email}
	to_addresses=${2:# a list with one or more recipient email addresses}
	subject=${3:# the desired subject for the email}

	username=${4:# username for logging into the SendGrid account.}
	password=${5:# password that corresponds to the username}
	api_key=${6:# sendgrid API key to use instead of username/password}
	cc=${7:# a list of email addresses to cc}
	bcc=${8:# a list of email addresses to bcc}
	attachments=${9:# a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)}
	from_name=${10:# the name you want to appear in the from field, i.e 'John Doe'}
	html_body=${11:no}
	headers=${12:# a dict to pass on as headers}

endsnippet

snippet cisco_spark "Send a message to a Cisco Spark Room or Individual." b
cisco_spark: >
	recipient_type=${1:roomId|toPersonEmail|toPersonId}
	recipient_id=${2:# The unique identifier associated with the supplied C(recipient_type).}
	personal_token=${3:# Your personal access token required to validate the Spark API.}
	message=${4:# The message you would like to send.}

	message_type=${5:#text|markdown}

endsnippet

snippet twilio "Sends a text message to a mobile phone through Twilio." b
twilio: >
	account_sid=${1:# u}
	auth_token=${2:# u}
	msg=${3:# t}
	to_numbers=${4:# o}
	from_number=${5:# t}

	media_url=${6:# a}

endsnippet

snippet pushbullet "Sends notifications to Pushbullet" b
pushbullet: >
	api_key=${1:# Push bullet API token}
	title=${2:# Title of the notification.}

	channel=${3:# The channel TAG you wish to broadcast a push notification, as seen on the "My Channels" > "Edit your channel" at Pushbullet page.}
	device=${4:# The device NAME you wish to send a push notification, as seen on the Pushbullet main page.}
	push_type=${5:#note|link}
	body=${6:# Body of the notification, e.g. Details of the fault you're alerting.}

endsnippet

snippet say "Makes a computer to speak." b
say: >
	msg=${1:# W}

	voice=${2:# W}

endsnippet

snippet slack "Send Slack notifications" b
slack: >
	token=${1:# Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like C(3Ffe373sfhRE6y42Fg3rvf4GlK).  In 1.8 and above, ansible adapts to the new slack API where tokens look like C(G922VJP24/D921DW937/3Ffe373sfhRE6y42Fg3rvf4GlK).  If tokens are in the new format then slack will ignore any value of domain.  If the token is in the old format the domain is required.  Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.  ** Please keep in mind the tokens are not the API tokens but are the webhook tokens.  In slack these are found in the webhook URL which are obtained under the apps and integrations. The incoming webhooks can be added in that area.  In some cases this may be locked by your Slack admin and you must request access.  It is there that the incoming webhooks can be added.  The key is on the end of the URL given to you in that section.}

	domain=${2:# Slack (sub)domain for your environment without protocol. (i.e. C(example.slack.com)) In 1.8 and beyond, this is deprecated and may be ignored.  See token documentation for information.}
	msg=${3:# Message to send. Note that the module does not handle escaping characters. Plain-text angle brackets and ampersands should be converted to HTML entities (e.g. & to &amp;) before sending. See Slack's documentation (U(https://api.slack.com/docs/message-formatting)) for more.}
	channel=${4:# Channel to send the message to. If absent, the message goes to the channel selected for the I(token).}
	thread_id=${5:# Optional. Timestamp of message to thread this message to as a float. https://api.slack.com/docs/message-threading}
	username=${6:Ansible}
	icon_url=${7:# Url for the message sender's icon (default C(https://www.ansible.com/favicon.ico))}
	icon_emoji=${8:# Emoji for the message sender. See Slack documentation for options. (if I(icon_emoji) is set, I(icon_url) will not be used)}
	link_names=${9:#1|0}
	parse=${10:full|none}
	validate_certs=${11:yes}
	color=${12:normal}
	attachments=${13:# Define a list of attachments. This list mirrors the Slack JSON API.}

endsnippet

snippet rocketchat "Send notifications to Rocket Chat" b
rocketchat: >
	domain=${1:# The domain for your environment without protocol. (i.e. C(example.com) or C(chat.example.com))}
	token=${2:# Rocket Chat Incoming Webhook integration token.  This provides authentication to Rocket Chat's Incoming webhook for posting messages.}

	protocol=${3:http|#https}
	msg=${4:# Message to be sent.}
	channel=${5:# Channel to send the message to. If absent, the message goes to the channel selected for the I(token) specified during the creation of webhook.}
	username=${6:Ansible}
	icon_url=${7:https://www.ansible.com/favicon.ico}
	icon_emoji=${8:# Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if I(icon_emoji) is set, I(icon_url) will not be used)}
	link_names=${9:#1|0}
	validate_certs=${10:yes}
	color=${11:#normal|good|warning|danger}
	attachments=${12:# Define a list of attachments.}

endsnippet

snippet logentries_msg "Send a message to logentries." b
logentries_msg: >
	token=${1:# Log token.}
	msg=${2:# The message body.}

	api=${3:data.logentries.com}
	port=${4:80}

endsnippet

snippet snow_record_find "Search for multiple records from ServiceNow" b
snow_record_find: >
	query=${1:# Dict to query for records.}

	table=${2:incident}
	max_records=${3:20}
	order_by=${4:-created_on}
	return_fields=${5:# Fields of the record to return in the json.}
	instance=${6:# The ServiceNow instance name, without the domain, service-now.com.}
	username=${7:# Name of user for connection to ServiceNow.}
	password=${8:# Password for username.}
	client_id=${9:# Client ID generated by ServiceNow.}
	client_secret=${10:# Client Secret associated with client id.}

endsnippet

snippet catapult "Send a sms / mms using the catapult bandwidth api" b
catapult: >
	src=${1:# One of your catapult telephone numbers the message should come from (must be in E.164 format, like C(+19195551212)).}
	dest=${2:# The phone number or numbers the message should be sent to (must be in E.164 format, like C(+19195551212)).}
	msg=${3:# The contents of the text message (must be 2048 characters or less).}
	user_id=${4:# User Id from Api account page.}
	api_token=${5:# Api Token from Api account page.}
	api_secret=${6:# Api Secret from Api account page.}

	media=${7:# For MMS messages, a media url to the location of the media to be sent with the message.}

endsnippet

snippet wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
wakeonlan: >
	mac=${1:# MAC address to send Wake-on-LAN broadcast packet for.}

	broadcast=${2:255.255.255.255}
	port=${3:7}

endsnippet

snippet intersight_info "Gather information about Intersight" b
intersight_info: >
	server_names=${1:# Server names to retrieve information from.}
	api_private_key=${2:# Filename (absolute path) of a PEM formatted file that contains your private key to be used for Intersight API authentication.}
	api_key_id=${3:# Public API Key ID associated with the private key.}

	api_uri=${4:https://intersight.com/api/v1}
	validate_certs=${5:yes}
	use_proxy=${6:yes}

endsnippet

snippet intersight_rest_api "REST API configuration for Cisco Intersight" b
intersight_rest_api: >
	resource_path=${1:# Resource URI being configured related to api_uri.}
	api_private_key=${2:# Filename (absolute path) of a PEM formatted file that contains your private key to be used for Intersight API authentication.}
	api_key_id=${3:# Public API Key ID associated with the private key.}

	query_params=${4:# Query parameters for the Intersight API query language.}
	update_method=${5:#patch|post}
	api_body=${6:# The payload for API requests used to modify resources.}
	state=${7:#present|absent}
	api_uri=${8:https://intersight.com/api/v1}
	validate_certs=${9:yes}
	use_proxy=${10:yes}

endsnippet

snippet intersight_info "Gather information about Intersight" b
intersight_info: >
	server_names=${1:# Server names to retrieve information from.}
	api_private_key=${2:# Filename (absolute path) of a PEM formatted file that contains your private key to be used for Intersight API authentication.}
	api_key_id=${3:# Public API Key ID associated with the private key.}

	api_uri=${4:https://intersight.com/api/v1}
	validate_certs=${5:yes}
	use_proxy=${6:yes}

endsnippet

snippet imc_rest "Manage Cisco IMC hardware through its REST API" b
imc_rest: >
	hostname=${1:# IP Address or hostname of Cisco IMC, resolvable by Ansible control host.}

	username=${2:admin}
	password=${3:password}
	path=${4:# Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.}
	content=${5:# When used instead of C(path), sets the content of the API requests directly.}
	protocol=${6:http|#https}
	timeout=${7:60}
	validate_certs=${8:yes}

endsnippet

snippet lxca_nodes "Custom module for lxca nodes inventory utility" b
lxca_nodes: >
	login_user=${1:# The username for use in HTTP basic authentication.}
	login_password=${2:# The password for use in HTTP basic authentication.}
	auth_url=${3:# lxca https full web address}

	uuid=${4:# u}
	command_options=${5:#nodes|nodes_by_uuid|nodes_by_chassis_uuid|nodes_status_managed|nodes_status_unmanaged}
	chassis=${6:# u}

endsnippet

snippet lxca_cmms "Custom module for lxca cmms inventory utility" b
lxca_cmms: >
	login_user=${1:# The username for use in HTTP basic authentication.}
	login_password=${2:# The password for use in HTTP basic authentication.}
	auth_url=${3:# lxca https full web address}

	uuid=${4:# u}
	command_options=${5:#cmms|cmms_by_uuid|cmms_by_chassis_uuid}
	chassis=${6:# u}

endsnippet

snippet stacki_host "Add or remove host to stacki front-end" b
stacki_host: >
	name=${1:# Name of the host to be added to Stacki.}
	stacki_user=${2:# Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead.}
	stacki_password=${3:# Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead.}
	stacki_endpoint=${4:# URL for the Stacki API Endpoint.}

	prim_intf_mac=${5:# MAC Address for the primary PXE boot network interface.}
	prim_intf_ip=${6:# IP Address for the primary network interface.}
	prim_intf=${7:# Name of the primary network interface.}
	force_install=${8:# Set value to True to force node into install state if it already exists in stacki.}

endsnippet

snippet redfish_info "Manages Out-Of-Band controllers using Redfish APIs" b
redfish_info: >
	baseuri=${1:# Base URI of OOB controller}
	username=${2:# User for authentication with OOB controller}
	password=${3:# Password for authentication with OOB controller}

	category=${4:['Systems']}
	command=${5:# List of commands to execute on OOB controller}
	timeout=${6:10}

endsnippet

snippet idrac_redfish_info "Manages servers through iDRAC using Dell Redfish APIs" b
idrac_redfish_info: >
	category=${1:# Category to execute on iDRAC controller}
	command=${2:# List of commands to execute on iDRAC controller}
	baseuri=${3:# Base URI of iDRAC controller}
	username=${4:# User for authentication with iDRAC controller}
	password=${5:# Password for authentication with iDRAC controller}

	timeout=${6:10}

endsnippet

snippet idrac_redfish_config "Manages servers through iDRAC using Dell Redfish APIs" b
idrac_redfish_config: >
	category=${1:# Category to execute on iDRAC}
	command=${2:# List of commands to execute on iDRAC}
	baseuri=${3:# Base URI of iDRAC}
	username=${4:# User for authentication with iDRAC}
	password=${5:# Password for authentication with iDRAC}

	manager_attribute_name=${6:null}
	manager_attribute_value=${7:null}
	timeout=${8:10}

endsnippet

snippet idrac_redfish_info "Manages servers through iDRAC using Dell Redfish APIs" b
idrac_redfish_info: >
	category=${1:# Category to execute on iDRAC controller}
	command=${2:# List of commands to execute on iDRAC controller}
	baseuri=${3:# Base URI of iDRAC controller}
	username=${4:# User for authentication with iDRAC controller}
	password=${5:# Password for authentication with iDRAC controller}

	timeout=${6:10}

endsnippet

snippet redfish_config "Manages Out-Of-Band controllers using Redfish APIs" b
redfish_config: >
	category=${1:# Category to execute on OOB controller}
	command=${2:# List of commands to execute on OOB controller}
	baseuri=${3:# Base URI of OOB controller}
	username=${4:# User for authentication with OOB controller}
	password=${5:# Password for authentication with OOB controller}

	bios_attribute_name=${6:null}
	bios_attribute_value=${7:null}
	timeout=${8:10}

endsnippet

snippet idrac_redfish_command "Manages Out-Of-Band controllers using iDRAC OEM Redfish APIs" b
idrac_redfish_command: >
	category=${1:# Category to execute on OOB controller}
	command=${2:# List of commands to execute on OOB controller}
	baseuri=${3:# Base URI of OOB controller}
	username=${4:# User for authentication with OOB controller}
	password=${5:# Password for authentication with OOB controller}

	timeout=${6:10}

endsnippet

snippet redfish_command "Manages Out-Of-Band controllers using Redfish APIs" b
redfish_command: >
	category=${1:# Category to execute on OOB controller}
	command=${2:# List of commands to execute on OOB controller}
	baseuri=${3:# Base URI of OOB controller}
	username=${4:# User for authentication with OOB controller}
	password=${5:# Password for authentication with OOB controller}

	id=${6:# ID of user to add/delete/modify}
	new_username=${7:# name of user to add/delete/modify}
	new_password=${8:# password of user to add/delete/modify}
	roleid=${9:# role of user to add/delete/modify}
	bootdevice=${10:# bootdevice when setting boot configuration}
	timeout=${11:10}
	uefi_target=${12:# UEFI target when bootdevice is "UefiTarget"}
	boot_next=${13:# BootNext target when bootdevice is "UefiBootNext"}

endsnippet

snippet redfish_info "Manages Out-Of-Band controllers using Redfish APIs" b
redfish_info: >
	baseuri=${1:# Base URI of OOB controller}
	username=${2:# User for authentication with OOB controller}
	password=${3:# Password for authentication with OOB controller}

	category=${4:['Systems']}
	command=${5:# List of commands to execute on OOB controller}
	timeout=${6:10}

endsnippet

snippet oneview_san_manager "Manage OneView SAN Manager resources" b
oneview_san_manager: >
	data=${1:# List with SAN Manager properties.}

	state=${2:#present|absent|connection_information_set}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	validate_etag=${4:yes}

endsnippet

snippet oneview_fcoe_network "Manage OneView FCoE Network resources" b
oneview_fcoe_network: >
	data=${1:# List with FCoE Network properties.}

	state=${2:#present|absent}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	validate_etag=${4:yes}

endsnippet

snippet oneview_san_manager_info "Retrieve information about one or more of the OneView SAN Managers" b
oneview_san_manager_info: >
	provider_display_name=${1:# Provider Display Name.}
	params=${2:# List of params to delimit, filter and sort the list of resources.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}

endsnippet

snippet oneview_enclosure_info "Retrieve information about one or more Enclosures" b
oneview_enclosure_info: >
	name=${1:# Enclosure name.}
	options=${2:# List with options to gather additional information about an Enclosure and related resources. Options allowed: C(script), C(environmentalConfiguration), and C(utilization). For the option C(utilization), you can provide specific parameters.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_logical_interconnect_group_info "Retrieve information about one or more of the OneView Logical Interconnect Groups" b
oneview_logical_interconnect_group_info: >
	name=${1:# Logical Interconnect Group name.}
	config=${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${3:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_logical_interconnect_group "Manage OneView Logical Interconnect Group resources" b
oneview_logical_interconnect_group: >
	data=${1:# List with the Logical Interconnect Group properties.}

	state=${2:absent|#present}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	validate_etag=${4:yes}

endsnippet

snippet oneview_network_set_info "Retrieve information about the OneView Network Sets" b
oneview_network_set_info: >
	name=${1:# Network Set name.}
	options=${2:# List with options to gather information about Network Set. Option allowed: C(withoutEthernet). The option C(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_fc_network_info "Retrieve the information about one or more of the OneView Fibre Channel Networks" b
oneview_fc_network_info: >
	name=${1:# Fibre Channel Network name.}
	config=${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${3:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_san_manager_info "Retrieve information about one or more of the OneView SAN Managers" b
oneview_san_manager_info: >
	provider_display_name=${1:# Provider Display Name.}
	params=${2:# List of params to delimit, filter and sort the list of resources.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}

endsnippet

snippet oneview_fc_network_info "Retrieve the information about one or more of the OneView Fibre Channel Networks" b
oneview_fc_network_info: >
	name=${1:# Fibre Channel Network name.}
	config=${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${3:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_network_set "Manage HPE OneView Network Set resources" b
oneview_network_set: >
	data=${1:# List with the Network Set properties.}

	state=${2:#present|absent}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	validate_etag=${4:yes}

endsnippet

snippet oneview_fc_network "Manage OneView Fibre Channel Network resources." b
oneview_fc_network: >
	data=${1:# List with the Fibre Channel Network properties.}

	state=${2:present|absent}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	validate_etag=${4:yes}

endsnippet

snippet oneview_fcoe_network_info "Retrieve the information about one or more of the OneView FCoE Networks" b
oneview_fcoe_network_info: >
	name=${1:# FCoE Network name.}
	config=${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${3:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_ethernet_network "Manage OneView Ethernet Network resources" b
oneview_ethernet_network: >
	data=${1:# List with Ethernet Network properties.}

	state=${2:#present|absent|default_bandwidth_reset}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	validate_etag=${4:yes}

endsnippet

snippet oneview_ethernet_network_info "Retrieve the information about one or more of the OneView Ethernet Networks" b
oneview_ethernet_network_info: >
	name=${1:# Ethernet Network name.}
	options=${2:# List with options to gather additional information about an Ethernet Network and related resources. Options allowed: C(associatedProfiles) and C(associatedUplinkGroups).}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_datacenter_info "Retrieve information about the OneView Data Centers" b
oneview_datacenter_info: >
	name=${1:# Data Center name.}
	options=${2:# Retrieve additional information. Options available: 'visualContent'.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_datacenter_info "Retrieve information about the OneView Data Centers" b
oneview_datacenter_info: >
	name=${1:# Data Center name.}
	options=${2:# Retrieve additional information. Options available: 'visualContent'.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_enclosure_info "Retrieve information about one or more Enclosures" b
oneview_enclosure_info: >
	name=${1:# Enclosure name.}
	options=${2:# List with options to gather additional information about an Enclosure and related resources. Options allowed: C(script), C(environmentalConfiguration), and C(utilization). For the option C(utilization), you can provide specific parameters.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_ethernet_network_info "Retrieve the information about one or more of the OneView Ethernet Networks" b
oneview_ethernet_network_info: >
	name=${1:# Ethernet Network name.}
	options=${2:# List with options to gather additional information about an Ethernet Network and related resources. Options allowed: C(associatedProfiles) and C(associatedUplinkGroups).}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_fcoe_network_info "Retrieve the information about one or more of the OneView FCoE Networks" b
oneview_fcoe_network_info: >
	name=${1:# FCoE Network name.}
	config=${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${3:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_network_set_info "Retrieve information about the OneView Network Sets" b
oneview_network_set_info: >
	name=${1:# Network Set name.}
	options=${2:# List with options to gather information about Network Set. Option allowed: C(withoutEthernet). The option C(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks.}
	config=${3:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${4:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet oneview_logical_interconnect_group_info "Retrieve information about one or more of the OneView Logical Interconnect Groups" b
oneview_logical_interconnect_group_info: >
	name=${1:# Logical Interconnect Group name.}
	config=${2:# Path to a .json configuration file containing the OneView client configuration. The configuration file is optional and when used should be present in the host running the ansible commands. If the file path is not provided, the configuration will be loaded from environment variables. For links to example configuration files or how to use the environment variables verify the notes section.}
	params=${3:# List of params to delimit, filter and sort the list of resources.}

endsnippet

snippet cobbler_sync "Sync Cobbler" b
cobbler_sync: >
	password=${1:# The password to log in to Cobbler.}

	host=${2:127.0.0.1}
	port=${3:# Port number to be used for REST connection.}
	username=${4:cobbler}
	use_ssl=${5:yes}
	validate_certs=${6:yes}

endsnippet

snippet cobbler_system "Manage system objects in Cobbler" b
cobbler_system: >
	password=${1:# The password to log in to Cobbler.}

	host=${2:127.0.0.1}
	port=${3:# Port number to be used for REST connection.}
	username=${4:cobbler}
	use_ssl=${5:yes}
	validate_certs=${6:yes}
	name=${7:# The system name to manage.}
	properties=${8:# A dictionary with system properties.}
	interfaces=${9:# A list of dictionaries containing interface options.}
	sync=${10:no}
	state=${11:absent|#present|query}

endsnippet

snippet hpilo_boot "Boot system using specific media through HP iLO interface" b
hpilo_boot: >
	host=${1:# The HP iLO hostname/address that is linked to the physical system.}

	login=${2:Administrator}
	password=${3:admin}
	media=${4:cdrom|floppy|hdd|network|normal|usb}
	image=${5:# The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename}
	state=${6:boot_always|#boot_once|connect|disconnect|no_boot|poweroff}
	force=${7:no}
	ssl_version=${8:SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2}

endsnippet

snippet hpilo_info "Gather information through an HP iLO interface" b
hpilo_info: >
	host=${1:# The HP iLO hostname/address that is linked to the physical system.}

	login=${2:Administrator}
	password=${3:admin}
	ssl_version=${4:SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2}

endsnippet

snippet hpilo_info "Gather information through an HP iLO interface" b
hpilo_info: >
	host=${1:# The HP iLO hostname/address that is linked to the physical system.}

	login=${2:Administrator}
	password=${3:admin}
	ssl_version=${4:SSLv3|SSLv23|#TLSv1|TLSv1_1|TLSv1_2}

endsnippet

snippet hponcfg "Configure HP iLO interface using hponcfg" b
hponcfg: >
	path=${1:# The XML file as accepted by hponcfg.}

	minfw=${2:# The minimum firmware level needed.}
	executable=${3:hponcfg}
	verbose=${4:no}

endsnippet

snippet cpm_serial_port_config "Set Serial port parameters in WTI OOB and PDU devices" b
cpm_serial_port_config: >
	cpm_url=${1:# This is the URL of the WTI device to send the module.}
	cpm_username=${2:# This is the Username of the WTI device to send the module.}
	cpm_password=${3:# This is the Password of the WTI device to send the module.}
	port=${4:# This is the port number that is getting the action performed on.}

	use_https=${5:yes}
	validate_certs=${6:yes}
	use_proxy=${7:no}
	portname=${8:# This is the Name of the Port that is displayed.}
	baud=${9:0|1|2|3|4|5|6|7|8|9|10}
	handshake=${10:0|1|2|3}
	stopbits=${11:0|1}
	parity=${12:0|1|2|3|4|5}
	mode=${13:0|1|2|3|4}
	cmd=${14:0|1}
	seq=${15:1|2|3}
	tout=${16:0|1|2|3|4|5}
	echo=${17:# -}
	break_allow=${18:# This is if the break character is allowed to be passed through the port, 0=Off, 1=On}
	logoff=${19:# This is the logout character to assign to the port}

endsnippet

snippet cpm_serial_port_info "Get Serial port parameters in WTI OOB and PDU devices" b
cpm_serial_port_info: >
	cpm_url=${1:# This is the URL of the WTI device to send the module.}
	cpm_username=${2:# This is the Username of the WTI device to send the module.}
	cpm_password=${3:# This is the Password of the WTI device to send the module.}
	port=${4:['*']}

	use_https=${5:yes}
	validate_certs=${6:yes}
	use_proxy=${7:no}

endsnippet

snippet cpm_plugconfig "Get and Set Plug Parameters on WTI OOB and PDU power devices" b
cpm_plugconfig: >
	cpm_action=${1:getplugconfig|setplugconfig}
	cpm_url=${2:# This is the URL of the WTI device to send the module.}
	plug_id=${3:# This is the plug number that is to be manipulated For the getplugconfig command, the plug_id 'all' will return the status of all the plugs the user has rights to access.}

	cpm_username=${4:# This is the Username of the WTI device to send the module.}
	cpm_password=${5:# This is the Password of the WTI device to send the module.}
	use_https=${6:yes}
	validate_certs=${7:yes}
	use_proxy=${8:no}
	plug_name=${9:# The new name of the Plug.}
	plug_bootdelay=${10:0|1|2|3|4|5|6|7|8|9}
	plug_default=${11:0|1}
	plug_bootpriority=${12:# Prioritizes which plug gets its state changed first. The lower the number the higher the priority. Valid value can from 1 to the maximum number of plugs of the WTI unit.}

endsnippet

snippet cpm_plugcontrol "Get and Set Plug actions on WTI OOB and PDU power devices" b
cpm_plugcontrol: >
	cpm_action=${1:getplugcontrol|setplugcontrol}
	cpm_url=${2:# This is the URL of the WTI device  to send the module.}
	plug_id=${3:# This is the plug number or the plug name that is to be manipulated For the plugget command, the plug_id 'all' will return the status of all the plugs the user has rights to access.}

	cpm_username=${4:# This is the Username of the WTI device to send the module.}
	cpm_password=${5:# This is the Password of the WTI device to send the module.}
	use_https=${6:yes}
	validate_certs=${7:yes}
	use_proxy=${8:no}
	plug_state=${9:on|off|boot|default}

endsnippet

snippet cpm_user "Get various status and parameters from WTI OOB and PDU devices" b
cpm_user: >
	cpm_action=${1:getuser|adduser|edituser|deleteuser}
	cpm_url=${2:# This is the URL of the WTI device to send the module.}
	cpm_username=${3:# This is the Basic Authentication Username of the WTI device to send the module.}
	cpm_password=${4:# This is the Basic Authentication Password of the WTI device to send the module.}
	user_name=${5:# This is the User Name that needs to be create/modified/deleted}

	use_https=${6:yes}
	validate_certs=${7:yes}
	use_proxy=${8:no}
	user_pass=${9:# This is the User Password that needs to be create/modified/deleted}
	user_accesslevel=${10:0|1|2|3}
	user_accessssh=${11:0|1}
	user_accessserial=${12:0|1}
	user_accessweb=${13:0|1}
	user_accessapi=${14:0|1}
	user_accessmonitor=${15:0|1}
	user_accessoutbound=${16:0|1}
	user_portaccess=${17:# If AccessLevel is lower than Administrator, which ports the user has access}
	user_plugaccess=${18:# If AccessLevel is lower than Administrator, which plugs the user has access}
	user_groupaccess=${19:# If AccessLevel is lower than Administrator, which Groups the user has access}
	user_callbackphone=${20:# This is the Call Back phone number used for POTS modem connections}

endsnippet

snippet ome_device_info "Retrieves the information about Device." b
ome_device_info: >
	hostname=${1:# Target IP Address or hostname.}
	username=${2:# Target username.}
	password=${3:# Target user password.}

	port=${4:443}
	fact_subset=${5:#basic_inventory|detailed_inventory|subsystem_health}
	system_query_options=${6:# I(system_query_options) applicable for the choices of the fact_subset. Either I(device_id) or I(device_service_tag) is mandatory for C(detailed_inventory) and C(subsystem_health) or both can be applicable.}

endsnippet

snippet idrac_server_config_profile "Export or Import iDRAC Server Configuration Profile (SCP)." b
idrac_server_config_profile: >
	idrac_ip=${1:# i}
	idrac_user=${2:# i}
	idrac_password=${3:# i}
	job_wait=${4:# W}
	share_name=${5:# C}

	idrac_port=${6:443}
	command=${7:import|#export}
	share_user=${8:# N}
	share_password=${9:# N}
	scp_file=${10:# S}
	scp_components=${11:#ALL|IDRAC|BIOS|NIC|RAID}
	shutdown_type=${12:#Graceful|Forced|NoReboot}
	end_host_power_state=${13:#On|Off}
	export_format=${14:JSON|#XML}
	export_use=${15:#Default|Clone|Replace}

endsnippet

snippet idrac_firmware "Firmware update from a repository on a network share (CIFS, NFS)." b
idrac_firmware: >
	idrac_ip=${1:# i}
	idrac_user=${2:# i}
	idrac_password=${3:# i}
	share_name=${4:# C}
	share_mnt=${5:# L}

	idrac_port=${6:443}
	share_user=${7:# N}
	share_password=${8:# N}
	reboot=${9:no}
	job_wait=${10:yes}
	catalog_file_name=${11:Catalog.xml}

endsnippet

snippet ucs_vsans "Configures VSANs on Cisco UCS Manager" b
ucs_vsans: >
	name=${1:# The name assigned to the VSAN.}
	vsan_id=${2:# The unique identifier assigned to the VSAN.}
	vlan_id=${3:# The unique string identifier assigned to the VLAN used for Fibre Channel connections.}
	hostname=${4:# IP address or hostname of Cisco UCS Manager.}
	password=${5:# Password for Cisco UCS Manager authentication.}

	state=${6:#present|absent}
	fc_zoning=${7:#disabled|enabled}
	fabric=${8:#common|A|B}
	username=${9:admin}
	port=${10:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${11:yes}
	use_proxy=${12:yes}
	proxy=${13:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_lan_connectivity "Configures LAN Connectivity Policies on Cisco UCS Manager" b
ucs_lan_connectivity: >
	name=${1:# The name of the LAN Connectivity Policy.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# A description of the LAN Connectivity Policy.}
	vnic_list=${6:# List of vNICs used by the LAN Connectivity Policy.}
	iscsi_vnic_list=${7:# List of iSCSI vNICs used by the LAN Connectivity Policy.}
	org_dn=${8:org-root}
	username=${9:admin}
	port=${10:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${11:yes}
	use_proxy=${12:yes}
	proxy=${13:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_managed_objects "Configures Managed Objects on Cisco UCS Manager" b
ucs_managed_objects: >
	objects=${1:# List of managed objects to configure.  Each managed object has suboptions the specify the Python SDK module, class, and properties to configure.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:absent|#present}
	username=${5:admin}
	port=${6:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${7:yes}
	use_proxy=${8:yes}
	proxy=${9:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_san_connectivity "Configures SAN Connectivity Policies on Cisco UCS Manager" b
ucs_san_connectivity: >
	name=${1:# The name of the SAN Connectivity Policy.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# A description of the policy.}
	wwnn_pool=${6:default}
	vhba_list=${7:# List of vHBAs used by the SAN Connectivity Policy.}
	org_dn=${8:org-root}
	username=${9:admin}
	port=${10:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${11:yes}
	use_proxy=${12:yes}
	proxy=${13:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_wwn_pool "Configures WWNN or WWPN pools on Cisco UCS Manager" b
ucs_wwn_pool: >
	name=${1:# The name of the World Wide Node Name (WWNN) or World Wide Port Name (WWPN) pool.}
	purpose=${2:node|port}
	hostname=${3:# IP address or hostname of Cisco UCS Manager.}
	password=${4:# Password for Cisco UCS Manager authentication.}

	state=${5:#present|absent}
	description=${6:# A description of the WWNN or WWPN pool.}
	order=${7:#default|sequential}
	first_addr=${8:# The first initiator in the World Wide Name (WWN) block.}
	last_addr=${9:# The last initiator in the World Wide Name (WWN) block.}
	org_dn=${10:org-root}
	username=${11:admin}
	port=${12:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${13:yes}
	use_proxy=${14:yes}
	proxy=${15:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_vhba_template "Configures vHBA templates on Cisco UCS Manager" b
ucs_vhba_template: >
	name=${1:# The name of the virtual HBA template.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# A user-defined description of the template.}
	fabric=${6:#A|B}
	redundancy_type=${7:#none|primary|secondary}
	vsan=${8:default}
	template_type=${9:#initial-template|updating-template}
	max_data=${10:2048}
	wwpn_pool=${11:default}
	qos_policy=${12:# The QoS policy that is associated with vHBAs created from this template.}
	pin_group=${13:# The SAN pin group that is associated with vHBAs created from this template.}
	stats_policy=${14:default}
	org_dn=${15:org-root}
	username=${16:admin}
	port=${17:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${18:yes}
	use_proxy=${19:yes}
	proxy=${20:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_vlans "Configures VLANs on Cisco UCS Manager" b
ucs_vlans: >
	name=${1:# The name assigned to the VLAN.}
	id=${2:# The unique string identifier assigned to the VLAN.}
	hostname=${3:# IP address or hostname of Cisco UCS Manager.}
	password=${4:# Password for Cisco UCS Manager authentication.}

	state=${5:#present|absent}
	multicast_policy=${6:}
	fabric=${7:#common|A|B}
	sharing=${8:#none|primary|isolated|community}
	native=${9:yes|#no}
	username=${10:admin}
	port=${11:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${12:yes}
	use_proxy=${13:yes}
	proxy=${14:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_disk_group_policy "Configures disk group policies on Cisco UCS Manager" b
ucs_disk_group_policy: >
	name=${1:# The name of the disk group policy. This name can be between 1 and 16 alphanumeric characters.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# The user-defined description of the storage profile. Enter up to 256 characters. "You can use any characters or spaces except the following:" "` (accent mark), \ (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."}
	raid_level=${6:#stripe|mirror|mirror-stripe|stripe-parity|stripe-dual-parity|stripe-parity-stripe|stripe-dual-parity-stripe}
	configuration_mode=${7:#automatic|manual}
	num_drives=${8:1}
	drive_type=${9:#unspecified|HDD|SSD}
	num_ded_hot_spares=${10:unspecified}
	num_glob_hot_spares=${11:unspecified}
	min_drive_size=${12:unspecified}
	use_remaining_disks=${13:yes|#no}
	manual_disks=${14:# List of manually configured disks.}
	virtual_drive=${15:# Configuration of virtual drive options.}
	org_dn=${16:org-root}
	username=${17:admin}
	port=${18:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${19:yes}
	use_proxy=${20:yes}
	proxy=${21:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_ntp_server "Configures NTP server on Cisco UCS Manager" b
ucs_ntp_server: >
	hostname=${1:# IP address or hostname of Cisco UCS Manager.}
	password=${2:# Password for Cisco UCS Manager authentication.}

	state=${3:absent|#present}
	ntp_server=${4:}
	description=${5:}
	username=${6:admin}
	port=${7:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${8:yes}
	use_proxy=${9:yes}
	proxy=${10:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_uuid_pool "Configures server UUID pools on Cisco UCS Manager" b
ucs_uuid_pool: >
	name=${1:# The name of the UUID pool.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# The user-defined description of the UUID pool.}
	prefix=${6:# UUID prefix used for the range of server UUIDs.}
	order=${7:#default|sequential}
	first_uuid=${8:# The first UUID in the block of UUIDs.}
	last_uuid=${9:# The last UUID in the block of UUIDs.}
	org_dn=${10:org-root}
	username=${11:admin}
	port=${12:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${13:yes}
	use_proxy=${14:yes}
	proxy=${15:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_dns_server "Configure DNS servers on Cisco UCS Manager" b
ucs_dns_server: >
	hostname=${1:# IP address or hostname of Cisco UCS Manager.}
	password=${2:# Password for Cisco UCS Manager authentication.}

	state=${3:absent|#present}
	dns_server=${4:# DNS server IP address.}
	description=${5:# A user-defined description of the DNS server.}
	delegate_to=${6:localhost}
	username=${7:admin}
	port=${8:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${9:yes}
	use_proxy=${10:yes}
	proxy=${11:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_vlan_find "Find VLANs on Cisco UCS Manager" b
ucs_vlan_find: >
	hostname=${1:# IP address or hostname of Cisco UCS Manager.}
	password=${2:# Password for Cisco UCS Manager authentication.}

	pattern=${3:# Regex pattern to find within the name property of the fabricVlan class.}
	fabric=${4:#common|A|B}
	vlanid=${5:# The unique string identifier assigned to the VLAN.}
	username=${6:admin}
	port=${7:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${8:yes}
	use_proxy=${9:yes}
	proxy=${10:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_org "Manages UCS Organizations for UCS Manager" b
ucs_org: >
	hostname=${1:# IP address or hostname of Cisco UCS Manager.}
	password=${2:# Password for Cisco UCS Manager authentication.}

	state=${3:absent|#present}
	org_name=${4:# The name of the organization.}
	parent_org_path=${5:root}
	description=${6:# A user-defined description of the organization.}
	delegate_to=${7:localhost}
	username=${8:admin}
	port=${9:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${10:yes}
	use_proxy=${11:yes}
	proxy=${12:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_vnic_template "Configures vNIC templates on Cisco UCS Manager" b
ucs_vnic_template: >
	name=${1:# The name of the vNIC template.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# A user-defined description of the vNIC template.}
	fabric=${6:#A|B|A-B|B-A}
	redundancy_type=${7:#none|primary|secondary}
	peer_redundancy_template=${8:# The Peer Redundancy Template.}
	target=${9:adapter}
	template_type=${10:#initial-template|updating-template}
	vlans_list=${11:# List of VLANs used by the vNIC template.}
	cdn_source=${12:#vnic-name|user-defined}
	cdn_name=${13:# CDN Name used when cdn_source is set to user-defined.}
	mtu=${14:1500}
	mac_pool=${15:# The MAC address pool that vNICs created from this vNIC template should use.}
	qos_policy=${16:# The quality of service (QoS) policy that vNICs created from this vNIC template should use.}
	network_control_policy=${17:# The network control policy that vNICs created from this vNIC template should use.}
	pin_group=${18:# The LAN pin group that vNICs created from this vNIC template should use.}
	stats_policy=${19:default}
	org_dn=${20:org-root}
	username=${21:admin}
	port=${22:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${23:yes}
	use_proxy=${24:yes}
	proxy=${25:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_storage_profile "Configures storage profiles on Cisco UCS Manager" b
ucs_storage_profile: >
	name=${1:# The name of the storage profile.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:absent|#present}
	description=${5:# The user-defined description of the storage profile.}
	local_luns=${6:# List of Local LUNs used by the storage profile.}
	org_dn=${7:org-root}
	username=${8:admin}
	port=${9:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${10:yes}
	use_proxy=${11:yes}
	proxy=${12:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_timezone "Configures timezone on Cisco UCS Manager" b
ucs_timezone: >
	hostname=${1:# IP address or hostname of Cisco UCS Manager.}
	password=${2:# Password for Cisco UCS Manager authentication.}

	state=${3:absent|#present}
	admin_state=${4:disabled|#enabled}
	description=${5:}
	timezone=${6:# The timezone name.}
	username=${7:admin}
	port=${8:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${9:yes}
	use_proxy=${10:yes}
	proxy=${11:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_ip_pool "Configures IP address pools on Cisco UCS Manager" b
ucs_ip_pool: >
	name=${1:# The name of the IP address pool.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# The user-defined description of the IP address pool.}
	order=${6:#default|sequential}
	first_addr=${7:# The first IPv4 address in the IPv4 addresses block.}
	last_addr=${8:# The last IPv4 address in the IPv4 addresses block.}
	subnet_mask=${9:255.255.255.0}
	default_gw=${10:0.0.0.0}
	primary_dns=${11:0.0.0.0}
	secondary_dns=${12:0.0.0.0}
	ipv6_first_addr=${13:# The first IPv6 address in the IPv6 addresses block.}
	ipv6_last_addr=${14:# The last IPv6 address in the IPv6 addresses block.}
	ipv6_prefix=${15:64}
	ipv6_default_gw=${16:::}
	ipv6_primary_dns=${17:::}
	ipv6_secondary_dns=${18:::}
	org_dn=${19:org-root}
	username=${20:admin}
	port=${21:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${22:yes}
	use_proxy=${23:yes}
	proxy=${24:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_service_profile_template "Configures Service Profile Templates on Cisco UCS Manager" b
ucs_service_profile_template: >
	name=${1:# The name of the service profile template.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	template_type=${5:#initial-template|updating-template}
	uuid_pool=${6:default}
	description=${7:# A user-defined description of the service profile template.}
	storage_profile=${8:# The name of the storage profile you want to associate with service profiles created from this template}
	local_disk_policy=${9:# The name of the local disk policy you want to associate with service profiles created from this template.}
	lan_connectivity_policy=${10:# The name of the LAN connectivity policy you want to associate with service profiles created from this template.}
	iqn_pool=${11:# The name of the IQN pool (initiator) you want to apply to all iSCSI vNICs for service profiles created from this template.}
	san_connectivity_policy=${12:# The name of the SAN connectivity policy you want to associate with service profiles created from this template.}
	vmedia_policy=${13:# The name of the vMedia policy you want to associate with service profiles created from this template.}
	boot_policy=${14:default}
	maintenance_policy=${15:# The name of the maintenance policy you want to associate with service profiles created from this template.}
	server_pool=${16:# The name of the server pool you want to associate with this service profile template.}
	server_pool_qualification=${17:# The name of the server pool policy qualification you want to use for this service profile template.}
	power_state=${18:#up|down}
	host_firmware_package=${19:# The name of the host firmware package you want to associate with service profiles created from this template.}
	bios_policy=${20:# The name of the BIOS policy you want to associate with service profiles created from this template.}
	ipmi_access_profile=${21:# The name of the IPMI access profile you want to associate with service profiles created from this template.}
	sol_policy=${22:# The name of the Serial over LAN (SoL) policy you want to associate with service profiles created from this template.}
	mgmt_ip_pool=${23:ext-mgmt}
	power_control_policy=${24:default}
	power_sync_policy=${25:# The name of the power sync policy you want to associate with service profiles created from this template.}
	scrub_policy=${26:# The name of the scrub policy you want to associate with service profiles created from this template.}
	kvm_mgmt_policy=${27:# The name of the KVM management policy you want to associate with service profiles created from this template.}
	graphics_card_policy=${28:# The name of the graphics card policy you want to associate with service profiles created from this template.}
	threshold_policy=${29:default}
	user_label=${30:# The User Label you want to assign to service profiles created from this template.}
	mgmt_interface_mode=${31:|in-band}
	mgmt_vnet_name=${32:# A VLAN selected from the associated VLAN group.}
	mgmt_inband_pool_name=${33:# How the inband management IPv4 address is derived for the server associated with this service profile.}
	org_dn=${34:org-root}
	username=${35:admin}
	port=${36:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${37:yes}
	use_proxy=${38:yes}
	proxy=${39:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ucs_mac_pool "Configures MAC address pools on Cisco UCS Manager" b
ucs_mac_pool: >
	name=${1:# The name of the MAC pool.}
	hostname=${2:# IP address or hostname of Cisco UCS Manager.}
	password=${3:# Password for Cisco UCS Manager authentication.}

	state=${4:#present|absent}
	description=${5:# A description of the MAC pool.}
	order=${6:#default|sequential}
	first_addr=${7:# The first MAC address in the block of addresses.}
	last_addr=${8:# The last MAC address in the block of addresses.}
	org_dn=${9:org-root}
	username=${10:admin}
	port=${11:# Port number to be used during connection (by default uses 443 for https and 80 for http connection).}
	use_ssl=${12:yes}
	use_proxy=${13:yes}
	proxy=${14:# If use_proxy is no, specfies proxy to be used for connection. e.g. 'http://proxy.xy.z:8080'}

endsnippet

snippet ipmi_boot "Management of order of boot devices" b
ipmi_boot: >
	name=${1:# Hostname or ip address of the BMC.}
	user=${2:# Username to use to connect to the BMC.}
	password=${3:# Password to connect to the BMC.}
	bootdev=${4:network -- Request network boot|floppy -- Boot from floppy|hd -- Boot from hard drive|safe -- Boot from hard drive, requesting 'safe mode'|optical -- boot from CD/DVD/BD drive|setup -- Boot into setup utility|default -- remove any IPMI directed boot device request}

	port=${5:623}
	state=${6:present -- Request system turn on|absent -- Request system turn on}
	persistent=${7:no}
	uefiboot=${8:no}

endsnippet

snippet ipmi_power "Power management for machine" b
ipmi_power: >
	name=${1:# Hostname or ip address of the BMC.}
	user=${2:# Username to use to connect to the BMC.}
	password=${3:# Password to connect to the BMC.}
	state=${4:on -- Request system turn on|off -- Request system turn off without waiting for OS to shutdown|shutdown -- Have system request OS proper shutdown|reset -- Request system reset without waiting for OS|boot -- If system is off, then 'on', else 'reset'}

	port=${5:623}
	timeout=${6:300}

endsnippet

snippet manageiq_tags "Management of resource tags in ManageIQ." b
manageiq_tags: >
	resource_type=${1:provider|host|vm|blueprint|category|cluster|data store|group|resource pool|service|service template|template|tenant|user}
	resource_name=${2:# the relevant resource name in manageiq}
	manageiq_connection=${3:# ManageIQ connection configuration information.}

	state=${4:absent|#present|list}
	tags=${5:# tags - list of dictionaries, each includes 'name' and 'category' keys.}

endsnippet

snippet manageiq_user "Management of users in ManageIQ." b
manageiq_user: >
	userid=${1:# The unique userid in manageiq, often mentioned as username.}
	manageiq_connection=${2:# ManageIQ connection configuration information.}

	state=${3:absent|#present}
	name=${4:# The users' full name.}
	password=${5:# The users' password.}
	group=${6:# The name of the group to which the user belongs.}
	email=${7:# The users' E-mail address.}
	update_password=${8:#always|on_create}

endsnippet

snippet manageiq_policies "Management of resource policy_profiles in ManageIQ." b
manageiq_policies: >
	resource_type=${1:provider|host|vm|blueprint|category|cluster|data store|group|resource pool|service|service template|template|tenant|user}
	resource_name=${2:# the name of the resource to which the profile should be [un]assigned}
	manageiq_connection=${3:# ManageIQ connection configuration information.}

	state=${4:absent|#present|list}
	policy_profiles=${5:# list of dictionaries, each includes the policy_profile 'name' key.}

endsnippet

snippet manageiq_group "Management of groups in ManageIQ." b
manageiq_group: >
	description=${1:# The group description.}
	manageiq_connection=${2:# ManageIQ connection configuration information.}

	state=${3:absent|#present}
	role_id=${4:# The the group role id}
	role=${5:# The the group role name}
	tenant_id=${6:# The tenant for the group identified by the tenant id.}
	tenant=${7:# The tenant for the group identified by the tenant name.}
	managed_filters=${8:# T}
	managed_filters_merge_mode=${9:merge|#replace}
	belongsto_filters=${10:# A}
	belongsto_filters_merge_mode=${11:merge|#replace}

endsnippet

snippet manageiq_provider "Management of provider in ManageIQ." b
manageiq_provider: >
	name=${1:# T}
	type=${2:Openshift|Amazon|oVirt|VMware|Azure|Director|OpenStack|GCE}
	manageiq_connection=${3:# ManageIQ connection configuration information.}

	state=${4:absent|#present|refresh}
	zone=${5:default}
	provider_region=${6:# T}
	host_default_vnc_port_start=${7:# T}
	host_default_vnc_port_end=${8:# T}
	subscription=${9:# M}
	project=${10:# G}
	azure_tenant_id=${11:# T}
	tenant_mapping_enabled=${12:no}
	api_version=${13:v2|v3}
	provider=${14:# D}
	metrics=${15:# M}
	alerts=${16:# A}
	ssh_keypair=${17:# S}

endsnippet

snippet manageiq_tenant "Management of tenants in ManageIQ." b
manageiq_tenant: >
	name=${1:# The tenant name.}
	description=${2:# The tenant description.}
	manageiq_connection=${3:# ManageIQ connection configuration information.}

	state=${4:absent|#present}
	parent_id=${5:# The id of the parent tenant. If not supplied the root tenant is used.}
	parent=${6:# The name of the parent tenant. If not supplied and no C(parent_id) is supplied the root tenant is used.}
	quotas=${7:# The tenant quotas.}

endsnippet

snippet manageiq_alert_profiles "Configuration of alert profiles for ManageIQ" b
manageiq_alert_profiles: >
	manageiq_connection=${1:# ManageIQ connection configuration information.}

	state=${2:absent|#present}
	name=${3:# The unique alert profile name in ManageIQ.}
	resource_type=${4:Vm|ContainerNode|MiqServer|Host|Storage|EmsCluster|ExtManagementSystem|MiddlewareServer}
	alerts=${5:# List of alert descriptions to assign to this profile.}
	notes=${6:# Optional notes for this profile}

endsnippet

snippet manageiq_alerts "Configuration of alerts in ManageIQ" b
manageiq_alerts: >
	manageiq_connection=${1:# ManageIQ connection configuration information.}

	state=${2:absent|#present}
	description=${3:# The unique alert description in ManageIQ.}
	resource_type=${4:Vm|ContainerNode|MiqServer|Host|Storage|EmsCluster|ExtManagementSystem|MiddlewareServer}
	expression_type=${5:#hash|miq}
	expression=${6:# The alert expression for ManageIQ.}
	enabled=${7:# Enable or disable the alert. Required if state is "present".}
	options=${8:# Additional alert options, such as notification type and frequency}

endsnippet

snippet jenkins_job_info "Get information about Jenkins jobs" b
jenkins_job_info: >
	name=${1:# Exact name of the Jenkins job to fetch information about.}
	glob=${2:# A shell glob of Jenkins job names to fetch information about.}
	color=${3:# Only fetch jobs with the given status color.}
	password=${4:# Password to authenticate with the Jenkins server.}
	token=${5:# API token used to authenticate with the Jenkins server.}
	url=${6:http://localhost:8080}
	user=${7:# User to authenticate with the Jenkins server.}
	validate_certs=${8:yes}

endsnippet

snippet supervisorctl "Manage the state of a program or group of programs running via supervisord" b
supervisorctl: >
	name=${1:# The name of the supervisord program or group to manage.}
	state=${2:present|started|stopped|restarted|absent|signalled}

	config=${3:# The supervisor configuration file path}
	server_url=${4:# URL on which supervisord server is listening}
	username=${5:# username to use for authentication}
	password=${6:# password to use for authentication}
	signal=${7:# The signal to send to the program/group, when combined with the 'signalled' state. Required when l(state=signalled).}
	supervisorctl_path=${8:# path to supervisorctl executable}

endsnippet

snippet htpasswd "manage user files for basic authentication" b
htpasswd: >
	path=${1:# Path to the file that contains the usernames and passwords}
	name=${2:# User name to add or remove}

	password=${3:# Password associated with user.}
	crypt_scheme=${4:#apr_md5_crypt|des_crypt|ldap_sha1|plaintext}
	state=${5:#present|absent}
	create=${6:yes}
	mode=${7:# The permissions the resulting file or directory should have.}
	owner=${8:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${9:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${10:# The user part of the SELinux file context.}
	serole=${11:# The role part of the SELinux file context.}
	setype=${12:# The type part of the SELinux file context.}
	selevel=${13:s0}
	unsafe_writes=${14:no}
	attributes=${15:# The attributes the resulting file or directory should have.}

endsnippet

snippet jboss "Deploy applications to JBoss" b
jboss: >
	deployment=${1:# The name of the deployment.}

	src=${2:# The remote path of the application ear or war to deploy.}
	deploy_path=${3:/var/lib/jbossas/standalone/deployments}
	state=${4:#present|absent}

endsnippet

snippet apache2_module "Enables/disables a module of the Apache2 webserver." b
apache2_module: >
	name=${1:# Name of the module to enable/disable as given to C(a2enmod/a2dismod).}

	identifier=${2:# Identifier of the module as listed by C(apache2ctl -M). This is optional and usually determined automatically by the common convention of appending C(_module) to I(name) as well as custom exception for popular modules.}
	force=${3:no}
	state=${4:#present|absent}
	ignore_configcheck=${5:no}

endsnippet

snippet taiga_issue "Creates/deletes an issue in a Taiga Project Management Platform" b
taiga_issue: >
	project=${1:# Name of the project containing the issue. Must exist previously.}
	subject=${2:# The issue subject.}
	issue_type=${3:# The issue type. Must exist previously.}

	taiga_host=${4:https://api.taiga.io}
	priority=${5:Normal}
	status=${6:New}
	severity=${7:Normal}
	description=${8:}
	attachment=${9:# Path to a file to be attached to the issue.}
	attachment_description=${10:}
	tags=${11:[]}
	state=${12:#present|absent}

endsnippet

snippet nginx_status_info "Retrieve information on nginx status." b
nginx_status_info: >
	url=${1:# URL of the nginx status.}

	timeout=${2:10}

endsnippet

snippet rundeck_project "Manage Rundeck projects." b
rundeck_project: >
	name=${1:# Sets the project name.}
	url=${2:# Sets the rundeck instance URL.}
	token=${3:# Sets the token to authenticate against Rundeck API.}

	state=${4:#present|absent}
	api_version=${5:14}

endsnippet

snippet jenkins_job_info "Get information about Jenkins jobs" b
jenkins_job_info: >
	name=${1:# Exact name of the Jenkins job to fetch information about.}
	glob=${2:# A shell glob of Jenkins job names to fetch information about.}
	color=${3:# Only fetch jobs with the given status color.}
	password=${4:# Password to authenticate with the Jenkins server.}
	token=${5:# API token used to authenticate with the Jenkins server.}
	url=${6:http://localhost:8080}
	user=${7:# User to authenticate with the Jenkins server.}
	validate_certs=${8:yes}

endsnippet

snippet gunicorn "Run gunicorn with various settings." b
gunicorn: >
	app=${1:# The app module. A name refers to a WSGI callable that should be found in the specified module.}

	venv=${2:# Path to the virtualenv directory.}
	config=${3:# Path to the gunicorn configuration file.}
	chdir=${4:# Chdir to specified directory before apps loading.}
	pid=${5:# A filename to use for the PID file. If not set and not found on the configuration file a tmp pid file will be created to check a successful run of gunicorn.}
	worker=${6:sync|eventlet|gevent|tornado |gthread|gaiohttp}
	user=${7:# Switch worker processes to run as this user.}

endsnippet

snippet jenkins_script "Executes a groovy script in the jenkins instance" b
jenkins_script: >
	script=${1:# The groovy script to be executed. This gets passed as a string Template if args is defined.}

	url=${2:http://localhost:8080}
	validate_certs=${3:yes}
	user=${4:# The username to connect to the jenkins server with.}
	password=${5:# The password to connect to the jenkins server with.}
	timeout=${6:10}
	args=${7:# A dict of key-value pairs used in formatting the script using string.Template (see https://docs.python.org/2/library/string.html#template-strings).}

endsnippet

snippet jenkins_job "Manage jenkins jobs" b
jenkins_job: >
	name=${1:# Name of the Jenkins job.}

	config=${2:# config in XML format.}
	enabled=${3:# Whether the job should be enabled or disabled.}
	password=${4:# Password to authenticate with the Jenkins server.}
	state=${5:#present|absent}
	token=${6:# API token used to authenticate alternatively to password.}
	url=${7:http://localhost:8080}
	user=${8:# User to authenticate with the Jenkins server.}

endsnippet

snippet django_manage "Manages a Django application." b
django_manage: >
	command=${1:cleanup|collectstatic|flush|loaddata|migrate|runfcgi|syncdb|test|validate}
	app_path=${2:# The path to the root of the Django application where B(manage.py) lives.}

	settings=${3:# The Python path to the application's settings module, such as 'myapp.settings'.}
	pythonpath=${4:# A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory.}
	virtualenv=${5:# An optional path to a I(virtualenv) installation to use while running the manage application.}
	apps=${6:# A list of space-delimited apps to target. Used by the 'test' command.}
	cache_table=${7:# The name of the table used for database-backed caching. Used by the 'createcachetable' command.}
	clear=${8:no}
	database=${9:# The database to target. Used by the 'createcachetable', 'flush', 'loaddata', and 'syncdb' commands.}
	failfast=${10:no}
	fixtures=${11:# A space-delimited list of fixture file names to load in the database. B(Required) by the 'loaddata' command.}
	skip=${12:# Will skip over out-of-order missing migrations, you can only use this parameter with I(migrate)}
	merge=${13:# Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with 'migrate' command}
	link=${14:# Will create links to the files instead of copying them, you can only use this parameter with 'collectstatic' command}

endsnippet

snippet jira "create and modify issues in a JIRA instance" b
jira: >
	uri=${1:# Base URI for the JIRA instance.}
	operation=${2:create|comment|edit|fetch|transition|link}
	username=${3:# The username to log-in with.}
	password=${4:# The password to log-in with.}

	project=${5:# The project for this operation. Required for issue creation.}
	summary=${6:# The issue summary, where appropriate.}
	description=${7:# The issue description, where appropriate.}
	issuetype=${8:# The issue type, for issue creation.}
	issue=${9:# An existing issue key to operate on.}
	comment=${10:# The comment text to add.}
	status=${11:# The desired status; only relevant for the transition operation.}
	assignee=${12:# Sets the assignee on create or transition operations. Note not all transitions will allow this.}
	linktype=${13:# Set type of link, when action 'link' selected.}
	inwardissue=${14:# Set issue from which link will be created.}
	outwardissue=${15:# Set issue to which link will be created.}
	fields=${16:# This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.}
	timeout=${17:10}
	validate_certs=${18:yes}

endsnippet

snippet jenkins_plugin "Add or remove Jenkins plugin" b
jenkins_plugin: >
	name=${1:# Plugin name.}

	group=${2:jenkins}
	jenkins_home=${3:/var/lib/jenkins}
	mode=${4:0644}
	owner=${5:jenkins}
	state=${6:absent|#present|pinned|unpinned|enabled|disabled|latest}
	timeout=${7:30}
	updates_expiration=${8:86400}
	updates_url=${9:https://updates.jenkins.io}
	url=${10:http://localhost:8080}
	version=${11:# Plugin version number.}
	with_dependencies=${12:yes}
	force=${13:no}
	http_agent=${14:ansible-httpget}
	use_proxy=${15:yes}
	validate_certs=${16:yes}
	url_username=${17:# The username for use in HTTP basic authentication.}
	url_password=${18:# The password for use in HTTP basic authentication.}
	force_basic_auth=${19:no}
	client_cert=${20:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${21:# PEM formatted file that contains your private key to be used for SSL client authentication.}

endsnippet

snippet apache2_mod_proxy "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool" b
apache2_mod_proxy: >
	balancer_vhost=${1:# (ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.}

	balancer_url_suffix=${2:/balancer-manager/}
	member_host=${3:# (ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.}
	state=${4:present|absent|enabled|disabled|drained|hot_standby|ignore_errors}
	tls=${5:no}
	validate_certs=${6:yes}

endsnippet

snippet deploy_helper "Manages some of the steps common in deploying projects." b
deploy_helper: >
	path=${1:# the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact.}

	state=${2:#present|finalize|absent|clean|query}
	release=${3:# the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during C(state=present), but needs to be set explicitly for C(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }}).}
	releases_path=${4:releases}
	shared_path=${5:shared}
	current_path=${6:current}
	unfinished_filename=${7:DEPLOY_UNFINISHED}
	clean=${8:yes}
	keep_releases=${9:5}

endsnippet

snippet rundeck_acl_policy "Manage Rundeck ACL policies." b
rundeck_acl_policy: >
	name=${1:# Sets the project name.}
	url=${2:# Sets the rundeck instance URL.}
	token=${3:# Sets the token to authenticate against Rundeck API.}

	state=${4:#present|absent}
	api_version=${5:14}
	project=${6:# Sets the project which receive the ACL policy.}
	policy=${7:# Sets the ACL policy content.}

endsnippet

snippet ejabberd_user "Manages users for ejabberd servers" b
ejabberd_user: >
	username=${1:# the name of the user to manage}
	host=${2:# the ejabberd host associated with this username}

	password=${3:# the password to assign to the username}
	logging=${4:no}
	state=${5:#present|absent}

endsnippet

snippet utm_ca_host_key_cert "create, update or destroy ca host_key_cert entry in Sophos UTM" b
utm_ca_host_key_cert: >
	name=${1:# The name of the object. Will be used to identify the entry.}
	ca=${2:# A reference to an existing utm_ca_signing_ca or utm_ca_verification_ca object.}
	meta=${3:# A reference to an existing utm_ca_meta_x509 object.}
	certificate=${4:# The certificate in PEM format.}
	utm_host=${5:# The REST Endpoint of the Sophos UTM.}
	utm_token=${6:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	comment=${7:# Optional comment string.}
	encrypted=${8:no}
	key=${9:# Optional private key in PEM format.}
	headers=${10:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${11:4444}
	utm_protocol=${12:http|#https}
	validate_certs=${13:yes}
	state=${14:absent|#present}

endsnippet

snippet utm_ca_host_key_cert_info "Get info for a ca host_key_cert entry in Sophos UTM" b
utm_ca_host_key_cert_info: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	headers=${4:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${5:4444}
	utm_protocol=${6:http|#https}
	validate_certs=${7:yes}
	state=${8:absent|#present}

endsnippet

snippet utm_proxy_location_info "create, update or destroy reverse_proxy location entry in Sophos UTM" b
utm_proxy_location_info: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	headers=${4:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${5:4444}
	utm_protocol=${6:http|#https}
	validate_certs=${7:yes}
	state=${8:absent|#present}

endsnippet

snippet utm_network_interface_address "Create, update or destroy network/interface_address object" b
utm_network_interface_address: >
	name=${1:# The name of the object. Will be used to identify the entry}
	address=${2:# The ip4 address of the network/interface_address object.}
	utm_host=${3:# The REST Endpoint of the Sophos UTM.}
	utm_token=${4:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	address6=${5:# The ip6 address of the network/interface_address object.}
	comment=${6:# An optional comment to add to the object}
	resolved=${7:# Whether or not the object is resolved}
	resolved6=${8:# Whether or not the object is resolved}
	headers=${9:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${10:4444}
	utm_protocol=${11:http|#https}
	validate_certs=${12:yes}
	state=${13:absent|#present}

endsnippet

snippet utm_proxy_frontend "create, update or destroy reverse_proxy frontend entry in Sophos UTM" b
utm_proxy_frontend: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	add_content_type_header=${4:no}
	address=${5:REF_DefaultInternalAddress}
	allowed_networks=${6:['REF_NetworkAny']}
	certificate=${7:}
	comment=${8:}
	disable_compression=${9:no}
	domain=${10:# A list of domain names for the frontend object}
	exceptions=${11:[]}
	htmlrewrite=${12:no}
	htmlrewrite_cookies=${13:no}
	implicitredirect=${14:no}
	lbmethod=${15:|#bybusyness|bytraffic|byrequests}
	locations=${16:[]}
	port=${17:80}
	preservehost=${18:no}
	profile=${19:}
	status=${20:yes}
	type=${21:#http|https}
	xheaders=${22:no}
	headers=${23:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${24:4444}
	utm_protocol=${25:http|#https}
	validate_certs=${26:yes}
	state=${27:absent|#present}

endsnippet

snippet utm_network_interface_address_info "Get info for a network/interface_address object" b
utm_network_interface_address_info: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	headers=${4:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${5:4444}
	utm_protocol=${6:http|#https}
	validate_certs=${7:yes}
	state=${8:absent|#present}

endsnippet

snippet utm_proxy_location "create, update or destroy reverse_proxy location entry in Sophos UTM" b
utm_proxy_location: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	access_control=${4:#0|1}
	allowed_networks=${5:REF_NetworkAny}
	auth_profile=${6:# The reference name of the auth profile}
	backend=${7:[]}
	be_path=${8:# The path of the backend}
	comment=${9:# The optional comment string}
	denied_networks=${10:[]}
	hot_standby=${11:no}
	path=${12:/}
	status=${13:yes}
	stickysession_id=${14:ROUTEID}
	stickysession_status=${15:no}
	websocket_passthrough=${16:no}
	headers=${17:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${18:4444}
	utm_protocol=${19:http|#https}
	validate_certs=${20:yes}
	state=${21:absent|#present}

endsnippet

snippet utm_aaa_group_info "get info for reverse_proxy frontend entry in Sophos UTM" b
utm_aaa_group_info: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	headers=${4:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${5:4444}
	utm_protocol=${6:http|#https}
	validate_certs=${7:yes}
	state=${8:absent|#present}

endsnippet

snippet utm_aaa_group "Create, update or destroy an aaa group object in Sophos UTM." b
utm_aaa_group: >
	name=${1:# The name of the object. Will be used to identify the entry.}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	adirectory_groups=${4:# List of adirectory group strings.}
	adirectory_groups_sids=${5:# Dictionary of group sids.}
	backend_match=${6:#none|adirectory|edirectory|radius|tacacs|ldap}
	comment=${7:}
	dynamic=${8:#none|ipsec_dn|directory_groups}
	edirectory_groups=${9:# List of edirectory group strings.}
	ipsec_dn=${10:# The ipsec dn string.}
	ldap_attribute=${11:# The ldap attribute to check against.}
	ldap_attribute_value=${12:# The ldap attribute value to check against.}
	members=${13:[]}
	network=${14:}
	radius_groups=${15:[]}
	tacacs_groups=${16:[]}
	headers=${17:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${18:4444}
	utm_protocol=${19:http|#https}
	validate_certs=${20:yes}
	state=${21:absent|#present}

endsnippet

snippet utm_dns_host "create, update or destroy dns entry in Sophos UTM" b
utm_dns_host: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	address=${4:0.0.0.0}
	address6=${5:::}
	comment=${6:# An optional comment to add to the dns host object}
	hostname=${7:# The hostname for the dns host object}
	interface=${8:# The reference name of the interface to use. If not provided the default interface will be used}
	resolved=${9:no}
	resolved6=${10:no}
	timeout=${11:0}
	headers=${12:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${13:4444}
	utm_protocol=${14:http|#https}
	validate_certs=${15:yes}
	state=${16:absent|#present}

endsnippet

snippet utm_proxy_frontend_info "create, update or destroy reverse_proxy frontend entry in Sophos UTM" b
utm_proxy_frontend_info: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	headers=${4:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${5:4444}
	utm_protocol=${6:http|#https}
	validate_certs=${7:yes}
	state=${8:absent|#present}

endsnippet

snippet utm_proxy_exception "Create, update or destroy reverse_proxy exception entry in Sophos UTM" b
utm_proxy_exception: >
	name=${1:# The name of the object. Will be used to identify the entry}
	utm_host=${2:# The REST Endpoint of the Sophos UTM.}
	utm_token=${3:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	op=${4:#AND|OR}
	path=${5:[]}
	skip_custom_threats_filters=${6:[]}
	skip_threats_filter_categories=${7:[]}
	skipav=${8:no}
	skipbadclients=${9:no}
	skipcookie=${10:no}
	skipform=${11:no}
	skipform_missingtoken=${12:no}
	skiphtmlrewrite=${13:no}
	skiptft=${14:no}
	skipurl=${15:no}
	source=${16:[]}
	status=${17:yes}
	headers=${18:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${19:4444}
	utm_protocol=${20:http|#https}
	validate_certs=${21:yes}
	state=${22:absent|#present}

endsnippet

snippet utm_proxy_auth_profile "create, update or destroy reverse_proxy auth_profile entry in Sophos UTM" b
utm_proxy_auth_profile: >
	name=${1:# The name of the object. Will be used to identify the entry}
	aaa=${2:# List of references to utm_aaa objects (allowed users or groups)}
	basic_prompt=${3:# The message in the basic authentication prompt}
	frontend_session_lifetime=${4:# session lifetime}
	frontend_session_timeout=${5:# session timeout}
	utm_host=${6:# The REST Endpoint of the Sophos UTM.}
	utm_token=${7:# The token used to identify at the REST-API. See U(https://www.sophos.com/en-us/medialibrary/PDFs/documentation/UTMonAWS/Sophos-UTM-RESTful-API.pdf?la=en), Chapter 2.4.2.}

	backend_mode=${8:Basic|#None}
	backend_strip_basic_auth=${9:#True|False}
	backend_user_prefix=${10:}
	backend_user_suffix=${11:}
	comment=${12:}
	frontend_cookie=${13:# Frontend cookie name}
	frontend_cookie_secret=${14:# Frontend cookie secret}
	frontend_form=${15:# Frontend authentication form name}
	frontend_form_template=${16:}
	frontend_login=${17:# Frontend login name}
	frontend_logout=${18:# Frontend logout name}
	frontend_mode=${19:#Basic|Form}
	frontend_realm=${20:# Frontend authentication realm}
	frontend_session_allow_persistency=${21:True|#False}
	frontend_session_lifetime_limited=${22:#True|False}
	frontend_session_lifetime_scope=${23:days|#hours|minutes}
	frontend_session_timeout_enabled=${24:#True|False}
	frontend_session_timeout_scope=${25:days|hours|#minutes}
	logout_delegation_urls=${26:[]}
	logout_mode=${27:#None|Delegation}
	redirect_to_requested_url=${28:True|#False}
	headers=${29:# A dictionary of additional headers to be sent to POST and PUT requests.}
	utm_port=${30:4444}
	utm_protocol=${31:http|#https}
	validate_certs=${32:yes}
	state=${33:absent|#present}

endsnippet

snippet tower_team "create, update, or destroy Ansible Tower team." b
tower_team: >
	name=${1:# Name to use for the team.}
	organization=${2:# Organization the team should be made a member of.}

	state=${3:#present|absent}
	tower_host=${4:# URL to your Tower instance.}
	tower_username=${5:# Username for your Tower instance.}
	tower_password=${6:# Password for your Tower instance.}
	validate_certs=${7:# Whether to allow insecure connections to Tower.}
	tower_config_file=${8:# Path to the Tower config file.}

endsnippet

snippet tower_role "create, update, or destroy Ansible Tower role." b
tower_role: >
	role=${1:admin|read|member|execute|adhoc|update|use|auditor|project_admin|inventory_admin|credential_admin|workflow_admin|notification_admin|job_template_admin}

	user=${2:# User that receives the permissions specified by the role.}
	team=${3:# Team that receives the permissions specified by the role.}
	target_team=${4:# Team that the role acts on.}
	inventory=${5:# Inventory the role acts on.}
	job_template=${6:# The job template the role acts on.}
	credential=${7:# Credential the role acts on.}
	organization=${8:# Organization the role acts on.}
	project=${9:# Project the role acts on.}
	state=${10:#present|absent}
	tower_host=${11:# URL to your Tower instance.}
	tower_username=${12:# Username for your Tower instance.}
	tower_password=${13:# Password for your Tower instance.}
	validate_certs=${14:# Whether to allow insecure connections to Tower.}
	tower_config_file=${15:# Path to the Tower config file.}

endsnippet

snippet tower_inventory "create, update, or destroy Ansible Tower inventory." b
tower_inventory: >
	name=${1:# The name to use for the inventory.}
	organization=${2:# Organization the inventory belongs to.}

	description=${3:# The description to use for the inventory.}
	variables=${4:# Inventory variables. Use C(@) to get from file.}
	kind=${5:#|smart}
	host_filter=${6:# The host_filter field. Only useful when C(kind=smart).}
	state=${7:#present|absent}
	tower_host=${8:# URL to your Tower instance.}
	tower_username=${9:# Username for your Tower instance.}
	tower_password=${10:# Password for your Tower instance.}
	validate_certs=${11:# Whether to allow insecure connections to Tower.}
	tower_config_file=${12:# Path to the Tower config file.}

endsnippet

snippet tower_workflow_launch "Run a workflow in Ansible Tower" b
tower_workflow_launch: >
	workflow_template=${1:# The name of the workflow template to run.}

	extra_vars=${2:# Any extra vars required to launch the job.}
	wait=${3:yes}
	timeout=${4:# If waiting for the workflow to complete this will abort after this amount of seconds}
	tower_host=${5:# URL to your Tower instance.}
	tower_username=${6:# Username for your Tower instance.}
	tower_password=${7:# Password for your Tower instance.}
	validate_certs=${8:# Whether to allow insecure connections to Tower.}
	tower_config_file=${9:# Path to the Tower config file.}

endsnippet

snippet tower_credential "create, update, or destroy Ansible Tower credential." b
tower_credential: >
	name=${1:# The name to use for the credential.}
	organization=${2:# Organization that should own the credential.}
	kind=${3:ssh|vault|net|scm|aws|vmware|satellite6|cloudforms|gce|azure_rm|openstack|rhv|insights|tower}

	description=${4:# The description to use for the credential.}
	user=${5:# User that should own this credential.}
	team=${6:# Team that should own this credential.}
	project=${7:# Project that should for this credential.}
	host=${8:# Host for this credential.}
	username=${9:# Username for this credential. ``access_key`` for AWS.}
	password=${10:# Password for this credential. ``secret_key`` for AWS. ``api_key`` for RAX.}
	ssh_key_data=${11:# SSH private key content. To extract the content from a file path, use the lookup function (see examples).}
	ssh_key_unlock=${12:# Unlock password for ssh_key.}
	authorize=${13:no}
	authorize_password=${14:# Password for net credentials that require authorize.}
	client=${15:# Client or application ID for azure_rm type.}
	security_token=${16:# STS token for aws type.}
	secret=${17:# Secret token for azure_rm type.}
	subscription=${18:# Subscription ID for azure_rm type.}
	tenant=${19:# Tenant ID for azure_rm type.}
	domain=${20:# Domain for openstack type.}
	become_method=${21:None|sudo|su|pbrun|pfexec|pmrun}
	become_username=${22:# Become username.}
	become_password=${23:# Become password.}
	vault_password=${24:# Vault password.}
	vault_id=${25:# Vault identifier.}
	state=${26:#present|absent}
	tower_host=${27:# URL to your Tower instance.}
	tower_username=${28:# Username for your Tower instance.}
	tower_password=${29:# Password for your Tower instance.}
	validate_certs=${30:# Whether to allow insecure connections to Tower.}
	tower_config_file=${31:# Path to the Tower config file.}

endsnippet

snippet tower_label "create, update, or destroy Ansible Tower label." b
tower_label: >
	name=${1:# Name to use for the label.}
	organization=${2:# Organization the label should be applied to.}

	state=${3:#present|absent}
	tower_host=${4:# URL to your Tower instance.}
	tower_username=${5:# Username for your Tower instance.}
	tower_password=${6:# Password for your Tower instance.}
	validate_certs=${7:# Whether to allow insecure connections to Tower.}
	tower_config_file=${8:# Path to the Tower config file.}

endsnippet

snippet tower_group "create, update, or destroy Ansible Tower group." b
tower_group: >
	name=${1:# The name to use for the group.}
	inventory=${2:# Inventory the group should be made a member of.}

	description=${3:# The description to use for the group.}
	variables=${4:# Variables to use for the group, use C(@) for a file.}
	credential=${5:# Credential to use for the group.}
	source=${6:manual|file|ec2|rax|vmware|gce|azure|azure_rm|openstack|satellite6|cloudforms|custom}
	source_regions=${7:# Regions for cloud provider.}
	source_vars=${8:# Override variables from source with variables from this field.}
	instance_filters=${9:# Comma-separated list of filter expressions for matching hosts.}
	group_by=${10:# Limit groups automatically created from inventory source.}
	source_script=${11:# Inventory script to be used when group type is C(custom).}
	overwrite=${12:no}
	overwrite_vars=${13:# Override vars in child groups and hosts with those from external source.}
	update_on_launch=${14:no}
	state=${15:#present|absent}
	tower_host=${16:# URL to your Tower instance.}
	tower_username=${17:# Username for your Tower instance.}
	tower_password=${18:# Password for your Tower instance.}
	validate_certs=${19:# Whether to allow insecure connections to Tower.}
	tower_config_file=${20:# Path to the Tower config file.}

endsnippet

snippet tower_send "Send assets to Ansible Tower." b
tower_send: >
	assets=${1:# The assets to import.}
	files=${2:[]}
	prevent=${3:[]}
	password_management=${4:#default|random}
	tower_host=${5:# URL to your Tower instance.}
	tower_username=${6:# Username for your Tower instance.}
	tower_password=${7:# Password for your Tower instance.}
	validate_certs=${8:# Whether to allow insecure connections to Tower.}
	tower_config_file=${9:# Path to the Tower config file.}

endsnippet

snippet tower_job_cancel "Cancel an Ansible Tower Job." b
tower_job_cancel: >
	job_id=${1:# ID of the job to cancel}

	fail_if_not_running=${2:no}
	tower_host=${3:# URL to your Tower instance.}
	tower_username=${4:# Username for your Tower instance.}
	tower_password=${5:# Password for your Tower instance.}
	validate_certs=${6:# Whether to allow insecure connections to Tower.}
	tower_config_file=${7:# Path to the Tower config file.}

endsnippet

snippet tower_host "create, update, or destroy Ansible Tower host." b
tower_host: >
	name=${1:# The name to use for the host.}
	inventory=${2:# Inventory the host should be made a member of.}

	description=${3:# The description to use for the host.}
	enabled=${4:yes}
	variables=${5:# Variables to use for the host. Use C(@) for a file.}
	state=${6:#present|absent}
	tower_host=${7:# URL to your Tower instance.}
	tower_username=${8:# Username for your Tower instance.}
	tower_password=${9:# Password for your Tower instance.}
	validate_certs=${10:# Whether to allow insecure connections to Tower.}
	tower_config_file=${11:# Path to the Tower config file.}

endsnippet

snippet tower_credential_type "Create, update, or destroy custom Ansible Tower credential type." b
tower_credential_type: >
	name=${1:# The name of the credential type.}

	description=${2:# The description of the credential type to give more detail about it.}
	kind=${3:ssh|vault|net|scm|cloud|insights}
	inputs=${4:# Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax.}
	injectors=${5:# Enter injectors using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax.}
	state=${6:#present|absent}
	validate_certs=${7:# Tower option to avoid certificates check.}
	tower_host=${8:# URL to your Tower instance.}
	tower_username=${9:# Username for your Tower instance.}
	tower_password=${10:# Password for your Tower instance.}
	tower_config_file=${11:# Path to the Tower config file.}

endsnippet

snippet tower_user "create, update, or destroy Ansible Tower user." b
tower_user: >
	username=${1:# The username of the user.}
	email=${2:# Email address of the user.}

	first_name=${3:# First name of the user.}
	last_name=${4:# Last name of the user.}
	password=${5:# Password of the user.}
	superuser=${6:no}
	auditor=${7:no}
	state=${8:#present|absent}
	tower_host=${9:# URL to your Tower instance.}
	tower_username=${10:# Username for your Tower instance.}
	tower_password=${11:# Password for your Tower instance.}
	validate_certs=${12:# Whether to allow insecure connections to Tower.}
	tower_config_file=${13:# Path to the Tower config file.}

endsnippet

snippet tower_inventory_source "create, update, or destroy Ansible Tower inventory source." b
tower_inventory_source: >
	name=${1:# The name to use for the inventory source.}
	inventory=${2:# The inventory the source is linked to.}
	source=${3:file|scm|ec2|gce|azure|azure_rm|vmware|satellite6|cloudforms|openstack|rhv|tower|custom}

	description=${4:# The description to use for the inventory source.}
	credential=${5:# Credential to use to retrieve the inventory from.}
	source_vars=${6:# The source_vars allow to Override variables found in the source config file. For example with Openstack, specifying *private: false* would change the output of the openstack.py script. It has to be YAML or JSON.}
	timeout=${7:# Number in seconds after which the Tower API methods will time out.}
	source_project=${8:# Use a *project* as a source for the *inventory*.}
	source_path=${9:# Path to the file to use as a source in the selected *project*.}
	update_on_project_update=${10:# That parameter will sync the inventory when the project is synced. It can only be used with a SCM source.}
	source_regions=${11:# List of regions for your cloud provider. You can include multiple all regions. Only Hosts associated with the selected regions will be updated. Refer to Ansible Tower documentation for more detail.}
	instance_filters=${12:# Provide a comma-separated list of filter expressions. Hosts are imported when all of the filters match. Refer to Ansible Tower documentation for more detail.}
	group_by=${13:# Specify which groups to create automatically. Group names will be created similar to the options selected. If blank, all groups above are created. Refer to Ansible Tower documentation for more detail.}
	source_script=${14:# The source custom script to use to build the inventory. It needs to exist.}
	overwrite=${15:# If set, any hosts and groups that were previously present on the external source but are now removed will be removed from the Tower inventory. Hosts and groups that were not managed by the inventory source will be promoted to the next manually created group or if there is no manually created group to promote them into, they will be left in the "all" default group for the inventory. When not checked, local child hosts and groups not found on the external source will remain untouched by the inventory update process.}
	overwrite_vars=${16:# If set, all variables for child groups and hosts will be removed and replaced by those found on the external source. When not checked, a merge will be performed, combining local variables with those found on the external source.}
	update_on_launch=${17:# Each time a job runs using this inventory, refresh the inventory from the selected source before executing job tasks.}
	update_cache_timeout=${18:# Time in seconds to consider an inventory sync to be current. During job runs and callbacks the task system will evaluate the timestamp of the latest sync. If it is older than Cache Timeout, it is not considered current, and a new inventory sync will be performed.}
	state=${19:#present|absent}
	validate_certs=${20:# Tower option to avoid certificates check.}
	tower_host=${21:# URL to your Tower instance.}
	tower_username=${22:# Username for your Tower instance.}
	tower_password=${23:# Password for your Tower instance.}
	tower_config_file=${24:# Path to the Tower config file.}

endsnippet

snippet tower_receive "Receive assets from Ansible Tower." b
tower_receive: >
	all=${1:False}
	organization=${2:[]}
	user=${3:[]}
	team=${4:[]}
	credential_type=${5:[]}
	credential=${6:[]}
	notification_template=${7:[]}
	inventory_script=${8:[]}
	inventory=${9:[]}
	project=${10:[]}
	job_template=${11:[]}
	workflow=${12:[]}
	tower_host=${13:# URL to your Tower instance.}
	tower_username=${14:# Username for your Tower instance.}
	tower_password=${15:# Password for your Tower instance.}
	validate_certs=${16:# Whether to allow insecure connections to Tower.}
	tower_config_file=${17:# Path to the Tower config file.}

endsnippet

snippet tower_notification "create, update, or destroy Ansible Tower notification." b
tower_notification: >
	name=${1:# The name of the notification.}
	notification_type=${2:email|slack|twilio|pagerduty|hipchat|webhook|irc}

	description=${3:# The description of the notification.}
	organization=${4:# The organization the notification belongs to.}
	notification_configuration=${5:# The notification configuration file. Note providing this field would disable all notification-configuration-related fields.}
	username=${6:# The mail server username. Required if I(notification_type=email).}
	sender=${7:# The sender email address. Required if I(notification_type=email).}
	recipients=${8:# The recipients email addresses. Required if I(notification_type=email).}
	use_tls=${9:# The TLS trigger. Required if I(notification_type=email).}
	host=${10:# The mail server host. Required if I(notification_type=email).}
	use_ssl=${11:# The SSL trigger. Required if I(notification_type=email) or if I(notification_type=irc).}
	password=${12:# The mail server password. Required if I(notification_type=email) or if I(notification_type=irc).}
	port=${13:# The mail server port. Required if I(notification_type=email) or if I(notification_type=irc).}
	channels=${14:# The destination Slack channels. Required if I(notification_type=slack).}
	token=${15:# The access token. Required if I(notification_type=slack), if I(notification_type=pagerduty) or if I(notification_type=hipchat).}
	account_token=${16:# The Twillio account token. Required if I(notification_type=twillio).}
	from_number=${17:# The source phone number. Required if I(notification_type=twillio).}
	to_numbers=${18:# The destination phone numbers. Required if I(notification_type=twillio).}
	account_sid=${19:# The Twillio account SID. Required if I(notification_type=twillio).}
	subdomain=${20:# The PagerDuty subdomain. Required if I(notification_type=pagerduty).}
	service_key=${21:# The PagerDuty service/integration API key. Required if I(notification_type=pagerduty).}
	client_name=${22:# The PagerDuty client identifier. Required if I(notification_type=pagerduty).}
	message_from=${23:# The label to be shown with the notification. Required if I(notification_type=hipchat).}
	api_url=${24:# The HipChat API URL. Required if I(notification_type=hipchat).}
	color=${25:yellow|green|red|purple|gray|random}
	rooms=${26:# HipChat rooms to send the notification to. Required if I(notification_type=hipchat).}
	notify=${27:# The notify channel trigger. Required if I(notification_type=hipchat).}
	url=${28:# The target URL. Required if I(notification_type=webhook).}
	headers=${29:# The HTTP headers as JSON string. Required if I(notification_type=webhook).}
	server=${30:# The IRC server address. Required if I(notification_type=irc).}
	nickname=${31:# The IRC nickname. Required if I(notification_type=irc).}
	targets=${32:# The destination channels or users. Required if I(notification_type=irc).}
	state=${33:#present|absent}
	tower_host=${34:# URL to your Tower instance.}
	tower_username=${35:# Username for your Tower instance.}
	tower_password=${36:# Password for your Tower instance.}
	validate_certs=${37:# Whether to allow insecure connections to Tower.}
	tower_config_file=${38:# Path to the Tower config file.}

endsnippet

snippet tower_organization "create, update, or destroy Ansible Tower organizations" b
tower_organization: >
	name=${1:# Name to use for the organization.}

	description=${2:# The description to use for the organization.}
	state=${3:#present|absent}
	tower_host=${4:# URL to your Tower instance.}
	tower_username=${5:# Username for your Tower instance.}
	tower_password=${6:# Password for your Tower instance.}
	validate_certs=${7:# Whether to allow insecure connections to Tower.}
	tower_config_file=${8:# Path to the Tower config file.}

endsnippet

snippet tower_job_list "List Ansible Tower jobs." b
tower_job_list: >
	status=${1:pending|waiting|running|error|failed|canceled|successful}
	page=${2:# Page number of the results to fetch.}
	all_pages=${3:no}
	query=${4:# Query used to further filter the list of jobs. C({"foo":"bar"}) will be passed at C(?foo=bar)}
	tower_host=${5:# URL to your Tower instance.}
	tower_username=${6:# Username for your Tower instance.}
	tower_password=${7:# Password for your Tower instance.}
	validate_certs=${8:# Whether to allow insecure connections to Tower.}
	tower_config_file=${9:# Path to the Tower config file.}

endsnippet

snippet tower_job_launch "Launch an Ansible Job." b
tower_job_launch: >
	job_template=${1:# Name of the job template to use.}

	job_explanation=${2:# Job explanation field.}
	job_type=${3:run|check|scan}
	inventory=${4:# Inventory to use for the job, only used if prompt for inventory is set.}
	credential=${5:# Credential to use for job, only used if prompt for credential is set.}
	extra_vars=${6:# Extra_vars to use for the job_template. Prepend C(@) if a file.}
	limit=${7:# Limit to use for the I(job_template).}
	tags=${8:# Specific tags to use for from playbook.}
	use_job_endpoint=${9:no}
	tower_host=${10:# URL to your Tower instance.}
	tower_username=${11:# Username for your Tower instance.}
	tower_password=${12:# Password for your Tower instance.}
	validate_certs=${13:# Whether to allow insecure connections to Tower.}
	tower_config_file=${14:# Path to the Tower config file.}

endsnippet

snippet tower_workflow_template "create, update, or destroy Ansible Tower workflow template." b
tower_workflow_template: >
	name=${1:# The name to use for the workflow.}

	allow_simultaneous=${2:# If enabled, simultaneous runs of this job template will be allowed.}
	ask_extra_vars=${3:# Prompt user for (extra_vars) on launch.}
	ask_inventory=${4:# Prompt user for inventory on launch.}
	description=${5:# The description to use for the workflow.}
	extra_vars=${6:# Extra variables used by Ansible in YAML or key=value format.}
	inventory=${7:# Name of the inventory to use for the job template.}
	organization=${8:# The organization the workflow is linked to.}
	schema=${9:# The schema is a JSON- or YAML-formatted string defining the hierarchy structure that connects the nodes. Refer to Tower documentation for more information.
}
	survey_enabled=${10:# Setting that variable will prompt the user for job type on the workflow launch.}
	survey=${11:# The definition of the survey associated to the workflow.}
	state=${12:#present|absent}
	tower_host=${13:# URL to your Tower instance.}
	tower_username=${14:# Username for your Tower instance.}
	tower_password=${15:# Password for your Tower instance.}
	validate_certs=${16:# Whether to allow insecure connections to Tower.}
	tower_config_file=${17:# Path to the Tower config file.}

endsnippet

snippet tower_project "create, update, or destroy Ansible Tower projects" b
tower_project: >
	name=${1:# Name to use for the project.}

	description=${2:# Description to use for the project.}
	scm_type=${3:#manual|git|hg|svn}
	scm_url=${4:# URL of SCM resource.}
	local_path=${5:# The server playbook directory for manual projects.}
	scm_branch=${6:# The branch to use for the SCM resource.}
	scm_credential=${7:# Name of the credential to use with this SCM resource.}
	scm_clean=${8:no}
	scm_delete_on_update=${9:no}
	scm_update_on_launch=${10:no}
	scm_update_cache_timeout=${11:0}
	job_timeout=${12:0}
	custom_virtualenv=${13:# Local absolute file path containing a custom Python virtualenv to use}
	organization=${14:# Primary key of organization for project.}
	state=${15:#present|absent}
	tower_host=${16:# URL to your Tower instance.}
	tower_username=${17:# Username for your Tower instance.}
	tower_password=${18:# Password for your Tower instance.}
	validate_certs=${19:# Whether to allow insecure connections to Tower.}
	tower_config_file=${20:# Path to the Tower config file.}

endsnippet

snippet tower_job_template "create, update, or destroy Ansible Tower job template." b
tower_job_template: >
	name=${1:# Name to use for the job template.}
	job_type=${2:run|check|scan}
	project=${3:# Name of the project to use for the job template.}
	playbook=${4:# Path to the playbook to use for the job template within the project provided.}

	description=${5:# Description to use for the job template.}
	inventory=${6:# Name of the inventory to use for the job template.}
	credential=${7:# Name of the credential to use for the job template.}
	vault_credential=${8:# Name of the vault credential to use for the job template.}
	forks=${9:# The number of parallel or simultaneous processes to use while executing the playbook.}
	limit=${10:# A host pattern to further constrain the list of hosts managed or affected by the playbook}
	verbosity=${11:#0|1|2|3|4}
	extra_vars_path=${12:# Path to the C(extra_vars) YAML file.}
	job_tags=${13:# Comma separated list of the tags to use for the job template.}
	force_handlers_enabled=${14:no}
	skip_tags=${15:# Comma separated list of the tags to skip for the job template.}
	start_at_task=${16:# Start the playbook at the task matching this name.}
	diff_mode_enabled=${17:no}
	fact_caching_enabled=${18:no}
	host_config_key=${19:# Allow provisioning callbacks using this host config key.}
	ask_diff_mode=${20:no}
	ask_extra_vars=${21:no}
	ask_limit=${22:no}
	ask_tags=${23:no}
	ask_skip_tags=${24:no}
	ask_job_type=${25:no}
	ask_verbosity=${26:no}
	ask_inventory=${27:no}
	ask_credential=${28:no}
	survey_enabled=${29:no}
	survey_spec=${30:# JSON/YAML dict formatted survey definition.}
	become_enabled=${31:no}
	concurrent_jobs_enabled=${32:no}
	state=${33:#present|absent}
	tower_host=${34:# URL to your Tower instance.}
	tower_username=${35:# Username for your Tower instance.}
	tower_password=${36:# Password for your Tower instance.}
	validate_certs=${37:# Whether to allow insecure connections to Tower.}
	tower_config_file=${38:# Path to the Tower config file.}

endsnippet

snippet tower_settings "Modify Ansible Tower settings." b
tower_settings: >
	name=${1:# Name of setting to modify}
	value=${2:# Value to be modified for given setting.}

	tower_host=${3:# URL to your Tower instance.}
	tower_username=${4:# Username for your Tower instance.}
	tower_password=${5:# Password for your Tower instance.}
	validate_certs=${6:# Whether to allow insecure connections to Tower.}
	tower_config_file=${7:# Path to the Tower config file.}

endsnippet

snippet tower_job_wait "Wait for Ansible Tower job to finish." b
tower_job_wait: >
	job_id=${1:# ID of the job to monitor.}

	min_interval=${2:1}
	max_interval=${3:30}
	timeout=${4:# Maximum time in seconds to wait for a job to finish.}
	tower_host=${5:# URL to your Tower instance.}
	tower_username=${6:# Username for your Tower instance.}
	tower_password=${7:# Password for your Tower instance.}
	validate_certs=${8:# Whether to allow insecure connections to Tower.}
	tower_config_file=${9:# Path to the Tower config file.}

endsnippet

snippet dellos10_config "Manage Dell EMC Networking OS10 configuration sections" b
dellos10_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	update=${8:#merge|check}
	save=${9:no}
	config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	backup=${11:no}
	backup_options=${12:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet dellos10_facts "Collect facts from remote devices running Dell EMC Networking OS10" b
dellos10_facts: >
	gather_subset=${1:['!config']}
	provider=${2:# A dict object containing connection details.}

endsnippet

snippet dellos10_command "Run commands on remote devices running Dell OS10" b
dellos10_command: >
	commands=${1:# List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
	match=${3:#all|any}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet frr_bgp "Configure global BGP settings on Free Range Routing(FRR)." b
frr_bgp: >
	config=${1:# Specifies the BGP related configuration.}
	operation=${2:#merge|replace|override|delete}

endsnippet

snippet frr_facts "Collect facts from remote devices running Free Range Routing (FRR)." b
frr_facts: >
	gather_subset=${1:!config}

endsnippet

snippet aireos_config "Manage Cisco WLC configurations" b
aireos_config: >
	lines=${1:# The ordered set of commands that should be configured. The commands must be the exact same commands as found in the device run-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	src=${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
	before=${3:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${5:#line|none}
	backup=${6:no}
	running_config=${7:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	save=${8:no}
	save_when=${9:always|#never|changed}
	diff_against=${10:intended|running}
	diff_ignore_lines=${11:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${12:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${13:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet aireos_command "Run commands on remote devices running Cisco WLC" b
aireos_command: >
	commands=${1:# List of commands to send to the remote aireos device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet ftd_file_download "Downloads files from Cisco FTD devices over HTTP(S)" b
ftd_file_download: >
	operation=${1:# The name of the operation to execute.}
	destination=${2:# Absolute path of where to download the file to.}

	path_params=${3:# Key-value pairs that should be sent as path parameters in a REST API call.}

endsnippet

snippet ftd_install "Installs FTD pkg image on the firewall" b
ftd_install: >
	device_hostname=${1:# Hostname of the device as appears in the prompt (e.g., 'firepower-5516').}
	device_password=${2:# Password to login on the device.}
	console_ip=${3:# IP address of a terminal server.}
	console_port=${4:# Device's port on a terminal server.}
	console_username=${5:# Username to login on a terminal server.}
	console_password=${6:# Password to login on a terminal server.}
	rommon_file_location=${7:# Path to the boot (ROMMON) image on TFTP server.}
	image_file_location=${8:# Path to the FTD pkg image on the server to be downloaded.}
	image_version=${9:# Version of FTD image to be installed.}

	device_username=${10:admin}
	device_sudo_password=${11:# Root password for the device. If not specified, `device_password` is used.}
	device_new_password=${12:# New device password to set after image installation.}
	device_ip=${13:# Device IP address of management interface.}
	device_gateway=${14:# Device gateway of management interface.}
	device_netmask=${15:# Device netmask of management interface.}
	device_model=${16:Cisco ASA5506-X Threat Defense|Cisco ASA5508-X Threat Defense|Cisco ASA5516-X Threat Defense|Cisco Firepower 2110 Threat Defense|Cisco Firepower 2120 Threat Defense|Cisco Firepower 2130 Threat Defense|Cisco Firepower 2140 Threat Defense}
	dns_server=${17:# DNS IP address of management interface.}
	force_install=${18:no}
	search_domains=${19:cisco.com}

endsnippet

snippet ftd_file_upload "Uploads files to Cisco FTD devices over HTTP(S)" b
ftd_file_upload: >
	operation=${1:# The name of the operation to execute.}
	file_to_upload=${2:# Absolute path to the file that should be uploaded.}

	register_as=${3:# Specifies Ansible fact name that is used to register received response from the FTD device.}

endsnippet

snippet ftd_configuration "Manages configuration on Cisco FTD devices over REST API" b
ftd_configuration: >
	operation=${1:# The name of the operation to execute. Commonly, the operation starts with 'add', 'edit', 'get', 'upsert' or 'delete' verbs, but can have an arbitrary name too.}

	data=${2:# Key-value pairs that should be sent as body parameters in a REST API call}
	query_params=${3:# Key-value pairs that should be sent as query parameters in a REST API call.}
	path_params=${4:# Key-value pairs that should be sent as path parameters in a REST API call.}
	register_as=${5:# Specifies Ansible fact name that is used to register received response from the FTD device.}
	filters=${6:# Key-value dict that represents equality filters. Every key is a property name and value is its desired value. If multiple filters are present, they are combined with logical operator AND.}

endsnippet

snippet ce_vxlan_gateway "Manages gateway for the VXLAN network on HUAWEI CloudEngine devices." b
ce_vxlan_gateway: >
	dfs_id=${1:# Specifies the ID of a DFS group. The value must be 1.}
	dfs_source_ip=${2:# Specifies the IPv4 address bound to a DFS group. The value is in dotted decimal notation.}
	dfs_source_vpn=${3:# Specifies the name of a VPN instance bound to a DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
	dfs_udp_port=${4:# Specifies the UDP port number of the DFS group. The value is an integer that ranges from 1025 to 65535.}
	dfs_all_active=${5:enable|disable}
	dfs_peer_ip=${6:# Configure the IP address of an all-active gateway peer. The value is in dotted decimal notation.}
	dfs_peer_vpn=${7:# Specifies the name of the VPN instance that is associated with all-active gateway peer. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
	vpn_instance=${8:# Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
	vpn_vni=${9:# Specifies a VNI ID. Binds a VXLAN network identifier (VNI) to a virtual private network (VPN) instance. The value is an integer ranging from 1 to 16000000.}
	vbdif_name=${10:# Full name of VBDIF interface, i.e. Vbdif100.}
	vbdif_bind_vpn=${11:# Specifies the name of the VPN instance that is associated with the interface. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
	vbdif_mac=${12:# Specifies a MAC address for a VBDIF interface. The value is in the format of H-H-H. Each H is a 4-digit hexadecimal number, such as C(00e0) or C(fc01). If an H contains less than four digits, 0s are added ahead. For example,  C(e0) is equal to C(00e0). A MAC address cannot be all 0s or 1s or a multicast MAC address.}
	arp_distribute_gateway=${13:enable|disable}
	arp_direct_route=${14:enable|disable}
	state=${15:#present|absent}

endsnippet

snippet ce_stp "Manages STP configuration on HUAWEI CloudEngine switches." b
ce_stp: >
	state=${1:#present|absent}
	stp_mode=${2:stp|rstp|mstp}
	stp_enable=${3:enable|disable}
	stp_converge=${4:fast|normal}
	bpdu_protection=${5:enable|disable}
	tc_protection=${6:enable|disable}
	tc_protection_interval=${7:# Set the time the MSTP device takes to handle the maximum number of TC BPDUs and immediately refresh forwarding entries. The value is an integer ranging from 1 to 600, in seconds.}
	tc_protection_threshold=${8:# Set the maximum number of TC BPDUs that the MSTP can handle. The value is an integer ranging from 1 to 255. The default value is 1 on the switch.}
	interface=${9:# Interface name. If the value is C(all), will apply configuration to all interfaces. if the value is a special name, only support input the full name.}
	edged_port=${10:enable|disable}
	bpdu_filter=${11:enable|disable}
	cost=${12:# Set the path cost of the current port. The default instance is 0.}
	root_protection=${13:enable|disable}
	loop_protection=${14:enable|disable}

endsnippet

snippet ce_info_center_debug "Manages information center debug configuration on HUAWEI CloudEngine switches." b
ce_info_center_debug: >
	state=${1:#present|absent}
	debug_time_stamp=${2:date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond}
	module_name=${3:# Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].}
	channel_id=${4:# Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.}
	debug_enable=${5:#no_use|true|false}
	debug_level=${6:emergencies|alert|critical|error|warning|notification|informational|debugging}

endsnippet

snippet ce_netconf "Run an arbitrary netconf command on HUAWEI CloudEngine switches." b
ce_netconf: >
	rpc=${1:get|edit-config|execute-action|execute-cli}
	cfg_xml=${2:# The config xml string.}

endsnippet

snippet ce_snmp_location "Manages SNMP location configuration on HUAWEI CloudEngine switches." b
ce_snmp_location: >
	location=${1:# Location information.}

	state=${2:#present|absent}

endsnippet

snippet ce_netstream_export "Manages netstream export on HUAWEI CloudEngine switches." b
ce_netstream_export: >
	type=${1:ip|vxlan}

	source_ip=${2:# Specifies source address which can be IPv6 or IPv4 of the exported NetStream packet.}
	host_ip=${3:# Specifies destination address which can be IPv6 or IPv4 of the exported NetStream packet.}
	host_port=${4:# Specifies the destination UDP port number of the exported packets. The value is an integer that ranges from 1 to 65535.}
	host_vpn=${5:# Specifies the VPN instance of the exported packets carrying flow statistics. Ensure the VPN instance has been created on the device.}
	version=${6:5|9}
	as_option=${7:origin|peer}
	bgp_nexthop=${8:enable|#disable}
	state=${9:#present|absent}

endsnippet

snippet ce_bgp_neighbor "Manages BGP peer configuration on HUAWEI CloudEngine switches." b
ce_bgp_neighbor: >
	vrf_name=${1:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
	peer_addr=${2:# Connection address of a peer, which can be an IPv4 or IPv6 address.}
	remote_as=${3:# AS number of a peer. The value is a string of 1 to 11 characters.}

	state=${4:#present|absent}
	description=${5:# Description of a peer, which can be letters or digits. The value is a string of 1 to 80 characters.}
	fake_as=${6:# Fake AS number that is specified for a local peer. The value is a string of 1 to 11 characters.}
	dual_as=${7:#no_use|true|false}
	conventional=${8:#no_use|true|false}
	route_refresh=${9:#no_use|true|false}
	is_ignore=${10:#no_use|true|false}
	local_if_name=${11:# Name of a source interface that sends BGP packets. The value is a string of 1 to 63 characters.}
	ebgp_max_hop=${12:# Maximum number of hops in an indirect EBGP connection. The value is an ranging from 1 to 255.}
	valid_ttl_hops=${13:# Enable GTSM on a peer or peer group. The valid-TTL-Value parameter is used to specify the number of TTL hops to be detected. The value is an integer ranging from 1 to 255.}
	connect_mode=${14:# The value can be Connect-only, Listen-only, or Both.}
	is_log_change=${15:#no_use|true|false}
	pswd_type=${16:null|cipher|simple}
	pswd_cipher_text=${17:# The character string in a password identifies the contents of the password, spaces not supported. The value is a string of 1 to 255 characters.}
	keep_alive_time=${18:# Specify the Keepalive time of a peer or peer group. The value is an integer ranging from 0 to 21845. The default value is 60.}
	hold_time=${19:# Specify the Hold time of a peer or peer group. The value is 0 or an integer ranging from 3 to 65535.}
	min_hold_time=${20:# Specify the Min hold time of a peer or peer group.}
	key_chain_name=${21:# Specify the Keychain authentication name used when BGP peers establish a TCP connection. The value is a string of 1 to 47 case-insensitive characters.}
	conn_retry_time=${22:# ConnectRetry interval. The value is an integer ranging from 1 to 65535.}
	tcp_MSS=${23:# Maximum TCP MSS value used for TCP connection establishment for a peer. The value is an integer ranging from 176 to 4096.}
	mpls_local_ifnet_disable=${24:#no_use|true|false}
	prepend_global_as=${25:#no_use|true|false}
	prepend_fake_as=${26:#no_use|true|false}
	is_bfd_block=${27:#no_use|true|false}
	multiplier=${28:# Specify the detection multiplier. The default value is 3. The value is an integer ranging from 3 to 50.}
	is_bfd_enable=${29:#no_use|true|false}
	rx_interval=${30:# Specify the minimum interval at which BFD packets are received. The value is an integer ranging from 50 to 1000, in milliseconds.}
	tx_interval=${31:# Specify the minimum interval at which BFD packets are sent. The value is an integer ranging from 50 to 1000, in milliseconds.}
	is_single_hop=${32:#no_use|true|false}

endsnippet

snippet ce_eth_trunk "Manages Eth-Trunk interfaces on HUAWEI CloudEngine switches." b
ce_eth_trunk: >
	trunk_id=${1:# Eth-Trunk interface number. The value is an integer. The value range depends on the assign forward eth-trunk mode command. When 256 is specified, the value ranges from 0 to 255. When 512 is specified, the value ranges from 0 to 511. When 1024 is specified, the value ranges from 0 to 1023.}

	mode=${2:manual|lacp-dynamic|lacp-static}
	min_links=${3:# Specifies the minimum number of Eth-Trunk member links in the Up state. The value is an integer ranging from 1 to the maximum number of interfaces that can be added to a Eth-Trunk interface.}
	hash_type=${4:src-dst-ip|src-dst-mac|enhanced|dst-ip|dst-mac|src-ip|src-mac}
	members=${5:# List of interfaces that will be managed in a given Eth-Trunk. The interface name must be full name.}
	force=${6:no}
	state=${7:#present|absent}

endsnippet

snippet ce_aaa_server_host "Manages AAA server host configuration on HUAWEI CloudEngine switches." b
ce_aaa_server_host: >
	state=${1:#present|absent}
	local_user_name=${2:# Name of a local user. The value is a string of 1 to 253 characters.}
	local_password=${3:# Login password of a user. The password can contain letters, numbers, and special characters. The value is a string of 1 to 255 characters.}
	local_service_type=${4:# The type of local user login through, such as ftp ssh snmp telnet.}
	local_ftp_dir=${5:# FTP user directory. The value is a string of 1 to 255 characters.}
	local_user_level=${6:# Login level of a local user. The value is an integer ranging from 0 to 15.}
	local_user_group=${7:# Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.}
	radius_group_name=${8:# RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.}
	radius_server_type=${9:Authentication|Accounting}
	radius_server_ip=${10:# IPv4 address of configured server. The value is a string of 0 to 255 characters, in dotted decimal notation.}
	radius_server_ipv6=${11:# IPv6 address of configured server. The total length is 128 bits.}
	radius_server_port=${12:# Configured server port for a particular server. The value is an integer ranging from 1 to 65535.}
	radius_server_mode=${13:Secondary-server|Primary-server}
	radius_vpn_name=${14:# Set VPN instance. The value is a string of 1 to 31 case-sensitive characters.}
	radius_server_name=${15:# Hostname of configured server. The value is a string of 0 to 255 case-sensitive characters.}
	hwtacacs_template=${16:# Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.}
	hwtacacs_server_ip=${17:# Server IPv4 address. Must be a valid unicast IP address. The value is a string of 0 to 255 characters, in dotted decimal notation.}
	hwtacacs_server_ipv6=${18:# Server IPv6 address. Must be a valid unicast IP address. The total length is 128 bits.}
	hwtacacs_server_type=${19:Authentication|Authorization|Accounting|Common}
	hwtacacs_is_secondary_server=${20:no}
	hwtacacs_vpn_name=${21:# VPN instance name.}
	hwtacacs_is_public_net=${22:no}
	hwtacacs_server_host_name=${23:# Hwtacacs server host name.}

endsnippet

snippet ce_static_route "Manages static route configuration on HUAWEI CloudEngine switches." b
ce_static_route: >
	prefix=${1:# Destination ip address of static route.}
	mask=${2:# Destination ip mask of static route.}
	aftype=${3:v4|v6}

	next_hop=${4:# Next hop address of static route.}
	nhp_interface=${5:# Next hop interface full name of static route.}
	vrf=${6:# VPN instance of destination ip address.}
	destvrf=${7:# VPN instance of next hop ip address.}
	tag=${8:# Route tag value (numeric).}
	description=${9:# Name of the route. Used with the name parameter on the CLI.}
	pref=${10:# Preference or administrative difference of route (range 1-255).}
	state=${11:#present|absent}

endsnippet

snippet ce_ospf "Manages configuration of an OSPF instance on HUAWEI CloudEngine switches." b
ce_ospf: >
	process_id=${1:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}

	area=${2:# Specifies the area ID. The area with the area-id being 0 is a backbone area. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.}
	addr=${3:# Specifies the address of the network segment where the interface resides. The value is in dotted decimal notation.}
	mask=${4:# IP network wildcard bits in decimal format between 0 and 32.}
	auth_mode=${5:none|hmac-sha256|md5|hmac-md5|simple}
	auth_text_simple=${6:# Specifies a password for simple authentication. The value is a string of 1 to 8 characters.}
	auth_key_id=${7:# Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.}
	auth_text_md5=${8:# Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.}
	nexthop_addr=${9:# IPv4 address for configure next-hop address's weight. Valid values are a string, formatted as an IP address.}
	nexthop_weight=${10:# Indicates the weight of the next hop. The smaller the value is, the higher the preference of the route is. It is an integer that ranges from 1 to 254.}
	max_load_balance=${11:# The maximum number of paths for forward packets over multiple paths. Valid value is an integer in the range from 1 to 64.}
	state=${12:#present|absent}

endsnippet

snippet ce_aaa_server "Manages AAA server global configuration on HUAWEI CloudEngine switches." b
ce_aaa_server: >
	state=${1:absent|#present}
	authen_scheme_name=${2:# Name of an authentication scheme. The value is a string of 1 to 32 characters.}
	first_authen_mode=${3:invalid|#local|hwtacacs|radius|none}
	author_scheme_name=${4:# Name of an authorization scheme. The value is a string of 1 to 32 characters.}
	first_author_mode=${5:invalid|#local|hwtacacs|if-authenticated|none}
	acct_scheme_name=${6:# Accounting scheme name. The value is a string of 1 to 32 characters.}
	accounting_mode=${7:invalid|hwtacacs|radius|#none}
	domain_name=${8:# Name of a domain. The value is a string of 1 to 64 characters.}
	radius_server_group=${9:# RADIUS server group's name. The value is a string of 1 to 32 case-insensitive characters.}
	hwtacas_template=${10:# Name of a HWTACACS template. The value is a string of 1 to 32 case-insensitive characters.}
	local_user_group=${11:# Name of the user group where the user belongs. The user inherits all the rights of the user group. The value is a string of 1 to 32 characters.}

endsnippet

snippet ce_reboot "Reboot a HUAWEI CloudEngine switches." b
ce_reboot: >
	confirm=${1:# Safeguard boolean. Set to true if you're sure you want to reboot.}

	save_config=${2:no}

endsnippet

snippet ce_vxlan_tunnel "Manages VXLAN tunnel configuration on HUAWEI CloudEngine devices." b
ce_vxlan_tunnel: >
	bridge_domain_id=${1:# Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.}
	vni_id=${2:# Specifies a VXLAN network identifier (VNI) ID. The value is an integer ranging from 1 to 16000000.}
	nve_name=${3:# Specifies the number of an NVE interface. The value ranges from 1 to 2.}
	nve_mode=${4:mode-l2|mode-l3}
	peer_list_ip=${5:# Specifies the IP address of a remote VXLAN tunnel endpoints (VTEP). The value is in dotted decimal notation.}
	protocol_type=${6:bgp|null}
	source_ip=${7:# Specifies an IP address for a source VTEP. The value is in dotted decimal notation.}
	state=${8:#present|absent}

endsnippet

snippet ce_netstream_template "Manages NetStream template configuration on HUAWEI CloudEngine switches." b
ce_netstream_template: >
	type=${1:ip|vxlan}

	state=${2:#present|absent}
	record_name=${3:# Configure the name of netstream record. The value is a string of 1 to 32 case-insensitive characters.}
	match=${4:destination-address|destination-port|tos|protocol|source-address|source-port}
	collect_counter=${5:bytes|packets}
	collect_interface=${6:input|output}
	description=${7:# Configure the description of netstream record. The value is a string of 1 to 80 case-insensitive characters.}

endsnippet

snippet ce_evpn_bgp_rr "Manages RR for the VXLAN Network on HUAWEI CloudEngine switches." b
ce_evpn_bgp_rr: >
	as_number=${1:# Specifies the number of the AS, in integer format. The value is an integer that ranges from 1 to 4294967295.}

	bgp_instance=${2:# Specifies the name of a BGP instance. The value of instance-name can be an integer 1 or a string of 1 to 31.}
	bgp_evpn_enable=${3:#enable|disable}
	peer_type=${4:group_name|ipv4_address}
	peer=${5:# Specifies the IPv4 address or the group name of a peer.}
	reflect_client=${6:enable|disable}
	policy_vpn_target=${7:enable|disable}

endsnippet

snippet ce_link_status "Get interface link status on HUAWEI CloudEngine switches." b
ce_link_status: >
	interface=${1:# For the interface parameter, you can enter C(all) to display information about all interfaces, an interface type such as C(40GE) to display information about interfaces of the specified type, or full name of an interface such as C(40GE1/0/22) or C(vlanif10) to display information about the specific interface.}

endsnippet

snippet ce_info_center_log "Manages information center log configuration on HUAWEI CloudEngine switches." b
ce_info_center_log: >
	log_time_stamp=${1:date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond}
	log_buff_enable=${2:#no_use|true|false}
	log_buff_size=${3:# Specifies the maximum number of logs in the log buffer. The value is an integer that ranges from 0 to 10240. If logbuffer-size is 0, logs are not displayed.}
	module_name=${4:# Specifies the name of a module. The value is a module name in registration logs.}
	channel_id=${5:# Specifies a channel ID. The value is an integer ranging from 0 to 9.}
	log_enable=${6:#no_use|true|false}
	log_level=${7:emergencies|alert|critical|error|warning|notification|informational|debugging}
	state=${8:#present|absent}

endsnippet

snippet ce_snmp_traps "Manages SNMP traps configuration on HUAWEI CloudEngine switches." b
ce_snmp_traps: >
	feature_name=${1:aaa|arp|bfd|bgp|cfg|configuration|dad|devm|dhcpsnp|dldp|driver|efm|erps|error-down|fcoe|fei|fei_comm|fm|ifnet|info|ipsg|ipv6|isis|l3vpn|lacp|lcs|ldm|ldp|ldt|lldp|mpls_lspm|msdp|mstp|nd|netconf|nqa|nvo3|openflow|ospf|ospfv3|pim|pim-std|qos|radius|rm|rmon|securitytrap|smlktrap|snmp|ssh|stackmng|sysclock|sysom|system|tcp|telnet|trill|trunk|tty|vbst|vfs|virtual-perception|vrrp|vstm|all}
	trap_name=${2:# Alarm trap name.}
	interface_type=${3:Ethernet|Eth-Trunk|Tunnel|NULL|LoopBack|Vlanif|100GE|40GE|MTunnel|10GE|GE|MEth|Vbdif|Nve}
	interface_number=${4:# Interface number.}
	port_number=${5:# Source port number.}

endsnippet

snippet ce_snmp_community "Manages SNMP community configuration on HUAWEI CloudEngine switches." b
ce_snmp_community: >
	acl_number=${1:# Access control list number.}
	community_name=${2:# Unique name to identify the community.}
	access_right=${3:read|write}
	community_mib_view=${4:# Mib view name.}
	group_name=${5:# Unique name to identify the SNMPv3 group.}
	security_level=${6:noAuthNoPriv|authentication|privacy}
	read_view=${7:# Mib view name for read.}
	write_view=${8:# Mib view name for write.}
	notify_view=${9:# Mib view name for notification.}
	state=${10:#present|absent}

endsnippet

snippet ce_netstream_global "Manages global parameters of NetStream on HUAWEI CloudEngine switches." b
ce_netstream_global: >
	interface=${1:# Netstream global interface.}

	type=${2:#ip|vxlan}
	state=${3:#present|absent}
	sampler_interval=${4:# Specifies the netstream sampler interval, length is 1 - 65535.}
	sampler_direction=${5:inbound|outbound}
	statistics_direction=${6:inbound|outbound}
	statistics_record=${7:# Specifies the flexible netstream statistic record, length is 1 - 32.}
	index_switch=${8:#16|32}

endsnippet

snippet ce_vrrp "Manages VRRP interfaces on HUAWEI CloudEngine devices." b
ce_vrrp: >
	interface=${1:# Name of an interface. The value is a string of 1 to 63 characters.}
	vrid=${2:present}
	virtual_ip=${3:# Virtual IP address. The value is a string of 0 to 255 characters.}
	vrrp_type=${4:normal|member|admin}
	admin_ignore_if_down=${5:false}
	admin_vrid=${6:# Tracked mVRRP ID. The value is an integer ranging from 1 to 255.}
	admin_interface=${7:# Tracked mVRRP interface name. The value is a string of 1 to 63 characters.}
	admin_flowdown=${8:false}
	priority=${9:# Configured VRRP priority. The value ranges from 1 to 254. The default value is 100. A larger value indicates a higher priority.}
	version=${10:v2|v3}
	advertise_interval=${11:# Configured interval between sending advertisements, in milliseconds. Only the master router sends VRRP advertisements. The default value is 1000 milliseconds.}
	preempt_timer_delay=${12:# Preemption delay. The value is an integer ranging from 0 to 3600. The default value is 0.}
	gratuitous_arp_interval=${13:# Interval at which gratuitous ARP packets are sent, in seconds. The value ranges from 30 to 1200.The default value is 300.}
	recover_delay=${14:# Delay in recovering after an interface goes Up. The delay is used for interface flapping suppression. The value is an integer ranging from 0 to 3600. The default value is 0 seconds.}
	holding_multiplier=${15:# The configured holdMultiplier.The value is an integer ranging from 3 to 10. The default value is 3.}
	auth_mode=${16:simple|md5|none}
	is_plain=${17:false}
	auth_key=${18:# This object is set based on the authentication type. When noAuthentication is specified, the value is empty. When simpleTextPassword or md5Authentication is specified, the value is a string of 1 to 8 characters in plaintext and displayed as a blank text for security.}
	fast_resume=${19:enable|disable}
	state=${20:#present|absent}

endsnippet

snippet ce_command "Run arbitrary command on HUAWEI CloudEngine devices." b
ce_command: >
	commands=${1:# The commands to send to the remote HUAWEI CloudEngine device over the configured provider.  The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}

	wait_for=${2:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
	match=${3:all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet ce_snmp_user "Manages SNMP user configuration on HUAWEI CloudEngine switches." b
ce_snmp_user: >
	acl_number=${1:# Access control list number.}
	usm_user_name=${2:# Unique name to identify the USM user.}
	aaa_local_user=${3:# Unique name to identify the local user.}
	remote_engine_id=${4:# Remote engine id of the USM user.}
	user_group=${5:# Name of the group where user belongs to.}
	auth_protocol=${6:noAuth|md5|sha}
	auth_key=${7:# The authentication password. Password length, 8-255 characters.}
	priv_protocol=${8:noPriv|des56|3des168|aes128|aes192|aes256}
	priv_key=${9:# The encryption password. Password length 8-255 characters.}

endsnippet

snippet ce_bfd_session "Manages BFD session configuration on HUAWEI CloudEngine devices." b
ce_bfd_session: >
	session_name=${1:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}

	create_type=${2:#static|auto}
	addr_type=${3:ipv4}
	out_if_name=${4:# Specifies the type and number of the interface bound to the BFD session.}
	dest_addr=${5:# Specifies the peer IP address bound to the BFD session.}
	src_addr=${6:# Indicates the source IP address carried in BFD packets.}
	local_discr=${7:# The BFD session local identifier does not need to be configured when the mode is auto.}
	remote_discr=${8:# The BFD session remote identifier does not need to be configured when the mode is auto.}
	vrf_name=${9:# Specifies the name of a Virtual Private Network (VPN) instance that is bound to a BFD session. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value _public_ is reserved and cannot be used as the VPN instance name.}
	use_default_ip=${10:no}
	state=${11:#present|absent}

endsnippet

snippet ce_mlag_interface "Manages MLAG interfaces on HUAWEI CloudEngine switches." b
ce_mlag_interface: >
	eth_trunk_id=${1:# Name of the local M-LAG interface. The value is ranging from 0 to 511.}
	dfs_group_id=${2:present}
	mlag_id=${3:# ID of the M-LAG. The value is an integer that ranges from 1 to 2048.}
	mlag_system_id=${4:# M-LAG global LACP system MAC address. The value is a string of 0 to 255 characters. The default value is the MAC address of the Ethernet port of MPU.}
	mlag_priority_id=${5:# M-LAG global LACP system priority. The value is an integer ranging from 0 to 65535. The default value is 32768.}
	interface=${6:# Name of the interface that enters the Error-Down state when the peer-link fails. The value is a string of 1 to 63 characters.}
	mlag_error_down=${7:enable|disable}
	state=${8:#present|absent}

endsnippet

snippet ce_mtu "Manages MTU settings on HUAWEI CloudEngine switches." b
ce_mtu: >
	interface=${1:# Full name of interface, i.e. 40GE1/0/22.}
	mtu=${2:# MTU for a specific interface. The value is an integer ranging from 46 to 9600, in bytes.}
	jumbo_max=${3:# Maximum frame size. The default value is 9216. The value is an integer and expressed in bytes. The value range is 1536 to 12224 for the CE12800 and 1536 to 12288 for ToR switches.}
	jumbo_min=${4:# Non-jumbo frame size threshold. The default value is 1518. The value is an integer that ranges from 1518 to jumbo_max, in bytes.}
	state=${5:#present|absent}

endsnippet

snippet ce_facts "Gets facts about HUAWEI CloudEngine switches." b
ce_facts: >
	gather_subset=${1:!config}

endsnippet

snippet ce_bfd_view "Manages BFD session view configuration on HUAWEI CloudEngine devices." b
ce_bfd_view: >
	session_name=${1:# Specifies the name of a BFD session. The value is a string of 1 to 15 case-sensitive characters without spaces.}

	local_discr=${2:# Specifies the local discriminator of a BFD session. The value is an integer that ranges from 1 to 16384.}
	remote_discr=${3:# Specifies the remote discriminator of a BFD session. The value is an integer that ranges from 1 to 4294967295.}
	min_tx_interval=${4:# Specifies the minimum interval for receiving BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.}
	min_rx_interval=${5:# Specifies the minimum interval for sending BFD packets. The value is an integer that ranges from 50 to 1000, in milliseconds.}
	detect_multi=${6:# Specifies the local detection multiplier of a BFD session. The value is an integer that ranges from 3 to 50.}
	wtr_interval=${7:# Specifies the WTR time of a BFD session. The value is an integer that ranges from 1 to 60, in minutes. The default value is 0.}
	tos_exp=${8:# Specifies a priority for BFD control packets. The value is an integer ranging from 0 to 7. The default value is 7, which is the highest priority.}
	admin_down=${9:no}
	description=${10:# Specifies the description of a BFD session. The value is a string of 1 to 51 case-sensitive characters with spaces.}
	state=${11:#present|absent}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet ce_evpn_bd_vni "Manages EVPN VXLAN Network Identifier (VNI) on HUAWEI CloudEngine switches." b
ce_evpn_bd_vni: >
	bridge_domain_id=${1:# Specify an existed bridge domain (BD).The value is an integer ranging from 1 to 16777215.}
	vpn_target_import=${2:# Add VPN targets to the import VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.}

	evpn=${3:#enable|disable}
	route_distinguisher=${4:# Configures a route distinguisher (RD) for a BD EVPN instance. The format of an RD can be as follows}
	vpn_target_both=${5:# Add VPN targets to both the import and export VPN target lists of a BD EVPN instance. The format is the same as route_distinguisher.}
	vpn_target_export=${6:# Add VPN targets to the export VPN target list of a BD EVPN instance. The format is the same as route_distinguisher.}
	state=${7:#present|absent}

endsnippet

snippet ce_evpn_bgp "Manages BGP EVPN configuration on HUAWEI CloudEngine switches." b
ce_evpn_bgp: >
	bgp_instance=${1:# Name of a BGP instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.}

	as_number=${2:# Specifies integral AS number. The value is an integer ranging from 1 to 4294967295.}
	peer_address=${3:# Specifies the IPv4 address of a BGP EVPN peer. The value is in dotted decimal notation.}
	peer_group_name=${4:# Specify the name of a peer group that BGP peers need to join. The value is a string of 1 to 47 case-sensitive characters, spaces not supported.}
	peer_enable=${5:true|false}
	advertise_router_type=${6:arp|irb}
	vpn_name=${7:# Associates a specified VPN instance with the IPv4 address family. The value is a string of 1 to 31 case-sensitive characters, spaces not supported.}
	advertise_l2vpn_evpn=${8:enable|disable}
	state=${9:#present|absent}

endsnippet

snippet ce_acl_advance "Manages advanced ACL configuration on HUAWEI CloudEngine switches." b
ce_acl_advance: >
	acl_name=${1:# ACL number or name. For a numbered rule group, the value ranging from 3000 to 3999 indicates a advance ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}

	state=${2:#present|absent|delete_acl}
	acl_num=${3:# ACL number. The value is an integer ranging from 3000 to 3999.}
	acl_step=${4:# ACL step. The value is an integer ranging from 1 to 20. The default value is 5.}
	acl_description=${5:# ACL description. The value is a string of 1 to 127 characters.}
	rule_name=${6:# Name of a basic ACL rule. The value is a string of 1 to 32 characters.}
	rule_id=${7:# ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.}
	rule_action=${8:permit|deny}
	protocol=${9:ip|icmp|igmp|ipinip|tcp|udp|gre|ospf}
	source_ip=${10:# Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.}
	src_mask=${11:# Source IP address mask. The value is an integer ranging from 1 to 32.}
	src_pool_name=${12:# Name of a source pool. The value is a string of 1 to 32 characters.}
	dest_ip=${13:# Destination IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.}
	dest_mask=${14:# Destination IP address mask. The value is an integer ranging from 1 to 32.}
	dest_pool_name=${15:# Name of a destination pool. The value is a string of 1 to 32 characters.}
	src_port_op=${16:lt|eq|gt|range}
	src_port_begin=${17:# Start port number of the source port. The value is an integer ranging from 0 to 65535.}
	src_port_end=${18:# End port number of the source port. The value is an integer ranging from 0 to 65535.}
	src_port_pool_name=${19:# Name of a source port pool. The value is a string of 1 to 32 characters.}
	dest_port_op=${20:lt|eq|gt|range}
	dest_port_begin=${21:# Start port number of the destination port. The value is an integer ranging from 0 to 65535.}
	dest_port_end=${22:# End port number of the destination port. The value is an integer ranging from 0 to 65535.}
	dest_port_pool_name=${23:# Name of a destination port pool. The value is a string of 1 to 32 characters.}
	frag_type=${24:fragment|clear_fragment}
	precedence=${25:# Data packets can be filtered based on the priority field. The value is an integer ranging from 0 to 7.}
	tos=${26:# ToS value on which data packet filtering is based. The value is an integer ranging from 0 to 15.}
	dscp=${27:# Differentiated Services Code Point. The value is an integer ranging from 0 to 63.}
	icmp_name=${28:unconfiged|echo|echo-reply|fragmentneed-DFset|host-redirect|host-tos-redirect|host-unreachable|information-reply|information-request|net-redirect|net-tos-redirect|net-unreachable|parameter-problem|port-unreachable|protocol-unreachable|reassembly-timeout|source-quench|source-route-failed|timestamp-reply|timestamp-request|ttl-exceeded|address-mask-reply|address-mask-request|custom}
	icmp_type=${29:# ICMP type. This parameter is available only when the packet protocol is ICMP. The value is an integer ranging from 0 to 255.}
	icmp_code=${30:# ICMP message code. Data packets can be filtered based on the ICMP message code. The value is an integer ranging from 0 to 255.}
	ttl_expired=${31:no}
	vrf_name=${32:# VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.}
	syn_flag=${33:# TCP flag value. The value is an integer ranging from 0 to 63.}
	tcp_flag_mask=${34:# TCP flag mask value. The value is an integer ranging from 0 to 63.}
	established=${35:no}
	time_range=${36:# Name of a time range in which an ACL rule takes effect.}
	rule_description=${37:# Description about an ACL rule.}
	igmp_type=${38:host-query|mrouter-adver|mrouter-solic|mrouter-termi|mtrace-resp|mtrace-route|v1host-report|v2host-report|v2leave-group|v3host-report}
	log_flag=${39:no}

endsnippet

snippet ce_vxlan_global "Manages global attributes of VXLAN and bridge domain on HUAWEI CloudEngine devices." b
ce_vxlan_global: >
	bridge_domain_id=${1:# Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.}
	tunnel_mode_vxlan=${2:enable|disable}
	nvo3_prevent_loops=${3:enable|disable}
	nvo3_acl_extend=${4:enable|disable}
	nvo3_gw_enhanced=${5:l2|l3}
	nvo3_service_extend=${6:enable|disable}
	nvo3_eth_trunk_hash=${7:enable|disable}
	nvo3_ecmp_hash=${8:enable|disable}
	state=${9:#present|absent}

endsnippet

snippet ce_startup "Manages a system startup information on HUAWEI CloudEngine switches." b
ce_startup: >
	cfg_file=${1:present}
	software_file=${2:# File name of the system software that is applied for the next startup. The value is a string of 5 to 255 characters.}
	patch_file=${3:# Name of the patch file that is applied for the next startup.}
	slot=${4:# Position of the device.The value is a string of 1 to 32 characters. The possible value of slot is all, slave-board, or the specific slotID.}
	action=${5:display}

endsnippet

snippet ce_netstream_aging "Manages timeout mode of NetStream on HUAWEI CloudEngine switches." b
ce_netstream_aging: >
	timeout_interval=${1:30}
	type=${2:ip|vxlan}
	state=${3:#present|absent}
	timeout_type=${4:active|inactive|tcp-session|manual}
	manual_slot=${5:# Specifies the slot number of netstream manual timeout.}

endsnippet

snippet ce_vrf_interface "Manages interface specific VPN configuration on HUAWEI CloudEngine switches." b
ce_vrf_interface: >
	vrf=${1:# VPN instance, the length of vrf name is 1 ~ 31, i.e. "test", but can not be C(_public_).}
	vpn_interface=${2:# An interface that can binding VPN instance, i.e. 40GE1/0/22, Vlanif10. Must be fully qualified interface name. Interface types, such as 10GE, 40GE, 100GE, LoopBack, MEth, Tunnel, Vlanif....}

	state=${3:#present|absent}

endsnippet

snippet ce_acl "Manages base ACL configuration on HUAWEI CloudEngine switches." b
ce_acl: >
	acl_name=${1:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 2999 indicates a basic ACL. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}

	state=${2:#present|absent|delete_acl}
	acl_num=${3:# ACL number. The value is an integer ranging from 2000 to 2999.}
	acl_step=${4:# ACL step. The value is an integer ranging from 1 to 20. The default value is 5.}
	acl_description=${5:# ACL description. The value is a string of 1 to 127 characters.}
	rule_name=${6:# Name of a basic ACL rule. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces or begin with an underscore (_).}
	rule_id=${7:# ID of a basic ACL rule in configuration mode. The value is an integer ranging from 0 to 4294967294.}
	rule_action=${8:permit|deny}
	source_ip=${9:# Source IP address. The value is a string of 0 to 255 characters.The default value is 0.0.0.0. The value is in dotted decimal notation.}
	src_mask=${10:# Mask of a source IP address. The value is an integer ranging from 1 to 32.}
	frag_type=${11:fragment|clear_fragment}
	vrf_name=${12:# VPN instance name. The value is a string of 1 to 31 characters.The default value is _public_.}
	time_range=${13:# Name of a time range in which an ACL rule takes effect. The value is a string of 1 to 32 characters. The value is case-insensitive, and cannot contain spaces. The name must start with an uppercase or lowercase letter. In addition, the word "all" cannot be specified as a time range name.}
	rule_description=${14:# Description about an ACL rule. The value is a string of 1 to 127 characters.}
	log_flag=${15:no}

endsnippet

snippet ce_dldp_interface "Manages interface DLDP configuration on HUAWEI CloudEngine switches." b
ce_dldp_interface: >
	interface=${1:# Must be fully qualified interface name, i.e. GE1/0/1, 10GE1/0/1, 40GE1/0/22, 100GE1/0/1.}

	enable=${2:enable|disable}
	mode_enable=${3:enable|disable}
	local_mac=${4:# Set the source MAC address for DLDP packets sent in the DLDP-compatible mode. The value of MAC address is in H-H-H format. H contains 1 to 4 hexadecimal digits.}
	reset=${5:enable|disable}
	state=${6:#present|absent}

endsnippet

snippet ce_vxlan_vap "Manages VXLAN virtual access point on HUAWEI CloudEngine Devices." b
ce_vxlan_vap: >
	bridge_domain_id=${1:# Specifies a bridge domain ID. The value is an integer ranging from 1 to 16777215.}
	bind_vlan_id=${2:# Specifies the VLAN binding to a BD(Bridge Domain). The value is an integer ranging ranging from 1 to 4094.}
	l2_sub_interface=${3:# Specifies an Sub-Interface full name, i.e. "10GE1/0/41.1". The value is a string of 1 to 63 case-insensitive characters, spaces supported.}
	encapsulation=${4:dot1q|default|untag|qinq|none}
	ce_vid=${5:# When I(encapsulation) is 'dot1q', specifies a VLAN ID in the outer VLAN tag. When I(encapsulation) is 'qinq', specifies an outer VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.}
	pe_vid=${6:# When I(encapsulation) is 'qinq', specifies an inner VLAN ID for double-tagged packets to be received by a Layer 2 sub-interface. The value is an integer ranging from 1 to 4094.}
	state=${7:#present|absent}

endsnippet

snippet ce_vxlan_arp "Manages ARP attributes of VXLAN on HUAWEI CloudEngine devices." b
ce_vxlan_arp: >
	evn_bgp=${1:enable|disable}
	evn_source_ip=${2:# Specifies the source address of an EVN BGP peer. The value is in dotted decimal notation.}
	evn_peer_ip=${3:# Specifies the IP address of an EVN BGP peer. The value is in dotted decimal notation.}
	evn_server=${4:enable|disable}
	evn_reflect_client=${5:enable|disable}
	vbdif_name=${6:# Full name of VBDIF interface, i.e. Vbdif100.}
	arp_collect_host=${7:enable|disable}
	host_collect_protocol=${8:bgp|none}
	bridge_domain_id=${9:# Specifies a BD(bridge domain) ID. The value is an integer ranging from 1 to 16777215.}
	arp_suppress=${10:enable|disable}
	state=${11:#present|absent}

endsnippet

snippet ce_interface "Manages physical attributes of interfaces on HUAWEI CloudEngine switches." b
ce_interface: >
	interface=${1:# Full name of interface, i.e. 40GE1/0/10, Tunnel1.}
	interface_type=${2:ge|10ge|25ge|4x10ge|40ge|100ge|vlanif|loopback|meth|eth-trunk|nve|tunnel|ethernet|fcoe-port|fabric-port|stack-port|null}
	admin_state=${3:up|down}
	description=${4:# Specifies an interface description. The value is a string of 1 to 242 case-sensitive characters, spaces supported but question marks (?) not supported.}
	mode=${5:layer2|layer3}
	l2sub=${6:no}
	state=${7:#present|absent|default}

endsnippet

snippet ce_rollback "Set a checkpoint or rollback to a checkpoint on HUAWEI CloudEngine switches." b
ce_rollback: >
	action=${1:rollback|clear|set|display|commit}

	commit_id=${2:# Specifies the label of the configuration rollback point to which system configurations are expected to roll back. The value is an integer that the system generates automatically.}
	label=${3:# Specifies a user label for a configuration rollback point. The value is a string of 1 to 256 case-sensitive ASCII characters, spaces not supported. The value must start with a letter and cannot be presented in a single hyphen (-).}
	filename=${4:# Specifies a configuration file for configuration rollback. The value is a string of 5 to 64 case-sensitive characters in the format of *.zip, *.cfg, or *.dat, spaces not supported.}
	last=${5:# Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.}
	oldest=${6:# Specifies the number of configuration rollback points. The value is an integer that ranges from 1 to 80.}

endsnippet

snippet ce_snmp_contact "Manages SNMP contact configuration on HUAWEI CloudEngine switches." b
ce_snmp_contact: >
	contact=${1:# Contact information.}

	state=${2:#present|absent}

endsnippet

snippet ce_ntp "Manages core NTP configuration on HUAWEI CloudEngine switches." b
ce_ntp: >
	server=${1:# Network address of NTP server.}
	peer=${2:# Network address of NTP peer.}
	key_id=${3:# Authentication key identifier to use with given NTP server or peer.}
	is_preferred=${4:enable|disable}
	vpn_name=${5:_public_}
	source_int=${6:# Local source interface from which NTP messages are sent. Must be fully qualified interface name, i.e. C(40GE1/0/22), C(vlanif10). Interface types, such as C(10GE), C(40GE), C(100GE), C(Eth-Trunk), C(LoopBack), C(MEth), C(NULL), C(Tunnel), C(Vlanif).}
	state=${7:#present|absent}

endsnippet

snippet ce_ip_interface "Manages L3 attributes for IPv4 and IPv6 interfaces on HUAWEI CloudEngine switches." b
ce_ip_interface: >
	interface=${1:# Full name of interface, i.e. 40GE1/0/22, vlanif10.}

	addr=${2:# IPv4 or IPv6 Address.}
	mask=${3:# Subnet mask for IPv4 or IPv6 Address in decimal format.}
	version=${4:#v4|v6}
	ipv4_type=${5:#main|sub}
	state=${6:#present|absent}

endsnippet

snippet ce_bgp_af "Manages BGP Address-family configuration on HUAWEI CloudEngine switches." b
ce_bgp_af: >
	vrf_name=${1:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created. The value is a string of 1 to 31 case-sensitive characters.}
	af_type=${2:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}

	state=${3:#present|absent}
	max_load_ibgp_num=${4:# Specify the maximum number of equal-cost IBGP routes. The value is an integer ranging from 1 to 65535.}
	ibgp_ecmp_nexthop_changed=${5:#no_use|true|false}
	max_load_ebgp_num=${6:# Specify the maximum number of equal-cost EBGP routes. The value is an integer ranging from 1 to 65535.}
	ebgp_ecmp_nexthop_changed=${7:#no_use|true|false}
	maximum_load_balance=${8:# Specify the maximum number of equal-cost routes in the BGP routing table. The value is an integer ranging from 1 to 65535.}
	ecmp_nexthop_changed=${9:#no_use|true|false}
	default_local_pref=${10:# Set the Local-Preference attribute. The value is an integer. The value is an integer ranging from 0 to 4294967295.}
	default_med=${11:# Specify the Multi-Exit-Discriminator (MED) of BGP routes. The value is an integer ranging from 0 to 4294967295.}
	default_rt_import_enable=${12:#no_use|true|false}
	router_id=${13:# ID of a router that is in IPv4 address format. The value is a string of 0 to 255 characters. The value is in dotted decimal notation.}
	vrf_rid_auto_sel=${14:#no_use|true|false}
	nexthop_third_party=${15:#no_use|true|false}
	summary_automatic=${16:#no_use|true|false}
	auto_frr_enable=${17:#no_use|true|false}
	load_balancing_as_path_ignore=${18:#no_use|true|false}
	rib_only_enable=${19:#no_use|true|false}
	rib_only_policy_name=${20:# Specify the name of a routing policy. The value is a string of 1 to 40 characters.}
	active_route_advertise=${21:#no_use|true|false}
	as_path_neglect=${22:#no_use|true|false}
	med_none_as_maximum=${23:#no_use|true|false}
	router_id_neglect=${24:#no_use|true|false}
	igp_metric_ignore=${25:#no_use|true|false}
	always_compare_med=${26:#no_use|true|false}
	determin_med=${27:#no_use|true|false}
	preference_external=${28:# Set the protocol priority of EBGP routes. The value is an integer ranging from 1 to 255.}
	preference_internal=${29:# Set the protocol priority of IBGP routes. The value is an integer ranging from 1 to 255.}
	preference_local=${30:# Set the protocol priority of a local BGP route. The value is an integer ranging from 1 to 255.}
	prefrence_policy_name=${31:# Set a routing policy to filter routes so that a configured priority is applied to the routes that match the specified policy. The value is a string of 1 to 40 characters.}
	reflect_between_client=${32:#no_use|true|false}
	reflector_cluster_id=${33:# Set a cluster ID. Configuring multiple RRs in a cluster can enhance the stability of the network. The value is an integer ranging from 1 to 4294967295.}
	reflector_cluster_ipv4=${34:# Set a cluster ipv4 address. The value is expressed in the format of an IPv4 address.}
	rr_filter_number=${35:# Set the number of the extended community filter supported by an RR group. The value is a string of 1 to 51 characters.}
	policy_vpn_target=${36:#no_use|true|false}
	next_hop_sel_depend_type=${37:#default|dependTunnel|dependIp}
	nhp_relay_route_policy_name=${38:# Specify the name of a route-policy for route iteration. The value is a string of 1 to 40 characters.}
	ebgp_if_sensitive=${39:#no_use|true|false}
	reflect_chg_path=${40:#no_use|true|false}
	add_path_sel_num=${41:# Number of Add-Path routes. The value is an integer ranging from 2 to 64.}
	route_sel_delay=${42:# Route selection delay. The value is an integer ranging from 0 to 3600.}
	allow_invalid_as=${43:#no_use|true|false}
	policy_ext_comm_enable=${44:#no_use|true|false}
	supernet_uni_adv=${45:#no_use|true|false}
	supernet_label_adv=${46:#no_use|true|false}
	ingress_lsp_policy_name=${47:# Ingress lsp policy name.}
	originator_prior=${48:#no_use|true|false}
	lowest_priority=${49:#no_use|true|false}
	relay_delay_enable=${50:#no_use|true|false}
	import_protocol=${51:direct|ospf|isis|static|rip|ospfv3|ripng}
	import_process_id=${52:# Process ID of an imported routing protocol. The value is an integer ranging from 0 to 4294967295.}
	network_address=${53:# Specify the IP address advertised by BGP. The value is a string of 0 to 255 characters.}
	mask_len=${54:# Specify the mask length of an IP address. The value is an integer ranging from 0 to 128.}

endsnippet

snippet ce_bgp_neighbor_af "Manages BGP neighbor Address-family configuration on HUAWEI CloudEngine switches." b
ce_bgp_neighbor_af: >
	vrf_name=${1:# Name of a BGP instance. The name is a case-sensitive string of characters. The BGP instance can be used only after the corresponding VPN instance is created.}
	af_type=${2:ipv4uni|ipv4multi|ipv4vpn|ipv6uni|ipv6vpn|evpn}
	remote_address=${3:# IPv4 or IPv6 peer connection address.}

	advertise_irb=${4:#no_use|true|false}
	advertise_arp=${5:#no_use|true|false}
	advertise_remote_nexthop=${6:#no_use|true|false}
	advertise_community=${7:#no_use|true|false}
	advertise_ext_community=${8:#no_use|true|false}
	discard_ext_community=${9:#no_use|true|false}
	allow_as_loop_enable=${10:#no_use|true|false}
	allow_as_loop_limit=${11:# Set the maximum number of repetitive local AS number. The value is an integer ranging from 1 to 10.}
	keep_all_routes=${12:#no_use|true|false}
	nexthop_configure=${13:null|local|invariable}
	preferred_value=${14:# Assign a preferred value for the routes learned from a specified peer. The value is an integer ranging from 0 to 65535.}
	public_as_only=${15:#no_use|true|false}
	public_as_only_force=${16:#no_use|true|false}
	public_as_only_limited=${17:#no_use|true|false}
	public_as_only_replace=${18:#no_use|true|false}
	public_as_only_skip_peer_as=${19:#no_use|true|false}
	route_limit=${20:# Configure the maximum number of routes that can be accepted from a peer. The value is an integer ranging from 1 to 4294967295.}
	route_limit_percent=${21:# Specify the percentage of routes when a router starts to generate an alarm. The value is an integer ranging from 1 to 100.}
	route_limit_type=${22:noparameter|alertOnly|idleForever|idleTimeout}
	route_limit_idle_timeout=${23:# Specify the value of the idle-timeout timer to automatically reestablish the connections after they are cut off when the number of routes exceeds the set threshold. The value is an integer ranging from 1 to 1200.}
	rt_updt_interval=${24:# Specify the minimum interval at which Update packets are sent. The value is an integer, in seconds. The value is an integer ranging from 0 to 600.}
	redirect_ip=${25:#no_use|true|false}
	redirect_ip_vaildation=${26:#no_use|true|false}
	reflect_client=${27:#no_use|true|false}
	substitute_as_enable=${28:#no_use|true|false}
	import_rt_policy_name=${29:# Specify the filtering policy applied to the routes learned from a peer. The value is a string of 1 to 40 characters.}
	export_rt_policy_name=${30:# Specify the filtering policy applied to the routes to be advertised to a peer. The value is a string of 1 to 40 characters.}
	import_pref_filt_name=${31:# Specify the IPv4 filtering policy applied to the routes received from a specified peer. The value is a string of 1 to 169 characters.}
	export_pref_filt_name=${32:# Specify the IPv4 filtering policy applied to the routes to be advertised to a specified peer. The value is a string of 1 to 169 characters.}
	import_as_path_filter=${33:# Apply an AS_Path-based filtering policy to the routes received from a specified peer. The value is an integer ranging from 1 to 256.}
	export_as_path_filter=${34:# Apply an AS_Path-based filtering policy to the routes to be advertised to a specified peer. The value is an integer ranging from 1 to 256.}
	import_as_path_name_or_num=${35:# A routing strategy based on the AS path list for routing received by a designated peer.}
	export_as_path_name_or_num=${36:# Application of a AS path list based filtering policy to the routing of a specified peer.}
	import_acl_name_or_num=${37:# Apply an IPv4 ACL-based filtering policy to the routes received from a specified peer. The value is a string of 1 to 32 characters.}
	export_acl_name_or_num=${38:# Apply an IPv4 ACL-based filtering policy to the routes to be advertised to a specified peer. The value is a string of 1 to 32 characters.}
	ipprefix_orf_enable=${39:#no_use|true|false}
	is_nonstd_ipprefix_mod=${40:#no_use|true|false}
	orftype=${41:# ORF Type. The value is an integer ranging from 0 to 65535.}
	orf_mode=${42:null|receive|send|both}
	soostring=${43:# Configure the Site-of-Origin (SoO) extended community attribute. The value is a string of 3 to 21 characters.}
	default_rt_adv_enable=${44:#no_use|true|false}
	default_rt_adv_policy=${45:# Specify the name of a used policy. The value is a string. The value is a string of 1 to 40 characters.}
	default_rt_match_mode=${46:null|matchall|matchany}
	add_path_mode=${47:null|receive|send|both}
	adv_add_path_num=${48:# The number of addPath advertise route. The value is an integer ranging from 2 to 64.}
	origin_as_valid=${49:#no_use|true|false}
	vpls_enable=${50:#no_use|true|false}
	vpls_ad_disable=${51:#no_use|true|false}
	update_pkt_standard_compatible=${52:#no_use|true|false}

endsnippet

snippet ce_switchport "Manages Layer 2 switchport interfaces on HUAWEI CloudEngine switches." b
ce_switchport: >
	interface=${1:# Full name of the interface, i.e. 40GE1/0/22.}

	mode=${2:access|trunk|hybrid|dot1qtunnel}
	default_vlan=${3:# If C(mode=access, or mode=dot1qtunnel), used as the access VLAN ID, in the range from 1 to 4094.}
	pvid_vlan=${4:# If C(mode=trunk, or mode=hybrid), used as the trunk native VLAN ID, in the range from 1 to 4094.}
	trunk_vlans=${5:# If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk, such as 2-10 or 2,5,10-15, etc.}
	untagged_vlans=${6:# If C(mode=hybrid), used as the VLAN range to ADD or REMOVE from the trunk, such as 2-10 or 2,5,10-15, etc.}
	tagged_vlans=${7:# If C(mode=hybrid), used as the VLAN range to ADD or REMOVE from the trunk, such as 2-10 or 2,5,10-15, etc.}
	state=${8:#present|absent|unconfigured}

endsnippet

snippet ce_file_copy "Copy a file to a remote cloudengine device over SCP on HUAWEI CloudEngine switches." b
ce_file_copy: >
	local_file=${1:# Path to local file. Local directory must exist. The maximum length of I(local_file) is C(4096).}

	remote_file=${2:# Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used. The maximum length of I(remote_file) is C(4096).}
	file_system=${3:flash:}

endsnippet

snippet ce_vrf_af "Manages VPN instance address family on HUAWEI CloudEngine switches." b
ce_vrf_af: >
	vrf=${1:# VPN instance.}

	vrf_aftype=${2:#v4|v6}
	route_distinguisher=${3:# VPN instance route distinguisher,the RD used to distinguish same route prefix from different vpn. The RD must be setted before setting vpn_target_value.}
	vpn_target_state=${4:present|absent}
	vpn_target_type=${5:export_extcommunity|import_extcommunity}
	vpn_target_value=${6:# VPN instance target value. Such as X.X.X.X:number<0-65535> or number<0-65535>:number<0-4294967295> or number<0-65535>.number<0-65535>:number<0-65535> or number<65536-4294967295>:number<0-65535> but not support 0:0 and 0.0:0.}
	evpn=${7:no}
	state=${8:#present|absent}

endsnippet

snippet ce_info_center_trap "Manages information center trap configuration on HUAWEI CloudEngine switches." b
ce_info_center_trap: >
	state=${1:#present|absent}
	trap_time_stamp=${2:date_boot|date_second|date_tenthsecond|date_millisecond|shortdate_second|shortdate_tenthsecond|shortdate_millisecond|formatdate_second|formatdate_tenthsecond|formatdate_millisecond}
	trap_buff_enable=${3:#no_use|true|false}
	trap_buff_size=${4:# Size of a trap buffer. The value is an integer ranging from 0 to 1024. The default value is 256.}
	module_name=${5:# Module name of the rule. The value is a string of 1 to 31 case-insensitive characters. The default value is default. Please use lower-case letter, such as [aaa, acl, arp, bfd].}
	channel_id=${6:# Number of a channel. The value is an integer ranging from 0 to 9. The default value is 0.}
	trap_enable=${7:#no_use|true|false}
	trap_level=${8:emergencies|alert|critical|error|warning|notification|informational|debugging}

endsnippet

snippet ce_acl_interface "Manages applying ACLs to interfaces on HUAWEI CloudEngine switches." b
ce_acl_interface: >
	acl_name=${1:# ACL number or name. For a numbered rule group, the value ranging from 2000 to 4999. For a named rule group, the value is a string of 1 to 32 case-sensitive characters starting with a letter, spaces not supported.}
	interface=${2:# Interface name. Only support interface full name, such as "40GE2/0/1".}
	direction=${3:inbound|outbound}

	state=${4:#present|absent}

endsnippet

snippet ce_info_center_global "Manages outputting logs on HUAWEI CloudEngine switches." b
ce_info_center_global: >
	info_center_enable=${1:true|false}
	packet_priority=${2:# Set the priority of the syslog packet.The value is an integer ranging from 0 to 7. The default value is 0.}
	suppress_enable=${3:false|true}
	logfile_max_num=${4:# Maximum number of log files of the same type. The default value is 200.}
	logfile_max_size=${5:4|8|16|32}
	channel_id=${6:# Number for channel. The value is an integer ranging from 0 to 9. The default value is 0.}
	channel_cfg_name=${7:console}
	channel_out_direct=${8:console|monitor|trapbuffer|logbuffer|snmp|logfile}
	filter_feature_name=${9:# Feature name of the filtered log. The value is a string of 1 to 31 case-insensitive characters.}
	filter_log_name=${10:# Name of the filtered log. The value is a string of 1 to 63 case-sensitive characters.}
	ip_type=${11:ipv4|ipv6}
	server_ip=${12:# Log server address, IPv4 or IPv6 type. The value is a string of 0 to 255 characters. The value can be an valid IPv4 or IPv6 address.}
	server_domain=${13:# Server name. The value is a string of 1 to 255 case-sensitive characters.}
	is_default_vpn=${14:no}
	vrf_name=${15:# VPN name on a log server. The value is a string of 1 to 31 case-sensitive characters. The default value is _public_.}
	level=${16:emergencies|alert|critical|error|warning|notification|informational|debugging}
	server_port=${17:# Number of a port sending logs.The value is an integer ranging from 1 to 65535. For UDP, the default value is 514. For TCP, the default value is 601. For TSL, the default value is 6514.}
	facility=${18:local0|local1|local2|local3|local4|local5|local6|local7}
	channel_name=${19:# Channel name. The value is a string of 1 to 30 case-sensitive characters.}
	timestamp=${20:UTC|localtime}
	transport_mode=${21:tcp|udp}
	ssl_policy_name=${22:# SSL policy name. The value is a string of 1 to 23 case-sensitive characters.}
	source_ip=${23:# Log source ip address, IPv4 or IPv6 type. The value is a string of 0 to 255. The value can be an valid IPv4 or IPv6 address.}
	state=${24:#present|absent}

endsnippet

snippet ce_dldp "Manages global DLDP configuration on HUAWEI CloudEngine switches." b
ce_dldp: >
	enable=${1:enable|disable}
	work_mode=${2:enhance|normal}
	time_internal=${3:# Specifies the interval for sending Advertisement packets. The value is an integer ranging from 1 to 100, in seconds. The default interval for sending Advertisement packets is 5 seconds.}
	auth_mode=${4:md5|simple|sha|hmac-sha256|none}
	auth_pwd=${5:# Specifies authentication password. The value is a string of 1 to 16 case-sensitive plaintexts or 24/32/48/108/128 case-sensitive encrypted characters. The string excludes a question mark (?).}
	reset=${6:enable|disable}

endsnippet

snippet ce_bgp "Manages BGP configuration on HUAWEI CloudEngine switches." b
ce_bgp: >
	state=${1:#present|absent}
	as_number=${2:# Local AS number. The value is a string of 1 to 11 characters.}
	graceful_restart=${3:#no_use|true|false}
	time_wait_for_rib=${4:# Period of waiting for the End-Of-RIB flag. The value is an integer ranging from 3 to 3000. The default value is 600.}
	as_path_limit=${5:# Maximum number of AS numbers in the AS_Path attribute. The default value is 255.}
	check_first_as=${6:#no_use|true|false}
	confed_id_number=${7:# Confederation ID. The value is a string of 1 to 11 characters.}
	confed_nonstanded=${8:#no_use|true|false}
	bgp_rid_auto_sel=${9:#no_use|true|false}
	keep_all_routes=${10:#no_use|true|false}
	memory_limit=${11:#no_use|true|false}
	gr_peer_reset=${12:#no_use|true|false}
	is_shutdown=${13:#no_use|true|false}
	suppress_interval=${14:# Suppress interval.}
	hold_interval=${15:# Hold interval.}
	clear_interval=${16:# Clear interval.}
	confed_peer_as_num=${17:# Confederation AS number, in two-byte or four-byte format. The value is a string of 1 to 11 characters.}
	vrf_name=${18:# Name of a BGP instance. The name is a case-sensitive string of characters.}
	vrf_rid_auto_sel=${19:#no_use|true|false}
	router_id=${20:# ID of a router that is in IPv4 address format.}
	keepalive_time=${21:# If the value of a timer changes, the BGP peer relationship between the routers is disconnected. The value is an integer ranging from 0 to 21845. The default value is 60.}
	hold_time=${22:# Hold time, in seconds. The value of the hold time can be 0 or range from 3 to 65535.}
	min_hold_time=${23:# Min hold time, in seconds. The value of the hold time can be 0 or range from 20 to 65535.}
	conn_retry_time=${24:# ConnectRetry interval. The value is an integer, in seconds. The default value is 32s.}
	ebgp_if_sensitive=${25:#no_use|true|false}
	default_af_type=${26:ipv4uni|ipv6uni}

endsnippet

snippet ce_config "Manage Huawei CloudEngine configuration sections." b
ce_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device current-configuration.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	backup=${8:no}
	config=${9:# The module, by default, will connect to the remote device and retrieve the current current-configuration to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current-configuration for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	defaults=${10:no}
	save=${11:no}
	backup_options=${12:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet ce_evpn_global "Manages global configuration of EVPN on HUAWEI CloudEngine switches." b
ce_evpn_global: >
	evpn_overlay_enable=${1:enable|disable}

endsnippet

snippet ce_sflow "Manages sFlow configuration on HUAWEI CloudEngine switches." b
ce_sflow: >
	agent_ip=${1:# Specifies the IPv4/IPv6 address of an sFlow agent.}
	source_ip=${2:# Specifies the source IPv4/IPv6 address of sFlow packets.}
	collector_id=${3:1|2}
	collector_ip=${4:# Specifies the IPv4/IPv6 address of the sFlow collector.}
	collector_ip_vpn=${5:# Specifies the name of a VPN instance. The value is a string of 1 to 31 case-sensitive characters, spaces not supported. When double quotation marks are used around the string, spaces are allowed in the string. The value C(_public_) is reserved and cannot be used as the VPN instance name.}
	collector_datagram_size=${6:# Specifies the maximum length of sFlow packets sent from an sFlow agent to an sFlow collector. The value is an integer, in bytes. It ranges from 1024 to 8100. The default value is 1400.}
	collector_udp_port=${7:# Specifies the UDP destination port number of sFlow packets. The value is an integer that ranges from 1 to 65535. The default value is 6343.}
	collector_meth=${8:meth|enhanced}
	collector_description=${9:# Specifies the description of an sFlow collector. The value is a string of 1 to 255 case-sensitive characters without spaces.}
	sflow_interface=${10:# Full name of interface for Flow Sampling or Counter. It must be a physical interface, Eth-Trunk, or Layer 2 subinterface.}
	sample_collector=${11:# Indicates the ID list of the collector.}
	sample_rate=${12:# Specifies the flow sampling rate in the format 1/rate. The value is an integer and ranges from 1 to 4294967295. The default value is 8192.}
	sample_length=${13:# Specifies the maximum length of sampled packets. The value is an integer and ranges from 18 to 512, in bytes. The default value is 128.}
	sample_direction=${14:inbound|outbound|both}
	counter_collector=${15:# Indicates the ID list of the counter collector.}
	counter_interval=${16:# Indicates the counter sampling interval. The value is an integer that ranges from 10 to 4294967295, in seconds. The default value is 20.}
	export_route=${17:enable|disable}
	rate_limit=${18:# Specifies the rate of sFlow packets sent from a card to the control plane. The value is an integer that ranges from 100 to 1500, in pps.}
	rate_limit_slot=${19:# Specifies the slot where the rate of output sFlow packets is limited. If this parameter is not specified, the rate of sFlow packets sent from all cards to the control plane is limited. The value is an integer or a string of characters.}
	forward_enp_slot=${20:# Enable the Embedded Network Processor (ENP) chip function. The switch uses the ENP chip to perform sFlow sampling, and the maximum sFlow sampling interval is 65535. If you set the sampling interval to be larger than 65535, the switch automatically restores it to 65535. The value is an integer or 'all'.}
	state=${21:#present|absent}

endsnippet

snippet ce_snmp_target_host "Manages SNMP target host configuration on HUAWEI CloudEngine switches." b
ce_snmp_target_host: >
	version=${1:none|v1|v2c|v3|v1v2c|v1v3|v2cv3|all}
	connect_port=${2:# Udp port used by SNMP agent to connect the Network management.}
	host_name=${3:# Unique name to identify target host entry.}
	address=${4:# Network Address.}
	notify_type=${5:trap|inform}
	vpn_name=${6:# VPN instance Name.}
	recv_port=${7:# UDP Port number used by network management to receive alarm messages.}
	security_model=${8:v1|v2c|v3}
	security_name=${9:# Security Name.}
	security_name_v3=${10:# Security Name V3.}
	security_level=${11:noAuthNoPriv|authentication|privacy}
	is_public_net=${12:#no_use|true|false}
	interface_name=${13:# Name of the interface to send the trap message.}

endsnippet

snippet ce_vlan "Manages VLAN resources and attributes on Huawei CloudEngine switches." b
ce_vlan: >
	vlan_id=${1:# Single VLAN ID, in the range from 1 to 4094.}
	vlan_range=${2:# Range of VLANs such as C(2-10) or C(2,5,10-15), etc.}
	name=${3:# Name of VLAN, minimum of 1 character, maximum of 31 characters.}
	description=${4:# Specify VLAN description, minimum of 1 character, maximum of 80 characters.}
	state=${5:#present|absent}

endsnippet

snippet ce_ospf_vrf "Manages configuration of an OSPF VPN instance on HUAWEI CloudEngine switches." b
ce_ospf_vrf: >
	ospf=${1:# The ID of the ospf process. Valid values are an integer, 1 - 4294967295, the default value is 1.}

	route_id=${2:# Specifies the ospf private route id,. Valid values are a string, formatted as an IP address (i.e. "10.1.1.1") the length is 0 - 20.}
	vrf=${3:_public_}
	description=${4:# Specifies the description information of ospf process.}
	bandwidth=${5:# Specifies the reference bandwidth used to assign ospf cost. Valid values are an integer, in Mbps, 1 - 2147483648, the default value is 100.}
	lsaalflag=${6:no}
	lsaainterval=${7:# Specifies the interval of arrive LSA when use the general timer. Valid value is an integer, in millisecond, from 0 to 10000.}
	lsaamaxinterval=${8:# Specifies the max interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 1000.}
	lsaastartinterval=${9:# Specifies the start interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.}
	lsaaholdinterval=${10:# Specifies the hold interval of arrive LSA when use the intelligent timer. Valid value is an integer, in millisecond, from 0 to 10000, the default value is 500.}
	lsaointervalflag=${11:no}
	lsaointerval=${12:# Specifies the interval of originate LSA . Valid value is an integer, in second, from 0 to 10, the default value is 5.}
	lsaomaxinterval=${13:# Specifies the max interval of originate LSA . Valid value is an integer, in millisecond, from 1 to 10000, the default value is 5000.}
	lsaostartinterval=${14:# Specifies the start interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 1000, the default value is 500.}
	lsaoholdinterval=${15:# Specifies the hold interval of originate LSA . Valid value is an integer, in millisecond, from 0 to 5000, the default value is 1000.}
	spfintervaltype=${16:#intelligent-timer|timer|millisecond}
	spfinterval=${17:# Specifies the interval to calculate SPF when use second level  timer. Valid value is an integer, in second, from 1 to 10.}
	spfintervalmi=${18:# Specifies the interval to calculate SPF when use millisecond level  timer. Valid value is an integer, in millisecond, from 1 to 10000.}
	spfmaxinterval=${19:# Specifies the max interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 20000, the default value is 5000.}
	spfstartinterval=${20:# Specifies the start interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 1000, the default value is 50.}
	spfholdinterval=${21:# Specifies the hold interval to calculate SPF when use intelligent timer. Valid value is an integer, in millisecond, from 1 to 5000, the default value is 200.}
	state=${22:#present|absent}

endsnippet

snippet ce_vrf "Manages VPN instance on HUAWEI CloudEngine switches." b
ce_vrf: >
	vrf=${1:# VPN instance, the length of vrf name is 1 - 31, i.e. "test", but can not be C(_public_).}

	description=${2:# Description of the vrf, the string length is 1 - 242 .}
	state=${3:#present|absent}

endsnippet

snippet ce_interface_ospf "Manages configuration of an OSPF interface instanceon HUAWEI CloudEngine switches." b
ce_interface_ospf: >
	interface=${1:# Full name of interface, i.e. 40GE1/0/10.}
	process_id=${2:# Specifies a process ID. The value is an integer ranging from 1 to 4294967295.}
	area=${3:# Ospf area associated with this ospf process. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer between 1 and 4294967295.}

	cost=${4:# The cost associated with this interface. Valid values are an integer in the range from 1 to 65535.}
	hello_interval=${5:# Time between sending successive hello packets. Valid values are an integer in the range from 1 to 65535.}
	dead_interval=${6:# Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer in the range from 1 to 235926000.}
	silent_interface=${7:no}
	auth_mode=${8:none|null|hmac-sha256|md5|hmac-md5|simple}
	auth_text_simple=${9:# Specifies a password for simple authentication. The value is a string of 1 to 8 characters.}
	auth_key_id=${10:# Authentication key id when C(auth_mode) is 'hmac-sha256', 'md5' or 'hmac-md5. Valid value is an integer is in the range from 1 to 255.}
	auth_text_md5=${11:# Specifies a password for MD5, HMAC-MD5, or HMAC-SHA256 authentication. The value is a string of 1 to 255 case-sensitive characters, spaces not supported.}
	state=${12:#present|absent}

endsnippet

snippet ce_ntp_auth "Manages NTP authentication configuration on HUAWEI CloudEngine switches." b
ce_ntp_auth: >
	key_id=${1:# Authentication key identifier (numeric).}

	auth_pwd=${2:# Plain text with length of 1 to 255, encrypted text with length of 20 to 392.}
	auth_mode=${3:hmac-sha256|md5}
	auth_type=${4:text|#encrypt}
	trusted_key=${5:enable|#disable}
	authentication=${6:enable|disable}
	state=${7:#present|absent}

endsnippet

snippet ce_bfd_global "Manages BFD global configuration on HUAWEI CloudEngine devices." b
ce_bfd_global: >
	bfd_enable=${1:enable|disable}
	default_ip=${2:# Specifies the default multicast IP address. The value ranges from 224.0.0.107 to 224.0.0.250.}
	tos_exp_dynamic=${3:# Indicates the priority of BFD control packets for dynamic BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.}
	tos_exp_static=${4:# Indicates the priority of BFD control packets for static BFD sessions. The value is an integer ranging from 0 to 7. The default priority is 7, which is the highest priority of BFD control packets.}
	damp_init_wait_time=${5:# Specifies an initial flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 2000.}
	damp_max_wait_time=${6:# Specifies a maximum flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 15000.}
	damp_second_wait_time=${7:# Specifies a secondary flapping suppression time for a BFD session. The value is an integer ranging from 1 to 3600000, in milliseconds. The default value is 5000.}
	delay_up_time=${8:# Specifies the delay before a BFD session becomes Up. The value is an integer ranging from 1 to 600, in seconds. The default value is 0, indicating that a BFD session immediately becomes Up.}
	state=${9:#present|absent}

endsnippet

snippet ce_mlag_config "Manages MLAG configuration on HUAWEI CloudEngine switches." b
ce_mlag_config: >
	dfs_group_id=${1:present}
	nickname=${2:# The nickname bound to a DFS group. The value is an integer that ranges from 1 to 65471.}
	pseudo_nickname=${3:# A pseudo nickname of a DFS group. The value is an integer that ranges from 1 to 65471.}
	pseudo_priority=${4:# The priority of a pseudo nickname. The value is an integer that ranges from 128 to 255. The default value is 192. A larger value indicates a higher priority.}
	ip_address=${5:# IP address bound to the DFS group. The value is in dotted decimal notation.}
	vpn_instance_name=${6:# Name of the VPN instance bound to the DFS group. The value is a string of 1 to 31 case-sensitive characters without spaces. If the character string is quoted by double quotation marks, the character string can contain spaces. The value _public_ is reserved and cannot be used as the VPN instance name.}
	priority_id=${7:# Priority of a DFS group. The value is an integer that ranges from 1 to 254. The default value is 100.}
	eth_trunk_id=${8:# Name of the peer-link interface. The value is in the range from 0 to 511.}
	peer_link_id=${9:# Number of the peer-link interface. The value is 1.}
	state=${10:#present|absent}

endsnippet

snippet ipadm_addrprop "Manage IP address properties on Solaris/illumos systems." b
ipadm_addrprop: >
	addrobj=${1:# Specifies the address object we want to manage.}
	property=${2:# Specifies the name of the address property we want to manage.}

	value=${3:# Specifies the value we want to set for the address property.}
	temporary=${4:no}
	state=${5:#present|absent|reset}

endsnippet

snippet ipadm_ifprop "Manage IP interface properties on Solaris/illumos systems." b
ipadm_ifprop: >
	interface=${1:# Specifies the IP interface we want to manage.}
	protocol=${2:# Specifies the protocol for which we want to manage properties.}
	property=${3:# Specifies the name of the property we want to manage.}

	value=${4:# Specifies the value we want to set for the property.}
	temporary=${5:no}
	state=${6:#present|absent|reset}

endsnippet

snippet dladm_vlan "Manage VLAN interfaces on Solaris/illumos systems." b
dladm_vlan: >
	name=${1:# VLAN interface name.}
	link=${2:# VLAN underlying link name.}

	temporary=${3:no}
	vlan_id=${4:no}
	state=${5:#present|absent}

endsnippet

snippet ipadm_if "Manage IP interfaces  on Solaris/illumos systems." b
ipadm_if: >
	name=${1:# IP interface name.}

	temporary=${2:no}
	state=${3:#present|absent|enabled|disabled}

endsnippet

snippet dladm_linkprop "Manage link properties on Solaris/illumos systems." b
dladm_linkprop: >
	link=${1:# Link interface name.}
	property=${2:# Specifies the name of the property we want to manage.}

	value=${3:# Specifies the value we want to set for the link property.}
	temporary=${4:no}
	state=${5:#present|absent|reset}

endsnippet

snippet dladm_iptun "Manage IP tunnel interfaces on Solaris/illumos systems." b
dladm_iptun: >
	name=${1:# IP tunnel interface name.}

	temporary=${2:no}
	type=${3:#ipv4|ipv6|6to4}
	local_address=${4:# Literal IP address or hostname corresponding to the tunnel source.}
	remote_address=${5:# Literal IP address or hostname corresponding to the tunnel destination.}
	state=${6:#present|absent}

endsnippet

snippet flowadm "Manage bandwidth resource control and priority for protocols, services and zones on Solaris/illumos systems" b
flowadm: >
	name=${1:# -}

	link=${2:# Specifiies a link to configure flow on.}
	local_ip=${3:# Identifies a network flow by the local IP address.}
	remote_ip=${4:# Identifies a network flow by the remote IP address.}
	transport=${5:# -}
	local_port=${6:# Identifies a service specified by the local port.}
	dsfield=${7:# -}
	maxbw=${8:# -}
	priority=${9:low|#medium|high}
	temporary=${10:no}
	state=${11:absent|#present|resetted}

endsnippet

snippet dladm_vnic "Manage VNICs on Solaris/illumos systems." b
dladm_vnic: >
	name=${1:# VNIC name.}
	link=${2:# VNIC underlying link name.}

	temporary=${3:no}
	mac=${4:no}
	vlan=${5:no}
	state=${6:#present|absent}

endsnippet

snippet ipadm_prop "Manage protocol properties on Solaris/illumos systems." b
ipadm_prop: >
	protocol=${1:# Specifies the protocol for which we want to manage properties.}
	property=${2:# Specifies the name of property we want to manage.}

	value=${3:# Specifies the value we want to set for the property.}
	temporary=${4:no}
	state=${5:#present|absent|reset}

endsnippet

snippet ipadm_addr "Manage IP addresses on an interface on Solaris/illumos systems" b
ipadm_addr: >
	addrobj=${1:# Specifies an unique IP address on the system.}

	address=${2:# Specifiies an IP address to configure in CIDR notation.}
	addrtype=${3:#static|dhcp|addrconf}
	temporary=${4:no}
	wait=${5:60}
	state=${6:absent|#present|up|down|enabled|disabled|refreshed}

endsnippet

snippet dladm_etherstub "Manage etherstubs on Solaris/illumos systems." b
dladm_etherstub: >
	name=${1:# Etherstub name.}

	temporary=${2:no}
	state=${3:#present|absent}

endsnippet

snippet enos_command "Run arbitrary commands on Lenovo ENOS devices" b
enos_command: >
	commands=${1:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	authorize=${6:no}
	auth_pass=${7:# Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet enos_facts "Collect facts from remote devices running Lenovo ENOS" b
enos_facts: >
	gather_subset=${1:!config}
	authorize=${2:no}
	auth_pass=${3:# Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet enos_config "Manage Lenovo ENOS configuration sections" b
enos_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block|config}
	config=${8:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	backup=${9:no}
	comment=${10:configured by enos_config}
	admin=${11:no}
	backup_options=${12:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	authorize=${13:no}
	auth_pass=${14:# Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.}
	provider=${15:# A dict object containing connection details.}

endsnippet

snippet netconf_rpc "Execute operations on NETCONF enabled network devices." b
netconf_rpc: >
	rpc=${1:# This argument specifies the request (name of the operation) to be executed on the remote NETCONF enabled device.}
	xmlns=${2:# NETCONF operations not defined in rfc6241 typically require the appropriate XML namespace to be set. In the case the I(request) option is not already provided in XML format, the namespace can be defined by the I(xmlns) option.}
	content=${3:# This argument specifies the optional request content (all RPC attributes). The I(content) value can either be provided as XML formatted string or as dictionary.}
	display=${4:json|pretty|xml}

endsnippet

snippet netconf_get "Fetch configuration/state data from NETCONF enabled network devices." b
netconf_get: >
	source=${1:running|candidate|startup}
	filter=${2:# This argument specifies the XML string which acts as a filter to restrict the portions of the data to be are retrieved from the remote device. If this option is not specified entire configuration or state data is returned in result depending on the value of C(source) option. The C(filter) value can be either XML string or XPath, if the filter is in XPath format the NETCONF server running on remote host should support xpath capability else it will result in an error.}
	display=${3:json|pretty|xml}
	lock=${4:#never|always|if-supported}

endsnippet

snippet netconf_config "netconf device configuration" b
netconf_config: >
	host=${1:# Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.}

	content=${2:# The configuration data as defined by the device's data models, the value can be either in xml string format or text format. The format of the configuration should be supported by remote Netconf server}
	target=${3:auto}
	source_datastore=${4:# Name of the configuration datastore to use as the source to copy the configuration to the datastore mentioned by C(target) option. The values can be either I(running), I(candidate), I(startup) or a remote URL}
	format=${5:#xml|text}
	lock=${6:never|#always|if-supported}
	default_operation=${7:merge|replace|none}
	confirm=${8:0}
	confirm_commit=${9:no}
	error_option=${10:#stop-on-error|continue-on-error|rollback-on-error}
	save=${11:no}
	backup=${12:no}
	delete=${13:no}
	commit=${14:yes}
	validate=${15:no}
	src=${16:# Specifies the source path to the xml file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(xml).}
	backup_options=${17:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	port=${18:830}
	username=${19:# Configures the username to use to authenticate the connection to the remote device.  This value is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.}
	password=${20:# Specifies the password to use to authenticate the connection to the remote device.   This value is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.}
	timeout=${21:10}
	ssh_keyfile=${22:# Specifies the SSH key to use to authenticate the connection to the remote device.   This value is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.}
	hostkey_verify=${23:yes}
	look_for_keys=${24:yes}

endsnippet

snippet opx_cps "CPS operations on networking device running Openswitch (OPX)" b
opx_cps: >
	module_name=${1:# Yang path to be configured.}
	attr_type=${2:# Attribute Yang type.}
	attr_data=${3:# Attribute Yang path and their corresponding data.}
	operation=${4:delete|#create|set|action|get}
	db=${5:no}
	qualifier=${6:#target|observed|proposed|realtime|registration|running|startup}
	commit_event=${7:no}

endsnippet

snippet routeros_facts "Collect facts from remote devices running MikroTik RouterOS" b
routeros_facts: >
	gather_subset=${1:!config}

endsnippet

snippet routeros_command "Run commands on remote devices running MikroTik RouterOS" b
routeros_command: >
	commands=${1:# List of commands to send to the remote RouterOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet nos_command "Run commands on remote devices running Extreme Networks NOS" b
nos_command: >
	commands=${1:# List of commands to send to the remote NOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet nos_facts "Collect facts from devices running Extreme NOS" b
nos_facts: >
	gather_subset=${1:!config}

endsnippet

snippet nos_config "Manage Extreme Networks NOS configuration sections" b
nos_config: >
	lines=${1:# The ordered set of commands that should be configured in the section. The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against. If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made. This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	multiline_delimiter=${8:@}
	backup=${9:no}
	running_config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source. There are times when it is not desirable to have the task get the current running-config for every task in a playbook. The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	diff_against=${11:running|intended}
	diff_ignore_lines=${12:# Use this argument to specify one or more lines that should be ignored during the diff. This is used for lines in the configuration that are automatically updated by the system. This argument takes a list of regular expressions or exact line matches.}
	intended_config=${13:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against. This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against. When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${14:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet openvswitch_bridge "Manage Open vSwitch bridges" b
openvswitch_bridge: >
	bridge=${1:# Name of bridge or fake bridge to manage}

	parent=${2:# Bridge parent of the fake bridge to manage}
	vlan=${3:# The VLAN id of the fake bridge to manage (must be between 0 and 4095). This parameter is required if I(parent) parameter is set.}
	state=${4:#present|absent}
	timeout=${5:5}
	external_ids=${6:# A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.}
	fail_mode=${7:secure|standalone}
	set=${8:# Run set command after bridge configuration. This parameter is non-idempotent, play will always return I(changed) state if present}

endsnippet

snippet openvswitch_port "Manage Open vSwitch ports" b
openvswitch_port: >
	bridge=${1:# Name of bridge to manage}
	port=${2:# Name of port to manage on the bridge}

	tag=${3:# VLAN tag for this port. Must be a value between 0 and 4095.}
	state=${4:#present|absent}
	timeout=${5:5}
	external_ids=${6:{}}
	set=${7:# Set a single property on a port.}

endsnippet

snippet openvswitch_db "Configure open vswitch database." b
openvswitch_db: >
	table=${1:# Identifies the table in the database.}
	record=${2:# Identifies the record in the table.}
	col=${3:# Identifies the column in the record.}
	value=${4:# Expected value for the table, record, column and key.}

	state=${5:#present|absent}
	key=${6:# Identifies the key in the record column, when the column is a map type.}
	timeout=${7:5}

endsnippet

snippet avi_controllerproperties "Module for setup of ControllerProperties Avi RESTful Object" b
avi_controllerproperties: >
	state=${1:absent|#present}
	avi_api_update_method=${2:#put|patch}
	avi_api_patch_op=${3:add|replace|delete}
	allow_ip_forwarding=${4:# Field introduced in 17.1.1.}
	allow_unauthenticated_apis=${5:# Allow unauthenticated access for special apis.}
	allow_unauthenticated_nodes=${6:# Boolean flag to set allow_unauthenticated_nodes.}
	api_idle_timeout=${7:# Allowed values are 0-1440.}
	api_perf_logging_threshold=${8:# Threshold to log request timing in portal_performance.log and server-timing response header.}
	appviewx_compat_mode=${9:# Export configuration in appviewx compatibility mode.}
	attach_ip_retry_interval=${10:# Number of attach_ip_retry_interval.}
	attach_ip_retry_limit=${11:# Number of attach_ip_retry_limit.}
	bm_use_ansible=${12:# Use ansible for se creation in baremetal.}
	cleanup_expired_authtoken_timeout_period=${13:# Period for auth token cleanup job.}
	cleanup_sessions_timeout_period=${14:# Period for sessions cleanup job.}
	cloud_reconcile=${15:# Enable/disable periodic reconcile for all the clouds.}
	cluster_ip_gratuitous_arp_period=${16:# Period for cluster ip gratuitous arp job.}
	consistency_check_timeout_period=${17:# Period for consistency check job.}
	crashed_se_reboot=${18:# Number of crashed_se_reboot.}
	dead_se_detection_timer=${19:# Number of dead_se_detection_timer.}
	dns_refresh_period=${20:# Period for refresh pool and gslb dns job.}
	dummy=${21:# Number of dummy.}
	enable_api_sharding=${22:# This setting enables the controller leader to shard api requests to the followers (if any).}
	enable_memory_balancer=${23:# Enable/disable memory balancer.}
	fatal_error_lease_time=${24:# Number of fatal_error_lease_time.}
	max_dead_se_in_grp=${25:# Number of max_dead_se_in_grp.}
	max_pcap_per_tenant=${26:# Maximum number of pcap files stored per tenant.}
	max_seq_attach_ip_failures=${27:# Maximum number of consecutive attach ip failures that halts vs placement.}
	max_seq_vnic_failures=${28:# Number of max_seq_vnic_failures.}
	persistence_key_rotate_period=${29:# Period for rotate app persistence keys job.}
	portal_token=${30:# Token used for uploading tech-support to portal.}
	process_locked_useraccounts_timeout_period=${31:# Period for process locked user accounts job.}
	process_pki_profile_timeout_period=${32:# Period for process pki profile job.}
	query_host_fail=${33:# Number of query_host_fail.}
	safenet_hsm_version=${34:# Version of the safenet package installed on the controller.}
	se_create_timeout=${35:# Number of se_create_timeout.}
	se_failover_attempt_interval=${36:# Interval between attempting failovers to an se.}
	se_from_marketplace=${37:# This setting decides whether se is to be deployed from the cloud marketplace or to be created by the controller.}
	se_offline_del=${38:# Number of se_offline_del.}
	se_vnic_cooldown=${39:# Number of se_vnic_cooldown.}
	secure_channel_cleanup_timeout=${40:# Period for secure channel cleanup job.}
	secure_channel_controller_token_timeout=${41:# Number of secure_channel_controller_token_timeout.}
	secure_channel_se_token_timeout=${42:# Number of secure_channel_se_token_timeout.}
	seupgrade_fabric_pool_size=${43:# Pool size used for all fabric commands during se upgrade.}
	seupgrade_segroup_min_dead_timeout=${44:# Time to wait before marking segroup upgrade as stuck.}
	ssl_certificate_expiry_warning_days=${45:# Number of days for ssl certificate expiry warning.}
	unresponsive_se_reboot=${46:# Number of unresponsive_se_reboot.}
	upgrade_dns_ttl=${47:# Time to account for dns ttl during upgrade.}
	upgrade_lease_time=${48:# Number of upgrade_lease_time.}
	url=${49:# Avi controller URL of the object.}
	uuid=${50:# Unique object identifier of the object.}
	vnic_op_fail_time=${51:# Number of vnic_op_fail_time.}
	vs_apic_scaleout_timeout=${52:# Time to wait for the scaled out se to become ready before marking the scaleout done, applies to apic configuration only.}
	vs_awaiting_se_timeout=${53:# Number of vs_awaiting_se_timeout.}
	vs_key_rotate_period=${54:# Period for rotate vs keys job.}
	vs_scaleout_ready_check_interval=${55:# Interval for checking scaleout_ready status while controller is waiting for scaleoutready rpc from the service engine.}
	vs_se_attach_ip_fail=${56:# Time to wait before marking attach ip operation on an se as failed.}
	vs_se_bootup_fail=${57:# Number of vs_se_bootup_fail.}
	vs_se_create_fail=${58:# Number of vs_se_create_fail.}
	vs_se_ping_fail=${59:# Number of vs_se_ping_fail.}
	vs_se_vnic_fail=${60:# Number of vs_se_vnic_fail.}
	vs_se_vnic_ip_fail=${61:# Number of vs_se_vnic_ip_fail.}
	warmstart_se_reconnect_wait_time=${62:# Number of warmstart_se_reconnect_wait_time.}
	warmstart_vs_resync_wait_time=${63:# Timeout for warmstart vs resync.}
	controller=${64:}
	username=${65:}
	password=${66:}
	tenant=${67:admin}
	tenant_uuid=${68:}
	api_version=${69:16.4.4}
	avi_credentials=${70:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${71:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${72:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_ipaddrgroup "Module for setup of IpAddrGroup Avi RESTful Object" b
avi_ipaddrgroup: >
	name=${1:# Name of the ip address group.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	addrs=${5:# Configure ip address(es).}
	apic_epg_name=${6:# Populate ip addresses from members of this cisco apic epg.}
	country_codes=${7:# Populate the ip address ranges from the geo database for this country.}
	description=${8:# User defined description for the object.}
	ip_ports=${9:# Configure (ip address, port) tuple(s).}
	marathon_app_name=${10:# Populate ip addresses from tasks of this marathon app.}
	marathon_service_port=${11:# Task port associated with marathon service port.}
	prefixes=${12:# Configure ip address prefix(es).}
	ranges=${13:# Configure ip address range(s).}
	tenant_ref=${14:# It is a reference to an object of type tenant.}
	url=${15:# Avi controller URL of the object.}
	uuid=${16:# Uuid of the ip address group.}
	controller=${17:}
	username=${18:}
	password=${19:}
	tenant=${20:admin}
	tenant_uuid=${21:}
	api_version=${22:16.4.4}
	avi_credentials=${23:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${24:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${25:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_clusterclouddetails "Module for setup of ClusterCloudDetails Avi RESTful Object" b
avi_clusterclouddetails: >
	name=${1:# Field introduced in 17.2.5.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	azure_info=${5:# Azure info to configure cluster_vip on the controller.}
	tenant_ref=${6:# It is a reference to an object of type tenant.}
	url=${7:# Avi controller URL of the object.}
	uuid=${8:# Field introduced in 17.2.5.}
	controller=${9:}
	username=${10:}
	password=${11:}
	tenant=${12:admin}
	tenant_uuid=${13:}
	api_version=${14:16.4.4}
	avi_credentials=${15:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${16:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${17:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_trafficcloneprofile "Module for setup of TrafficCloneProfile Avi RESTful Object" b
avi_trafficcloneprofile: >
	name=${1:# Name for the traffic clone profile.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	clone_servers=${5:# Field introduced in 17.1.1.}
	cloud_ref=${6:# It is a reference to an object of type cloud.}
	preserve_client_ip=${7:# Specifies if client ip needs to be preserved to clone destination.}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Uuid of the traffic clone profile.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_virtualservice "Module for setup of VirtualService Avi RESTful Object" b
avi_virtualservice: >
	name=${1:# Name for the virtual service.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	active_standby_se_tag=${5:# This configuration only applies if the virtualservice is in legacy active standby ha mode and load distribution among active standby is enabled.}
	allow_invalid_client_cert=${6:# Process request even if invalid client certificate is presented.}
	analytics_policy=${7:# Determines analytics settings for the application.}
	analytics_profile_ref=${8:# Specifies settings related to analytics.}
	apic_contract_graph=${9:# The name of the contract/graph associated with the virtual service.}
	application_profile_ref=${10:# Enable application layer specific features for the virtual service.}
	auto_allocate_floating_ip=${11:# Auto-allocate floating/elastic ip from the cloud infrastructure.}
	auto_allocate_ip=${12:# Auto-allocate vip from the provided subnet.}
	availability_zone=${13:# Availability-zone to place the virtual service.}
	avi_allocated_fip=${14:# (internal-use) fip allocated by avi in the cloud infrastructure.}
	avi_allocated_vip=${15:# (internal-use) vip allocated by avi in the cloud infrastructure.}
	azure_availability_set=${16:# (internal-use)applicable for azure only.}
	bulk_sync_kvcache=${17:# (this is a beta feature).}
	client_auth=${18:# Http authentication configuration for protected resources.}
	close_client_conn_on_config_update=${19:# Close client connection on vs config update.}
	cloud_config_cksum=${20:# Checksum of cloud configuration for vs.}
	cloud_ref=${21:# It is a reference to an object of type cloud.}
	cloud_type=${22:# Enum options - cloud_none, cloud_vcenter, cloud_openstack, cloud_aws, cloud_vca, cloud_apic, cloud_mesos, cloud_linuxserver, cloud_docker_ucp,}
	connections_rate_limit=${23:# Rate limit the incoming connections to this virtual service.}
	content_rewrite=${24:# Profile used to match and rewrite strings in request and/or response body.}
	created_by=${25:# Creator name.}
	delay_fairness=${26:# Select the algorithm for qos fairness.}
	description=${27:# User defined description for the object.}
	discovered_network_ref=${28:# (internal-use) discovered networks providing reachability for client facing virtual service ip.}
	discovered_networks=${29:# (internal-use) discovered networks providing reachability for client facing virtual service ip.}
	discovered_subnet=${30:# (internal-use) discovered subnets providing reachability for client facing virtual service ip.}
	dns_info=${31:# Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.}
	dns_policies=${32:# Dns policies applied on the dns traffic of the virtual service.}
	east_west_placement=${33:# Force placement on all se's in service group (mesos mode only).}
	enable_autogw=${34:# Response traffic to clients will be sent back to the source mac address of the connection, rather than statically sent to a default gateway.}
	enable_rhi=${35:# Enable route health injection using the bgp config in the vrf context.}
	enable_rhi_snat=${36:# Enable route health injection for source nat'ted floating ip address using the bgp config in the vrf context.}
	enabled=${37:# Enable or disable the virtual service.}
	error_page_profile_ref=${38:# Error page profile to be used for this virtualservice.this profile is used to send the custom error page to the client generated by the proxy.}
	floating_ip=${39:# Floating ip to associate with this virtual service.}
	floating_subnet_uuid=${40:# If auto_allocate_floating_ip is true and more than one floating-ip subnets exist, then the subnet for the floating ip address allocation.}
	flow_dist=${41:# Criteria for flow distribution among ses.}
	flow_label_type=${42:# Criteria for flow labelling.}
	fqdn=${43:# Dns resolvable, fully qualified domain name of the virtualservice.}
	host_name_xlate=${44:# Translate the host name sent to the servers to this value.}
	http_policies=${45:# Http policies applied on the data traffic of the virtual service.}
	ign_pool_net_reach=${46:# Ignore pool servers network reachability constraints for virtual service placement.}
	ip_address=${47:# Ip address of the virtual service.}
	ipam_network_subnet=${48:# Subnet and/or network for allocating virtualservice ip by ipam provider module.}
	l4_policies=${49:# L4 policies applied to the data traffic of the virtual service.}
	limit_doser=${50:# Limit potential dos attackers who exceed max_cps_per_client significantly to a fraction of max_cps_per_client for a while.}
	max_cps_per_client=${51:# Maximum connections per second per client ip.}
	microservice_ref=${52:# Microservice representing the virtual service.}
	min_pools_up=${53:# Minimum number of up pools to mark vs up.}
	network_profile_ref=${54:# Determines network settings such as protocol, tcp or udp, and related options for the protocol.}
	network_ref=${55:# Manually override the network on which the virtual service is placed.}
	network_security_policy_ref=${56:# Network security policies for the virtual service.}
	nsx_securitygroup=${57:# A list of nsx service groups representing the clients which can access the virtual ip of the virtual service.}
	performance_limits=${58:# Optional settings that determine performance limits like max connections or bandwidth etc.}
	pool_group_ref=${59:# The pool group is an object that contains pools.}
	pool_ref=${60:# The pool is an object that contains destination servers and related attributes such as load-balancing and persistence.}
	port_uuid=${61:# (internal-use) network port assigned to the virtual service ip address.}
	remove_listening_port_on_vs_down=${62:# Remove listening port if virtualservice is down.}
	requests_rate_limit=${63:# Rate limit the incoming requests to this virtual service.}
	saml_sp_config=${64:# Application-specific saml config.}
	scaleout_ecmp=${65:# Disable re-distribution of flows across service engines for a virtual service.}
	se_group_ref=${66:# The service engine group to use for this virtual service.}
	security_policy_ref=${67:# Security policy applied on the traffic of the virtual service.}
	server_network_profile_ref=${68:# Determines the network settings profile for the server side of tcp proxied connections.}
	service_metadata=${69:# Metadata pertaining to the service provided by this virtual service.}
	service_pool_select=${70:# Select pool based on destination port.}
	services=${71:# List of services defined for this virtual service.}
	sideband_profile=${72:# Sideband configuration to be used for this virtualservice.it can be used for sending traffic to sideband vips for external inspection etc.}
	snat_ip=${73:# Nat'ted floating source ip address(es) for upstream connection to servers.}
	sp_pool_refs=${74:# Gslb pools used to manage site-persistence functionality.}
	ssl_key_and_certificate_refs=${75:# Select or create one or two certificates, ec and/or rsa, that will be presented to ssl/tls terminated connections.}
	ssl_profile_ref=${76:# Determines the set of ssl versions and ciphers to accept for ssl/tls terminated connections.}
	ssl_profile_selectors=${77:# Select ssl profile based on client ip address match.}
	ssl_sess_cache_avg_size=${78:# Expected number of ssl session cache entries (may be exceeded).}
	sso_policy=${79:# Client authentication and authorization policy for the virtualservice.}
	sso_policy_ref=${80:# The sso policy attached to the virtualservice.}
	static_dns_records=${81:# List of static dns records applied to this virtual service.}
	subnet=${82:# Subnet providing reachability for client facing virtual service ip.}
	subnet_uuid=${83:# It represents subnet for the virtual service ip address allocation when auto_allocate_ip is true.it is only applicable in openstack or aws cloud.}
	tenant_ref=${84:# It is a reference to an object of type tenant.}
	topology_policies=${85:# Topology policies applied on the dns traffic of the virtual service based ongslb topology algorithm.}
	traffic_clone_profile_ref=${86:# Server network or list of servers for cloning traffic.}
	traffic_enabled=${87:# Knob to enable the virtual service traffic on its assigned service engines.}
	type=${88:# Specify if this is a normal virtual service, or if it is the parent or child of an sni-enabled virtual hosted virtual service.}
	url=${89:# Avi controller URL of the object.}
	use_bridge_ip_as_vip=${90:# Use bridge ip as vip on each host in mesos deployments.}
	use_vip_as_snat=${91:# Use the virtual ip as the snat ip for health monitoring and sending traffic to the backend servers instead of the service engine interface ip.}
	uuid=${92:# Uuid of the virtualservice.}
	vh_domain_name=${93:# The exact name requested from the client's sni-enabled tls hello domain name field.}
	vh_parent_vs_uuid=${94:# Specifies the virtual service acting as virtual hosting (sni) parent.}
	vip=${95:# List of virtual service ips.}
	vrf_context_ref=${96:# Virtual routing context that the virtual service is bound to.}
	vs_datascripts=${97:# Datascripts applied on the data traffic of the virtual service.}
	vsvip_cloud_config_cksum=${98:# Checksum of cloud configuration for vsvip.}
	vsvip_ref=${99:# Mostly used during the creation of shared vs, this field refers to entities that can be shared across virtual services.}
	waf_policy_ref=${100:# Waf policy for the virtual service.}
	weight=${101:# The quality of service weight to assign to traffic transmitted from this virtual service.}
	controller=${102:}
	username=${103:}
	password=${104:}
	tenant=${105:admin}
	tenant_uuid=${106:}
	api_version=${107:16.4.4}
	avi_credentials=${108:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${109:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${110:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_healthmonitor "Module for setup of HealthMonitor Avi RESTful Object" b
avi_healthmonitor: >
	name=${1:# A user friendly name for this health monitor.}
	type=${2:# Type of the health monitor.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	description=${6:# User defined description for the object.}
	dns_monitor=${7:# Healthmonitordns settings for healthmonitor.}
	external_monitor=${8:# Healthmonitorexternal settings for healthmonitor.}
	failed_checks=${9:# Number of continuous failed health checks before the server is marked down.}
	http_monitor=${10:# Healthmonitorhttp settings for healthmonitor.}
	https_monitor=${11:# Healthmonitorhttp settings for healthmonitor.}
	is_federated=${12:# This field describes the object's replication scope.}
	monitor_port=${13:# Use this port instead of the port defined for the server in the pool.}
	radius_monitor=${14:# Health monitor for radius.}
	receive_timeout=${15:# A valid response from the server is expected within the receive timeout window.}
	send_interval=${16:# Frequency, in seconds, that monitors are sent to a server.}
	sip_monitor=${17:# Health monitor for sip.}
	successful_checks=${18:# Number of continuous successful health checks before server is marked up.}
	tcp_monitor=${19:# Healthmonitortcp settings for healthmonitor.}
	tenant_ref=${20:# It is a reference to an object of type tenant.}
	udp_monitor=${21:# Healthmonitorudp settings for healthmonitor.}
	url=${22:# Avi controller URL of the object.}
	uuid=${23:# Uuid of the health monitor.}
	controller=${24:}
	username=${25:}
	password=${26:}
	tenant=${27:admin}
	tenant_uuid=${28:}
	api_version=${29:16.4.4}
	avi_credentials=${30:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${31:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${32:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_analyticsprofile "Module for setup of AnalyticsProfile Avi RESTful Object" b
avi_analyticsprofile: >
	name=${1:# The name of the analytics profile.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	apdex_response_threshold=${5:# If a client receives an http response in less than the satisfactory latency threshold, the request is considered satisfied.}
	apdex_response_tolerated_factor=${6:# Client tolerated response latency factor.}
	apdex_rtt_threshold=${7:# Satisfactory client to avi round trip time(rtt).}
	apdex_rtt_tolerated_factor=${8:# Tolerated client to avi round trip time(rtt) factor.}
	apdex_rum_threshold=${9:# If a client is able to load a page in less than the satisfactory latency threshold, the pageload is considered satisfied.}
	apdex_rum_tolerated_factor=${10:# Virtual service threshold factor for tolerated page load time (plt) as multiple of apdex_rum_threshold.}
	apdex_server_response_threshold=${11:# A server http response is considered satisfied if latency is less than the satisfactory latency threshold.}
	apdex_server_response_tolerated_factor=${12:# Server tolerated response latency factor.}
	apdex_server_rtt_threshold=${13:# Satisfactory client to avi round trip time(rtt).}
	apdex_server_rtt_tolerated_factor=${14:# Tolerated client to avi round trip time(rtt) factor.}
	client_log_config=${15:# Configure which logs are sent to the avi controller from ses and how they are processed.}
	client_log_streaming_config=${16:# Configure to stream logs to an external server.}
	conn_lossy_ooo_threshold=${17:# A connection between client and avi is considered lossy when more than this percentage of out of order packets are received.}
	conn_lossy_timeo_rexmt_threshold=${18:# A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted due to timeout.}
	conn_lossy_total_rexmt_threshold=${19:# A connection between client and avi is considered lossy when more than this percentage of packets are retransmitted.}
	conn_lossy_zero_win_size_event_threshold=${20:# A client connection is considered lossy when percentage of times a packet could not be transmitted due to tcp zero window is above this threshold.}
	conn_server_lossy_ooo_threshold=${21:# A connection between avi and server is considered lossy when more than this percentage of out of order packets are received.}
	conn_server_lossy_timeo_rexmt_threshold=${22:# A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted due to timeout.}
	conn_server_lossy_total_rexmt_threshold=${23:# A connection between avi and server is considered lossy when more than this percentage of packets are retransmitted.}
	conn_server_lossy_zero_win_size_event_threshold=${24:# A server connection is considered lossy when percentage of times a packet could not be transmitted due to tcp zero window is above this threshold.}
	description=${25:# User defined description for the object.}
	disable_ondemand_metrics=${26:# Virtual service (vs) metrics are processed only when there is live data traffic on the vs.}
	disable_se_analytics=${27:# Disable node (service engine) level analytics forvs metrics.}
	disable_server_analytics=${28:# Disable analytics on backend servers.}
	disable_vs_analytics=${29:# Disable virtualservice (frontend) analytics.}
	enable_advanced_analytics=${30:# Enables advanced analytics features like anomaly detection.}
	exclude_client_close_before_request_as_error=${31:# Exclude client closed connection before an http request could be completed from being classified as an error.}
	exclude_dns_policy_drop_as_significant=${32:# Exclude dns policy drops from the list of errors.}
	exclude_gs_down_as_error=${33:# Exclude queries to gslb services that are operationally down from the list of errors.}
	exclude_http_error_codes=${34:# List of http status codes to be excluded from being classified as an error.}
	exclude_invalid_dns_domain_as_error=${35:# Exclude dns queries to domains outside the domains configured in the dns application profile from the list of errors.}
	exclude_invalid_dns_query_as_error=${36:# Exclude invalid dns queries from the list of errors.}
	exclude_no_dns_record_as_error=${37:# Exclude queries to domains that did not have configured services/records from the list of errors.}
	exclude_no_valid_gs_member_as_error=${38:# Exclude queries to gslb services that have no available members from the list of errors.}
	exclude_persistence_change_as_error=${39:# Exclude persistence server changed while load balancing' from the list of errors.}
	exclude_server_dns_error_as_error=${40:# Exclude server dns error response from the list of errors.}
	exclude_server_tcp_reset_as_error=${41:# Exclude server tcp reset from errors.}
	exclude_sip_error_codes=${42:# List of sip status codes to be excluded from being classified as an error.}
	exclude_syn_retransmit_as_error=${43:# Exclude 'server unanswered syns' from the list of errors.}
	exclude_tcp_reset_as_error=${44:# Exclude tcp resets by client from the list of potential errors.}
	exclude_unsupported_dns_query_as_error=${45:# Exclude unsupported dns queries from the list of errors.}
	healthscore_max_server_limit=${46:# Skips health score computation of pool servers when number of servers in a pool is more than this setting.}
	hs_event_throttle_window=${47:# Time window (in secs) within which only unique health change events should occur.}
	hs_max_anomaly_penalty=${48:# Maximum penalty that may be deducted from health score for anomalies.}
	hs_max_resources_penalty=${49:# Maximum penalty that may be deducted from health score for high resource utilization.}
	hs_max_security_penalty=${50:# Maximum penalty that may be deducted from health score based on security assessment.}
	hs_min_dos_rate=${51:# Dos connection rate below which the dos security assessment will not kick in.}
	hs_performance_boost=${52:# Adds free performance score credits to health score.}
	hs_pscore_traffic_threshold_l4_client=${53:# Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.}
	hs_pscore_traffic_threshold_l4_server=${54:# Threshold number of connections in 5min, below which apdexr, apdexc, rum_apdex, and other network quality metrics are not computed.}
	hs_security_certscore_expired=${55:# Score assigned when the certificate has expired.}
	hs_security_certscore_gt30d=${56:# Score assigned when the certificate expires in more than 30 days.}
	hs_security_certscore_le07d=${57:# Score assigned when the certificate expires in less than or equal to 7 days.}
	hs_security_certscore_le30d=${58:# Score assigned when the certificate expires in less than or equal to 30 days.}
	hs_security_chain_invalidity_penalty=${59:# Penalty for allowing certificates with invalid chain.}
	hs_security_cipherscore_eq000b=${60:# Score assigned when the minimum cipher strength is 0 bits.}
	hs_security_cipherscore_ge128b=${61:# Score assigned when the minimum cipher strength is greater than equal to 128 bits.}
	hs_security_cipherscore_lt128b=${62:# Score assigned when the minimum cipher strength is less than 128 bits.}
	hs_security_encalgo_score_none=${63:# Score assigned when no algorithm is used for encryption.}
	hs_security_encalgo_score_rc4=${64:# Score assigned when rc4 algorithm is used for encryption.}
	hs_security_hsts_penalty=${65:# Penalty for not enabling hsts.}
	hs_security_nonpfs_penalty=${66:# Penalty for allowing non-pfs handshakes.}
	hs_security_selfsignedcert_penalty=${67:# Deprecated.}
	hs_security_ssl30_score=${68:# Score assigned when supporting ssl3.0 encryption protocol.}
	hs_security_tls10_score=${69:# Score assigned when supporting tls1.0 encryption protocol.}
	hs_security_tls11_score=${70:# Score assigned when supporting tls1.1 encryption protocol.}
	hs_security_tls12_score=${71:# Score assigned when supporting tls1.2 encryption protocol.}
	hs_security_weak_signature_algo_penalty=${72:# Penalty for allowing weak signature algorithm(s).}
	ondemand_metrics_idle_timeout=${73:# This flag sets the time duration of no live data traffic after which virtual service metrics processing is suspended.}
	ranges=${74:# List of http status code ranges to be excluded from being classified as an error.}
	resp_code_block=${75:# Block of http response codes to be excluded from being classified as an error.}
	sensitive_log_profile=${76:# Rules applied to the http application log for filtering sensitive information.}
	sip_log_depth=${77:# Maximum number of sip messages added in logs for a sip transaction.}
	tenant_ref=${78:# It is a reference to an object of type tenant.}
	url=${79:# Avi controller URL of the object.}
	uuid=${80:# Uuid of the analytics profile.}
	controller=${81:}
	username=${82:}
	password=${83:}
	tenant=${84:admin}
	tenant_uuid=${85:}
	api_version=${86:16.4.4}
	avi_credentials=${87:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${88:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${89:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_gslb "Module for setup of Gslb Avi RESTful Object" b
avi_gslb: >
	leader_cluster_uuid=${1:# Mark this site as leader of gslb configuration.}
	name=${2:# Name for the gslb object.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	async_interval=${6:# Frequency with which messages are propagated to vs mgr.}
	clear_on_max_retries=${7:# Max retries after which the remote site is treated as a fresh start.}
	client_ip_addr_group=${8:# Group to specify if the client ip addresses are public or private.}
	description=${9:# User defined description for the object.}
	dns_configs=${10:# Sub domain configuration for the gslb.}
	is_federated=${11:# This field indicates that this object is replicated across gslb federation.}
	maintenance_mode=${12:# This field disables the configuration operations on the leader for all federated objects.}
	send_interval=${13:# Frequency with which group members communicate.}
	send_interval_prior_to_maintenance_mode=${14:# The user can specify a send-interval while entering maintenance mode.}
	sites=${15:# Select avi site member belonging to this gslb.}
	tenant_ref=${16:# It is a reference to an object of type tenant.}
	third_party_sites=${17:# Third party site member belonging to this gslb.}
	url=${18:# Avi controller URL of the object.}
	uuid=${19:# Uuid of the gslb object.}
	view_id=${20:# The view-id is used in change-leader mode to differentiate partitioned groups while they have the same gslb namespace.}
	controller=${21:}
	username=${22:}
	password=${23:}
	tenant=${24:admin}
	tenant_uuid=${25:}
	api_version=${26:16.4.4}
	avi_credentials=${27:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${28:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${29:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_prioritylabels "Module for setup of PriorityLabels Avi RESTful Object" b
avi_prioritylabels: >
	name=${1:# The name of the priority labels.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	cloud_ref=${5:# It is a reference to an object of type cloud.}
	description=${6:# A description of the priority labels.}
	equivalent_labels=${7:# Equivalent priority labels in descending order.}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Uuid of the priority labels.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_pool "Module for setup of Pool Avi RESTful Object" b
avi_pool: >
	name=${1:# The name of the pool.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	a_pool=${5:# Name of container cloud application that constitutes a pool in a a-b pool configuration, if different from vs app.}
	ab_pool=${6:# A/b pool configuration.}
	ab_priority=${7:# Priority of this pool in a a-b pool pair.}
	analytics_policy=${8:# Determines analytics settings for the pool.}
	analytics_profile_ref=${9:# Specifies settings related to analytics.}
	apic_epg_name=${10:# Synchronize cisco apic epg members with pool servers.}
	application_persistence_profile_ref=${11:# Persistence will ensure the same user sticks to the same server for a desired duration of time.}
	autoscale_launch_config_ref=${12:# If configured then avi will trigger orchestration of pool server creation and deletion.}
	autoscale_networks=${13:# Network ids for the launch configuration.}
	autoscale_policy_ref=${14:# Reference to server autoscale policy.}
	capacity_estimation=${15:# Inline estimation of capacity of servers.}
	capacity_estimation_ttfb_thresh=${16:# The maximum time-to-first-byte of a server.}
	cloud_config_cksum=${17:# Checksum of cloud configuration for pool.}
	cloud_ref=${18:# It is a reference to an object of type cloud.}
	conn_pool_properties=${19:# Connection pool properties.}
	connection_ramp_duration=${20:# Duration for which new connections will be gradually ramped up to a server recently brought online.}
	created_by=${21:# Creator name.}
	default_server_port=${22:# Traffic sent to servers will use this destination server port unless overridden by the server's specific port attribute.}
	delete_server_on_dns_refresh=${23:# Indicates whether existing ips are disabled(false) or deleted(true) on dns hostname refreshdetail -- on a dns refresh, some ips set on pool may}
	description=${24:# A description of the pool.}
	domain_name=${25:# Comma separated list of domain names which will be used to verify the common names or subject alternative names presented by server certificates.}
	east_west=${26:# Inherited config from virtualservice.}
	enabled=${27:# Enable or disable the pool.}
	external_autoscale_groups=${28:# Names of external auto-scale groups for pool servers.}
	fail_action=${29:# Enable an action - close connection, http redirect or local http response - when a pool failure happens.}
	fewest_tasks_feedback_delay=${30:# Periodicity of feedback for fewest tasks server selection algorithm.}
	graceful_disable_timeout=${31:# Used to gracefully disable a server.}
	gslb_sp_enabled=${32:# Indicates if the pool is a site-persistence pool.}
	health_monitor_refs=${33:# Verify server health by applying one or more health monitors.}
	host_check_enabled=${34:# Enable common name check for server certificate.}
	inline_health_monitor=${35:# The passive monitor will monitor client to server connections and requests and adjust traffic load to servers based on successful responses.}
	ipaddrgroup_ref=${36:# Use list of servers from ip address group.}
	lb_algorithm=${37:# The load balancing algorithm will pick a server within the pool's list of available servers.}
	lb_algorithm_consistent_hash_hdr=${38:# Http header name to be used for the hash key.}
	lb_algorithm_core_nonaffinity=${39:# Degree of non-affinity for core affinity based server selection.}
	lb_algorithm_hash=${40:# Criteria used as a key for determining the hash between the client and  server.}
	lookup_server_by_name=${41:# Allow server lookup by name.}
	max_concurrent_connections_per_server=${42:# The maximum number of concurrent connections allowed to each server within the pool.}
	max_conn_rate_per_server=${43:# Rate limit connections to each server.}
	min_health_monitors_up=${44:# Minimum number of health monitors in up state to mark server up.}
	min_servers_up=${45:# Minimum number of servers in up state for marking the pool up.}
	networks=${46:# (internal-use) networks designated as containing servers for this pool.}
	nsx_securitygroup=${47:# A list of nsx service groups where the servers for the pool are created.}
	pki_profile_ref=${48:# Avi will validate the ssl certificate present by a server against the selected pki profile.}
	placement_networks=${49:# Manually select the networks and subnets used to provide reachability to the pool's servers.}
	prst_hdr_name=${50:# Header name for custom header persistence.}
	request_queue_depth=${51:# Minimum number of requests to be queued when pool is full.}
	request_queue_enabled=${52:# Enable request queue when pool is full.}
	rewrite_host_header_to_server_name=${53:# Rewrite incoming host header to server name of the server to which the request is proxied.}
	rewrite_host_header_to_sni=${54:# If sni server name is specified, rewrite incoming host header to the sni server name.}
	server_auto_scale=${55:# Server autoscale.}
	server_count=${56:# Field deprecated in 18.2.1.}
	server_name=${57:# Fully qualified dns hostname which will be used in the tls sni extension in server connections if sni is enabled.}
	server_reselect=${58:# Server reselect configuration for http requests.}
	server_timeout=${59:# Server timeout value specifies the time within which a server connection needs to be established and a request-response exchange completes}
	servers=${60:# The pool directs load balanced traffic to this list of destination servers.}
	service_metadata=${61:# Metadata pertaining to the service provided by this pool.}
	sni_enabled=${62:# Enable tls sni for server connections.}
	ssl_key_and_certificate_ref=${63:# Service engines will present a client ssl certificate to the server.}
	ssl_profile_ref=${64:# When enabled, avi re-encrypts traffic to the backend servers.}
	tenant_ref=${65:# It is a reference to an object of type tenant.}
	url=${66:# Avi controller URL of the object.}
	use_service_port=${67:# Do not translate the client's destination port when sending the connection to the server.}
	uuid=${68:# Uuid of the pool.}
	vrf_ref=${69:# Virtual routing context that the pool is bound to.}
	controller=${70:}
	username=${71:}
	password=${72:}
	tenant=${73:admin}
	tenant_uuid=${74:}
	api_version=${75:16.4.4}
	avi_credentials=${76:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${77:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${78:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_snmptrapprofile "Module for setup of SnmpTrapProfile Avi RESTful Object" b
avi_snmptrapprofile: >
	name=${1:# A user-friendly name of the snmp trap configuration.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	tenant_ref=${5:# It is a reference to an object of type tenant.}
	trap_servers=${6:# The ip address or hostname of the snmp trap destination server.}
	url=${7:# Avi controller URL of the object.}
	uuid=${8:# Uuid of the snmp trap profile object.}
	controller=${9:}
	username=${10:}
	password=${11:}
	tenant=${12:admin}
	tenant_uuid=${13:}
	api_version=${14:16.4.4}
	avi_credentials=${15:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${16:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${17:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_applicationprofile "Module for setup of ApplicationProfile Avi RESTful Object" b
avi_applicationprofile: >
	name=${1:# The name of the application profile.}
	type=${2:# Specifies which application layer proxy is enabled for the virtual service.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	cloud_config_cksum=${6:# Checksum of application profiles.}
	created_by=${7:# Name of the application profile creator.}
	description=${8:# User defined description for the object.}
	dns_service_profile=${9:# Specifies various dns service related controls for virtual service.}
	dos_rl_profile=${10:# Specifies various security related controls for virtual service.}
	http_profile=${11:# Specifies the http application proxy profile parameters.}
	preserve_client_ip=${12:# Specifies if client ip needs to be preserved for backend connection.}
	preserve_client_port=${13:# Specifies if we need to preserve client port while preserving client ip for backend connections.}
	sip_service_profile=${14:# Specifies various sip service related controls for virtual service.}
	tcp_app_profile=${15:# Specifies the tcp application proxy profile parameters.}
	tenant_ref=${16:# It is a reference to an object of type tenant.}
	url=${17:# Avi controller URL of the object.}
	uuid=${18:# Uuid of the application profile.}
	controller=${19:}
	username=${20:}
	password=${21:}
	tenant=${22:admin}
	tenant_uuid=${23:}
	api_version=${24:16.4.4}
	avi_credentials=${25:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${26:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${27:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_poolgroup "Module for setup of PoolGroup Avi RESTful Object" b
avi_poolgroup: >
	name=${1:# The name of the pool group.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	cloud_config_cksum=${5:# Checksum of cloud configuration for poolgroup.}
	cloud_ref=${6:# It is a reference to an object of type cloud.}
	created_by=${7:# Name of the user who created the object.}
	deployment_policy_ref=${8:# When setup autoscale manager will automatically promote new pools into production when deployment goals are met.}
	description=${9:# Description of pool group.}
	fail_action=${10:# Enable an action - close connection, http redirect, or local http response - when a pool group failure happens.}
	implicit_priority_labels=${11:# Whether an implicit set of priority labels is generated.}
	members=${12:# List of pool group members object of type poolgroupmember.}
	min_servers=${13:# The minimum number of servers to distribute traffic to.}
	priority_labels_ref=${14:# Uuid of the priority labels.}
	service_metadata=${15:# Metadata pertaining to the service provided by this poolgroup.}
	tenant_ref=${16:# It is a reference to an object of type tenant.}
	url=${17:# Avi controller URL of the object.}
	uuid=${18:# Uuid of the pool group.}
	controller=${19:}
	username=${20:}
	password=${21:}
	tenant=${22:admin}
	tenant_uuid=${23:}
	api_version=${24:16.4.4}
	avi_credentials=${25:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${26:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${27:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_vsdatascriptset "Module for setup of VSDataScriptSet Avi RESTful Object" b
avi_vsdatascriptset: >
	name=${1:# Name for the virtual service datascript collection.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	created_by=${5:# Creator name.}
	datascript=${6:# Datascripts to execute.}
	description=${7:# User defined description for the object.}
	ipgroup_refs=${8:# Uuid of ip groups that could be referred by vsdatascriptset objects.}
	pool_group_refs=${9:# Uuid of pool groups that could be referred by vsdatascriptset objects.}
	pool_refs=${10:# Uuid of pools that could be referred by vsdatascriptset objects.}
	protocol_parser_refs=${11:# List of protocol parsers that could be referred by vsdatascriptset objects.}
	string_group_refs=${12:# Uuid of string groups that could be referred by vsdatascriptset objects.}
	tenant_ref=${13:# It is a reference to an object of type tenant.}
	url=${14:# Avi controller URL of the object.}
	uuid=${15:# Uuid of the virtual service datascript collection.}
	controller=${16:}
	username=${17:}
	password=${18:}
	tenant=${19:admin}
	tenant_uuid=${20:}
	api_version=${21:16.4.4}
	avi_credentials=${22:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${23:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${24:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_scheduler "Module for setup of Scheduler Avi RESTful Object" b
avi_scheduler: >
	name=${1:# Name of scheduler.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	backup_config_ref=${5:# Backup configuration to be executed by this scheduler.}
	enabled=${6:# Boolean flag to set enabled.}
	end_date_time=${7:# Scheduler end date and time.}
	frequency=${8:# Frequency at which custom scheduler will run.}
	frequency_unit=${9:# Unit at which custom scheduler will run.}
	run_mode=${10:# Scheduler run mode.}
	run_script_ref=${11:# Control script to be executed by this scheduler.}
	scheduler_action=${12:# Define scheduler action.}
	start_date_time=${13:# Scheduler start date and time.}
	tenant_ref=${14:# It is a reference to an object of type tenant.}
	url=${15:# Avi controller URL of the object.}
	uuid=${16:# Unique object identifier of the object.}
	controller=${17:}
	username=${18:}
	password=${19:}
	tenant=${20:admin}
	tenant_uuid=${21:}
	api_version=${22:16.4.4}
	avi_credentials=${23:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${24:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${25:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_errorpagebody "Module for setup of ErrorPageBody Avi RESTful Object" b
avi_errorpagebody: >
	name=${1:# Field introduced in 17.2.4.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	error_page_body=${5:# Error page body sent to client when match.}
	format=${6:# Format of an error page body html or json.}
	tenant_ref=${7:# It is a reference to an object of type tenant.}
	url=${8:# Avi controller URL of the object.}
	uuid=${9:# Field introduced in 17.2.4.}
	controller=${10:}
	username=${11:}
	password=${12:}
	tenant=${13:admin}
	tenant_uuid=${14:}
	api_version=${15:16.4.4}
	avi_credentials=${16:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${17:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${18:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_httppolicyset "Module for setup of HTTPPolicySet Avi RESTful Object" b
avi_httppolicyset: >
	name=${1:# Name of the http policy set.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	cloud_config_cksum=${5:# Checksum of cloud configuration for pool.}
	created_by=${6:# Creator name.}
	description=${7:# User defined description for the object.}
	http_request_policy=${8:# Http request policy for the virtual service.}
	http_response_policy=${9:# Http response policy for the virtual service.}
	http_security_policy=${10:# Http security policy for the virtual service.}
	is_internal_policy=${11:# Boolean flag to set is_internal_policy.}
	tenant_ref=${12:# It is a reference to an object of type tenant.}
	url=${13:# Avi controller URL of the object.}
	uuid=${14:# Uuid of the http policy set.}
	controller=${15:}
	username=${16:}
	password=${17:}
	tenant=${18:admin}
	tenant_uuid=${19:}
	api_version=${20:16.4.4}
	avi_credentials=${21:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${22:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${23:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_alertsyslogconfig "Module for setup of AlertSyslogConfig Avi RESTful Object" b
avi_alertsyslogconfig: >
	name=${1:# A user-friendly name of the syslog notification.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	description=${5:# User defined description for alert syslog config.}
	syslog_servers=${6:# The list of syslog servers.}
	tenant_ref=${7:# It is a reference to an object of type tenant.}
	url=${8:# Avi controller URL of the object.}
	uuid=${9:# Unique object identifier of the object.}
	controller=${10:}
	username=${11:}
	password=${12:}
	tenant=${13:admin}
	tenant_uuid=${14:}
	api_version=${15:16.4.4}
	avi_credentials=${16:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${17:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${18:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_api_version "Avi API Version Module" b
avi_api_version: >
	controller=${1:}
	username=${2:}
	password=${3:}
	tenant=${4:admin}
	tenant_uuid=${5:}
	api_version=${6:16.4.4}
	avi_credentials=${7:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${8:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${9:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_ipamdnsproviderprofile "Module for setup of IpamDnsProviderProfile Avi RESTful Object" b
avi_ipamdnsproviderprofile: >
	name=${1:# Name for the ipam/dns provider profile.}
	type=${2:# Provider type for the ipam/dns provider profile.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	allocate_ip_in_vrf=${6:# If this flag is set, only allocate ip from networks in the virtual service vrf.}
	aws_profile=${7:# Provider details if type is aws.}
	azure_profile=${8:# Provider details if type is microsoft azure.}
	custom_profile=${9:# Provider details if type is custom.}
	gcp_profile=${10:# Provider details if type is google cloud.}
	infoblox_profile=${11:# Provider details if type is infoblox.}
	internal_profile=${12:# Provider details if type is avi.}
	oci_profile=${13:# Provider details for oracle cloud.}
	openstack_profile=${14:# Provider details if type is openstack.}
	proxy_configuration=${15:# Field introduced in 17.1.1.}
	tenant_ref=${16:# It is a reference to an object of type tenant.}
	tencent_profile=${17:# Provider details for tencent cloud.}
	url=${18:# Avi controller URL of the object.}
	uuid=${19:# Uuid of the ipam/dns provider profile.}
	controller=${20:}
	username=${21:}
	password=${22:}
	tenant=${23:admin}
	tenant_uuid=${24:}
	api_version=${25:16.4.4}
	avi_credentials=${26:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${27:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${28:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_microservicegroup "Module for setup of MicroServiceGroup Avi RESTful Object" b
avi_microservicegroup: >
	name=${1:# Name of the microservice group.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	created_by=${5:# Creator name.}
	description=${6:# User defined description for the object.}
	service_refs=${7:# Configure microservice(es).}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Uuid of the microservice group.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_errorpageprofile "Module for setup of ErrorPageProfile Avi RESTful Object" b
avi_errorpageprofile: >
	name=${1:# Field introduced in 17.2.4.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	app_name=${5:# Name of the virtual service which generated the error page.}
	company_name=${6:# Name of the company to show in error page.}
	error_pages=${7:# Defined error pages for http status codes.}
	host_name=${8:# Fully qualified domain name for which the error page is generated.}
	tenant_ref=${9:# It is a reference to an object of type tenant.}
	url=${10:# Avi controller URL of the object.}
	uuid=${11:# Field introduced in 17.2.4.}
	controller=${12:}
	username=${13:}
	password=${14:}
	tenant=${15:admin}
	tenant_uuid=${16:}
	api_version=${17:16.4.4}
	avi_credentials=${18:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${19:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${20:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_seproperties "Module for setup of SeProperties Avi RESTful Object" b
avi_seproperties: >
	state=${1:absent|#present}
	avi_api_update_method=${2:#put|patch}
	avi_api_patch_op=${3:add|replace|delete}
	se_agent_properties=${4:# Seagentproperties settings for seproperties.}
	se_bootup_properties=${5:# Sebootupproperties settings for seproperties.}
	se_runtime_properties=${6:# Seruntimeproperties settings for seproperties.}
	url=${7:# Avi controller URL of the object.}
	uuid=${8:# Unique object identifier of the object.}
	controller=${9:}
	username=${10:}
	password=${11:}
	tenant=${12:admin}
	tenant_uuid=${13:}
	api_version=${14:16.4.4}
	avi_credentials=${15:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${16:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${17:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_gslbservice "Module for setup of GslbService Avi RESTful Object" b
avi_gslbservice: >
	name=${1:# Name for the gslb service.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	application_persistence_profile_ref=${5:# The federated application persistence associated with gslbservice site persistence functionality.}
	controller_health_status_enabled=${6:# Gs member's overall health status is derived based on a combination of controller and datapath health-status inputs.}
	created_by=${7:# Creator name.}
	description=${8:# User defined description for the object.}
	domain_names=${9:# Fully qualified domain name of the gslb service.}
	down_response=${10:# Response to the client query when the gslb service is down.}
	enabled=${11:# Enable or disable the gslb service.}
	groups=${12:# Select list of pools belonging to this gslb service.}
	health_monitor_refs=${13:# Verify vs health by applying one or more health monitors.}
	health_monitor_scope=${14:# Health monitor probe can be executed for all the members or it can be executed only for third-party members.}
	hm_off=${15:# This field is an internal field and is used in se.}
	is_federated=${16:# This field indicates that this object is replicated across gslb federation.}
	min_members=${17:# The minimum number of members to distribute traffic to.}
	num_dns_ip=${18:# Number of ip addresses of this gslb service to be returned by the dns service.}
	pool_algorithm=${19:# The load balancing algorithm will pick a gslb pool within the gslb service list of available pools.}
	site_persistence_enabled=${20:# Enable site-persistence for the gslbservice.}
	tenant_ref=${21:# It is a reference to an object of type tenant.}
	ttl=${22:# Ttl value (in seconds) for records served for this gslb service by the dns service.}
	url=${23:# Avi controller URL of the object.}
	use_edns_client_subnet=${24:# Use the client ip subnet from the edns option as source ipaddress for client geo-location and consistent hash algorithm.}
	uuid=${25:# Uuid of the gslb service.}
	wildcard_match=${26:# Enable wild-card match of fqdn  if an exact match is not found in the dns table, the longest match is chosen by wild-carding the fqdn in the dns}
	controller=${27:}
	username=${28:}
	password=${29:}
	tenant=${30:admin}
	tenant_uuid=${31:}
	api_version=${32:16.4.4}
	avi_credentials=${33:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${34:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${35:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_backup "Module for setup of Backup Avi RESTful Object" b
avi_backup: >
	file_name=${1:# The file name of backup.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	backup_config_ref=${5:# Backupconfiguration information.}
	local_file_url=${6:# Url to download the backup file.}
	remote_file_url=${7:# Url to download the backup file.}
	scheduler_ref=${8:# Scheduler information.}
	tenant_ref=${9:# It is a reference to an object of type tenant.}
	timestamp=${10:# Unix timestamp of when the backup file is created.}
	url=${11:# Avi controller URL of the object.}
	uuid=${12:# Unique object identifier of the object.}
	controller=${13:}
	username=${14:}
	password=${15:}
	tenant=${16:admin}
	tenant_uuid=${17:}
	api_version=${18:16.4.4}
	avi_credentials=${19:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${20:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${21:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_customipamdnsprofile "Module for setup of CustomIpamDnsProfile Avi RESTful Object" b
avi_customipamdnsprofile: >
	name=${1:# Name of the custom ipam dns profile.}
	script_uri=${2:# Script uri of form controller //ipamdnsscripts/<file-name>.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	script_params=${6:# Parameters that are always passed to the ipam/dns script.}
	tenant_ref=${7:# It is a reference to an object of type tenant.}
	url=${8:# Avi controller URL of the object.}
	uuid=${9:# Field introduced in 17.1.1.}
	controller=${10:}
	username=${11:}
	password=${12:}
	tenant=${13:admin}
	tenant_uuid=${14:}
	api_version=${15:16.4.4}
	avi_credentials=${16:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${17:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${18:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_serviceenginegroup "Module for setup of ServiceEngineGroup Avi RESTful Object" b
avi_serviceenginegroup: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	accelerated_networking=${5:# Enable accelerated networking option for azure se.}
	active_standby=${6:# Service engines in active/standby mode for ha failover.}
	additional_config_memory=${7:# Indicates the percent of config memory used for config updates.}
	advertise_backend_networks=${8:# Advertise reach-ability of backend server networks via adc through bgp for default gateway feature.}
	aggressive_failure_detection=${9:# Enable aggressive failover configuration for ha.}
	algo=${10:# In compact placement, virtual services are placed on existing ses until max_vs_per_se limit is reached.}
	allow_burst=${11:# Allow ses to be created using burst license.}
	app_cache_percent=${12:# A percent value of total se memory reserved for application caching.}
	app_learning_memory_percent=${13:# A percent value of total se memory reserved for application learning.}
	archive_shm_limit=${14:# Amount of se memory in gb until which shared memory is collected in core archive.}
	async_ssl=${15:# Ssl handshakes will be handled by dedicated ssl threads.}
	async_ssl_threads=${16:# Number of async ssl threads per se_dp.}
	auto_rebalance=${17:# If set, virtual services will be automatically migrated when load on an se is less than minimum or more than maximum thresholds.}
	auto_rebalance_capacity_per_se=${18:# Capacities of se for auto rebalance for each criteria.}
	auto_rebalance_criteria=${19:# Set of criteria for se auto rebalance.}
	auto_rebalance_interval=${20:# Frequency of rebalance, if 'auto rebalance' is enabled.}
	auto_redistribute_active_standby_load=${21:# Redistribution of virtual services from the takeover se to the replacement se can cause momentary traffic loss.}
	bgp_state_update_interval=${22:# Bgp peer state update interval.}
	buffer_se=${23:# Excess service engine capacity provisioned for ha failover.}
	cloud_ref=${24:# It is a reference to an object of type cloud.}
	config_debugs_on_all_cores=${25:# Enable config debugs on all cores of se.}
	connection_memory_percentage=${26:# Percentage of memory for connection state.}
	cpu_reserve=${27:# Boolean flag to set cpu_reserve.}
	cpu_socket_affinity=${28:# Allocate all the cpu cores for the service engine virtual machines  on the same cpu socket.}
	custom_securitygroups_data=${29:# Custom security groups to be associated with data vnics for se instances in openstack and aws clouds.}
	custom_securitygroups_mgmt=${30:# Custom security groups to be associated with management vnic for se instances in openstack and aws clouds.}
	custom_tag=${31:# Custom tag will be used to create the tags for se instance in aws.}
	data_network_id=${32:# Subnet used to spin up the data nic for service engines, used only for azure cloud.}
	datascript_timeout=${33:# Number of instructions before datascript times out.}
	dedicated_dispatcher_core=${34:# Dedicate the core that handles packet receive/transmit from the network to just the dispatching function.}
	description=${35:# User defined description for the object.}
	disable_avi_securitygroups=${36:# By default, avi creates and manages security groups along with custom sg provided by user.}
	disable_csum_offloads=${37:# Stop using tcp/udp and ip checksum offload features of nics.}
	disable_gro=${38:# Disable generic receive offload (gro) in dpdk poll-mode driver packet receive path.}
	disable_se_memory_check=${39:# If set, disable the config memory check done in service engine.}
	disable_tso=${40:# Disable tcp segmentation offload (tso) in dpdk poll-mode driver packet transmit path.}
	disk_per_se=${41:# Amount of disk space for each of the service engine virtual machines.}
	distribute_load_active_standby=${42:# Use both the active and standby service engines for virtual service placement in the legacy active standby ha mode.}
	distribute_queues=${43:# Distributes queue ownership among cores so multiple cores handle dispatcher duties.}
	enable_hsm_priming=${44:# (this is a beta feature).}
	enable_multi_lb=${45:# Applicable only for azure cloud with basic sku lb.}
	enable_routing=${46:# Enable routing for this serviceenginegroup .}
	enable_vip_on_all_interfaces=${47:# Enable vip on all interfaces of se.}
	enable_vmac=${48:# Use virtual mac address for interfaces on which floating interface ips are placed.}
	ephemeral_portrange_end=${49:# End local ephemeral port number for outbound connections.}
	ephemeral_portrange_start=${50:# Start local ephemeral port number for outbound connections.}
	extra_config_multiplier=${51:# Multiplier for extra config to support large vs/pool config.}
	extra_shared_config_memory=${52:# Extra config memory to support large geo db configuration.}
	floating_intf_ip=${53:# If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.}
	floating_intf_ip_se_2=${54:# If serviceenginegroup is configured for legacy 1+1 active standby ha mode, floating ip's will be advertised only by the active se in the pair.}
	flow_table_new_syn_max_entries=${55:# Maximum number of flow table entries that have not completed tcp three-way handshake yet.}
	free_list_size=${56:# Number of entries in the free list.}
	ha_mode=${57:# High availability mode for all the virtual services using this service engine group.}
	hardwaresecuritymodulegroup_ref=${58:# It is a reference to an object of type hardwaresecuritymodulegroup.}
	heap_minimum_config_memory=${59:# Minimum required heap memory to apply any configuration.}
	hm_on_standby=${60:# Enable active health monitoring from the standby se for all placed virtual services.}
	host_attribute_key=${61:# Key of a (key, value) pair identifying a label for a set of nodes usually in container clouds.}
	host_attribute_value=${62:# Value of a (key, value) pair identifying a label for a set of nodes usually in container clouds.}
	host_gateway_monitor=${63:# Enable the host gateway monitor when service engine is deployed as docker container.}
	hypervisor=${64:# Override default hypervisor.}
	ignore_rtt_threshold=${65:# Ignore rtt samples if it is above threshold.}
	ingress_access_data=${66:# Program se security group ingress rules to allow vip data access from remote cidr type.}
	ingress_access_mgmt=${67:# Program se security group ingress rules to allow ssh/icmp management access from remote cidr type.}
	instance_flavor=${68:# Instance/flavor name for se instance.}
	iptables=${69:# Iptables rules.}
	least_load_core_selection=${70:# Select core with least load for new flow.}
	license_tier=${71:# Specifies the license tier which would be used.}
	license_type=${72:# If no license type is specified then default license enforcement for the cloud type is chosen.}
	log_disksz=${73:# Maximum disk capacity (in mb) to be allocated to an se.}
	max_cpu_usage=${74:# When cpu usage on an se exceeds this threshold, virtual services hosted on this se may be rebalanced to other ses to reduce load.}
	max_memory_per_mempool=${75:# Max bytes that can be allocated in a single mempool.}
	max_public_ips_per_lb=${76:# Applicable to azure platform only.}
	max_rules_per_lb=${77:# Applicable to azure platform only.}
	max_scaleout_per_vs=${78:# Maximum number of active service engines for the virtual service.}
	max_se=${79:# Maximum number of services engines in this group.}
	max_vs_per_se=${80:# Maximum number of virtual services that can be placed on a single service engine.}
	mem_reserve=${81:# Boolean flag to set mem_reserve.}
	memory_for_config_update=${82:# Indicates the percent of memory reserved for config updates.}
	memory_per_se=${83:# Amount of memory for each of the service engine virtual machines.}
	mgmt_network_ref=${84:# Management network to use for avi service engines.}
	mgmt_subnet=${85:# Management subnet to use for avi service engines.}
	min_cpu_usage=${86:# When cpu usage on an se falls below the minimum threshold, virtual services hosted on the se may be consolidated onto other underutilized ses.}
	min_scaleout_per_vs=${87:# Minimum number of active service engines for the virtual service.}
	min_se=${88:# Minimum number of services engines in this group (relevant for se autorebalance only).}
	minimum_connection_memory=${89:# Indicates the percent of memory reserved for connections.}
	minimum_required_config_memory=${90:# Required available config memory to apply any configuration.}
	n_log_streaming_threads=${91:# Number of threads to use for log streaming.}
	non_significant_log_throttle=${92:# This setting limits the number of non-significant logs generated per second per core on this se.}
	num_dispatcher_cores=${93:# Number of dispatcher cores (0,1,2,4,8 or 16).}
	num_flow_cores_sum_changes_to_ignore=${94:# Number of changes in num flow cores sum to ignore.}
	openstack_availability_zone=${95:# Field deprecated in 17.1.1.}
	openstack_availability_zones=${96:# Field introduced in 17.1.1.}
	openstack_mgmt_network_name=${97:# Avi management network name.}
	openstack_mgmt_network_uuid=${98:# Management network uuid.}
	os_reserved_memory=${99:# Amount of extra memory to be reserved for use by the operating system on a service engine.}
	per_app=${100:# Per-app se mode is designed for deploying dedicated load balancers per app (vs).}
	placement_mode=${101:# If placement mode is 'auto', virtual services are automatically placed on service engines.}
	realtime_se_metrics=${102:# Enable or disable real time se metrics.}
	reboot_on_stop=${103:# Reboot the system if the se is stopped.}
	se_bandwidth_type=${104:# Select the se bandwidth for the bandwidth license.}
	se_deprovision_delay=${105:# Duration to preserve unused service engine virtual machines before deleting them.}
	se_dos_profile=${106:# Dosthresholdprofile settings for serviceenginegroup.}
	se_dpdk_pmd=${107:# Determines if dpdk pool mode driver should be used or not   0  automatically determine based on hypervisor/nic type 1  unconditionally use dpdk}
	se_flow_probe_retries=${108:# Flow probe retry count if no replies are received.}
	se_flow_probe_timer=${109:# Timeout in milliseconds for flow probe entries.}
	se_ipc_udp_port=${110:# Udp port for se_dp ipc in docker bridge mode.}
	se_name_prefix=${111:# Prefix to use for virtual machine name of service engines.}
	se_pcap_lookahead=${112:# Enables lookahead mode of packet receive in pcap mode.}
	se_pcap_reinit_frequency=${113:# Frequency in seconds at which periodically a pcap reinit check is triggered.}
	se_pcap_reinit_threshold=${114:# Threshold for input packet receive errors in pcap mode exceeding which a pcap reinit is triggered.}
	se_probe_port=${115:# Tcp port on se where echo service will be run.}
	se_remote_punt_udp_port=${116:# Udp port for punted packets in docker bridge mode.}
	se_routing=${117:# Enable routing via service engine datapath.}
	se_sb_dedicated_core=${118:# Sideband traffic will be handled by a dedicated core.}
	se_sb_threads=${119:# Number of sideband threads per se.}
	se_thread_multiplier=${120:# Multiplier for se threads based on vcpu.}
	se_tracert_port_range=${121:# Traceroute port range.}
	se_tunnel_mode=${122:# Determines if dsr from secondary se is active or not  0  automatically determine based on hypervisor type.}
	se_tunnel_udp_port=${123:# Udp port for tunneled packets from secondary to primary se in docker bridge mode.}
	se_udp_encap_ipc=${124:# Determines if se-se ipc messages are encapsulated in a udp header  0  automatically determine based on hypervisor type.}
	se_use_dpdk=${125:# Determines if dpdk library should be used or not   0  automatically determine based on hypervisor type 1  use dpdk if pcap is not enabled 2}
	se_vs_hb_max_pkts_in_batch=${126:# Maximum number of aggregated vs heartbeat packets to send in a batch.}
	se_vs_hb_max_vs_in_pkt=${127:# Maximum number of virtualservices for which heartbeat messages are aggregated in one packet.}
	self_se_election=${128:# Enable ses to elect a primary amongst themselves in the absence of a connectivity to controller.}
	service_ip6_subnets=${129:# Ipv6 subnets assigned to the se group.}
	service_ip_subnets=${130:# Subnets assigned to the se group.}
	shm_minimum_config_memory=${131:# Minimum required shared memory to apply any configuration.}
	significant_log_throttle=${132:# This setting limits the number of significant logs generated per second per core on this se.}
	ssl_preprocess_sni_hostname=${133:# (beta) preprocess ssl client hello for sni hostname extension.if set to true, this will apply sni child's ssl protocol(s), if they are different}
	tenant_ref=${134:# It is a reference to an object of type tenant.}
	udf_log_throttle=${135:# This setting limits the number of udf logs generated per second per core on this se.}
	url=${136:# Avi controller URL of the object.}
	use_standard_alb=${137:# Use standard sku azure load balancer.}
	uuid=${138:# Unique object identifier of the object.}
	vcenter_clusters=${139:# Vcenterclusters settings for serviceenginegroup.}
	vcenter_datastore_mode=${140:# Enum options - vcenter_datastore_any, vcenter_datastore_local, vcenter_datastore_shared.}
	vcenter_datastores=${141:# List of vcenterdatastore.}
	vcenter_datastores_include=${142:# Boolean flag to set vcenter_datastores_include.}
	vcenter_folder=${143:# Folder to place all the service engine virtual machines in vcenter.}
	vcenter_hosts=${144:# Vcenterhosts settings for serviceenginegroup.}
	vcpus_per_se=${145:# Number of vcpus for each of the service engine virtual machines.}
	vip_asg=${146:# When vip_asg is set, vip configuration will be managed by avi.user will be able to configure vip_asg or vips individually at the time of create.}
	vs_host_redundancy=${147:# Ensure primary and secondary service engines are deployed on different physical hosts.}
	vs_scalein_timeout=${148:# Time to wait for the scaled in se to drain existing flows before marking the scalein done.}
	vs_scalein_timeout_for_upgrade=${149:# During se upgrade, time to wait for the scaled-in se to drain existing flows before marking the scalein done.}
	vs_scaleout_timeout=${150:# Time to wait for the scaled out se to become ready before marking the scaleout done.}
	vs_se_scaleout_additional_wait_time=${151:# Wait time for sending scaleout ready notification after virtual service is marked up.}
	vs_se_scaleout_ready_timeout=${152:# Timeout in seconds for service engine to sendscaleout ready notification of a virtual service.}
	vs_switchover_timeout=${153:# During se upgrade in a legacy active/standby segroup, time to wait for the new primary se to accept flows before marking the switchover done.}
	vss_placement=${154:# Parameters to place virtual services on only a subset of the cores of an se.}
	vss_placement_enabled=${155:# If set, virtual services will be placed on only a subset of the cores of an se.}
	waf_learning_interval=${156:# Frequency with which se publishes waf learning.}
	waf_learning_memory=${157:# Amount of memory reserved on se for waf learning.}
	waf_mempool=${158:# Enable memory pool for waf.}
	waf_mempool_size=${159:# Memory pool size used for waf.}
	controller=${160:}
	username=${161:}
	password=${162:}
	tenant=${163:admin}
	tenant_uuid=${164:}
	api_version=${165:16.4.4}
	avi_credentials=${166:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${167:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${168:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_stringgroup "Module for setup of StringGroup Avi RESTful Object" b
avi_stringgroup: >
	name=${1:# Name of the string group.}
	type=${2:# Type of stringgroup.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	description=${6:# User defined description for the object.}
	kv=${7:# Configure key value in the string group.}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Uuid of the string group.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_networksecuritypolicy "Module for setup of NetworkSecurityPolicy Avi RESTful Object" b
avi_networksecuritypolicy: >
	state=${1:absent|#present}
	avi_api_update_method=${2:#put|patch}
	avi_api_patch_op=${3:add|replace|delete}
	cloud_config_cksum=${4:# Checksum of cloud configuration for network sec policy.}
	created_by=${5:# Creator name.}
	description=${6:# User defined description for the object.}
	name=${7:# Name of the object.}
	rules=${8:# List of networksecurityrule.}
	tenant_ref=${9:# It is a reference to an object of type tenant.}
	url=${10:# Avi controller URL of the object.}
	uuid=${11:# Unique object identifier of the object.}
	controller=${12:}
	username=${13:}
	password=${14:}
	tenant=${15:admin}
	tenant_uuid=${16:}
	api_version=${17:16.4.4}
	avi_credentials=${18:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${19:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${20:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_backupconfiguration "Module for setup of BackupConfiguration Avi RESTful Object" b
avi_backupconfiguration: >
	name=${1:# Name of backup configuration.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	aws_access_key=${5:# Aws access key id.}
	aws_bucket_id=${6:# Aws bucket.}
	aws_secret_access=${7:# Aws secret access key.}
	backup_file_prefix=${8:# Prefix of the exported configuration file.}
	backup_passphrase=${9:# Passphrase of backup configuration.}
	maximum_backups_stored=${10:# Rotate the backup files based on this count.}
	remote_directory=${11:# Directory at remote destination with write permission for ssh user.}
	remote_hostname=${12:# Remote destination.}
	save_local=${13:# Local backup.}
	ssh_user_ref=${14:# Access credentials for remote destination.}
	tenant_ref=${15:# It is a reference to an object of type tenant.}
	upload_to_remote_host=${16:# Remote backup.}
	upload_to_s3=${17:# Cloud backup.}
	url=${18:# Avi controller URL of the object.}
	uuid=${19:# Unique object identifier of the object.}
	controller=${20:}
	username=${21:}
	password=${22:}
	tenant=${23:admin}
	tenant_uuid=${24:}
	api_version=${25:16.4.4}
	avi_credentials=${26:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${27:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${28:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_cloud "Module for setup of Cloud Avi RESTful Object" b
avi_cloud: >
	name=${1:# Name of the object.}
	vtype=${2:# Cloud type.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	apic_configuration=${6:# Apicconfiguration settings for cloud.}
	apic_mode=${7:# Boolean flag to set apic_mode.}
	autoscale_polling_interval=${8:# Cloudconnector polling interval for external autoscale groups.}
	aws_configuration=${9:# Awsconfiguration settings for cloud.}
	azure_configuration=${10:# Field introduced in 17.2.1.}
	cloudstack_configuration=${11:# Cloudstackconfiguration settings for cloud.}
	custom_tags=${12:# Custom tags for all avi created resources in the cloud infrastructure.}
	dhcp_enabled=${13:# Select the ip address management scheme.}
	dns_provider_ref=${14:# Dns profile for the cloud.}
	docker_configuration=${15:# Dockerconfiguration settings for cloud.}
	east_west_dns_provider_ref=${16:# Dns profile for east-west services.}
	east_west_ipam_provider_ref=${17:# Ipam profile for east-west services.}
	enable_vip_static_routes=${18:# Use static routes for vip side network resolution during virtualservice placement.}
	gcp_configuration=${19:# Google cloud platform configuration.}
	ip6_autocfg_enabled=${20:# Enable ipv6 auto configuration.}
	ipam_provider_ref=${21:# Ipam profile for the cloud.}
	license_tier=${22:# Specifies the default license tier which would be used by new se groups.}
	license_type=${23:# If no license type is specified then default license enforcement for the cloud type is chosen.}
	linuxserver_configuration=${24:# Linuxserverconfiguration settings for cloud.}
	mesos_configuration=${25:# Field deprecated in 18.2.2.}
	mtu=${26:# Mtu setting for the cloud.}
	nsx_configuration=${27:# Configuration parameters for nsx manager.}
	obj_name_prefix=${28:# Default prefix for all automatically created objects in this cloud.}
	openstack_configuration=${29:# Openstackconfiguration settings for cloud.}
	oshiftk8s_configuration=${30:# Oshiftk8sconfiguration settings for cloud.}
	prefer_static_routes=${31:# Prefer static routes over interface routes during virtualservice placement.}
	proxy_configuration=${32:# Proxyconfiguration settings for cloud.}
	rancher_configuration=${33:# Rancherconfiguration settings for cloud.}
	state_based_dns_registration=${34:# Dns records for vips are added/deleted based on the operational state of the vips.}
	tenant_ref=${35:# It is a reference to an object of type tenant.}
	url=${36:# Avi controller URL of the object.}
	uuid=${37:# Unique object identifier of the object.}
	vca_configuration=${38:# Vcloudairconfiguration settings for cloud.}
	vcenter_configuration=${39:# Vcenterconfiguration settings for cloud.}
	controller=${40:}
	username=${41:}
	password=${42:}
	tenant=${43:admin}
	tenant_uuid=${44:}
	api_version=${45:16.4.4}
	avi_credentials=${46:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${47:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${48:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_dnspolicy "Module for setup of DnsPolicy Avi RESTful Object" b
avi_dnspolicy: >
	name=${1:# Name of the dns policy.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	created_by=${5:# Creator name.}
	description=${6:# Field introduced in 17.1.1.}
	rule=${7:# Dns rules.}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Uuid of the dns policy.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_api_session "Avi API Module" b
avi_api_session: >
	http_method=${1:get|put|post|patch|delete}

	data=${2:# HTTP body in YAML or JSON format.}
	params=${3:# Query parameters passed to the HTTP API.}
	path=${4:# Path for Avi API resource. For example, C(path: virtualservice) will translate to C(api/virtualserivce).}
	timeout=${5:60}
	controller=${6:}
	username=${7:}
	password=${8:}
	tenant=${9:admin}
	tenant_uuid=${10:}
	api_version=${11:16.4.4}
	avi_credentials=${12:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${13:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${14:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_webhook "Module for setup of Webhook Avi RESTful Object" b
avi_webhook: >
	name=${1:# The name of the webhook profile.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	callback_url=${5:# Callback url for the webhook.}
	description=${6:# Field introduced in 17.1.1.}
	tenant_ref=${7:# It is a reference to an object of type tenant.}
	url=${8:# Avi controller URL of the object.}
	uuid=${9:# Uuid of the webhook profile.}
	verification_token=${10:# Verification token sent back with the callback asquery parameters.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_tenant "Module for setup of Tenant Avi RESTful Object" b
avi_tenant: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	config_settings=${5:# Tenantconfiguration settings for tenant.}
	created_by=${6:# Creator of this tenant.}
	description=${7:# User defined description for the object.}
	local=${8:# Boolean flag to set local.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Unique object identifier of the object.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_alertscriptconfig "Module for setup of AlertScriptConfig Avi RESTful Object" b
avi_alertscriptconfig: >
	name=${1:# A user-friendly name of the script.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	action_script=${5:# User defined alert action script.}
	tenant_ref=${6:# It is a reference to an object of type tenant.}
	url=${7:# Avi controller URL of the object.}
	uuid=${8:# Unique object identifier of the object.}
	controller=${9:}
	username=${10:}
	password=${11:}
	tenant=${12:admin}
	tenant_uuid=${13:}
	api_version=${14:16.4.4}
	avi_credentials=${15:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${16:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${17:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_applicationpersistenceprofile "Module for setup of ApplicationPersistenceProfile Avi RESTful Object" b
avi_applicationpersistenceprofile: >
	name=${1:# A user-friendly name for the persistence profile.}
	persistence_type=${2:# Method used to persist clients to the same server for a duration of time or a session.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	app_cookie_persistence_profile=${6:# Specifies the application cookie persistence profile parameters.}
	description=${7:# User defined description for the object.}
	hdr_persistence_profile=${8:# Specifies the custom http header persistence profile parameters.}
	http_cookie_persistence_profile=${9:# Specifies the http cookie persistence profile parameters.}
	ip_persistence_profile=${10:# Specifies the client ip persistence profile parameters.}
	is_federated=${11:# This field describes the object's replication scope.}
	server_hm_down_recovery=${12:# Specifies behavior when a persistent server has been marked down by a health monitor.}
	tenant_ref=${13:# It is a reference to an object of type tenant.}
	url=${14:# Avi controller URL of the object.}
	uuid=${15:# Uuid of the persistence profile.}
	controller=${16:}
	username=${17:}
	password=${18:}
	tenant=${19:admin}
	tenant_uuid=${20:}
	api_version=${21:16.4.4}
	avi_credentials=${22:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${23:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${24:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_pkiprofile "Module for setup of PKIProfile Avi RESTful Object" b
avi_pkiprofile: >
	name=${1:# Name of the pki profile.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	ca_certs=${5:# List of certificate authorities (root and intermediate) trusted that is used for certificate validation.}
	created_by=${6:# Creator name.}
	crl_check=${7:# When enabled, avi will verify via crl checks that certificates in the trust chain have not been revoked.}
	crls=${8:# Certificate revocation lists.}
	ignore_peer_chain=${9:# When enabled, avi will not trust intermediate and root certs presented by a client.}
	is_federated=${10:# This field describes the object's replication scope.}
	tenant_ref=${11:# It is a reference to an object of type tenant.}
	url=${12:# Avi controller URL of the object.}
	uuid=${13:# Unique object identifier of the object.}
	validate_only_leaf_crl=${14:# When enabled, avi will only validate the revocation status of the leaf certificate using crl.}
	controller=${15:}
	username=${16:}
	password=${17:}
	tenant=${18:admin}
	tenant_uuid=${19:}
	api_version=${20:16.4.4}
	avi_credentials=${21:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${22:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${23:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_actiongroupconfig "Module for setup of ActionGroupConfig Avi RESTful Object" b
avi_actiongroupconfig: >
	external_only=${1:# Generate alert only to external destinations.}
	level=${2:# When an alert is generated, mark its priority via the alert level.}
	name=${3:# Name of the object.}

	state=${4:absent|#present}
	avi_api_update_method=${5:#put|patch}
	avi_api_patch_op=${6:add|replace|delete}
	action_script_config_ref=${7:# Reference of the action script configuration to be used.}
	autoscale_trigger_notification=${8:# Trigger notification to autoscale manager.}
	description=${9:# User defined description for the object.}
	email_config_ref=${10:# Select the email notification configuration to use when sending alerts via email.}
	snmp_trap_profile_ref=${11:# Select the snmp trap notification to use when sending alerts via snmp trap.}
	syslog_config_ref=${12:# Select the syslog notification configuration to use when sending alerts via syslog.}
	tenant_ref=${13:# It is a reference to an object of type tenant.}
	url=${14:# Avi controller URL of the object.}
	uuid=${15:# Unique object identifier of the object.}
	controller=${16:}
	username=${17:}
	password=${18:}
	tenant=${19:admin}
	tenant_uuid=${20:}
	api_version=${21:16.4.4}
	avi_credentials=${22:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${23:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${24:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_gslbservice_patch_member "Avi API Module" b
avi_gslbservice_patch_member: >
	name=${1:# Name of the GSLB Service}

	data=${2:# HTTP body of GSLB Service Member in YAML or JSON format.}
	params=${3:# Query parameters passed to the HTTP API.}
	state=${4:absent|#present}
	controller=${5:}
	username=${6:}
	password=${7:}
	tenant=${8:admin}
	tenant_uuid=${9:}
	api_version=${10:16.4.4}
	avi_credentials=${11:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${12:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${13:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_vsvip "Module for setup of VsVip Avi RESTful Object" b
avi_vsvip: >
	name=${1:# Name for the vsvip object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	cloud_ref=${5:# It is a reference to an object of type cloud.}
	dns_info=${6:# Service discovery specific data including fully qualified domain name, type and time-to-live of the dns record.}
	east_west_placement=${7:# Force placement on all service engines in the service engine group (container clouds only).}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	use_standard_alb=${10:# This overrides the cloud level default and needs to match the se group value in which it will be used if the se group use_standard_alb value is}
	uuid=${11:# Uuid of the vsvip object.}
	vip=${12:# List of virtual service ips and other shareable entities.}
	vrf_context_ref=${13:# Virtual routing context that the virtual service is bound to.}
	vsvip_cloud_config_cksum=${14:# Checksum of cloud configuration for vsvip.}
	controller=${15:}
	username=${16:}
	password=${17:}
	tenant=${18:admin}
	tenant_uuid=${19:}
	api_version=${20:16.4.4}
	avi_credentials=${21:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${22:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${23:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_cloudconnectoruser "Module for setup of CloudConnectorUser Avi RESTful Object" b
avi_cloudconnectoruser: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	azure_serviceprincipal=${5:# Field introduced in 17.2.1.}
	azure_userpass=${6:# Field introduced in 17.2.1.}
	gcp_credentials=${7:# Credentials for google cloud platform.}
	oci_credentials=${8:# Credentials for oracle cloud infrastructure.}
	private_key=${9:# Private_key of cloudconnectoruser.}
	public_key=${10:# Public_key of cloudconnectoruser.}
	tenant_ref=${11:# It is a reference to an object of type tenant.}
	tencent_credentials=${12:# Credentials for tencent cloud.}
	url=${13:# Avi controller URL of the object.}
	uuid=${14:# Unique object identifier of the object.}
	controller=${15:}
	username=${16:}
	password=${17:}
	tenant=${18:admin}
	tenant_uuid=${19:}
	api_version=${20:16.4.4}
	avi_credentials=${21:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${22:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${23:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_networkprofile "Module for setup of NetworkProfile Avi RESTful Object" b
avi_networkprofile: >
	name=${1:# The name of the network profile.}
	profile=${2:# Networkprofileunion settings for networkprofile.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	connection_mirror=${6:# When enabled, avi mirrors all tcp fastpath connections to standby.}
	description=${7:# User defined description for the object.}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Uuid of the network profile.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_alertconfig "Module for setup of AlertConfig Avi RESTful Object" b
avi_alertconfig: >
	alert_rule=${1:# List of filters matching on events or client logs used for triggering alerts.}
	category=${2:# Determines whether an alert is raised immediately when event occurs (realtime) or after specified number of events occurs within rolling time}
	name=${3:# Name of the alert configuration.}
	source=${4:# Signifies system events or the type of client logsused in this alert configuration.}

	state=${5:absent|#present}
	avi_api_update_method=${6:#put|patch}
	avi_api_patch_op=${7:add|replace|delete}
	action_group_ref=${8:# The alert config will trigger the selected alert action, which can send notifications and execute a controlscript.}
	autoscale_alert=${9:# This alert config applies to auto scale alerts.}
	description=${10:# A custom description field.}
	enabled=${11:# Enable or disable this alert config from generating new alerts.}
	expiry_time=${12:# An alert is expired and deleted after the expiry time has elapsed.}
	obj_uuid=${13:# Uuid of the resource for which alert was raised.}
	object_type=${14:# The object type to which the alert config is associated with.}
	recommendation=${15:# Recommendation of alertconfig.}
	rolling_window=${16:# Only if the number of events is reached or exceeded within the time window will an alert be generated.}
	summary=${17:# Summary of reason why alert is generated.}
	tenant_ref=${18:# It is a reference to an object of type tenant.}
	threshold=${19:# An alert is created only when the number of events meets or exceeds this number within the chosen time frame.}
	throttle=${20:# Alerts are suppressed (throttled) for this duration of time since the last alert was raised for this alert config.}
	url=${21:# Avi controller URL of the object.}
	uuid=${22:# Unique object identifier of the object.}
	controller=${23:}
	username=${24:}
	password=${25:}
	tenant=${26:admin}
	tenant_uuid=${27:}
	api_version=${28:16.4.4}
	avi_credentials=${29:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${30:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${31:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_serviceengine "Module for setup of ServiceEngine Avi RESTful Object" b
avi_serviceengine: >
	state=${1:absent|#present}
	avi_api_update_method=${2:#put|patch}
	avi_api_patch_op=${3:add|replace|delete}
	availability_zone=${4:# Availability_zone of serviceengine.}
	cloud_ref=${5:# It is a reference to an object of type cloud.}
	container_mode=${6:# Boolean flag to set container_mode.}
	container_type=${7:# Enum options - container_type_bridge, container_type_host, container_type_host_dpdk.}
	controller_created=${8:# Boolean flag to set controller_created.}
	controller_ip=${9:# Controller_ip of serviceengine.}
	data_vnics=${10:# List of vnic.}
	enable_state=${11:# Inorder to disable se set this field appropriately.}
	flavor=${12:# Flavor of serviceengine.}
	host_ref=${13:# It is a reference to an object of type vimgrhostruntime.}
	hypervisor=${14:# Enum options - default, vmware_esx, kvm, vmware_vsan, xen.}
	mgmt_vnic=${15:# Vnic settings for serviceengine.}
	name=${16:# Name of the object.}
	resources=${17:# Seresources settings for serviceengine.}
	se_group_ref=${18:# It is a reference to an object of type serviceenginegroup.}
	tenant_ref=${19:# It is a reference to an object of type tenant.}
	url=${20:# Avi controller URL of the object.}
	uuid=${21:# Unique object identifier of the object.}
	controller=${22:}
	username=${23:}
	password=${24:}
	tenant=${25:admin}
	tenant_uuid=${26:}
	api_version=${27:16.4.4}
	avi_credentials=${28:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${29:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${30:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_useraccount "Avi UserAccount Module" b
avi_useraccount: >
	old_password=${1:# Old password for update password or default password for bootstrap.}
	force_change=${2:# If specifically set to true then old password is tried first for controller and then the new password is tried. If not specified this flag then the new password is tried first.}
	controller=${3:}
	username=${4:}
	password=${5:}
	tenant=${6:admin}
	tenant_uuid=${7:}
	api_version=${8:16.4.4}
	avi_credentials=${9:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${10:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${11:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_systemconfiguration "Module for setup of SystemConfiguration Avi RESTful Object" b
avi_systemconfiguration: >
	state=${1:absent|#present}
	avi_api_update_method=${2:#put|patch}
	avi_api_patch_op=${3:add|replace|delete}
	admin_auth_configuration=${4:# Adminauthconfiguration settings for systemconfiguration.}
	default_license_tier=${5:# Specifies the default license tier which would be used by new clouds.}
	dns_configuration=${6:# Dnsconfiguration settings for systemconfiguration.}
	dns_virtualservice_refs=${7:# Dns virtualservices hosting fqdn records for applications across avi vantage.}
	docker_mode=${8:# Boolean flag to set docker_mode.}
	email_configuration=${9:# Emailconfiguration settings for systemconfiguration.}
	global_tenant_config=${10:# Tenantconfiguration settings for systemconfiguration.}
	linux_configuration=${11:# Linuxconfiguration settings for systemconfiguration.}
	mgmt_ip_access_control=${12:# Configure ip access control for controller to restrict open access.}
	ntp_configuration=${13:# Ntpconfiguration settings for systemconfiguration.}
	portal_configuration=${14:# Portalconfiguration settings for systemconfiguration.}
	proxy_configuration=${15:# Proxyconfiguration settings for systemconfiguration.}
	secure_channel_configuration=${16:# Configure secure channel properties.}
	snmp_configuration=${17:# Snmpconfiguration settings for systemconfiguration.}
	ssh_ciphers=${18:# Allowed ciphers list for ssh to the management interface on the controller and service engines.}
	ssh_hmacs=${19:# Allowed hmac list for ssh to the management interface on the controller and service engines.}
	url=${20:# Avi controller URL of the object.}
	uuid=${21:# Unique object identifier of the object.}
	welcome_workflow_complete=${22:# This flag is set once the initial controller setup workflow is complete.}
	controller=${23:}
	username=${24:}
	password=${25:}
	tenant=${26:admin}
	tenant_uuid=${27:}
	api_version=${28:16.4.4}
	avi_credentials=${29:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${30:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${31:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_gslbgeodbprofile "Module for setup of GslbGeoDbProfile Avi RESTful Object" b
avi_gslbgeodbprofile: >
	name=${1:# A user-friendly name for the geodb profile.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	description=${5:# Field introduced in 17.1.1.}
	entries=${6:# List of geodb entries.}
	is_federated=${7:# This field indicates that this object is replicated across gslb federation.}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Uuid of the geodb profile.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_useraccountprofile "Module for setup of UserAccountProfile Avi RESTful Object" b
avi_useraccountprofile: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	account_lock_timeout=${5:# Lock timeout period (in minutes).}
	credentials_timeout_threshold=${6:# The time period after which credentials expire.}
	max_concurrent_sessions=${7:# Maximum number of concurrent sessions allowed.}
	max_login_failure_count=${8:# Number of login attempts before lockout.}
	max_password_history_count=${9:# Maximum number of passwords to be maintained in the password history.}
	url=${10:# Avi controller URL of the object.}
	uuid=${11:# Unique object identifier of the object.}
	controller=${12:}
	username=${13:}
	password=${14:}
	tenant=${15:admin}
	tenant_uuid=${16:}
	api_version=${17:16.4.4}
	avi_credentials=${18:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${19:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${20:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_l4policyset "Module for setup of L4PolicySet Avi RESTful Object" b
avi_l4policyset: >
	name=${1:# Name of the l4 policy set.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	created_by=${5:# Creator name.}
	description=${6:# Field introduced in 17.2.7.}
	is_internal_policy=${7:# Field introduced in 17.2.7.}
	l4_connection_policy=${8:# Policy to apply when a new transport connection is setup.}
	tenant_ref=${9:# It is a reference to an object of type tenant.}
	url=${10:# Avi controller URL of the object.}
	uuid=${11:# Id of the l4 policy set.}
	controller=${12:}
	username=${13:}
	password=${14:}
	tenant=${15:admin}
	tenant_uuid=${16:}
	api_version=${17:16.4.4}
	avi_credentials=${18:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${19:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${20:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_role "Module for setup of Role Avi RESTful Object" b
avi_role: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	privileges=${5:# List of permission.}
	tenant_ref=${6:# It is a reference to an object of type tenant.}
	url=${7:# Avi controller URL of the object.}
	uuid=${8:# Unique object identifier of the object.}
	controller=${9:}
	username=${10:}
	password=${11:}
	tenant=${12:admin}
	tenant_uuid=${13:}
	api_version=${14:16.4.4}
	avi_credentials=${15:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${16:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${17:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_alertemailconfig "Module for setup of AlertEmailConfig Avi RESTful Object" b
avi_alertemailconfig: >
	name=${1:# A user-friendly name of the email notification service.}
	to_emails=${2:# Alerts are sent to the comma separated list of  email recipients.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	cc_emails=${6:# Alerts are copied to the comma separated list of  email recipients.}
	description=${7:# User defined description for the object.}
	tenant_ref=${8:# It is a reference to an object of type tenant.}
	url=${9:# Avi controller URL of the object.}
	uuid=${10:# Unique object identifier of the object.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_serverautoscalepolicy "Module for setup of ServerAutoScalePolicy Avi RESTful Object" b
avi_serverautoscalepolicy: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	description=${5:# User defined description for the object.}
	intelligent_autoscale=${6:# Use avi intelligent autoscale algorithm where autoscale is performed by comparing load on the pool against estimated capacity of all the servers.}
	intelligent_scalein_margin=${7:# Maximum extra capacity as percentage of load used by the intelligent scheme.}
	intelligent_scaleout_margin=${8:# Minimum extra capacity as percentage of load used by the intelligent scheme.}
	max_scalein_adjustment_step=${9:# Maximum number of servers to scalein simultaneously.}
	max_scaleout_adjustment_step=${10:# Maximum number of servers to scaleout simultaneously.}
	max_size=${11:# Maximum number of servers after scaleout.}
	min_size=${12:# No scale-in happens once number of operationally up servers reach min_servers.}
	scalein_alertconfig_refs=${13:# Trigger scalein when alerts due to any of these alert configurations are raised.}
	scalein_cooldown=${14:# Cooldown period during which no new scalein is triggered to allow previous scalein to successfully complete.}
	scaleout_alertconfig_refs=${15:# Trigger scaleout when alerts due to any of these alert configurations are raised.}
	scaleout_cooldown=${16:# Cooldown period during which no new scaleout is triggered to allow previous scaleout to successfully complete.}
	tenant_ref=${17:# It is a reference to an object of type tenant.}
	url=${18:# Avi controller URL of the object.}
	use_predicted_load=${19:# Use predicted load rather than current load.}
	uuid=${20:# Unique object identifier of the object.}
	controller=${21:}
	username=${22:}
	password=${23:}
	tenant=${24:admin}
	tenant_uuid=${25:}
	api_version=${26:16.4.4}
	avi_credentials=${27:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${28:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${29:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_sslprofile "Module for setup of SSLProfile Avi RESTful Object" b
avi_sslprofile: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	accepted_ciphers=${5:# Ciphers suites represented as defined by U(http://www.openssl.org/docs/apps/ciphers.html).}
	accepted_versions=${6:# Set of versions accepted by the server.}
	cipher_enums=${7:# Enum options - tls_ecdhe_ecdsa_with_aes_128_gcm_sha256, tls_ecdhe_ecdsa_with_aes_256_gcm_sha384, tls_ecdhe_rsa_with_aes_128_gcm_sha256,}
	description=${8:# User defined description for the object.}
	dhparam=${9:# Dh parameters used in ssl.}
	enable_ssl_session_reuse=${10:# Enable ssl session re-use.}
	prefer_client_cipher_ordering=${11:# Prefer the ssl cipher ordering presented by the client during the ssl handshake over the one specified in the ssl profile.}
	send_close_notify=${12:# Send 'close notify' alert message for a clean shutdown of the ssl connection.}
	ssl_rating=${13:# Sslrating settings for sslprofile.}
	ssl_session_timeout=${14:# The amount of time in seconds before an ssl session expires.}
	tags=${15:# List of tag.}
	tenant_ref=${16:# It is a reference to an object of type tenant.}
	type=${17:# Ssl profile type.}
	url=${18:# Avi controller URL of the object.}
	uuid=${19:# Unique object identifier of the object.}
	controller=${20:}
	username=${21:}
	password=${22:}
	tenant=${23:admin}
	tenant_uuid=${24:}
	api_version=${25:16.4.4}
	avi_credentials=${26:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${27:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${28:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_cloudproperties "Module for setup of CloudProperties Avi RESTful Object" b
avi_cloudproperties: >
	state=${1:absent|#present}
	avi_api_update_method=${2:#put|patch}
	avi_api_patch_op=${3:add|replace|delete}
	cc_props=${4:# Cloudconnector properties.}
	cc_vtypes=${5:# Cloud types supported by cloudconnector.}
	hyp_props=${6:# Hypervisor properties.}
	info=${7:# Properties specific to a cloud type.}
	url=${8:# Avi controller URL of the object.}
	uuid=${9:# Unique object identifier of the object.}
	controller=${10:}
	username=${11:}
	password=${12:}
	tenant=${13:admin}
	tenant_uuid=${14:}
	api_version=${15:16.4.4}
	avi_credentials=${16:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${17:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${18:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_sslkeyandcertificate "Module for setup of SSLKeyAndCertificate Avi RESTful Object" b
avi_sslkeyandcertificate: >
	certificate=${1:# Sslcertificate settings for sslkeyandcertificate.}
	name=${2:# Name of the object.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	ca_certs=${6:# Ca certificates in certificate chain.}
	certificate_base64=${7:# States if the certificate is base64 encoded.}
	certificate_management_profile_ref=${8:# It is a reference to an object of type certificatemanagementprofile.}
	created_by=${9:# Creator name.}
	dynamic_params=${10:# Dynamic parameters needed for certificate management profile.}
	enckey_base64=${11:# Encrypted private key corresponding to the private key (e.g.}
	enckey_name=${12:# Name of the encrypted private key (e.g.}
	format=${13:# Format of the key/certificate file.}
	hardwaresecuritymodulegroup_ref=${14:# It is a reference to an object of type hardwaresecuritymodulegroup.}
	key=${15:# Private key.}
	key_base64=${16:# States if the private key is base64 encoded.}
	key_params=${17:# Sslkeyparams settings for sslkeyandcertificate.}
	key_passphrase=${18:# Passphrase used to encrypt the private key.}
	status=${19:# Enum options - ssl_certificate_finished, ssl_certificate_pending.}
	tenant_ref=${20:# It is a reference to an object of type tenant.}
	type=${21:# Enum options - ssl_certificate_type_virtualservice, ssl_certificate_type_system, ssl_certificate_type_ca.}
	url=${22:# Avi controller URL of the object.}
	uuid=${23:# Unique object identifier of the object.}
	controller=${24:}
	username=${25:}
	password=${26:}
	tenant=${27:admin}
	tenant_uuid=${28:}
	api_version=${29:16.4.4}
	avi_credentials=${30:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${31:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${32:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_authprofile "Module for setup of AuthProfile Avi RESTful Object" b
avi_authprofile: >
	name=${1:# Name of the auth profile.}
	type=${2:# Type of the auth profile.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	description=${6:# User defined description for the object.}
	http=${7:# Http user authentication params.}
	ldap=${8:# Ldap server and directory settings.}
	pa_agent_ref=${9:# Pingaccessagent uuid.}
	saml=${10:# Saml settings.}
	tacacs_plus=${11:# Tacacs+ settings.}
	tenant_ref=${12:# It is a reference to an object of type tenant.}
	url=${13:# Avi controller URL of the object.}
	uuid=${14:# Uuid of the auth profile.}
	controller=${15:}
	username=${16:}
	password=${17:}
	tenant=${18:admin}
	tenant_uuid=${19:}
	api_version=${20:16.4.4}
	avi_credentials=${21:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${22:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${23:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_user "Avi User Module" b
avi_user: >
	name=${1:# Full name of the user.}
	obj_username=${2:# Name that the user will supply when signing into Avi Vantage, such as jdoe or jdoe@avinetworks.com.}
	obj_password=${3:# You may either enter a case-sensitive password in this field for the new or existing user.}

	state=${4:absent|#present}
	email=${5:# Email address of the user. This field is used when a user loses their password and requests to have it reset. See Password Recovery.}
	access=${6:# Access settings (write, read, or no access) for each type of resource within Vantage.}
	is_superuser=${7:# If the user will need to have the same privileges as the admin account, set it to true.}
	is_active=${8:# Activates the current user account.}
	avi_api_update_method=${9:post|#put|patch}
	avi_api_patch_op=${10:add|replace|delete}
	user_profile_ref=${11:# Refer user profile.}
	default_tenant_ref=${12:/api/tenant?name=admin}
	controller=${13:}
	username=${14:}
	password=${15:}
	tenant=${16:admin}
	tenant_uuid=${17:}
	api_version=${18:16.4.4}
	avi_credentials=${19:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${20:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${21:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_cluster "Module for setup of Cluster Avi RESTful Object" b
avi_cluster: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	nodes=${5:# List of clusternode.}
	rejoin_nodes_automatically=${6:# Re-join cluster nodes automatically in the event one of the node is reset to factory.}
	tenant_ref=${7:# It is a reference to an object of type tenant.}
	url=${8:# Avi controller URL of the object.}
	uuid=${9:# Unique object identifier of the object.}
	virtual_ip=${10:# A virtual ip address.}
	controller=${11:}
	username=${12:}
	password=${13:}
	tenant=${14:admin}
	tenant_uuid=${15:}
	api_version=${16:16.4.4}
	avi_credentials=${17:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${18:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${19:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_hardwaresecuritymodulegroup "Module for setup of HardwareSecurityModuleGroup Avi RESTful Object" b
avi_hardwaresecuritymodulegroup: >
	hsm=${1:# Hardware security module configuration.}
	name=${2:# Name of the hsm group configuration object.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	tenant_ref=${6:# It is a reference to an object of type tenant.}
	url=${7:# Avi controller URL of the object.}
	uuid=${8:# Uuid of the hsm group configuration object.}
	controller=${9:}
	username=${10:}
	password=${11:}
	tenant=${12:admin}
	tenant_uuid=${13:}
	api_version=${14:16.4.4}
	avi_credentials=${15:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${16:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${17:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_autoscalelaunchconfig "Module for setup of AutoScaleLaunchConfig Avi RESTful Object" b
avi_autoscalelaunchconfig: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	description=${5:# User defined description for the object.}
	image_id=${6:# Unique id of the amazon machine image (ami)  or openstack vm id.}
	mesos=${7:# Autoscalemesossettings settings for autoscalelaunchconfig.}
	openstack=${8:# Autoscaleopenstacksettings settings for autoscalelaunchconfig.}
	tenant_ref=${9:# It is a reference to an object of type tenant.}
	url=${10:# Avi controller URL of the object.}
	use_external_asg=${11:# If set to true, serverautoscalepolicy will use the autoscaling group (external_autoscaling_groups) from pool to perform scale up and scale down.}
	uuid=${12:# Unique object identifier of the object.}
	controller=${13:}
	username=${14:}
	password=${15:}
	tenant=${16:admin}
	tenant_uuid=${17:}
	api_version=${18:16.4.4}
	avi_credentials=${19:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${20:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${21:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_vrfcontext "Module for setup of VrfContext Avi RESTful Object" b
avi_vrfcontext: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	bgp_profile=${5:# Bgp local and peer info.}
	cloud_ref=${6:# It is a reference to an object of type cloud.}
	debugvrfcontext=${7:# Configure debug flags for vrf.}
	description=${8:# User defined description for the object.}
	gateway_mon=${9:# Configure ping based heartbeat check for gateway in service engines of vrf.}
	internal_gateway_monitor=${10:# Configure ping based heartbeat check for all default gateways in service engines of vrf.}
	static_routes=${11:# List of staticroute.}
	system_default=${12:# Boolean flag to set system_default.}
	tenant_ref=${13:# It is a reference to an object of type tenant.}
	url=${14:# Avi controller URL of the object.}
	uuid=${15:# Unique object identifier of the object.}
	controller=${16:}
	username=${17:}
	password=${18:}
	tenant=${19:admin}
	tenant_uuid=${20:}
	api_version=${21:16.4.4}
	avi_credentials=${22:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${23:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${24:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_certificatemanagementprofile "Module for setup of CertificateManagementProfile Avi RESTful Object" b
avi_certificatemanagementprofile: >
	name=${1:# Name of the pki profile.}
	script_path=${2:# Script_path of certificatemanagementprofile.}

	state=${3:absent|#present}
	avi_api_update_method=${4:#put|patch}
	avi_api_patch_op=${5:add|replace|delete}
	script_params=${6:# List of customparams.}
	tenant_ref=${7:# It is a reference to an object of type tenant.}
	url=${8:# Avi controller URL of the object.}
	uuid=${9:# Unique object identifier of the object.}
	controller=${10:}
	username=${11:}
	password=${12:}
	tenant=${13:admin}
	tenant_uuid=${14:}
	api_version=${15:16.4.4}
	avi_credentials=${16:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${17:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${18:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_network "Module for setup of Network Avi RESTful Object" b
avi_network: >
	name=${1:# Name of the object.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	cloud_ref=${5:# It is a reference to an object of type cloud.}
	configured_subnets=${6:# List of subnet.}
	dhcp_enabled=${7:# Select the ip address management scheme for this network.}
	exclude_discovered_subnets=${8:# When selected, excludes all discovered subnets in this network from consideration for virtual service placement.}
	ip6_autocfg_enabled=${9:# Enable ipv6 auto configuration.}
	synced_from_se=${10:# Boolean flag to set synced_from_se.}
	tenant_ref=${11:# It is a reference to an object of type tenant.}
	url=${12:# Avi controller URL of the object.}
	uuid=${13:# Unique object identifier of the object.}
	vcenter_dvs=${14:# Boolean flag to set vcenter_dvs.}
	vimgrnw_ref=${15:# It is a reference to an object of type vimgrnwruntime.}
	vrf_context_ref=${16:# It is a reference to an object of type vrfcontext.}
	controller=${17:}
	username=${18:}
	password=${19:}
	tenant=${20:admin}
	tenant_uuid=${21:}
	api_version=${22:16.4.4}
	avi_credentials=${23:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${24:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${25:# It disables avi session information to be cached as a fact.}

endsnippet

snippet avi_poolgroupdeploymentpolicy "Module for setup of PoolGroupDeploymentPolicy Avi RESTful Object" b
avi_poolgroupdeploymentpolicy: >
	name=${1:# The name of the pool group deployment policy.}

	state=${2:absent|#present}
	avi_api_update_method=${3:#put|patch}
	avi_api_patch_op=${4:add|replace|delete}
	auto_disable_old_prod_pools=${5:# It will automatically disable old production pools once there is a new production candidate.}
	description=${6:# User defined description for the object.}
	evaluation_duration=${7:# Duration of evaluation period for automatic deployment.}
	rules=${8:# List of pgdeploymentrule.}
	scheme=${9:# Deployment scheme.}
	target_test_traffic_ratio=${10:# Target traffic ratio before pool is made production.}
	tenant_ref=${11:# It is a reference to an object of type tenant.}
	test_traffic_ratio_rampup=${12:# Ratio of the traffic that is sent to the pool under test.}
	url=${13:# Avi controller URL of the object.}
	uuid=${14:# Uuid of the pool group deployment policy.}
	webhook_ref=${15:# Webhook configured with url that avi controller will pass back information about pool group, old and new pool information and current deployment}
	controller=${16:}
	username=${17:}
	password=${18:}
	tenant=${19:admin}
	tenant_uuid=${20:}
	api_version=${21:16.4.4}
	avi_credentials=${22:# Avi Credentials dictionary which can be used in lieu of enumerating Avi Controller login details.}
	api_context=${23:# Avi API context that includes current session ID and CSRF Token.}
	avi_disable_session_cache_as_fact=${24:# It disables avi session information to be cached as a fact.}

endsnippet

snippet exos_facts "Collect facts from devices running Extreme EXOS" b
exos_facts: >
	gather_subset=${1:['!config']}
	gather_network_resources=${2:# When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all and the resources like interfaces, vlans etc. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Valid subsets are 'all', 'lldp_global'.}

endsnippet

snippet exos_lldp_global "Configure and manage Link Layer Discovery Protocol(LLDP) attributes on EXOS platforms." b
exos_lldp_global: >
	config=${1:# A}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet exos_config "Manage Extreme Networks EXOS configuration sections" b
exos_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	src=${2:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines).}
	before=${3:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${4:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${5:#line|strict|exact|none}
	replace=${6:#line|block}
	backup=${7:no}
	running_config=${8:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	defaults=${9:no}
	save_when=${10:always|#never|modified|changed}
	diff_against=${11:#running|startup|intended}
	diff_ignore_lines=${12:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${13:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${14:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet exos_command "Run commands on remote devices running Extreme EXOS" b
exos_command: >
	commands=${1:# List of commands to send to the remote EXOS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet ironware_facts "Collect facts from devices running Extreme Ironware" b
ironware_facts: >
	gather_subset=${1:['!config', '!mpls']}
	authorize=${2:no}
	provider=${3:# B(Deprecated)}

endsnippet

snippet ironware_command "Run arbitrary commands on Extreme IronWare devices" b
ironware_command: >
	commands=${1:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	authorize=${6:no}
	provider=${7:# B(Deprecated)}

endsnippet

snippet ironware_config "Manage configuration sections on Extreme Ironware devices" b
ironware_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	update=${8:#merge|check}
	commit=${9:#merge|check}
	backup=${10:no}
	config=${11:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
	save_when=${12:always|#never|modified}
	backup_options=${13:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	authorize=${14:no}
	provider=${15:# B(Deprecated)}

endsnippet

snippet slxos_l2_interface "Manage Layer-2 interface on Extreme Networks SLX-OS devices." b
slxos_l2_interface: >
	name=${1:# Full name of the interface excluding any logical unit number, i.e. Ethernet 0/1.}

	mode=${2:#access|trunk}
	access_vlan=${3:# Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.}
	trunk_vlans=${4:# List of VLANs to be configured in trunk port. If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.}
	native_vlan=${5:# Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.}
	trunk_allowed_vlans=${6:# List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".}
	aggregate=${7:# List of Layer-2 interface definitions.}
	state=${8:#present|absent|unconfigured}

endsnippet

snippet slxos_config "Manage Extreme Networks SLX-OS configuration sections" b
slxos_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	multiline_delimiter=${8:@}
	backup=${9:no}
	running_config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	defaults=${11:no}
	save_when=${12:always|#never|modified|changed}
	diff_against=${13:running|startup|intended}
	diff_ignore_lines=${14:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${15:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${16:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet slxos_command "Run commands on remote devices running Extreme Networks SLX-OS" b
slxos_command: >
	commands=${1:# List of commands to send to the remote SLX-OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet slxos_l3_interface "Manage L3 interfaces on Extreme Networks SLX-OS network devices." b
slxos_l3_interface: >
	name=${1:# Name of the L3 interface to be configured eg. Ethernet 0/2}
	ipv4=${2:# IPv4 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24}
	ipv6=${3:# IPv6 address to be set for the L3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64}
	aggregate=${4:# List of L3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.}
	state=${5:#present|absent}

endsnippet

snippet slxos_lldp "Manage LLDP configuration on Extreme Networks SLX-OS network devices." b
slxos_lldp: >
	state=${1:#present|absent}

endsnippet

snippet slxos_interface "Manage Interfaces on Extreme SLX-OS network devices" b
slxos_interface: >
	name=${1:# Name of the Interface.}

	description=${2:# Description of Interface.}
	enabled=${3:yes}
	speed=${4:# Interface link speed.}
	mtu=${5:# Maximum size of transmit packet.}
	tx_rate=${6:# Transmit rate in bits per second (bps).}
	rx_rate=${7:# Receiver rate in bits per second (bps).}
	neighbors=${8:# Check the operational state of given interface C(name) for LLDP neighbor.}
	aggregate=${9:# L}
	delay=${10:10}
	state=${11:#present|absent|up|down}

endsnippet

snippet slxos_facts "Collect facts from devices running Extreme SLX-OS" b
slxos_facts: >
	gather_subset=${1:['!config']}

endsnippet

snippet slxos_linkagg "Manage link aggregation groups on Extreme Networks SLX-OS network devices" b
slxos_linkagg: >
	group=${1:# Channel-group number for the port-channel Link aggregation group. Range 1-1024.}
	mode=${2:active|on|passive}
	members=${3:# List of members of the link aggregation group.}
	aggregate=${4:# L}
	state=${5:#present|absent}
	purge=${6:# Purge links not defined in the I(aggregate) parameter.}

endsnippet

snippet slxos_vlan "Manage VLANs on Extreme Networks SLX-OS network devices" b
slxos_vlan: >
	vlan_id=${1:# ID of the VLAN. Range 1-4094.}
	interfaces=${2:# List of interfaces that should be associated to the VLAN.}

	name=${3:# Name of the VLAN.}
	delay=${4:10}
	aggregate=${5:# L}
	purge=${6:no}
	state=${7:#present|absent}

endsnippet

snippet netscaler_server "Manage server configuration" b
netscaler_server: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	name=${4:# Name for the server.}
	ipaddress=${5:# IPv4 or IPv6 address of the server. If you create an IP address based server, you can specify the name of the server, instead of its IP address, when creating a service. Note: If you do not create a server entry, the server IP address that you enter when you create a service becomes the name of the server.}
	domain=${6:# Domain name of the server. For a domain based configuration, you must create the server first.}
	translationip=${7:# IP address used to transform the server's DNS-resolved IP address.}
	translationmask=${8:# The netmask of the translation ip.}
	domainresolveretry=${9:5}
	ipv6address=${10:no}
	comment=${11:# Any information about the server.}
	td=${12:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
	graceful=${13:# Shut down gracefully, without accepting any new connections, and disabling each service when all of its connections are closed.}
	delay=${14:# Time, in seconds, after which all the services configured on the server are disabled.}
	disabled=${15:no}
	nitro_protocol=${16:#http|https}
	validate_certs=${17:yes}
	nitro_timeout=${18:310}
	state=${19:absent|#present}
	save_config=${20:yes}

endsnippet

snippet netscaler_servicegroup "Manage service group configuration in Netscaler" b
netscaler_servicegroup: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	servicegroupname=${4:# Name of the service group. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the name is created.}
	servicetype=${5:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX}
	cachetype=${6:TRANSPARENT|REVERSE|FORWARD}
	maxclient=${7:# Maximum number of simultaneous open connections for the service group.}
	maxreq=${8:# Maximum number of requests that can be sent on a persistent connection to the service group.}
	cacheable=${9:# Use the transparent cache redirection virtual server to forward the request to the cache server.}
	cip=${10:enabled|disabled}
	cipheader=${11:# Name of the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If client IP insertion is enabled, and the client IP header is not specified, the value of Client IP Header parameter or the value set by the set ns config command is used as client's IP header name.}
	usip=${12:# Use client's IP address as the source IP address when initiating connection to the server. With the NO setting, which is the default, a mapped IP (MIP) address or subnet IP (SNIP) address is used as the source IP address to initiate server side connections.}
	pathmonitor=${13:# Path monitoring for clustering.}
	pathmonitorindv=${14:# Individual Path monitoring decisions.}
	useproxyport=${15:# Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.}
	healthmonitor=${16:# Monitor the health of this service. Available settings function as follows:}
	sp=${17:# Enable surge protection for the service group.}
	rtspsessionidremap=${18:# Enable RTSP session ID mapping for the service group.}
	clttimeout=${19:# Time, in seconds, after which to terminate an idle client connection.}
	svrtimeout=${20:# Time, in seconds, after which to terminate an idle server connection.}
	cka=${21:# Enable client keep-alive for the service group.}
	tcpb=${22:# Enable TCP buffering for the service group.}
	cmp=${23:# Enable compression for the specified service.}
	maxbandwidth=${24:# Maximum bandwidth, in Kbps, allocated for all the services in the service group.}
	monthreshold=${25:# Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.}
	downstateflush=${26:enabled|disabled}
	tcpprofilename=${27:# Name of the TCP profile that contains TCP configuration settings for the service group.}
	httpprofilename=${28:# Name of the HTTP profile that contains HTTP configuration settings for the service group.}
	comment=${29:# Any information about the service group.}
	appflowlog=${30:enabled|disabled}
	netprofile=${31:# Network profile for the service group.}
	autoscale=${32:DISABLED|DNS|POLICY}
	memberport=${33:# member port.}
	graceful=${34:# Wait for all existing connections to the service to terminate before shutting down the service.}
	servicemembers=${35:# A list of dictionaries describing each service member of the service group.}
	monitorbindings=${36:# A list of monitornames to bind to this service}
	disabled=${37:no}
	nitro_protocol=${38:#http|https}
	validate_certs=${39:yes}
	nitro_timeout=${40:310}
	state=${41:absent|#present}
	save_config=${42:yes}

endsnippet

snippet netscaler_gslb_vserver "Configure gslb vserver entities in Netscaler." b
netscaler_gslb_vserver: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	name=${4:# Name for the GSLB virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.}
	servicetype=${5:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE}
	dnsrecordtype=${6:A|AAAA|CNAME|NAPTR}
	lbmethod=${7:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD}
	backuplbmethod=${8:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|STATICPROXIMITY|RTT|CUSTOMLOAD}
	netmask=${9:# IPv4 network mask for use in the SOURCEIPHASH load balancing method.}
	v6netmasklen=${10:# Number of bits to consider, in an IPv6 source IP address, for creating the hash that is required by the C(SOURCEIPHASH) load balancing method.}
	tolerance=${11:# Site selection tolerance, in milliseconds, for implementing the RTT load balancing method. If a site's RTT deviates from the lowest RTT by more than the specified tolerance, the site is not considered when the NetScaler appliance makes a GSLB decision. The appliance implements the round robin method of global server load balancing between sites whose RTT values are within the specified tolerance. If the tolerance is 0 (zero), the appliance always sends clients the IP address of the site with the lowest RTT.}
	persistencetype=${12:SOURCEIP|NONE}
	persistenceid=${13:# The persistence ID for the GSLB virtual server. The ID is a positive integer that enables GSLB sites to identify the GSLB virtual server, and is required if source IP address based or spill over based persistence is enabled on the virtual server.}
	persistmask=${14:# The optional IPv4 network mask applied to IPv4 addresses to establish source IP address based persistence.}
	v6persistmasklen=${15:# Number of bits to consider in an IPv6 source IP address when creating source IP address based persistence sessions.}
	timeout=${16:# Idle time, in minutes, after which a persistence entry is cleared.}
	mir=${17:enabled|disabled}
	disableprimaryondown=${18:enabled|disabled}
	dynamicweight=${19:SERVICECOUNT|SERVICEWEIGHT|DISABLED}
	considereffectivestate=${20:NONE|STATE_ONLY}
	comment=${21:# Any comments that you might want to associate with the GSLB virtual server.}
	somethod=${22:CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE}
	sopersistence=${23:enabled|disabled}
	sopersistencetimeout=${24:# Timeout for spillover persistence, in minutes.}
	sothreshold=${25:# Threshold at which spillover occurs. Specify an integer for the CONNECTION spillover method, a bandwidth value in kilobits per second for the BANDWIDTH method (do not enter the units), or a percentage for the HEALTH method (do not enter the percentage symbol).}
	sobackupaction=${26:DROP|ACCEPT|REDIRECT}
	appflowlog=${27:enabled|disabled}
	domain_bindings=${28:# List of bindings for domains for this glsb vserver.}
	service_bindings=${29:# List of bindings for gslb services bound to this gslb virtual server.}
	disabled=${30:no}
	nitro_protocol=${31:#http|https}
	validate_certs=${32:yes}
	nitro_timeout=${33:310}
	state=${34:absent|#present}
	save_config=${35:yes}

endsnippet

snippet netscaler_save_config "Save Netscaler configuration." b
netscaler_save_config: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	nitro_protocol=${4:#http|https}
	validate_certs=${5:yes}
	nitro_timeout=${6:310}

endsnippet

snippet netscaler_gslb_service "Manage gslb service entities in Netscaler." b
netscaler_gslb_service: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	servicename=${4:# Name for the GSLB service. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Can be changed after the GSLB service is created.}
	cnameentry=${5:# Canonical name of the GSLB service. Used in CNAME-based GSLB.}
	servername=${6:# Name of the server hosting the GSLB service.}
	servicetype=${7:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|NNTP|ANY|SIP_UDP|SIP_TCP|SIP_SSL|RADIUS|RDP|RTSP|MYSQL|MSSQL|ORACLE}
	port=${8:# Port on which the load balancing entity represented by this GSLB service listens.}
	publicip=${9:# The public IP address that a NAT device translates to the GSLB service's private IP address. Optional.}
	publicport=${10:# The public port associated with the GSLB service's public IP address. The port is mapped to the service's private port number. Applicable to the local GSLB service. Optional.}
	maxclient=${11:# The maximum number of open connections that the service can support at any given time. A GSLB service whose connection count reaches the maximum is not considered when a GSLB decision is made, until the connection count drops below the maximum.}
	healthmonitor=${12:# Monitor the health of the GSLB service.}
	sitename=${13:# Name of the GSLB site to which the service belongs.}
	cip=${14:enabled|disabled}
	cipheader=${15:# Name for the HTTP header that stores the client's IP address. Used with the Client IP option. If client IP header insertion is enabled on the service and a name is not specified for the header, the NetScaler appliance uses the name specified by the cipHeader parameter in the set ns param command or, in the GUI, the Client IP Header parameter in the Configure HTTP Parameters dialog box.}
	sitepersistence=${16:ConnectionProxy|HTTPRedirect|NONE}
	siteprefix=${17:# The site's prefix string. When the service is bound to a GSLB virtual server, a GSLB site domain is generated internally for each bound service-domain pair by concatenating the site prefix of the service and the name of the domain. If the special string NONE is specified, the site-prefix string is unset. When implementing HTTP redirect site persistence, the NetScaler appliance redirects GSLB requests to GSLB services by using their site domains.}
	clttimeout=${18:# Idle time, in seconds, after which a client connection is terminated. Applicable if connection proxy based site persistence is used.}
	maxbandwidth=${19:# Integer specifying the maximum bandwidth allowed for the service. A GSLB service whose bandwidth reaches the maximum is not considered when a GSLB decision is made, until its bandwidth consumption drops below the maximum.}
	downstateflush=${20:enabled|disabled}
	maxaaausers=${21:# Maximum number of SSL VPN users that can be logged on concurrently to the VPN virtual server that is represented by this GSLB service. A GSLB service whose user count reaches the maximum is not considered when a GSLB decision is made, until the count drops below the maximum.}
	monthreshold=${22:# Monitoring threshold value for the GSLB service. If the sum of the weights of the monitors that are bound to this GSLB service and are in the UP state is not equal to or greater than this threshold value, the service is marked as DOWN.}
	hashid=${23:# Unique hash identifier for the GSLB service, used by hash based load balancing methods.}
	comment=${24:# Any comments that you might want to associate with the GSLB service.}
	appflowlog=${25:enabled|disabled}
	ipaddress=${26:# IP address for the GSLB service. Should represent a load balancing, content switching, or VPN virtual server on the NetScaler appliance, or the IP address of another load balancing device.}
	monitor_bindings=${27:# Bind monitors to this gslb service}
	nitro_protocol=${28:#http|https}
	validate_certs=${29:yes}
	nitro_timeout=${30:310}
	state=${31:absent|#present}
	save_config=${32:yes}

endsnippet

snippet netscaler_cs_action "Manage content switching actions" b
netscaler_cs_action: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	name=${4:# Name for the content switching action. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the content switching action is created.}
	targetlbvserver=${5:# Name of the load balancing virtual server to which the content is switched.}
	targetvserver=${6:# Name of the VPN virtual server to which the content is switched.}
	targetvserverexpr=${7:# Information about this content switching action.}
	comment=${8:# Comments associated with this cs action.}
	nitro_protocol=${9:#http|https}
	validate_certs=${10:yes}
	nitro_timeout=${11:310}
	state=${12:absent|#present}
	save_config=${13:yes}

endsnippet

snippet netscaler_lb_vserver "Manage load balancing vserver configuration" b
netscaler_lb_vserver: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	name=${4:# Name for the virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the virtual server is created.}
	servicetype=${5:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|DNS|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|RTSP|PUSH|SSL_PUSH|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|TFTP|ORACLE|SMPP|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX}
	ipv46=${6:# IPv4 or IPv6 address to assign to the virtual server.}
	ippattern=${7:# IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.}
	ipmask=${8:# IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.}
	port=${9:# Port number for the virtual server.}
	range=${10:# Number of IP addresses that the appliance must generate and assign to the virtual server. The virtual server then functions as a network virtual server, accepting traffic on any of the generated IP addresses. The IP addresses are generated automatically, as follows:}
	persistencetype=${11:SOURCEIP|COOKIEINSERT|SSLSESSION|RULE|URLPASSIVE|CUSTOMSERVERID|DESTIP|SRCIPDESTIP|CALLID|RTSPSID|DIAMETER|FIXSESSION|NONE}
	timeout=${12:# Time period for which a persistence session is in effect.}
	persistencebackup=${13:SOURCEIP|NONE}
	backuppersistencetimeout=${14:# Time period for which backup persistence is in effect.}
	lbmethod=${15:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|URLHASH|DOMAINHASH|DESTINATIONIPHASH|SOURCEIPHASH|SRCIPDESTIPHASH|LEASTBANDWIDTH|LEASTPACKETS|TOKEN|SRCIPSRCPORTHASH|LRTM|CALLIDHASH|CUSTOMLOAD|LEASTREQUEST|AUDITLOGHASH|STATICPROXIMITY}
	hashlength=${16:# Number of bytes to consider for the hash value used in the URLHASH and DOMAINHASH load balancing methods.}
	netmask=${17:# IPv4 subnet mask to apply to the destination IP address or source IP address when the load balancing method is C(DESTINATIONIPHASH) or C(SOURCEIPHASH).}
	v6netmasklen=${18:# Number of bits to consider in an IPv6 destination or source IP address, for creating the hash that is required by the C(DESTINATIONIPHASH) and C(SOURCEIPHASH) load balancing methods.}
	backuplbmethod=${19:ROUNDROBIN|LEASTCONNECTION|LEASTRESPONSETIME|SOURCEIPHASH|LEASTBANDWIDTH|LEASTPACKETS|CUSTOMLOAD}
	cookiename=${20:# Use this parameter to specify the cookie name for C(COOKIE) persistence type. It specifies the name of cookie with a maximum of 32 characters. If not specified, cookie name is internally generated.}
	listenpolicy=${21:# Default syntax expression identifying traffic accepted by the virtual server. Can be either an expression (for example, C(CLIENT.IP.DST.IN_SUBNET(192.0.2.0/24)) or the name of a named expression. In the above example, the virtual server accepts all requests whose destination IP address is in the 192.0.2.0/24 subnet.}
	listenpriority=${22:# Integer specifying the priority of the listen policy. A higher number specifies a lower priority. If a request matches the listen policies of more than one virtual server the virtual server whose listen policy has the highest priority (the lowest priority number) accepts the request.}
	resrule=${23:# Default syntax expression specifying which part of a server's response to use for creating rule based persistence sessions (persistence type RULE). Can be either an expression or the name of a named expression.}
	persistmask=${24:# Persistence mask for IP based persistence types, for IPv4 virtual servers.}
	v6persistmasklen=${25:# Persistence mask for IP based persistence types, for IPv6 virtual servers.}
	rtspnat=${26:# Use network address translation (NAT) for RTSP data connections.}
	m=${27:IP|MAC|IPTUNNEL|TOS}
	tosid=${28:# TOS ID of the virtual server. Applicable only when the load balancing redirection mode is set to TOS.}
	datalength=${29:# Length of the token to be extracted from the data segment of an incoming packet, for use in the token method of load balancing. The length of the token, specified in bytes, must not be greater than 24 KB. Applicable to virtual servers of type TCP.}
	dataoffset=${30:# Offset to be considered when extracting a token from the TCP payload. Applicable to virtual servers, of type TCP, using the token method of load balancing. Must be within the first 24 KB of the TCP payload.}
	sessionless=${31:enabled|disabled}
	connfailover=${32:DISABLED|STATEFUL|STATELESS}
	redirurl=${33:# URL to which to redirect traffic if the virtual server becomes unavailable.}
	cacheable=${34:# Route cacheable requests to a cache redirection virtual server. The load balancing virtual server can forward requests only to a transparent cache redirection virtual server that has an IP address and port combination of *:80, so such a cache redirection virtual server must be configured on the appliance.}
	clttimeout=${35:# Idle time, in seconds, after which a client connection is terminated.}
	somethod=${36:CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE}
	sopersistence=${37:enabled|disabled}
	sopersistencetimeout=${38:# Timeout for spillover persistence, in minutes.}
	healththreshold=${39:# Threshold in percent of active services below which vserver state is made down. If this threshold is 0, vserver state will be up even if one bound service is up.}
	sothreshold=${40:# Threshold at which spillover occurs. Specify an integer for the C(CONNECTION) spillover method, a bandwidth value in kilobits per second for the C(BANDWIDTH) method (do not enter the units), or a percentage for the C(HEALTH) method (do not enter the percentage symbol).}
	sobackupaction=${41:DROP|ACCEPT|REDIRECT}
	redirectportrewrite=${42:enabled|disabled}
	downstateflush=${43:enabled|disabled}
	disableprimaryondown=${44:enabled|disabled}
	insertvserveripport=${45:OFF|VIPADDR|V6TOV4MAPPING}
	vipheader=${46:# Name for the inserted header. The default name is vip-header.}
	authenticationhost=${47:# Fully qualified domain name (FQDN) of the authentication virtual server to which the user must be redirected for authentication. Make sure that the Authentication parameter is set to C(yes).}
	authentication=${48:# Enable or disable user authentication.}
	authn401=${49:# Enable or disable user authentication with HTTP 401 responses.}
	authnvsname=${50:# Name of an authentication virtual server with which to authenticate users.}
	push=${51:enabled|disabled}
	pushvserver=${52:# Name of the load balancing virtual server, of type PUSH or SSL_PUSH, to which the server pushes updates received on the load balancing virtual server that you are configuring.}
	pushlabel=${53:# Expression for extracting a label from the server's response. Can be either an expression or the name of a named expression.}
	pushmulticlients=${54:# Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.}
	tcpprofilename=${55:# Name of the TCP profile whose settings are to be applied to the virtual server.}
	httpprofilename=${56:# Name of the HTTP profile whose settings are to be applied to the virtual server.}
	dbprofilename=${57:# Name of the DB profile whose settings are to be applied to the virtual server.}
	comment=${58:# Any comments that you might want to associate with the virtual server.}
	l2conn=${59:# Use Layer 2 parameters (channel number, MAC address, and VLAN ID) in addition to the 4-tuple (<source IP>:<source port>::<destination IP>:<destination port>) that is used to identify a connection. Allows multiple TCP and non-TCP connections with the same 4-tuple to co-exist on the NetScaler appliance.}
	oracleserverversion=${60:10G|11G}
	mssqlserverversion=${61:70|2000|2000SP1|2005|2008|2008R2|2012|2014}
	mysqlprotocolversion=${62:# MySQL protocol version that the virtual server advertises to clients.}
	mysqlserverversion=${63:# MySQL server version string that the virtual server advertises to clients.}
	mysqlcharacterset=${64:# Character set that the virtual server advertises to clients.}
	mysqlservercapabilities=${65:# Server capabilities that the virtual server advertises to clients.}
	appflowlog=${66:enabled|disabled}
	netprofile=${67:# Name of the network profile to associate with the virtual server. If you set this parameter, the virtual server uses only the IP addresses in the network profile as source IP addresses when initiating connections with servers.}
	icmpvsrresponse=${68:PASSIVE|ACTIVE}
	rhistate=${69:PASSIVE|ACTIVE}
	newservicerequest=${70:# Number of requests, or percentage of the load on existing services, by which to increase the load on a new service at each interval in slow-start mode. A non-zero value indicates that slow-start is applicable. A zero value indicates that the global RR startup parameter is applied. Changing the value to zero will cause services currently in slow start to take the full traffic as determined by the LB method. Subsequently, any new services added will use the global RR factor.}
	newservicerequestunit=${71:PER_SECOND|PERCENT}
	newservicerequestincrementinterval=${72:# Interval, in seconds, between successive increments in the load on a new service or a service whose state has just changed from DOWN to UP. A value of 0 (zero) specifies manual slow start.}
	minautoscalemembers=${73:# Minimum number of members expected to be present when vserver is used in Autoscale.}
	maxautoscalemembers=${74:# Maximum number of members expected to be present when vserver is used in Autoscale.}
	persistavpno=${75:# Persist AVP number for Diameter Persistency.}
	skippersistency=${76:Bypass|ReLb|None}
	td=${77:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
	authnprofile=${78:# Name of the authentication profile to be used when authentication is turned on.}
	macmoderetainvlan=${79:enabled|disabled}
	dbslb=${80:enabled|disabled}
	dns64=${81:enabled|disabled}
	bypassaaaa=${82:# If this option is enabled while resolving DNS64 query AAAA queries are not sent to back end dns server.}
	recursionavailable=${83:# When set to YES, this option causes the DNS replies from this vserver to have the RA bit turned on. Typically one would set this option to YES, when the vserver is load balancing a set of DNS servers thatsupport recursive queries.}
	processlocal=${84:enabled|disabled}
	dnsprofilename=${85:# Name of the DNS profile to be associated with the VServer. DNS profile properties will be applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.}
	servicebindings=${86:# List of services along with the weights that are load balanced.}
	servicegroupbindings=${87:# List of service groups along with the weights that are load balanced.}
	ssl_certkey=${88:# The name of the ssl certificate that is bound to this service.}
	disabled=${89:no}
	nitro_protocol=${90:#http|https}
	validate_certs=${91:yes}
	nitro_timeout=${92:310}
	state=${93:absent|#present}
	save_config=${94:yes}

endsnippet

snippet netscaler_cs_vserver "Manage content switching vserver" b
netscaler_cs_vserver: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	name=${4:# Name for the content switching virtual server. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space, colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters.}
	td=${5:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
	servicetype=${6:HTTP|SSL|TCP|FTP|RTSP|SSL_TCP|UDP|DNS|SIP_UDP|SIP_TCP|SIP_SSL|ANY|RADIUS|RDP|MYSQL|MSSQL|DIAMETER|SSL_DIAMETER|DNS_TCP|ORACLE|SMPP}
	ipv46=${7:# IP address of the content switching virtual server.}
	targettype=${8:GSLB}
	ippattern=${9:# IP address pattern, in dotted decimal notation, for identifying packets to be accepted by the virtual server. The IP Mask parameter specifies which part of the destination IP address is matched against the pattern. Mutually exclusive with the IP Address parameter.}
	ipmask=${10:# IP mask, in dotted decimal notation, for the IP Pattern parameter. Can have leading or trailing non-zero octets (for example, C(255.255.240.0) or C(0.0.255.255)). Accordingly, the mask specifies whether the first n bits or the last n bits of the destination IP address in a client request are to be matched with the corresponding bits in the IP pattern. The former is called a forward mask. The latter is called a reverse mask.}
	range=${11:# Number of consecutive IP addresses, starting with the address specified by the IP Address parameter, to include in a range of addresses assigned to this virtual server.}
	port=${12:# Port number for content switching virtual server.}
	stateupdate=${13:enabled|disabled}
	cacheable=${14:# Use this option to specify whether a virtual server, used for load balancing or content switching, routes requests to the cache redirection virtual server before sending it to the configured servers.}
	redirecturl=${15:# URL to which traffic is redirected if the virtual server becomes unavailable. The service type of the virtual server should be either C(HTTP) or C(SSL).}
	clttimeout=${16:# Idle time, in seconds, after which the client connection is terminated. The default values are:}
	precedence=${17:RULE|URL}
	casesensitive=${18:# Consider case in URLs (for policies that use URLs instead of RULES). For example, with the C(on) setting, the URLs /a/1.html and /A/1.HTML are treated differently and can have different targets (set by content switching policies). With the C(off) setting, /a/1.html and /A/1.HTML are switched to the same target.}
	somethod=${19:CONNECTION|DYNAMICCONNECTION|BANDWIDTH|HEALTH|NONE}
	sopersistence=${20:enabled|disabled}
	sopersistencetimeout=${21:# Time-out value, in minutes, for spillover persistence.}
	sothreshold=${22:# Depending on the spillover method, the maximum number of connections or the maximum total bandwidth (Kbps) that a virtual server can handle before spillover occurs.}
	sobackupaction=${23:DROP|ACCEPT|REDIRECT}
	redirectportrewrite=${24:enabled|disabled}
	downstateflush=${25:enabled|disabled}
	backupvserver=${26:# Name of the backup virtual server that you are configuring. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Can be changed after the backup virtual server is created. You can assign a different backup virtual server or rename the existing virtual server.}
	disableprimaryondown=${27:enabled|disabled}
	insertvserveripport=${28:OFF|VIPADDR|V6TOV4MAPPING}
	vipheader=${29:# Name of virtual server IP and port header, for use with the VServer IP Port Insertion parameter.}
	rtspnat=${30:# Enable network address translation (NAT) for real-time streaming protocol (RTSP) connections.}
	authenticationhost=${31:# FQDN of the authentication virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).}
	authentication=${32:# Authenticate users who request a connection to the content switching virtual server.}
	listenpolicy=${33:# String specifying the listen policy for the content switching virtual server. Can be either the name of an existing expression or an in-line expression.}
	authn401=${34:# Enable HTTP 401-response based authentication.}
	authnvsname=${35:# Name of authentication virtual server that authenticates the incoming user requests to this content switching virtual server. .}
	push=${36:enabled|disabled}
	pushvserver=${37:# Name of the load balancing virtual server, of type C(PUSH) or C(SSL_PUSH), to which the server pushes updates received on the client-facing load balancing virtual server.}
	pushlabel=${38:# Expression for extracting the label from the response received from server. This string can be either an existing rule name or an inline expression. The service type of the virtual server should be either C(HTTP) or C(SSL).}
	pushmulticlients=${39:# Allow multiple Web 2.0 connections from the same client to connect to the virtual server and expect updates.}
	tcpprofilename=${40:# Name of the TCP profile containing TCP configuration settings for the virtual server.}
	httpprofilename=${41:# Name of the HTTP profile containing HTTP configuration settings for the virtual server. The service type of the virtual server should be either C(HTTP) or C(SSL).}
	dbprofilename=${42:# Name of the DB profile.}
	oracleserverversion=${43:10G|11G}
	comment=${44:# Information about this virtual server.}
	mssqlserverversion=${45:70|2000|2000SP1|2005|2008|2008R2|2012|2014}
	l2conn=${46:# Use L2 Parameters to identify a connection.}
	mysqlprotocolversion=${47:# The protocol version returned by the mysql vserver.}
	mysqlserverversion=${48:# The server version string returned by the mysql vserver.}
	mysqlcharacterset=${49:# The character set returned by the mysql vserver.}
	mysqlservercapabilities=${50:# The server capabilities returned by the mysql vserver.}
	appflowlog=${51:enabled|disabled}
	netprofile=${52:# The name of the network profile.}
	icmpvsrresponse=${53:PASSIVE|ACTIVE}
	rhistate=${54:PASSIVE|ACTIVE}
	authnprofile=${55:# Name of the authentication profile to be used when authentication is turned on.}
	dnsprofilename=${56:# Name of the DNS profile to be associated with the VServer. DNS profile properties will applied to the transactions processed by a VServer. This parameter is valid only for DNS and DNS-TCP VServers.}
	domainname=${57:# Domain name for which to change the time to live (TTL) and/or backup service IP address.}
	ttl=${58:# .}
	backupip=${59:# .}
	cookiedomain=${60:# .}
	cookietimeout=${61:# .}
	sitedomainttl=${62:# .}
	lbvserver=${63:# The default Load Balancing virtual server.}
	ssl_certkey=${64:# The name of the ssl certificate that is bound to this service.}
	disabled=${65:no}
	nitro_protocol=${66:#http|https}
	validate_certs=${67:yes}
	nitro_timeout=${68:310}
	state=${69:absent|#present}
	save_config=${70:yes}

endsnippet

snippet netscaler_nitro_request "Issue Nitro API requests to a Netscaler instance." b
netscaler_nitro_request: >
	nitro_user=${1:# The username with which to authenticate to the Netscaler node.}
	nitro_pass=${2:# The password with which to authenticate to the Netscaler node.}
	expected_nitro_errorcode=${3:[0]}

	nsip=${4:# The IP address of the Netscaler or MAS instance where the Nitro API calls will be made.}
	nitro_protocol=${5:#http|https}
	validate_certs=${6:yes}
	nitro_auth_token=${7:# The authentication token provided by the C(mas_login) operation. It is required when issuing Nitro API calls through a MAS proxy.}
	resource=${8:# The type of resource we are operating on.}
	name=${9:# The name of the resource we are operating on.}
	attributes=${10:# The attributes of the Nitro object we are operating on.}
	args=${11:# A dictionary which defines the key arguments by which we will select the Nitro object to operate on.}
	filter=${12:# A dictionary which defines the filter with which to refine the Nitro objects returned by the C(get_filtered) I(operation).}
	operation=${13:add|update|get|get_by_args|get_filtered|get_all|delete|delete_by_args|count|mas_login|save_config|action}
	action=${14:# The action to perform when the I(operation) value is set to C(action).}
	instance_ip=${15:# The IP address of the target Netscaler instance when issuing a Nitro request through a MAS proxy.}
	instance_name=${16:# The name of the target Netscaler instance when issuing a Nitro request through a MAS proxy.}
	instance_id=${17:# The id of the target Netscaler instance when issuing a Nitro request through a MAS proxy.}

endsnippet

snippet netscaler_cs_policy "Manage content switching policy" b
netscaler_cs_policy: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	policyname=${4:# Name for the content switching policy. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at sign C(@), equal sign C(=), and hyphen C(-) characters. Cannot be changed after a policy is created.}
	url=${5:# URL string that is matched with the URL of a request. Can contain a wildcard character. Specify the string value in the following format: C([[prefix] [*]] [.suffix]).}
	rule=${6:# Expression, or name of a named expression, against which traffic is evaluated. Written in the classic or default syntax.}
	domain=${7:# The domain name. The string value can range to 63 characters.}
	action=${8:# Content switching action that names the target load balancing virtual server to which the traffic is switched.}
	nitro_protocol=${9:#http|https}
	validate_certs=${10:yes}
	nitro_timeout=${11:310}
	state=${12:absent|#present}
	save_config=${13:yes}

endsnippet

snippet netscaler_lb_monitor "Manage load balancing monitors" b
netscaler_lb_monitor: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	monitorname=${4:# Name for the monitor. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore, hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters.}
	type=${5:PING|TCP|HTTP|TCP-ECV|HTTP-ECV|UDP-ECV|DNS|FTP|LDNS-PING|LDNS-TCP|LDNS-DNS|RADIUS|USER|HTTP-INLINE|SIP-UDP|SIP-TCP|LOAD|FTP-EXTENDED|SMTP|SNMP|NNTP|MYSQL|MYSQL-ECV|MSSQL-ECV|ORACLE-ECV|LDAP|POP3|CITRIX-XML-SERVICE|CITRIX-WEB-INTERFACE|DNS-TCP|RTSP|ARP|CITRIX-AG|CITRIX-AAC-LOGINPAGE|CITRIX-AAC-LAS|CITRIX-XD-DDC|ND6|CITRIX-WI-EXTENDED|DIAMETER|RADIUS_ACCOUNTING|STOREFRONT|APPC|SMPP|CITRIX-XNC-ECV|CITRIX-XDM|CITRIX-STA-SERVICE|CITRIX-STA-SERVICE-NHOP}
	action=${6:NONE|LOG|DOWN}
	respcode=${7:# Response codes for which to mark the service as UP. For any other response code, the action performed depends on the monitor type. C(HTTP) monitors and C(RADIUS) monitors mark the service as C(DOWN), while C(HTTP-INLINE) monitors perform the action indicated by the Action parameter.}
	httprequest=${8:# HTTP request to send to the server (for example, C("HEAD /file.html")).}
	rtsprequest=${9:# RTSP request to send to the server (for example, C("OPTIONS *")).}
	customheaders=${10:# Custom header string to include in the monitoring probes.}
	maxforwards=${11:# Maximum number of hops that the SIP request used for monitoring can traverse to reach the server. Applicable only to monitors of type C(SIP-UDP).}
	sipmethod=${12:OPTIONS|INVITE|REGISTER}
	sipuri=${13:# SIP URI string to send to the service (for example, C(sip:sip.test)). Applicable only to monitors of type C(SIP-UDP).}
	sipreguri=${14:# SIP user to be registered. Applicable only if the monitor is of type C(SIP-UDP) and the SIP Method parameter is set to C(REGISTER).}
	send=${15:# String to send to the service. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.}
	recv=${16:# String expected from the server for the service to be marked as UP. Applicable to C(TCP-ECV), C(HTTP-ECV), and C(UDP-ECV) monitors.}
	query=${17:# Domain name to resolve as part of monitoring the DNS service (for example, C(example.com)).}
	querytype=${18:Address|Zone|AAAA}
	scriptname=${19:# Path and name of the script to execute. The script must be available on the NetScaler appliance, in the /nsconfig/monitors/ directory.}
	scriptargs=${20:# String of arguments for the script. The string is copied verbatim into the request.}
	dispatcherip=${21:# IP address of the dispatcher to which to send the probe.}
	dispatcherport=${22:# Port number on which the dispatcher listens for the monitoring probe.}
	username=${23:# User name with which to probe the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC) or C(CITRIX-XDM) server.}
	password=${24:# Password that is required for logging on to the C(RADIUS), C(NNTP), C(FTP), C(FTP-EXTENDED), C(MYSQL), C(MSSQL), C(POP3), C(CITRIX-AG), C(CITRIX-XD-DDC), C(CITRIX-WI-EXTENDED), C(CITRIX-XNC-ECV) or C(CITRIX-XDM) server. Used in conjunction with the user name specified for the C(username) parameter.}
	secondarypassword=${25:# Secondary password that users might have to provide to log on to the Access Gateway server. Applicable to C(CITRIX-AG) monitors.}
	logonpointname=${26:# Name of the logon point that is configured for the Citrix Access Gateway Advanced Access Control software. Required if you want to monitor the associated login page or Logon Agent. Applicable to C(CITRIX-AAC-LAS) and C(CITRIX-AAC-LOGINPAGE) monitors.}
	lasversion=${27:# Version number of the Citrix Advanced Access Control Logon Agent. Required by the C(CITRIX-AAC-LAS) monitor.}
	radkey=${28:# Authentication key (shared secret text string) for RADIUS clients and servers to exchange. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).}
	radnasid=${29:# NAS-Identifier to send in the Access-Request packet. Applicable to monitors of type C(RADIUS).}
	radnasip=${30:# Network Access Server (NAS) IP address to use as the source IP address when monitoring a RADIUS server. Applicable to monitors of type C(RADIUS) and C(RADIUS_ACCOUNTING).}
	radaccounttype=${31:# Account Type to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
	radframedip=${32:# Source ip with which the packet will go out . Applicable to monitors of type C(RADIUS_ACCOUNTING).}
	radapn=${33:# Called Station Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
	radmsisdn=${34:# Calling Stations Id to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
	radaccountsession=${35:# Account Session ID to be used in Account Request Packet. Applicable to monitors of type C(RADIUS_ACCOUNTING).}
	lrtm=${36:enabled|disabled}
	deviation=${37:# Time value added to the learned average response time in dynamic response time monitoring (DRTM). When a deviation is specified, the appliance learns the average response time of bound services and adds the deviation to the average. The final value is then continually adjusted to accommodate response time variations over time. Specified in milliseconds, seconds, or minutes.}
	units1=${38:SEC|MSEC|MIN}
	interval=${39:# Time interval between two successive probes. Must be greater than the value of Response Time-out.}
	units3=${40:SEC|MSEC|MIN}
	resptimeout=${41:# Amount of time for which the appliance must wait before it marks a probe as FAILED. Must be less than the value specified for the Interval parameter.}
	units4=${42:SEC|MSEC|MIN}
	resptimeoutthresh=${43:# Response time threshold, specified as a percentage of the Response Time-out parameter. If the response to a monitor probe has not arrived when the threshold is reached, the appliance generates an SNMP trap called monRespTimeoutAboveThresh. After the response time returns to a value below the threshold, the appliance generates a monRespTimeoutBelowThresh SNMP trap. For the traps to be generated, the "MONITOR-RTO-THRESHOLD" alarm must also be enabled.}
	retries=${44:# Maximum number of probes to send to establish the state of a service for which a monitoring probe failed.}
	failureretries=${45:# Number of retries that must fail, out of the number specified for the Retries parameter, for a service to be marked as DOWN. For example, if the Retries parameter is set to 10 and the Failure Retries parameter is set to 6, out of the ten probes sent, at least six probes must fail if the service is to be marked as DOWN. The default value of 0 means that all the retries must fail if the service is to be marked as DOWN.}
	alertretries=${46:# Number of consecutive probe failures after which the appliance generates an SNMP trap called monProbeFailed.}
	successretries=${47:# Number of consecutive successful probes required to transition a service's state from DOWN to UP.}
	downtime=${48:# Time duration for which to wait before probing a service that has been marked as DOWN. Expressed in milliseconds, seconds, or minutes.}
	units2=${49:SEC|MSEC|MIN}
	destip=${50:# IP address of the service to which to send probes. If the parameter is set to 0, the IP address of the server to which the monitor is bound is considered the destination IP address.}
	destport=${51:# TCP or UDP port to which to send the probe. If the parameter is set to 0, the port number of the service to which the monitor is bound is considered the destination port. For a monitor of type C(USER), however, the destination port is the port number that is included in the HTTP request sent to the dispatcher. Does not apply to monitors of type C(PING).}
	state=${52:enabled|disabled}
	reverse=${53:# Mark a service as DOWN, instead of UP, when probe criteria are satisfied, and as UP instead of DOWN when probe criteria are not satisfied.}
	transparent=${54:# The monitor is bound to a transparent device such as a firewall or router. The state of a transparent device depends on the responsiveness of the services behind it. If a transparent device is being monitored, a destination IP address must be specified. The probe is sent to the specified IP address by using the MAC address of the transparent device.}
	iptunnel=${55:# Send the monitoring probe to the service through an IP tunnel. A destination IP address must be specified.}
	tos=${56:# Probe the service by encoding the destination IP address in the IP TOS (6) bits.}
	tosid=${57:# The TOS ID of the specified destination IP. Applicable only when the TOS parameter is set.}
	secure=${58:# Use a secure SSL connection when monitoring a service. Applicable only to TCP based monitors. The secure option cannot be used with a C(CITRIX-AG) monitor, because a CITRIX-AG monitor uses a secure connection by default.}
	validatecred=${59:# Validate the credentials of the Xen Desktop DDC server user. Applicable to monitors of type C(CITRIX-XD-DDC).}
	domain=${60:# Domain in which the XenDesktop Desktop Delivery Controller (DDC) servers or Web Interface servers are present. Required by C(CITRIX-XD-DDC) and C(CITRIX-WI-EXTENDED) monitors for logging on to the DDC servers and Web Interface servers, respectively.}
	ipaddress=${61:# Set of IP addresses expected in the monitoring response from the DNS server, if the record type is A or AAAA. Applicable to C(DNS) monitors.}
	group=${62:# Name of a newsgroup available on the NNTP service that is to be monitored. The appliance periodically generates an NNTP query for the name of the newsgroup and evaluates the response. If the newsgroup is found on the server, the service is marked as UP. If the newsgroup does not exist or if the search fails, the service is marked as DOWN. Applicable to NNTP monitors.}
	filename=${63:# Name of a file on the FTP server. The appliance monitors the FTP service by periodically checking the existence of the file on the server. Applicable to C(FTP-EXTENDED) monitors.}
	basedn=${64:# The base distinguished name of the LDAP service, from where the LDAP server can begin the search for the attributes in the monitoring query. Required for C(LDAP) service monitoring.}
	binddn=${65:# The distinguished name with which an LDAP monitor can perform the Bind operation on the LDAP server. Optional. Applicable to C(LDAP) monitors.}
	filter=${66:# Filter criteria for the LDAP query. Optional.}
	attribute=${67:# Attribute to evaluate when the LDAP server responds to the query. Success or failure of the monitoring probe depends on whether the attribute exists in the response. Optional.}
	database=${68:# Name of the database to connect to during authentication.}
	oraclesid=${69:# Name of the service identifier that is used to connect to the Oracle database during authentication.}
	sqlquery=${70:# SQL query for a C(MYSQL-ECV) or C(MSSQL-ECV) monitor. Sent to the database server after the server authenticates the connection.}
	evalrule=${71:# Default syntax expression that evaluates the database server's response to a MYSQL-ECV or MSSQL-ECV monitoring query. Must produce a Boolean result. The result determines the state of the server. If the expression returns TRUE, the probe succeeds.}
	mssqlprotocolversion=${72:70|2000|2000SP1|2005|2008|2008R2|2012|2014}
	Snmpoid=${73:# SNMP OID for C(SNMP) monitors.}
	snmpcommunity=${74:# Community name for C(SNMP) monitors.}
	snmpthreshold=${75:# Threshold for C(SNMP) monitors.}
	snmpversion=${76:V1|V2}
	metrictable=${77:# Metric table to which to bind metrics.}
	application=${78:# Name of the application used to determine the state of the service. Applicable to monitors of type C(CITRIX-XML-SERVICE).}
	sitepath=${79:# URL of the logon page. For monitors of type C(CITRIX-WEB-INTERFACE), to monitor a dynamic page under the site path, terminate the site path with a slash C(/). Applicable to C(CITRIX-WEB-INTERFACE), C(CITRIX-WI-EXTENDED) and C(CITRIX-XDM) monitors.}
	storename=${80:# Store Name. For monitors of type C(STOREFRONT), C(storename) is an optional argument defining storefront service store name. Applicable to C(STOREFRONT) monitors.}
	storefrontacctservice=${81:# Enable/Disable probing for Account Service. Applicable only to Store Front monitors. For multi-tenancy configuration users my skip account service.}
	hostname=${82:# Hostname in the FQDN format (Example: C(porche.cars.org)). Applicable to C(STOREFRONT) monitors.}
	netprofile=${83:# Name of the network profile.}
	originhost=${84:# Origin-Host value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
	originrealm=${85:# Origin-Realm value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
	hostipaddress=${86:# Host-IP-Address value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. If Host-IP-Address is not specified, the appliance inserts the mapped IP (MIP) address or subnet IP (SNIP) address from which the CER request (the monitoring probe) is sent.}
	vendorid=${87:# Vendor-Id value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
	productname=${88:# Product-Name value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
	firmwarerevision=${89:# Firmware-Revision value for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers.}
	authapplicationid=${90:# List of Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring CER message.}
	acctapplicationid=${91:# List of Acct-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message.}
	inbandsecurityid=${92:NO_INBAND_SECURITY|TLS}
	supportedvendorids=${93:# List of Supported-Vendor-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum eight of these AVPs are supported in a monitoring message.}
	vendorspecificvendorid=${94:# Vendor-Id to use in the Vendor-Specific-Application-Id grouped attribute-value pair (AVP) in the monitoring CER message. To specify Auth-Application-Id or Acct-Application-Id in Vendor-Specific-Application-Id, use vendorSpecificAuthApplicationIds or vendorSpecificAcctApplicationIds, respectively. Only one Vendor-Id is supported for all the Vendor-Specific-Application-Id AVPs in a CER monitoring message.}
	vendorspecificauthapplicationids=${95:# List of Vendor-Specific-Auth-Application-Id attribute value pairs (AVPs) for the Capabilities-Exchange-Request (CER) message to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.}
	vendorspecificacctapplicationids=${96:# List of Vendor-Specific-Acct-Application-Id attribute value pairs (AVPs) to use for monitoring Diameter servers. A maximum of eight of these AVPs are supported in a monitoring message. The specified value is combined with the value of vendorSpecificVendorId to obtain the Vendor-Specific-Application-Id AVP in the CER monitoring message.}
	kcdaccount=${97:# KCD Account used by C(MSSQL) monitor.}
	storedb=${98:enabled|disabled}
	storefrontcheckbackendservices=${99:# This option will enable monitoring of services running on storefront server. Storefront services are monitored by probing to a Windows service that runs on the Storefront server and exposes details of which storefront services are running.}
	trofscode=${100:# Code expected when the server is under maintenance.}
	trofsstring=${101:# String expected from the server for the service to be marked as trofs. Applicable to HTTP-ECV/TCP-ECV monitors.}
	nitro_protocol=${102:#http|https}
	validate_certs=${103:yes}
	nitro_timeout=${104:310}
	save_config=${105:yes}

endsnippet

snippet netscaler_ssl_certkey "Manage ssl certificate keys." b
netscaler_ssl_certkey: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	certkey=${4:# Name for the certificate and private-key pair. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the certificate-key pair is created.}
	cert=${5:# Name of and, optionally, path to the X509 certificate file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.}
	key=${6:# Name of and, optionally, path to the private-key file that is used to form the certificate-key pair. The certificate file should be present on the appliance's hard-disk drive or solid-state drive. Storing a certificate in any location other than the default might cause inconsistency in a high availability setup. /nsconfig/ssl/ is the default path.}
	password=${7:# Passphrase that was used to encrypt the private-key. Use this option to load encrypted private-keys in PEM format.}
	inform=${8:DER|PEM|PFX}
	passplain=${9:# Pass phrase used to encrypt the private-key. Required when adding an encrypted private-key in PEM format.}
	expirymonitor=${10:enabled|disabled}
	notificationperiod=${11:# Time, in number of days, before certificate expiration, at which to generate an alert that the certificate is about to expire.}
	nitro_protocol=${12:#http|https}
	validate_certs=${13:yes}
	nitro_timeout=${14:310}
	state=${15:absent|#present}
	save_config=${16:yes}

endsnippet

snippet netscaler_gslb_site "Manage gslb site entities in Netscaler." b
netscaler_gslb_site: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	sitename=${4:# Name for the GSLB site. Must begin with an ASCII alphanumeric or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the virtual server is created.}
	sitetype=${5:REMOTE|LOCAL}
	siteipaddress=${6:# IP address for the GSLB site. The GSLB site uses this IP address to communicate with other GSLB sites. For a local site, use any IP address that is owned by the appliance (for example, a SNIP or MIP address, or the IP address of the ADNS service).}
	publicip=${7:# Public IP address for the local site. Required only if the appliance is deployed in a private address space and the site has a public IP address hosted on an external firewall or a NAT device.}
	metricexchange=${8:enabled|disabled}
	nwmetricexchange=${9:enabled|disabled}
	sessionexchange=${10:enabled|disabled}
	triggermonitor=${11:ALWAYS|MEPDOWN|MEPDOWN_SVCDOWN}
	parentsite=${12:# Parent site of the GSLB site, in a parent-child topology.}
	clip=${13:# Cluster IP address. Specify this parameter to connect to the remote cluster site for GSLB auto-sync. Note: The cluster IP address is defined when creating the cluster.}
	publicclip=${14:# IP address to be used to globally access the remote cluster when it is deployed behind a NAT. It can be same as the normal cluster IP address.}
	naptrreplacementsuffix=${15:# The naptr replacement suffix configured here will be used to construct the naptr replacement field in NAPTR record.}
	nitro_protocol=${16:#http|https}
	validate_certs=${17:yes}
	nitro_timeout=${18:310}
	state=${19:absent|#present}
	save_config=${20:yes}

endsnippet

snippet netscaler_service "Manage service configuration in Netscaler" b
netscaler_service: >
	nsip=${1:# The ip address of the netscaler appliance where the nitro API calls will be made.}
	nitro_user=${2:# The username with which to authenticate to the netscaler node.}
	nitro_pass=${3:# The password with which to authenticate to the netscaler node.}

	name=${4:# Name for the service. Must begin with an ASCII alphabetic or underscore C(_) character, and must contain only ASCII alphanumeric, underscore C(_), hash C(#), period C(.), space C( ), colon C(:), at C(@), equals C(=), and hyphen C(-) characters. Cannot be changed after the service has been created.}
	ip=${5:# IP to assign to the service.}
	servername=${6:# Name of the server that hosts the service.}
	servicetype=${7:HTTP|FTP|TCP|UDP|SSL|SSL_BRIDGE|SSL_TCP|DTLS|NNTP|RPCSVR|DNS|ADNS|SNMP|RTSP|DHCPRA|ANY|SIP_UDP|SIP_TCP|SIP_SSL|DNS_TCP|ADNS_TCP|MYSQL|MSSQL|ORACLE|RADIUS|RADIUSListener|RDP|DIAMETER|SSL_DIAMETER|TFTP|SMPP|PPTP|GRE|SYSLOGTCP|SYSLOGUDP|FIX|SSL_FIX}
	port=${8:# Port number of the service.}
	cleartextport=${9:# Port to which clear text data must be sent after the appliance decrypts incoming SSL traffic. Applicable to transparent SSL services.}
	cachetype=${10:TRANSPARENT|REVERSE|FORWARD}
	maxclient=${11:# Maximum number of simultaneous open connections to the service.}
	healthmonitor=${12:yes}
	maxreq=${13:# Maximum number of requests that can be sent on a persistent connection to the service.}
	cacheable=${14:no}
	cip=${15:enabled|disabled}
	cipheader=${16:# Name for the HTTP header whose value must be set to the IP address of the client. Used with the Client IP parameter. If you set the Client IP parameter, and you do not specify a name for the header, the appliance uses the header name specified for the global Client IP Header parameter (the cipHeader parameter in the set ns param CLI command or the Client IP Header parameter in the Configure HTTP Parameters dialog box at System > Settings > Change HTTP parameters). If the global Client IP Header parameter is not specified, the appliance inserts a header with the name "client-ip.".}
	usip=${17:# Use the client's IP address as the source IP address when initiating a connection to the server. When creating a service, if you do not set this parameter, the service inherits the global Use Source IP setting (available in the enable ns mode and disable ns mode CLI commands, or in the System > Settings > Configure modes > Configure Modes dialog box). However, you can override this setting after you create the service.}
	pathmonitor=${18:# Path monitoring for clustering.}
	pathmonitorindv=${19:# Individual Path monitoring decisions.}
	useproxyport=${20:# Use the proxy port as the source port when initiating connections with the server. With the NO setting, the client-side connection port is used as the source port for the server-side connection.}
	sp=${21:# Enable surge protection for the service.}
	rtspsessionidremap=${22:no}
	clttimeout=${23:# Time, in seconds, after which to terminate an idle client connection.}
	svrtimeout=${24:# Time, in seconds, after which to terminate an idle server connection.}
	customserverid=${25:# Unique identifier for the service. Used when the persistency type for the virtual server is set to Custom Server ID.}
	serverid=${26:# The identifier for the service. This is used when the persistency type is set to Custom Server ID.}
	cka=${27:# Enable client keep-alive for the service.}
	tcpb=${28:# Enable TCP buffering for the service.}
	cmp=${29:# Enable compression for the service.}
	maxbandwidth=${30:# Maximum bandwidth, in Kbps, allocated to the service.}
	accessdown=${31:no}
	monthreshold=${32:# Minimum sum of weights of the monitors that are bound to this service. Used to determine whether to mark a service as UP or DOWN.}
	downstateflush=${33:enabled|disabled}
	tcpprofilename=${34:# Name of the TCP profile that contains TCP configuration settings for the service.}
	httpprofilename=${35:# Name of the HTTP profile that contains HTTP configuration settings for the service.}
	hashid=${36:# A numerical identifier that can be used by hash based load balancing methods. Must be unique for each service.}
	comment=${37:# Any information about the service.}
	appflowlog=${38:enabled|disabled}
	netprofile=${39:# Network profile to use for the service.}
	td=${40:# Integer value that uniquely identifies the traffic domain in which you want to configure the entity. If you do not specify an ID, the entity becomes part of the default traffic domain, which has an ID of 0.}
	processlocal=${41:enabled|disabled}
	dnsprofilename=${42:# Name of the DNS profile to be associated with the service. DNS profile properties will applied to the transactions processed by a service. This parameter is valid only for ADNS and ADNS-TCP services.}
	ipaddress=${43:# The new IP address of the service.}
	graceful=${44:no}
	monitor_bindings=${45:# A list of load balancing monitors to bind to this service.}
	disabled=${46:no}
	nitro_protocol=${47:#http|https}
	validate_certs=${48:yes}
	nitro_timeout=${49:310}
	state=${50:absent|#present}
	save_config=${51:yes}

endsnippet

snippet bcf_switch "Create and remove a bcf switch." b
bcf_switch: >
	name=${1:# The name of the switch.}
	fabric_role=${2:spine|leaf}
	mac=${3:# The MAC address of the switch.}
	controller=${4:# The controller IP address.}

	leaf_group=${5:# The leaf group of the switch if the switch is a leaf.}
	state=${6:#present|absent}
	validate_certs=${7:yes}
	access_token=${8:# Big Cloud Fabric access token. If this isn't set then the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}

endsnippet

snippet bigmon_policy "Create and remove a bigmon out-of-band policy." b
bigmon_policy: >
	name=${1:# The name of the policy.}
	controller=${2:# The controller address.}

	policy_description=${3:# Description of policy.}
	action=${4:#forward|drop|flow-gen}
	priority=${5:100}
	duration=${6:0}
	start_time=${7:ansible_date_time.iso8601}
	delivery_packet_count=${8:0}
	state=${9:#present|absent}
	validate_certs=${10:yes}
	access_token=${11:# Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}

endsnippet

snippet bigmon_chain "Create and remove a bigmon inline service chain." b
bigmon_chain: >
	name=${1:# The name of the chain.}
	controller=${2:# The controller IP address.}

	state=${3:#present|absent}
	validate_certs=${4:yes}
	access_token=${5:# Bigmon access token. If this isn't set, the environment variable C(BIGSWITCH_ACCESS_TOKEN) is used.}

endsnippet

snippet fmgr_device_provision_template "Manages Device Provisioning Templates in FortiManager." b
fmgr_device_provision_template: >
	adom=${1:# The ADOM the configuration should belong to.}
	device_unique_name=${2:# The unique device's name that you are editing.}
	provisioning_template=${3:# The provisioning template you want to apply (default = default).}
	provision_targets=${4:# The friendly names of devices in FortiManager to assign the provisioning template to. CSV separated list.}

	mode=${5:#add|set|delete|update}
	snmp_status=${6:enable|disable}
	snmp_v2c_query_port=${7:# Sets the snmp v2c community query port.}
	snmp_v2c_trap_port=${8:# Sets the snmp v2c community trap port.}
	snmp_v2c_status=${9:enable|disable}
	snmp_v2c_trap_status=${10:enable|disable}
	snmp_v2c_query_status=${11:enable|disable}
	snmp_v2c_name=${12:# Specifies the v2c community name.}
	snmp_v2c_id=${13:# Primary key for the snmp community. this must be unique!}
	snmp_v2c_trap_src_ipv4=${14:# Source ip the traps should come from IPv4.}
	snmp_v2c_trap_hosts_ipv4=${15:# -}
	snmp_v2c_query_hosts_ipv4=${16:# -}
	snmpv3_auth_proto=${17:md5|sha}
	snmpv3_auth_pwd=${18:# SNMPv3 auth pwd __ currently not encrypted! ensure this file is locked down permissions wise!}
	snmpv3_name=${19:# SNMPv3 user name.}
	snmpv3_notify_hosts=${20:# List of ipv4 hosts to send snmpv3 traps to. Comma separated IPv4 list.}
	snmpv3_priv_proto=${21:aes|des|aes256|aes256cisco}
	snmpv3_priv_pwd=${22:# SNMPv3 priv pwd currently not encrypted! ensure this file is locked down permissions wise!}
	snmpv3_queries=${23:enable|disable}
	snmpv3_query_port=${24:# SNMPv3 query port.}
	snmpv3_security_level=${25:no-auth-no-priv|auth-no-priv|auth-priv}
	snmpv3_source_ip=${26:# SNMPv3 source ipv4 address for traps.}
	snmpv3_status=${27:enable|disable}
	snmpv3_trap_rport=${28:# SNMPv3 trap remote port.}
	snmpv3_trap_status=${29:enable|disable}
	syslog_port=${30:# Syslog port that will be set.}
	syslog_server=${31:# Server the syslogs will be sent to.}
	syslog_status=${32:enable|disable}
	syslog_mode=${33:#udp|legacy-reliable|reliable}
	syslog_filter=${34:emergency|alert|critical|error|warning|notification|information|debug}
	syslog_facility=${35:kernel|user|mail|daemon|auth|#syslog|lpr|news|uucp|cron|authpriv|ftp|ntp|audit|alert|clock|local0|local1|local2|local3|local4|local5|local6|local7}
	syslog_enc_algorithm=${36:high|low|#disable|high-medium}
	syslog_certificate=${37:# Certificate used to communicate with Syslog server if encryption on.}
	ntp_status=${38:enable|disable}
	ntp_sync_interval=${39:# Sets the interval in minutes for ntp sync.}
	ntp_type=${40:fortiguard|custom}
	ntp_server=${41:# Only used with custom ntp_type -- specifies IP of server to sync to -- comma separated ip addresses for multiples.}
	ntp_auth=${42:enable|disable}
	ntp_auth_pwd=${43:# Sets the ntp auth password.}
	ntp_v3=${44:enable|disable}
	admin_https_redirect=${45:enable|disable}
	admin_https_port=${46:# SSL admin gui port number.}
	admin_http_port=${47:# Non-SSL admin gui port number.}
	admin_timeout=${48:# Admin timeout in minutes.}
	admin_language=${49:english|simch|japanese|korean|spanish|trach|french|portuguese}
	admin_switch_controller=${50:enable|disable}
	admin_gui_theme=${51:green|red|blue|melongene|mariner}
	admin_enable_fortiguard=${52:none|direct|this-fmg}
	admin_fortianalyzer_target=${53:# Configures faz target.}
	admin_fortiguard_target=${54:# Configures fortiguard target.}
	smtp_username=${55:# SMTP auth username.}
	smtp_password=${56:# SMTP password.}
	smtp_port=${57:# SMTP port number.}
	smtp_replyto=${58:# SMTP reply to address.}
	smtp_conn_sec=${59:none|starttls|smtps}
	smtp_server=${60:# SMTP server ipv4 address.}
	smtp_source_ipv4=${61:# SMTP source ip address.}
	smtp_validate_cert=${62:enable|disable}
	dns_suffix=${63:# Sets the local dns domain suffix.}
	dns_primary_ipv4=${64:# primary ipv4 dns forwarder.}
	dns_secondary_ipv4=${65:# secondary ipv4 dns forwarder.}
	delete_provisioning_template=${66:# If specified, all other options are ignored. The specified provisioning template will be deleted.}

endsnippet

snippet fmgr_device_config "Edit device configurations" b
fmgr_device_config: >
	device_unique_name=${1:# The unique device's name that you are editing. A.K.A. Friendly name of the device in FortiManager.}

	adom=${2:root}
	device_hostname=${3:# The device's new hostname.}
	install_config=${4:disable}
	interface=${5:# The interface/port number you are editing.}
	interface_ip=${6:# The IP and subnet of the interface/port you are editing.}
	interface_allow_access=${7:# Specify what protocols are allowed on the interface, comma-separated list (see examples).}

endsnippet

snippet fmgr_secprof_voip "VOIP security profiles in FMG" b
fmgr_secprof_voip: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	name=${3:# Profile name.}
	comment=${4:# Comment.}
	sccp=${5:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	sccp_block_mcast=${6:disable|enable}
	sccp_log_call_summary=${7:disable|enable}
	sccp_log_violations=${8:disable|enable}
	sccp_max_calls=${9:# Maximum calls per minute per SCCP client (max 65535).}
	sccp_status=${10:disable|enable}
	sccp_verify_header=${11:disable|enable}
	sip=${12:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	sip_ack_rate=${13:# ACK request rate limit (per second, per policy).}
	sip_block_ack=${14:disable|enable}
	sip_block_bye=${15:disable|enable}
	sip_block_cancel=${16:disable|enable}
	sip_block_geo_red_options=${17:disable|enable}
	sip_block_info=${18:disable|enable}
	sip_block_invite=${19:disable|enable}
	sip_block_long_lines=${20:disable|enable}
	sip_block_message=${21:disable|enable}
	sip_block_notify=${22:disable|enable}
	sip_block_options=${23:disable|enable}
	sip_block_prack=${24:disable|enable}
	sip_block_publish=${25:disable|enable}
	sip_block_refer=${26:disable|enable}
	sip_block_register=${27:disable|enable}
	sip_block_subscribe=${28:disable|enable}
	sip_block_unknown=${29:disable|enable}
	sip_block_update=${30:disable|enable}
	sip_bye_rate=${31:# BYE request rate limit (per second, per policy).}
	sip_call_keepalive=${32:# Continue tracking calls with no RTP for this many minutes.}
	sip_cancel_rate=${33:# CANCEL request rate limit (per second, per policy).}
	sip_contact_fixup=${34:disable|enable}
	sip_hnt_restrict_source_ip=${35:disable|enable}
	sip_hosted_nat_traversal=${36:disable|enable}
	sip_info_rate=${37:# INFO request rate limit (per second, per policy).}
	sip_invite_rate=${38:# INVITE request rate limit (per second, per policy).}
	sip_ips_rtp=${39:disable|enable}
	sip_log_call_summary=${40:disable|enable}
	sip_log_violations=${41:disable|enable}
	sip_malformed_header_allow=${42:pass|discard|respond}
	sip_malformed_header_call_id=${43:pass|discard|respond}
	sip_malformed_header_contact=${44:pass|discard|respond}
	sip_malformed_header_content_length=${45:pass|discard|respond}
	sip_malformed_header_content_type=${46:pass|discard|respond}
	sip_malformed_header_cseq=${47:pass|discard|respond}
	sip_malformed_header_expires=${48:pass|discard|respond}
	sip_malformed_header_from=${49:pass|discard|respond}
	sip_malformed_header_max_forwards=${50:pass|discard|respond}
	sip_malformed_header_p_asserted_identity=${51:pass|discard|respond}
	sip_malformed_header_rack=${52:pass|discard|respond}
	sip_malformed_header_record_route=${53:pass|discard|respond}
	sip_malformed_header_route=${54:pass|discard|respond}
	sip_malformed_header_rseq=${55:pass|discard|respond}
	sip_malformed_header_sdp_a=${56:pass|discard|respond}
	sip_malformed_header_sdp_b=${57:pass|discard|respond}
	sip_malformed_header_sdp_c=${58:pass|discard|respond}
	sip_malformed_header_sdp_i=${59:pass|discard|respond}
	sip_malformed_header_sdp_k=${60:pass|discard|respond}
	sip_malformed_header_sdp_m=${61:pass|discard|respond}
	sip_malformed_header_sdp_o=${62:pass|discard|respond}
	sip_malformed_header_sdp_r=${63:pass|discard|respond}
	sip_malformed_header_sdp_s=${64:pass|discard|respond}
	sip_malformed_header_sdp_t=${65:pass|discard|respond}
	sip_malformed_header_sdp_v=${66:pass|discard|respond}
	sip_malformed_header_sdp_z=${67:pass|discard|respond}
	sip_malformed_header_to=${68:pass|discard|respond}
	sip_malformed_header_via=${69:pass|discard|respond}
	sip_malformed_request_line=${70:pass|discard|respond}
	sip_max_body_length=${71:# Maximum SIP message body length (0 meaning no limit).}
	sip_max_dialogs=${72:# Maximum number of concurrent calls/dialogs (per policy).}
	sip_max_idle_dialogs=${73:# Maximum number established but idle dialogs to retain (per policy).}
	sip_max_line_length=${74:# Maximum SIP header line length (78-4096).}
	sip_message_rate=${75:# MESSAGE request rate limit (per second, per policy).}
	sip_nat_trace=${76:disable|enable}
	sip_no_sdp_fixup=${77:disable|enable}
	sip_notify_rate=${78:# NOTIFY request rate limit (per second, per policy).}
	sip_open_contact_pinhole=${79:disable|enable}
	sip_open_record_route_pinhole=${80:disable|enable}
	sip_open_register_pinhole=${81:disable|enable}
	sip_open_via_pinhole=${82:disable|enable}
	sip_options_rate=${83:# OPTIONS request rate limit (per second, per policy).}
	sip_prack_rate=${84:# PRACK request rate limit (per second, per policy).}
	sip_preserve_override=${85:disable|enable}
	sip_provisional_invite_expiry_time=${86:# Expiry time for provisional INVITE (10 - 3600 sec).}
	sip_publish_rate=${87:# PUBLISH request rate limit (per second, per policy).}
	sip_refer_rate=${88:# REFER request rate limit (per second, per policy).}
	sip_register_contact_trace=${89:disable|enable}
	sip_register_rate=${90:# REGISTER request rate limit (per second, per policy).}
	sip_rfc2543_branch=${91:disable|enable}
	sip_rtp=${92:disable|enable}
	sip_ssl_algorithm=${93:high|medium|low}
	sip_ssl_auth_client=${94:# Require a client certificate and authenticate it with the peer/peergrp.}
	sip_ssl_auth_server=${95:# Authenticate the server's certificate with the peer/peergrp.}
	sip_ssl_client_certificate=${96:# Name of Certificate to offer to server if requested.}
	sip_ssl_client_renegotiation=${97:allow|deny|secure}
	sip_ssl_max_version=${98:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	sip_ssl_min_version=${99:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	sip_ssl_mode=${100:off|full}
	sip_ssl_pfs=${101:require|deny|allow}
	sip_ssl_send_empty_frags=${102:disable|enable}
	sip_ssl_server_certificate=${103:# Name of Certificate return to the client in every SSL connection.}
	sip_status=${104:disable|enable}
	sip_strict_register=${105:disable|enable}
	sip_subscribe_rate=${106:# SUBSCRIBE request rate limit (per second, per policy).}
	sip_unknown_header=${107:pass|discard|respond}
	sip_update_rate=${108:# UPDATE request rate limit (per second, per policy).}

endsnippet

snippet fmgr_query "Query FortiManager data objects for use in Ansible workflows." b
fmgr_query: >
	object=${1:device|cluster_nodes|task|custom}

	adom=${2:root}
	custom_endpoint=${3:# ADVANCED USERS ONLY! REQUIRES KNOWLEDGE OF FMGR JSON API!}
	custom_dict=${4:# ADVANCED USERS ONLY! REQUIRES KNOWLEDGE OF FMGR JSON API!}
	device_ip=${5:# The IP of the device you want to query.}
	device_unique_name=${6:# The desired "friendly" name of the device you want to query.}
	device_serial=${7:# The serial number of the device you want to query.}
	task_id=${8:# The ID of the task you wish to query status on. If left blank and object = 'task' a list of tasks are returned.}
	nodes=${9:# A LIST of firewalls in the cluster you want to verify i.e. ["firewall_A","firewall_B"].}

endsnippet

snippet fmgr_fwobj_ippool "Allows the editing of IP Pool Objects within FortiManager." b
fmgr_fwobj_ippool: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	type=${3:overload|one-to-one|fixed-port-range|port-block-allocation}
	startip=${4:# First IPv4 address (inclusive) in the range for the address pool (format xxx.xxx.xxx.xxx, Default| 0.0.0.0).}
	source_startip=${5:# First IPv4 address (inclusive) in the range of the source addresses to be translated (format xxx.xxx.xxx.xxx, Default| 0.0.0.0).}
	source_endip=${6:# Final IPv4 address (inclusive) in the range of the source addresses to be translated (format xxx.xxx.xxx.xxx, Default| 0.0.0.0).}
	permit_any_host=${7:disable|enable}
	pba_timeout=${8:# Port block allocation timeout (seconds).}
	num_blocks_per_user=${9:# Number of addresses blocks that can be used by a user (1 to 128, default = 8).}
	name=${10:# IP pool name.}
	endip=${11:# Final IPv4 address (inclusive) in the range for the address pool (format xxx.xxx.xxx.xxx, Default| 0.0.0.0).}
	comments=${12:# Comment.}
	block_size=${13:# Number of addresses in a block (64 to 4096, default = 128).}
	associated_interface=${14:# Associated interface name.}
	arp_reply=${15:disable|enable}
	arp_intf=${16:# Select an interface from available options that will reply to ARP requests. (If blank, any is selected).}
	dynamic_mapping=${17:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	dynamic_mapping_arp_intf=${18:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_arp_reply=${19:disable|enable}
	dynamic_mapping_associated_interface=${20:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_block_size=${21:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_comments=${22:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_endip=${23:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_num_blocks_per_user=${24:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_pba_timeout=${25:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_permit_any_host=${26:disable|enable}
	dynamic_mapping_source_endip=${27:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_source_startip=${28:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_startip=${29:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_type=${30:overload|one-to-one|fixed-port-range|port-block-allocation}

endsnippet

snippet fmgr_fwpol_ipv4 "Allows the add/delete of Firewall Policies on Packages in FortiManager." b
fmgr_fwpol_ipv4: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	package_name=${3:default}
	fail_on_missing_dependency=${4:enable|#disable}
	wsso=${5:disable|enable}
	webfilter_profile=${6:# Name of an existing Web filter profile.}
	webcache_https=${7:disable|enable}
	webcache=${8:disable|enable}
	wccp=${9:disable|enable}
	wanopt_profile=${10:# WAN optimization profile.}
	wanopt_peer=${11:# WAN optimization peer.}
	wanopt_passive_opt=${12:default|transparent|non-transparent}
	wanopt_detection=${13:active|passive|off}
	wanopt=${14:disable|enable}
	waf_profile=${15:# Name of an existing Web application firewall profile.}
	vpntunnel=${16:# Policy-based IPsec VPN |  name of the IPsec VPN Phase 1.}
	voip_profile=${17:# Name of an existing VoIP profile.}
	vlan_filter=${18:# Set VLAN filters.}
	vlan_cos_rev=${19:# VLAN reverse direction user priority | 255 passthrough, 0 lowest, 7 highest..}
	vlan_cos_fwd=${20:# VLAN forward direction user priority | 255 passthrough, 0 lowest, 7 highest.}
	utm_status=${21:disable|enable}
	users=${22:# Names of individual users that can authenticate with this policy.}
	url_category=${23:# URL category ID list.}
	traffic_shaper_reverse=${24:# Reverse traffic shaper.}
	traffic_shaper=${25:# Traffic shaper.}
	timeout_send_rst=${26:disable|enable}
	tcp_session_without_syn=${27:all|data-only|disable}
	tcp_mss_sender=${28:# Sender TCP maximum segment size (MSS).}
	tcp_mss_receiver=${29:# Receiver TCP maximum segment size (MSS).}
	status=${30:disable|enable}
	ssl_ssh_profile=${31:# Name of an existing SSL SSH profile.}
	ssl_mirror_intf=${32:# SSL mirror interface name.}
	ssl_mirror=${33:disable|enable}
	ssh_filter_profile=${34:# Name of an existing SSH filter profile.}
	srcintf=${35:# Incoming (ingress) interface.}
	srcaddr_negate=${36:disable|enable}
	srcaddr=${37:# Source address and address group names.}
	spamfilter_profile=${38:# Name of an existing Spam filter profile.}
	session_ttl=${39:# TTL in seconds for sessions accepted by this policy (0 means use the system default session TTL).}
	service_negate=${40:disable|enable}
	service=${41:# Service and service group names.}
	send_deny_packet=${42:disable|enable}
	schedule_timeout=${43:disable|enable}
	schedule=${44:# Schedule name.}
	scan_botnet_connections=${45:disable|block|monitor}
	rtp_nat=${46:disable|enable}
	rtp_addr=${47:# Address names if this is an RTP NAT policy.}
	rsso=${48:disable|enable}
	replacemsg_override_group=${49:# Override the default replacement message group for this policy.}
	redirect_url=${50:# URL users are directed to after seeing and accepting the disclaimer or authenticating.}
	radius_mac_auth_bypass=${51:disable|enable}
	profile_type=${52:single|group}
	profile_protocol_options=${53:# Name of an existing Protocol options profile.}
	profile_group=${54:# Name of profile group.}
	poolname=${55:# IP Pool names.}
	policyid=${56:# Policy ID.}
	permit_stun_host=${57:disable|enable}
	permit_any_host=${58:disable|enable}
	per_ip_shaper=${59:# Per-IP traffic shaper.}
	outbound=${60:disable|enable}
	ntlm_guest=${61:disable|enable}
	ntlm_enabled_browsers=${62:# HTTP-User-Agent value of supported browsers.}
	ntlm=${63:disable|enable}
	np_acceleration=${64:disable|enable}
	natoutbound=${65:disable|enable}
	natip=${66:# Policy-based IPsec VPN |  source NAT IP address for outgoing traffic.}
	natinbound=${67:disable|enable}
	nat=${68:disable|enable}
	name=${69:# Policy name.}
	mms_profile=${70:# Name of an existing MMS profile.}
	match_vip=${71:disable|enable}
	logtraffic_start=${72:disable|enable}
	logtraffic=${73:disable|all|utm}
	learning_mode=${74:disable|enable}
	label=${75:# Label for the policy that appears when the GUI is in Section View mode.}
	ips_sensor=${76:# Name of an existing IPS sensor.}
	ippool=${77:disable|enable}
	internet_service_src_negate=${78:disable|enable}
	internet_service_src_id=${79:# Internet Service source ID.}
	internet_service_src_custom=${80:# Custom Internet Service source name.}
	internet_service_src=${81:disable|enable}
	internet_service_negate=${82:disable|enable}
	internet_service_id=${83:# Internet Service ID.}
	internet_service_custom=${84:# Custom Internet Service name.}
	internet_service=${85:disable|enable}
	inbound=${86:disable|enable}
	identity_based_route=${87:# Name of identity-based routing rule.}
	icap_profile=${88:# Name of an existing ICAP profile.}
	gtp_profile=${89:# GTP profile.}
	groups=${90:# Names of user groups that can authenticate with this policy.}
	global_label=${91:# Label for the policy that appears when the GUI is in Global View mode.}
	fsso_agent_for_ntlm=${92:# FSSO agent to use for NTLM authentication.}
	fsso=${93:disable|enable}
	fixedport=${94:disable|enable}
	firewall_session_dirty=${95:check-all|check-new}
	dstintf=${96:# Outgoing (egress) interface.}
	dstaddr_negate=${97:disable|enable}
	dstaddr=${98:# Destination address and address group names.}
	dsri=${99:disable|enable}
	dscp_value=${100:# DSCP value.}
	dscp_negate=${101:disable|enable}
	dscp_match=${102:disable|enable}
	dnsfilter_profile=${103:# Name of an existing DNS filter profile.}
	dlp_sensor=${104:# Name of an existing DLP sensor.}
	disclaimer=${105:disable|enable}
	diffservcode_rev=${106:# Change packet's reverse (reply) DiffServ to this value.}
	diffservcode_forward=${107:# Change packet's DiffServ to this value.}
	diffserv_reverse=${108:disable|enable}
	diffserv_forward=${109:disable|enable}
	devices=${110:# Names of devices or device groups that can be matched by the policy.}
	delay_tcp_npu_session=${111:disable|enable}
	custom_log_fields=${112:# Custom fields to append to log messages for this policy.}
	comments=${113:# Comment.}
	capture_packet=${114:disable|enable}
	captive_portal_exempt=${115:disable|enable}
	block_notification=${116:disable|enable}
	av_profile=${117:# Name of an existing Antivirus profile.}
	auto_asic_offload=${118:disable|enable}
	auth_redirect_addr=${119:# HTTP-to-HTTPS redirect address for firewall authentication.}
	auth_path=${120:disable|enable}
	auth_cert=${121:# HTTPS server certificate for policy authentication.}
	application_list=${122:# Name of an existing Application list.}
	application=${123:# Application ID list.}
	app_group=${124:# Application group names.}
	app_category=${125:# Application category ID list.}
	action=${126:deny|accept|ipsec}
	vpn_dst_node=${127:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	vpn_dst_node_host=${128:# VPN Destination Node Host.}
	vpn_dst_node_seq=${129:# VPN Destination Node Seq.}
	vpn_dst_node_subnet=${130:# VPN Destination Node Seq.}
	vpn_src_node=${131:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	vpn_src_node_host=${132:# VPN Source Node Host.}
	vpn_src_node_seq=${133:# VPN Source Node Seq.}
	vpn_src_node_subnet=${134:# VPN Source Node.}

endsnippet

snippet fmgr_device "Add or remove device from FortiManager." b
fmgr_device: >
	adom=${1:root}

	mode=${2:#add|delete}
	blind_add=${3:enable|#disable}
	device_username=${4:# The username of the device being added to FortiManager.}
	device_password=${5:# The password of the device being added to FortiManager.}
	device_ip=${6:# The IP of the device being added to FortiManager. Supports both IPv4 and IPv6.}
	device_unique_name=${7:# The desired "friendly" name of the device being added to FortiManager.}
	device_serial=${8:# The serial number of the device being added to FortiManager.}

endsnippet

snippet fmgr_secprof_waf "FortiManager web application firewall security profile" b
fmgr_secprof_waf: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	name=${3:# WAF Profile name.}
	external=${4:disable|enable}
	extended_log=${5:disable|enable}
	comment=${6:# Comment.}
	address_list=${7:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	address_list_blocked_address=${8:# Blocked address.}
	address_list_blocked_log=${9:disable|enable}
	address_list_severity=${10:low|medium|high}
	address_list_status=${11:disable|enable}
	address_list_trusted_address=${12:# Trusted address.}
	constraint=${13:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	constraint_content_length_action=${14:allow|block}
	constraint_content_length_length=${15:# Length of HTTP content in bytes (0 to 2147483647).}
	constraint_content_length_log=${16:disable|enable}
	constraint_content_length_severity=${17:low|medium|high}
	constraint_content_length_status=${18:disable|enable}
	constraint_exception_address=${19:# Host address.}
	constraint_exception_content_length=${20:disable|enable}
	constraint_exception_header_length=${21:disable|enable}
	constraint_exception_hostname=${22:disable|enable}
	constraint_exception_line_length=${23:disable|enable}
	constraint_exception_malformed=${24:disable|enable}
	constraint_exception_max_cookie=${25:disable|enable}
	constraint_exception_max_header_line=${26:disable|enable}
	constraint_exception_max_range_segment=${27:disable|enable}
	constraint_exception_max_url_param=${28:disable|enable}
	constraint_exception_method=${29:disable|enable}
	constraint_exception_param_length=${30:disable|enable}
	constraint_exception_pattern=${31:# URL pattern.}
	constraint_exception_regex=${32:disable|enable}
	constraint_exception_url_param_length=${33:disable|enable}
	constraint_exception_version=${34:disable|enable}
	constraint_header_length_action=${35:allow|block}
	constraint_header_length_length=${36:# Length of HTTP header in bytes (0 to 2147483647).}
	constraint_header_length_log=${37:disable|enable}
	constraint_header_length_severity=${38:low|medium|high}
	constraint_header_length_status=${39:disable|enable}
	constraint_hostname_action=${40:allow|block}
	constraint_hostname_log=${41:disable|enable}
	constraint_hostname_severity=${42:low|medium|high}
	constraint_hostname_status=${43:disable|enable}
	constraint_line_length_action=${44:allow|block}
	constraint_line_length_length=${45:# Length of HTTP line in bytes (0 to 2147483647).}
	constraint_line_length_log=${46:disable|enable}
	constraint_line_length_severity=${47:low|medium|high}
	constraint_line_length_status=${48:disable|enable}
	constraint_malformed_action=${49:allow|block}
	constraint_malformed_log=${50:disable|enable}
	constraint_malformed_severity=${51:low|medium|high}
	constraint_malformed_status=${52:disable|enable}
	constraint_max_cookie_action=${53:allow|block}
	constraint_max_cookie_log=${54:disable|enable}
	constraint_max_cookie_max_cookie=${55:# Maximum number of cookies in HTTP request (0 to 2147483647).}
	constraint_max_cookie_severity=${56:low|medium|high}
	constraint_max_cookie_status=${57:disable|enable}
	constraint_max_header_line_action=${58:allow|block}
	constraint_max_header_line_log=${59:disable|enable}
	constraint_max_header_line_max_header_line=${60:# Maximum number HTTP header lines (0 to 2147483647).}
	constraint_max_header_line_severity=${61:low|medium|high}
	constraint_max_header_line_status=${62:disable|enable}
	constraint_max_range_segment_action=${63:allow|block}
	constraint_max_range_segment_log=${64:disable|enable}
	constraint_max_range_segment_max_range_segment=${65:# Maximum number of range segments in HTTP range line (0 to 2147483647).}
	constraint_max_range_segment_severity=${66:low|medium|high}
	constraint_max_range_segment_status=${67:disable|enable}
	constraint_max_url_param_action=${68:allow|block}
	constraint_max_url_param_log=${69:disable|enable}
	constraint_max_url_param_max_url_param=${70:# Maximum number of parameters in URL (0 to 2147483647).}
	constraint_max_url_param_severity=${71:low|medium|high}
	constraint_max_url_param_status=${72:disable|enable}
	constraint_method_action=${73:allow|block}
	constraint_method_log=${74:disable|enable}
	constraint_method_severity=${75:low|medium|high}
	constraint_method_status=${76:disable|enable}
	constraint_param_length_action=${77:allow|block}
	constraint_param_length_length=${78:# Maximum length of parameter in URL, HTTP POST request or HTTP body in bytes (0 to 2147483647).}
	constraint_param_length_log=${79:disable|enable}
	constraint_param_length_severity=${80:low|medium|high}
	constraint_param_length_status=${81:disable|enable}
	constraint_url_param_length_action=${82:allow|block}
	constraint_url_param_length_length=${83:# Maximum length of URL parameter in bytes (0 to 2147483647).}
	constraint_url_param_length_log=${84:disable|enable}
	constraint_url_param_length_severity=${85:low|medium|high}
	constraint_url_param_length_status=${86:disable|enable}
	constraint_version_action=${87:allow|block}
	constraint_version_log=${88:disable|enable}
	constraint_version_severity=${89:low|medium|high}
	constraint_version_status=${90:disable|enable}
	method=${91:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	method_default_allowed_methods=${92:delete|get|head|options|post|put|trace|others|connect}
	method_log=${93:disable|enable}
	method_severity=${94:low|medium|high}
	method_status=${95:disable|enable}
	method_method_policy_address=${96:# Host address.}
	method_method_policy_allowed_methods=${97:delete|get|head|options|post|put|trace|others|connect}
	method_method_policy_pattern=${98:# URL pattern.}
	method_method_policy_regex=${99:disable|enable}
	signature=${100:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	signature_credit_card_detection_threshold=${101:# The minimum number of Credit cards to detect violation.}
	signature_disabled_signature=${102:# Disabled signatures}
	signature_disabled_sub_class=${103:# Disabled signature subclasses.}
	signature_custom_signature_action=${104:allow|block|erase}
	signature_custom_signature_case_sensitivity=${105:disable|enable}
	signature_custom_signature_direction=${106:request|response}
	signature_custom_signature_log=${107:disable|enable}
	signature_custom_signature_name=${108:# Signature name.}
	signature_custom_signature_pattern=${109:# Match pattern.}
	signature_custom_signature_severity=${110:low|medium|high}
	signature_custom_signature_status=${111:disable|enable}
	signature_custom_signature_target=${112:arg|arg-name|req-body|req-cookie|req-cookie-name|req-filename|req-header|req-header-name|req-raw-uri|req-uri|resp-body|resp-hdr|resp-status}
	signature_main_class_action=${113:allow|block|erase}
	signature_main_class_log=${114:disable|enable}
	signature_main_class_severity=${115:low|medium|high}
	signature_main_class_status=${116:disable|enable}
	url_access=${117:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	url_access_action=${118:bypass|permit|block}
	url_access_address=${119:# Host address.}
	url_access_log=${120:disable|enable}
	url_access_severity=${121:low|medium|high}
	url_access_access_pattern_negate=${122:disable|enable}
	url_access_access_pattern_pattern=${123:# URL pattern.}
	url_access_access_pattern_regex=${124:disable|enable}
	url_access_access_pattern_srcaddr=${125:# Source address.}

endsnippet

snippet fmgr_secprof_dns "Manage DNS security profiles in FortiManager" b
fmgr_secprof_dns: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	youtube_restrict=${3:strict|moderate}
	sdns_ftgd_err_log=${4:disable|enable}
	sdns_domain_log=${5:disable|enable}
	safe_search=${6:disable|enable}
	redirect_portal=${7:# IP address of the SDNS redirect portal.}
	name=${8:# Profile name.}
	log_all_domain=${9:disable|enable}
	external_ip_blocklist=${10:# One or more external IP block lists.}
	comment=${11:# Comment for the security profile to show in the FortiManager GUI.}
	block_botnet=${12:disable|enable}
	block_action=${13:block|redirect}
	domain_filter_domain_filter_table=${14:# DNS domain filter table ID.}
	ftgd_dns_options=${15:error-allow|ftgd-disable}
	ftgd_dns_filters_action=${16:monitor|block}
	ftgd_dns_filters_category=${17:# Category number.}
	ftgd_dns_filters_log=${18:disable|enable}

endsnippet

snippet fmgr_ha "Manages the High-Availability State of FortiManager Clusters and Nodes." b
fmgr_ha: >
	fmgr_ha_mode=${1:standalone|master|slave}
	fmgr_ha_peer_ipv4=${2:# Sets the IPv4 address of a HA peer.}
	fmgr_ha_peer_ipv6=${3:# Sets the IPv6 address of a HA peer.}
	fmgr_ha_peer_sn=${4:# Sets the HA Peer Serial Number.}
	fmgr_ha_peer_status=${5:enable|disable}
	fmgr_ha_cluster_pw=${6:# Sets the password for the HA cluster. Only required once. System remembers between HA mode switches.}
	fmgr_ha_cluster_id=${7:1}
	fmgr_ha_hb_threshold=${8:3}
	fmgr_ha_hb_interval=${9:5}
	fmgr_ha_file_quota=${10:4096}

endsnippet

snippet fmgr_secprof_wanopt "WAN optimization" b
fmgr_secprof_wanopt: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	transparent=${3:disable|enable}
	name=${4:# Profile name.}
	comments=${5:# Comment.}
	auth_group=${6:# Optionally add an authentication group to restrict access to the WAN Optimization tunnel to peers in the authentication group.}
	cifs=${7:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	cifs_byte_caching=${8:disable|enable}
	cifs_log_traffic=${9:disable|enable}
	cifs_port=${10:# Single port number or port number range for CIFS. Only packets with a destination port number that matches this port number or range are accepted by this profile.}
	cifs_prefer_chunking=${11:dynamic|fix}
	cifs_secure_tunnel=${12:disable|enable}
	cifs_status=${13:disable|enable}
	cifs_tunnel_sharing=${14:private|shared|express-shared}
	ftp=${15:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ftp_byte_caching=${16:disable|enable}
	ftp_log_traffic=${17:disable|enable}
	ftp_port=${18:# Single port number or port number range for FTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.}
	ftp_prefer_chunking=${19:dynamic|fix}
	ftp_secure_tunnel=${20:disable|enable}
	ftp_status=${21:disable|enable}
	ftp_tunnel_sharing=${22:private|shared|express-shared}
	http=${23:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	http_byte_caching=${24:disable|enable}
	http_log_traffic=${25:disable|enable}
	http_port=${26:# Single port number or port number range for HTTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.}
	http_prefer_chunking=${27:dynamic|fix}
	http_secure_tunnel=${28:disable|enable}
	http_ssl=${29:disable|enable}
	http_ssl_port=${30:# Port on which to expect HTTPS traffic for SSL/TLS offloading.}
	http_status=${31:disable|enable}
	http_tunnel_non_http=${32:disable|enable}
	http_tunnel_sharing=${33:private|shared|express-shared}
	http_unknown_http_version=${34:best-effort|reject|tunnel}
	mapi=${35:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	mapi_byte_caching=${36:disable|enable}
	mapi_log_traffic=${37:disable|enable}
	mapi_port=${38:# Single port number or port number range for MAPI. Only packets with a destination port number that matches this port number or range are accepted by this profile.}
	mapi_secure_tunnel=${39:disable|enable}
	mapi_status=${40:disable|enable}
	mapi_tunnel_sharing=${41:private|shared|express-shared}
	tcp=${42:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	tcp_byte_caching=${43:disable|enable}
	tcp_byte_caching_opt=${44:mem-only|mem-disk}
	tcp_log_traffic=${45:disable|enable}
	tcp_port=${46:# Single port number or port number range for TCP. Only packets with a destination port number that matches this port number or range are accepted by this profile.}
	tcp_secure_tunnel=${47:disable|enable}
	tcp_ssl=${48:disable|enable}
	tcp_ssl_port=${49:# Port on which to expect HTTPS traffic for SSL/TLS offloading.}
	tcp_status=${50:disable|enable}
	tcp_tunnel_sharing=${51:private|shared|express-shared}

endsnippet

snippet fmgr_secprof_web "Manage web filter security profiles in FortiManager" b
fmgr_secprof_web: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	youtube_channel_status=${3:disable|blacklist|whitelist}
	wisp_servers=${4:# WISP servers.}
	wisp_algorithm=${5:auto-learning|primary-secondary|round-robin}
	wisp=${6:disable|enable}
	web_url_log=${7:disable|enable}
	web_invalid_domain_log=${8:disable|enable}
	web_ftgd_quota_usage=${9:disable|enable}
	web_ftgd_err_log=${10:disable|enable}
	web_filter_vbs_log=${11:disable|enable}
	web_filter_unknown_log=${12:disable|enable}
	web_filter_referer_log=${13:disable|enable}
	web_filter_jscript_log=${14:disable|enable}
	web_filter_js_log=${15:disable|enable}
	web_filter_cookie_removal_log=${16:disable|enable}
	web_filter_cookie_log=${17:disable|enable}
	web_filter_command_block_log=${18:disable|enable}
	web_filter_applet_log=${19:disable|enable}
	web_filter_activex_log=${20:disable|enable}
	web_extended_all_action_log=${21:disable|enable}
	web_content_log=${22:disable|enable}
	replacemsg_group=${23:# Replacement message group.}
	post_action=${24:normal|block}
	ovrd_perm=${25:bannedword-override|urlfilter-override|fortiguard-wf-override|contenttype-check-override}
	options=${26:block-invalid-url|jscript|js|vbs|unknown|wf-referer|intrinsic|wf-cookie|per-user-bwl|activexfilter|cookiefilter|javafilter}
	name=${27:# Profile name.}
	log_all_url=${28:disable|enable}
	inspection_mode=${29:proxy|flow-based}
	https_replacemsg=${30:disable|enable}
	extended_log=${31:disable|enable}
	comment=${32:# Optional comments.}
	ftgd_wf=${33:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ftgd_wf_exempt_quota=${34:# Do not stop quota for these categories.}
	ftgd_wf_max_quota_timeout=${35:# Maximum FortiGuard quota used by single page view in seconds (excludes streams).}
	ftgd_wf_options=${36:error-allow|rate-server-ip|connect-request-bypass|ftgd-disable}
	ftgd_wf_ovrd=${37:# Allow web filter profile overrides.}
	ftgd_wf_rate_crl_urls=${38:disable|enable}
	ftgd_wf_rate_css_urls=${39:disable|enable}
	ftgd_wf_rate_image_urls=${40:disable|enable}
	ftgd_wf_rate_javascript_urls=${41:disable|enable}
	ftgd_wf_filters_action=${42:block|monitor|warning|authenticate}
	ftgd_wf_filters_auth_usr_grp=${43:# Groups with permission to authenticate.}
	ftgd_wf_filters_category=${44:# Categories and groups the filter examines.}
	ftgd_wf_filters_log=${45:disable|enable}
	ftgd_wf_filters_override_replacemsg=${46:# Override replacement message.}
	ftgd_wf_filters_warn_duration=${47:# Duration of warnings.}
	ftgd_wf_filters_warning_duration_type=${48:session|timeout}
	ftgd_wf_filters_warning_prompt=${49:per-domain|per-category}
	ftgd_wf_quota_category=${50:# FortiGuard categories to apply quota to (category action must be set to monitor).}
	ftgd_wf_quota_duration=${51:# Duration of quota.}
	ftgd_wf_quota_override_replacemsg=${52:# Override replacement message.}
	ftgd_wf_quota_type=${53:time|traffic}
	ftgd_wf_quota_unit=${54:B|KB|MB|GB}
	ftgd_wf_quota_value=${55:# Traffic quota value.}
	override=${56:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	override_ovrd_cookie=${57:deny|allow}
	override_ovrd_dur=${58:# Override duration.}
	override_ovrd_dur_mode=${59:constant|ask}
	override_ovrd_scope=${60:user|user-group|ip|ask|browser}
	override_ovrd_user_group=${61:# User groups with permission to use the override.}
	override_profile=${62:# Web filter profile with permission to create overrides.}
	override_profile_attribute=${63:User-Name|NAS-IP-Address|Framed-IP-Address|Framed-IP-Netmask|Filter-Id|Login-IP-Host|Reply-Message|Callback-Number|Callback-Id|Framed-Route|Framed-IPX-Network|Class|Called-Station-Id|Calling-Station-Id|NAS-Identifier|Proxy-State|Login-LAT-Service|Login-LAT-Node|Login-LAT-Group|Framed-AppleTalk-Zone|Acct-Session-Id|Acct-Multi-Session-Id}
	override_profile_type=${64:list|radius}
	url_extraction=${65:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	url_extraction_redirect_header=${66:# HTTP header name to use for client redirect on blocked requests}
	url_extraction_redirect_no_content=${67:disable|enable}
	url_extraction_redirect_url=${68:# HTTP header value to use for client redirect on blocked requests}
	url_extraction_server_fqdn=${69:# URL extraction server FQDN (fully qualified domain name)}
	url_extraction_status=${70:disable|enable}
	web=${71:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	web_blacklist=${72:disable|enable}
	web_bword_table=${73:# Banned word table ID.}
	web_bword_threshold=${74:# Banned word score threshold.}
	web_content_header_list=${75:# Content header list.}
	web_keyword_match=${76:# Search keywords to log when match is found.}
	web_log_search=${77:disable|enable}
	web_safe_search=${78:url|header}
	web_urlfilter_table=${79:# URL filter table ID.}
	web_whitelist=${80:exempt-av|exempt-webcontent|exempt-activex-java-cookie|exempt-dlp|exempt-rangeblock|extended-log-others}
	web_youtube_restrict=${81:strict|none|moderate}
	youtube_channel_filter=${82:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	youtube_channel_filter_channel_id=${83:# YouTube channel ID to be filtered.}
	youtube_channel_filter_comment=${84:# Comment.}

endsnippet

snippet fmgr_secprof_appctrl "Manage application control security profiles" b
fmgr_secprof_appctrl: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	unknown_application_log=${3:disable|enable}
	unknown_application_action=${4:pass|block}
	replacemsg_group=${5:# Replacement message group.}
	p2p_black_list=${6:skype|edonkey|bittorrent}
	other_application_log=${7:disable|enable}
	other_application_action=${8:pass|block}
	options=${9:allow-dns|allow-icmp|allow-http|allow-ssl|allow-quic}
	name=${10:# List name.}
	extended_log=${11:disable|enable}
	deep_app_inspection=${12:disable|enable}
	comment=${13:# comments}
	app_replacemsg=${14:disable|enable}
	entries=${15:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	entries_action=${16:pass|block|reset}
	entries_application=${17:# ID of allowed applications.}
	entries_behavior=${18:# Application behavior filter.}
	entries_category=${19:# Category ID list.}
	entries_log=${20:disable|enable}
	entries_log_packet=${21:disable|enable}
	entries_per_ip_shaper=${22:# Per-IP traffic shaper.}
	entries_popularity=${23:1|2|3|4|5}
	entries_protocols=${24:# Application protocol filter.}
	entries_quarantine=${25:none|attacker}
	entries_quarantine_expiry=${26:# Duration of quarantine. (Format}
	entries_quarantine_log=${27:disable|enable}
	entries_rate_count=${28:# Count of the rate.}
	entries_rate_duration=${29:# Duration (sec) of the rate.}
	entries_rate_mode=${30:periodical|continuous}
	entries_rate_track=${31:none|src-ip|dest-ip|dhcp-client-mac|dns-domain}
	entries_risk=${32:# Risk, or impact, of allowing traffic from this application to occur 1 - 5;}
	entries_session_ttl=${33:# Session TTL (0 = default).}
	entries_shaper=${34:# Traffic shaper.}
	entries_shaper_reverse=${35:# Reverse traffic shaper.}
	entries_sub_category=${36:# Application Sub-category ID list.}
	entries_technology=${37:# Application technology filter.}
	entries_vendor=${38:# Application vendor filter.}
	entries_parameters_value=${39:# Parameter value.}

endsnippet

snippet fmgr_fwobj_address "Allows the management of firewall objects in FortiManager" b
fmgr_fwobj_address: >
	adom=${1:root}
	allow_routing=${2:enable|#disable}
	associated_interface=${3:# Associated interface name.}
	cache_ttl=${4:# Minimal TTL of individual IP addresses in FQDN cache. Only applies when type = wildcard-fqdn.}
	color=${5:22}
	comment=${6:# Comment for the object in FortiManager.}
	country=${7:# Country name. Required if type = geographic.}
	end_ip=${8:# End IP. Only used when ipv4 = iprange.}
	group_members=${9:# Address group member. If this is defined w/out group_name, the operation will fail.}
	group_name=${10:# Address group name. If this is defined in playbook task, all other options are ignored.}
	ipv4=${11:ipmask|iprange|fqdn|wildcard|geography|wildcard-fqdn|group}
	ipv4addr=${12:# IP and network mask. If only defining one IP use this parameter. (i.e. 10.7.220.30/255.255.255.255)}
	ipv6=${13:ip|iprange|group}
	ipv6addr=${14:# IPv6 address in full. (i.e. 2001:0db8:85a3:0000:0000:8a2e:0370:7334)}
	fqdn=${15:# Fully qualified domain name.}
	mode=${16:#add|set|delete}
	multicast=${17:multicastrange|broadcastmask|ip6}
	name=${18:# Friendly Name Address object name in FortiManager.}
	obj_id=${19:# Object ID for NSX.}
	start_ip=${20:# Start IP. Only used when ipv4 = iprange.}
	visibility=${21:#enable|disable}
	wildcard=${22:# IP address and wildcard netmask. Required if ipv4 = wildcard.}
	wildcard_fqdn=${23:# Wildcard FQDN. Required if ipv4 = wildcard-fqdn.}

endsnippet

snippet fmgr_secprof_proxy "Manage proxy security profiles in FortiManager" b
fmgr_secprof_proxy: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	strip_encoding=${3:disable|enable}
	name=${4:# Profile name.}
	log_header_change=${5:disable|enable}
	header_x_forwarded_for=${6:pass|add|remove}
	header_x_authenticated_user=${7:pass|add|remove}
	header_x_authenticated_groups=${8:pass|add|remove}
	header_via_response=${9:pass|add|remove}
	header_via_request=${10:pass|add|remove}
	header_front_end_https=${11:pass|add|remove}
	header_client_ip=${12:pass|add|remove}
	headers=${13:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	headers_action=${14:add-to-request|add-to-response|remove-from-request|remove-from-response}
	headers_content=${15:# HTTP header's content.}
	headers_name=${16:# HTTP forwarded header name.}

endsnippet

snippet fmgr_secprof_ips "Managing IPS security profiles in FortiManager" b
fmgr_secprof_ips: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	replacemsg_group=${3:# Replacement message group.}
	name=${4:# Sensor name.}
	extended_log=${5:disable|enable}
	comment=${6:# Comment.}
	block_malicious_url=${7:disable|enable}
	entries=${8:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	entries_action=${9:pass|block|reset|default}
	entries_application=${10:# Applications to be protected. set application ? lists available applications. all includes all applications. other includes all unlisted applications.}
	entries_location=${11:# Protect client or server traffic.}
	entries_log=${12:disable|enable}
	entries_log_attack_context=${13:disable|enable}
	entries_log_packet=${14:disable|enable}
	entries_os=${15:# Operating systems to be protected.  all includes all operating systems. other includes all unlisted operating systems.}
	entries_protocol=${16:# Protocols to be examined. set protocol ? lists available protocols. all includes all protocols. other includes all unlisted protocols.}
	entries_quarantine=${17:none|attacker}
	entries_quarantine_expiry=${18:# Duration of quarantine.}
	entries_quarantine_log=${19:disable|enable}
	entries_rate_count=${20:# Count of the rate.}
	entries_rate_duration=${21:# Duration (sec) of the rate.}
	entries_rate_mode=${22:periodical|continuous}
	entries_rate_track=${23:none|src-ip|dest-ip|dhcp-client-mac|dns-domain}
	entries_rule=${24:# Identifies the predefined or custom IPS signatures to add to the sensor.}
	entries_severity=${25:# Relative severity of the signature, from info to critical. Log messages generated by the signature include the severity.}
	entries_status=${26:disable|enable|default}
	entries_exempt_ip_dst_ip=${27:# Destination IP address and netmask.}
	entries_exempt_ip_src_ip=${28:# Source IP address and netmask.}
	filter=${29:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	filter_action=${30:pass|block|default|reset}
	filter_application=${31:# Vulnerable application filter.}
	filter_location=${32:# Vulnerability location filter.}
	filter_log=${33:disable|enable}
	filter_log_packet=${34:disable|enable}
	filter_name=${35:# Filter name.}
	filter_os=${36:# Vulnerable OS filter.}
	filter_protocol=${37:# Vulnerable protocol filter.}
	filter_quarantine=${38:none|attacker}
	filter_quarantine_expiry=${39:# Duration of quarantine in minute.}
	filter_quarantine_log=${40:disable|enable}
	filter_severity=${41:# Vulnerability severity filter.}
	filter_status=${42:disable|enable|default}
	override=${43:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	override_action=${44:pass|block|reset}
	override_log=${45:disable|enable}
	override_log_packet=${46:disable|enable}
	override_quarantine=${47:none|attacker}
	override_quarantine_expiry=${48:# Duration of quarantine in minute.}
	override_quarantine_log=${49:disable|enable}
	override_rule_id=${50:# Override rule ID.}
	override_status=${51:disable|enable}
	override_exempt_ip_dst_ip=${52:# Destination IP address and netmask.}
	override_exempt_ip_src_ip=${53:# Source IP address and netmask.}

endsnippet

snippet fmgr_fwobj_service "Manages FortiManager Firewall Service Objects." b
fmgr_fwobj_service: >
	adom=${1:root}
	app_category=${2:# Application category ID.}
	app_service_type=${3:# Application service type.}
	application=${4:# Application ID.}
	category=${5:# Service category.}
	check_reset_range=${6:# Enable disable RST check.}
	color=${7:22}
	comment=${8:# Comment.}
	custom_type=${9:tcp_udp_sctp|icmp|icmp6|ip|http|ftp|connect|socks_tcp|socks_udp|#all}
	explicit_proxy=${10:enable|#disable}
	fqdn=${11:}
	group_name=${12:# Name of the Service Group.}
	group_member=${13:# Comma-Seperated list of members' names.}
	icmp_code=${14:# ICMP code.}
	icmp_type=${15:# ICMP type.}
	iprange=${16:0.0.0.0}
	name=${17:# Custom service name.}
	mode=${18:#add|set|delete}
	object_type=${19:custom|group|category}
	protocol=${20:# Protocol type.}
	protocol_number=${21:# IP protocol number.}
	sctp_portrange=${22:# Multiple SCTP port ranges. Comma separated list of destination ports to add (i.e. '443,80').}
	session_ttl=${23:0}
	tcp_halfclose_timer=${24:0}
	tcp_halfopen_timer=${25:0}
	tcp_portrange=${26:# Comma separated list of destination ports to add (i.e. '443,80').}
	tcp_timewait_timer=${27:0}
	udp_idle_timer=${28:0}
	udp_portrange=${29:# Comma separated list of destination ports to add (i.e. '443,80').}
	visibility=${30:#enable|disable}

endsnippet

snippet fmgr_fwobj_ippool6 "Allows the editing of IP Pool Objects within FortiManager." b
fmgr_fwobj_ippool6: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	startip=${3:# First IPv6 address (inclusive) in the range for the address pool.}
	name=${4:# IPv6 IP pool name.}
	endip=${5:# Final IPv6 address (inclusive) in the range for the address pool.}
	comments=${6:# Comment.}
	dynamic_mapping=${7:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	dynamic_mapping_comments=${8:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_endip=${9:# Dynamic Mapping clone of original suffixed parameter.}
	dynamic_mapping_startip=${10:# Dynamic Mapping clone of original suffixed parameter.}

endsnippet

snippet fmgr_fwobj_vip "Manages Virtual IPs objects in FortiManager" b
fmgr_fwobj_vip: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	websphere_server=${3:disable|enable}
	weblogic_server=${4:disable|enable}
	type=${5:static-nat|load-balance|server-load-balance|dns-translation|fqdn}
	ssl_server_session_state_type=${6:disable|time|count|both}
	ssl_server_session_state_timeout=${7:# Number of minutes to keep FortiGate to Server SSL session state.}
	ssl_server_session_state_max=${8:# Maximum number of FortiGate to Server SSL session states to keep.}
	ssl_server_min_version=${9:ssl-3.0|tls-1.0|tls-1.1|tls-1.2|client}
	ssl_server_max_version=${10:ssl-3.0|tls-1.0|tls-1.1|tls-1.2|client}
	ssl_server_algorithm=${11:high|low|medium|custom|client}
	ssl_send_empty_frags=${12:disable|enable}
	ssl_pfs=${13:require|deny|allow}
	ssl_mode=${14:half|full}
	ssl_min_version=${15:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	ssl_max_version=${16:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	ssl_http_match_host=${17:disable|enable}
	ssl_http_location_conversion=${18:disable|enable}
	ssl_hsts_include_subdomains=${19:disable|enable}
	ssl_hsts_age=${20:# Number of seconds the client should honour the HSTS setting.}
	ssl_hsts=${21:disable|enable}
	ssl_hpkp_report_uri=${22:# URL to report HPKP violations to.}
	ssl_hpkp_primary=${23:# Certificate to generate primary HPKP pin from.}
	ssl_hpkp_include_subdomains=${24:disable|enable}
	ssl_hpkp_backup=${25:# Certificate to generate backup HPKP pin from.}
	ssl_hpkp_age=${26:# Number of seconds the client should honour the HPKP setting.}
	ssl_hpkp=${27:disable|enable|report-only}
	ssl_dh_bits=${28:768|1024|1536|2048|3072|4096}
	ssl_client_session_state_type=${29:disable|time|count|both}
	ssl_client_session_state_timeout=${30:# Number of minutes to keep client to FortiGate SSL session state.}
	ssl_client_session_state_max=${31:# Maximum number of client to FortiGate SSL session states to keep.}
	ssl_client_renegotiation=${32:deny|allow|secure}
	ssl_client_fallback=${33:disable|enable}
	ssl_certificate=${34:# The name of the SSL certificate to use for SSL acceleration.}
	ssl_algorithm=${35:high|medium|low|custom}
	srcintf_filter=${36:# Interfaces to which the VIP applies. Separate the names with spaces.}
	src_filter=${37:# Source address filter. Each address must be either an IP/subnet (x.x.x.x/n) or a range (x.x.x.x-y.y.y.y).}
	service=${38:# Service name.}
	server_type=${39:http|https|ssl|tcp|udp|ip|imaps|pop3s|smtps}
	protocol=${40:tcp|udp|sctp|icmp}
	portmapping_type=${41:1-to-1|m-to-n}
	portforward=${42:disable|enable}
	persistence=${43:none|http-cookie|ssl-session-id}
	outlook_web_access=${44:disable|enable}
	nat_source_vip=${45:disable|enable}
	name=${46:# Virtual IP name.}
	monitor=${47:# Name of the health check monitor to use when polling to determine a virtual server's connectivity status.}
	max_embryonic_connections=${48:# Maximum number of incomplete connections.}
	mappedport=${49:# Port number range on the destination network to which the external port number range is mapped.}
	mappedip=${50:# IP address or address range on the destination network to which the external IP address is mapped.}
	mapped_addr=${51:# Mapped FQDN address name.}
	ldb_method=${52:static|round-robin|weighted|least-session|least-rtt|first-alive|http-host}
	https_cookie_secure=${53:disable|enable}
	http_multiplex=${54:disable|enable}
	http_ip_header_name=${55:# For HTTP multiplexing, enter a custom HTTPS header name. The orig client IP address is added to this header.}
	http_ip_header=${56:disable|enable}
	http_cookie_share=${57:disable|same-ip}
	http_cookie_path=${58:# Limit HTTP cookie persistence to the specified path.}
	http_cookie_generation=${59:# Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.}
	http_cookie_domain_from_host=${60:disable|enable}
	http_cookie_domain=${61:# Domain that HTTP cookie persistence should apply to.}
	http_cookie_age=${62:# Time in minutes that client web browsers should keep a cookie. Default is 60 seconds. 0 = no time limit.}
	gratuitous_arp_interval=${63:# Enable to have the VIP send gratuitous ARPs. 0=disabled. Set from 5 up to 8640000 seconds to enable.}
	extport=${64:# Incoming port number range that you want to map to a port number range on the destination network.}
	extip=${65:# IP address or address range on the external interface that you want to map to an address or address range on t}
	extintf=${66:# Interface connected to the source network that receives the packets that will be forwarded to the destination}
	extaddr=${67:# External FQDN address name.}
	dns_mapping_ttl=${68:# DNS mapping TTL (Set to zero to use TTL in DNS response, default = 0).}
	comment=${69:# Comment.}
	color=${70:# Color of icon on the GUI.}
	arp_reply=${71:disable|enable}
	dynamic_mapping=${72:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	dynamic_mapping_arp_reply=${73:disable|enable}
	dynamic_mapping_color=${74:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_comment=${75:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_dns_mapping_ttl=${76:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_extaddr=${77:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_extintf=${78:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_extip=${79:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_extport=${80:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_gratuitous_arp_interval=${81:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_http_cookie_age=${82:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_http_cookie_domain=${83:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_http_cookie_domain_from_host=${84:disable|enable}
	dynamic_mapping_http_cookie_generation=${85:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_http_cookie_path=${86:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_http_cookie_share=${87:disable|same-ip}
	dynamic_mapping_http_ip_header=${88:disable|enable}
	dynamic_mapping_http_ip_header_name=${89:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_http_multiplex=${90:disable|enable}
	dynamic_mapping_https_cookie_secure=${91:disable|enable}
	dynamic_mapping_ldb_method=${92:static|round-robin|weighted|least-session|least-rtt|first-alive|http-host}
	dynamic_mapping_mapped_addr=${93:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_mappedip=${94:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_mappedport=${95:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_max_embryonic_connections=${96:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_monitor=${97:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_nat_source_vip=${98:disable|enable}
	dynamic_mapping_outlook_web_access=${99:disable|enable}
	dynamic_mapping_persistence=${100:none|http-cookie|ssl-session-id}
	dynamic_mapping_portforward=${101:disable|enable}
	dynamic_mapping_portmapping_type=${102:1-to-1|m-to-n}
	dynamic_mapping_protocol=${103:tcp|udp|sctp|icmp}
	dynamic_mapping_server_type=${104:http|https|ssl|tcp|udp|ip|imaps|pop3s|smtps}
	dynamic_mapping_service=${105:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_src_filter=${106:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_srcintf_filter=${107:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_algorithm=${108:high|medium|low|custom}
	dynamic_mapping_ssl_certificate=${109:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_client_fallback=${110:disable|enable}
	dynamic_mapping_ssl_client_renegotiation=${111:deny|allow|secure}
	dynamic_mapping_ssl_client_session_state_max=${112:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_client_session_state_timeout=${113:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_client_session_state_type=${114:disable|time|count|both}
	dynamic_mapping_ssl_dh_bits=${115:768|1024|1536|2048|3072|4096}
	dynamic_mapping_ssl_hpkp=${116:disable|enable|report-only}
	dynamic_mapping_ssl_hpkp_age=${117:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_hpkp_backup=${118:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_hpkp_include_subdomains=${119:disable|enable}
	dynamic_mapping_ssl_hpkp_primary=${120:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_hpkp_report_uri=${121:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_hsts=${122:disable|enable}
	dynamic_mapping_ssl_hsts_age=${123:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_hsts_include_subdomains=${124:disable|enable}
	dynamic_mapping_ssl_http_location_conversion=${125:disable|enable}
	dynamic_mapping_ssl_http_match_host=${126:disable|enable}
	dynamic_mapping_ssl_max_version=${127:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	dynamic_mapping_ssl_min_version=${128:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	dynamic_mapping_ssl_mode=${129:half|full}
	dynamic_mapping_ssl_pfs=${130:require|deny|allow}
	dynamic_mapping_ssl_send_empty_frags=${131:disable|enable}
	dynamic_mapping_ssl_server_algorithm=${132:high|low|medium|custom|client}
	dynamic_mapping_ssl_server_max_version=${133:ssl-3.0|tls-1.0|tls-1.1|tls-1.2|client}
	dynamic_mapping_ssl_server_min_version=${134:ssl-3.0|tls-1.0|tls-1.1|tls-1.2|client}
	dynamic_mapping_ssl_server_session_state_max=${135:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_server_session_state_timeout=${136:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_server_session_state_type=${137:disable|time|count|both}
	dynamic_mapping_type=${138:static-nat|load-balance|server-load-balance|dns-translation|fqdn}
	dynamic_mapping_weblogic_server=${139:disable|enable}
	dynamic_mapping_websphere_server=${140:disable|enable}
	dynamic_mapping_realservers_client_ip=${141:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_healthcheck=${142:disable|enable|vip}
	dynamic_mapping_realservers_holddown_interval=${143:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_http_host=${144:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_ip=${145:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_max_connections=${146:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_monitor=${147:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_port=${148:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_seq=${149:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_realservers_status=${150:active|standby|disable}
	dynamic_mapping_realservers_weight=${151:# Dynamic Mapping Version of Suffixed Option Name. Sub-Table. Same Descriptions as Parent.}
	dynamic_mapping_ssl_cipher_suites_cipher=${152:TLS-RSA-WITH-RC4-128-MD5|TLS-RSA-WITH-RC4-128-SHA|TLS-RSA-WITH-DES-CBC-SHA|TLS-RSA-WITH-3DES-EDE-CBC-SHA|TLS-RSA-WITH-AES-128-CBC-SHA|TLS-RSA-WITH-AES-256-CBC-SHA|TLS-RSA-WITH-AES-128-CBC-SHA256|TLS-RSA-WITH-AES-256-CBC-SHA256|TLS-RSA-WITH-CAMELLIA-128-CBC-SHA|TLS-RSA-WITH-CAMELLIA-256-CBC-SHA|TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256|TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256|TLS-RSA-WITH-SEED-CBC-SHA|TLS-RSA-WITH-ARIA-128-CBC-SHA256|TLS-RSA-WITH-ARIA-256-CBC-SHA384|TLS-DHE-RSA-WITH-DES-CBC-SHA|TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA|TLS-DHE-RSA-WITH-AES-128-CBC-SHA|TLS-DHE-RSA-WITH-AES-256-CBC-SHA|TLS-DHE-RSA-WITH-AES-128-CBC-SHA256|TLS-DHE-RSA-WITH-AES-256-CBC-SHA256|TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA|TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA|TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256|TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256|TLS-DHE-RSA-WITH-SEED-CBC-SHA|TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256|TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-RC4-128-SHA|TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA|TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA|TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA|TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256|TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256|TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256|TLS-DHE-RSA-WITH-AES-128-GCM-SHA256|TLS-DHE-RSA-WITH-AES-256-GCM-SHA384|TLS-DHE-DSS-WITH-AES-128-CBC-SHA|TLS-DHE-DSS-WITH-AES-256-CBC-SHA|TLS-DHE-DSS-WITH-AES-128-CBC-SHA256|TLS-DHE-DSS-WITH-AES-128-GCM-SHA256|TLS-DHE-DSS-WITH-AES-256-CBC-SHA256|TLS-DHE-DSS-WITH-AES-256-GCM-SHA384|TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256|TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256|TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384|TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA|TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256|TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256|TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384|TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384|TLS-RSA-WITH-AES-128-GCM-SHA256|TLS-RSA-WITH-AES-256-GCM-SHA384|TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA|TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA|TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256|TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256|TLS-DHE-DSS-WITH-SEED-CBC-SHA|TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256|TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256|TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256|TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384|TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA|TLS-DHE-DSS-WITH-DES-CBC-SHA}
	dynamic_mapping_ssl_cipher_suites_versions=${153:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	realservers=${154:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	realservers_client_ip=${155:# Only clients in this IP range can connect to this real server.}
	realservers_healthcheck=${156:disable|enable|vip}
	realservers_holddown_interval=${157:# Time in seconds that the health check monitor monitors an unresponsive server that should be active.}
	realservers_http_host=${158:# HTTP server domain name in HTTP header.}
	realservers_ip=${159:# IP address of the real server.}
	realservers_max_connections=${160:# Max number of active connections that can be directed to the real server. When reached, sessions are sent to}
	realservers_monitor=${161:# Name of the health check monitor to use when polling to determine a virtual server's connectivity status.}
	realservers_port=${162:# Port for communicating with the real server. Required if port forwarding is enabled.}
	realservers_seq=${163:# Real Server Sequence Number}
	realservers_status=${164:active|standby|disable}
	realservers_weight=${165:# Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more}
	ssl_cipher_suites=${166:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ssl_cipher_suites_cipher=${167:TLS-RSA-WITH-RC4-128-MD5|TLS-RSA-WITH-RC4-128-SHA|TLS-RSA-WITH-DES-CBC-SHA|TLS-RSA-WITH-3DES-EDE-CBC-SHA|TLS-RSA-WITH-AES-128-CBC-SHA|TLS-RSA-WITH-AES-256-CBC-SHA|TLS-RSA-WITH-AES-128-CBC-SHA256|TLS-RSA-WITH-AES-256-CBC-SHA256|TLS-RSA-WITH-CAMELLIA-128-CBC-SHA|TLS-RSA-WITH-CAMELLIA-256-CBC-SHA|TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256|TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256|TLS-RSA-WITH-SEED-CBC-SHA|TLS-RSA-WITH-ARIA-128-CBC-SHA256|TLS-RSA-WITH-ARIA-256-CBC-SHA384|TLS-DHE-RSA-WITH-DES-CBC-SHA|TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA|TLS-DHE-RSA-WITH-AES-128-CBC-SHA|TLS-DHE-RSA-WITH-AES-256-CBC-SHA|TLS-DHE-RSA-WITH-AES-128-CBC-SHA256|TLS-DHE-RSA-WITH-AES-256-CBC-SHA256|TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA|TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA|TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256|TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256|TLS-DHE-RSA-WITH-SEED-CBC-SHA|TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256|TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-RC4-128-SHA|TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA|TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA|TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA|TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256|TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256|TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256|TLS-DHE-RSA-WITH-AES-128-GCM-SHA256|TLS-DHE-RSA-WITH-AES-256-GCM-SHA384|TLS-DHE-DSS-WITH-AES-128-CBC-SHA|TLS-DHE-DSS-WITH-AES-256-CBC-SHA|TLS-DHE-DSS-WITH-AES-128-CBC-SHA256|TLS-DHE-DSS-WITH-AES-128-GCM-SHA256|TLS-DHE-DSS-WITH-AES-256-CBC-SHA256|TLS-DHE-DSS-WITH-AES-256-GCM-SHA384|TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256|TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256|TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384|TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA|TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256|TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256|TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384|TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384|TLS-RSA-WITH-AES-128-GCM-SHA256|TLS-RSA-WITH-AES-256-GCM-SHA384|TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA|TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA|TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256|TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256|TLS-DHE-DSS-WITH-SEED-CBC-SHA|TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256|TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256|TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256|TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384|TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA|TLS-DHE-DSS-WITH-DES-CBC-SHA}
	ssl_cipher_suites_versions=${168:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}
	ssl_server_cipher_suites=${169:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ssl_server_cipher_suites_cipher=${170:TLS-RSA-WITH-RC4-128-MD5|TLS-RSA-WITH-RC4-128-SHA|TLS-RSA-WITH-DES-CBC-SHA|TLS-RSA-WITH-3DES-EDE-CBC-SHA|TLS-RSA-WITH-AES-128-CBC-SHA|TLS-RSA-WITH-AES-256-CBC-SHA|TLS-RSA-WITH-AES-128-CBC-SHA256|TLS-RSA-WITH-AES-256-CBC-SHA256|TLS-RSA-WITH-CAMELLIA-128-CBC-SHA|TLS-RSA-WITH-CAMELLIA-256-CBC-SHA|TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256|TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256|TLS-RSA-WITH-SEED-CBC-SHA|TLS-RSA-WITH-ARIA-128-CBC-SHA256|TLS-RSA-WITH-ARIA-256-CBC-SHA384|TLS-DHE-RSA-WITH-DES-CBC-SHA|TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA|TLS-DHE-RSA-WITH-AES-128-CBC-SHA|TLS-DHE-RSA-WITH-AES-256-CBC-SHA|TLS-DHE-RSA-WITH-AES-128-CBC-SHA256|TLS-DHE-RSA-WITH-AES-256-CBC-SHA256|TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA|TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA|TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256|TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256|TLS-DHE-RSA-WITH-SEED-CBC-SHA|TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256|TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-RC4-128-SHA|TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA|TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA|TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA|TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256|TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256|TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256|TLS-DHE-RSA-WITH-AES-128-GCM-SHA256|TLS-DHE-RSA-WITH-AES-256-GCM-SHA384|TLS-DHE-DSS-WITH-AES-128-CBC-SHA|TLS-DHE-DSS-WITH-AES-256-CBC-SHA|TLS-DHE-DSS-WITH-AES-128-CBC-SHA256|TLS-DHE-DSS-WITH-AES-128-GCM-SHA256|TLS-DHE-DSS-WITH-AES-256-CBC-SHA256|TLS-DHE-DSS-WITH-AES-256-GCM-SHA384|TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256|TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256|TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384|TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA|TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256|TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256|TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384|TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384|TLS-RSA-WITH-AES-128-GCM-SHA256|TLS-RSA-WITH-AES-256-GCM-SHA384|TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA|TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA|TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256|TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256|TLS-DHE-DSS-WITH-SEED-CBC-SHA|TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256|TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256|TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384|TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256|TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384|TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA|TLS-DHE-DSS-WITH-DES-CBC-SHA}
	ssl_server_cipher_suites_priority=${171:# SSL/TLS cipher suites priority.}
	ssl_server_cipher_suites_versions=${172:ssl-3.0|tls-1.0|tls-1.1|tls-1.2}

endsnippet

snippet fmgr_script "Add/Edit/Delete and execute scripts" b
fmgr_script: >
	adom=${1:# The administrative domain (admon) the configuration belongs to}
	script_name=${2:# The name of the script.}

	vdom=${3:# The virtual domain (vdom) the configuration belongs to}
	mode=${4:#add|delete|execute|set}
	script_type=${5:# The type of script (CLI or TCL).}
	script_target=${6:# The target of the script to be run.}
	script_description=${7:# The description of the script.}
	script_content=${8:# The script content that will be executed.}
	script_scope=${9:# (datasource) The devices that the script will run on, can have both device member and device group member.}
	script_package=${10:# (datasource) Policy package object to run the script against}

endsnippet

snippet fmgr_secprof_spam "spam filter profile for FMG" b
fmgr_secprof_spam: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	spam_rbl_table=${3:# Anti-spam DNSBL table ID.}
	spam_mheader_table=${4:# Anti-spam MIME header table ID.}
	spam_log_fortiguard_response=${5:disable|enable}
	spam_log=${6:disable|enable}
	spam_iptrust_table=${7:# Anti-spam IP trust table ID.}
	spam_filtering=${8:disable|enable}
	spam_bword_threshold=${9:# Spam banned word threshold.}
	spam_bword_table=${10:# Anti-spam banned word table ID.}
	spam_bwl_table=${11:# Anti-spam black/white list table ID.}
	replacemsg_group=${12:# Replacement message group.}
	options=${13:bannedword|spamfsip|spamfssubmit|spamfschksum|spamfsurl|spamhelodns|spamraddrdns|spamrbl|spamhdrcheck|spamfsphish|spambwl}
	name=${14:# Profile name.}
	flow_based=${15:disable|enable}
	external=${16:disable|enable}
	comment=${17:# Comment.}
	gmail=${18:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	gmail_log=${19:disable|enable}
	imap=${20:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	imap_action=${21:pass|tag}
	imap_log=${22:disable|enable}
	imap_tag_msg=${23:# Subject text or header added to spam email.}
	imap_tag_type=${24:subject|header|spaminfo}
	mapi=${25:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	mapi_action=${26:pass|discard}
	mapi_log=${27:disable|enable}
	msn_hotmail=${28:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	msn_hotmail_log=${29:disable|enable}
	pop3=${30:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	pop3_action=${31:pass|tag}
	pop3_log=${32:disable|enable}
	pop3_tag_msg=${33:# Subject text or header added to spam email.}
	pop3_tag_type=${34:subject|header|spaminfo}
	smtp=${35:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	smtp_action=${36:pass|tag|discard}
	smtp_hdrip=${37:disable|enable}
	smtp_local_override=${38:disable|enable}
	smtp_log=${39:disable|enable}
	smtp_tag_msg=${40:# Subject text or header added to spam email.}
	smtp_tag_type=${41:subject|header|spaminfo}
	yahoo_mail=${42:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	yahoo_mail_log=${43:disable|enable}

endsnippet

snippet fmgr_secprof_av "Manage security profile" b
fmgr_secprof_av: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	scan_mode=${3:quick|full}
	replacemsg_group=${4:# Replacement message group customized for this profile.}
	name=${5:# Profile name.}
	mobile_malware_db=${6:disable|enable}
	inspection_mode=${7:proxy|flow-based}
	ftgd_analytics=${8:disable|suspicious|everything}
	extended_log=${9:disable|enable}
	comment=${10:# Comment.}
	av_virus_log=${11:disable|enable}
	av_block_log=${12:disable|enable}
	analytics_wl_filetype=${13:# Do not submit files matching this DLP file-pattern to FortiSandbox.}
	analytics_max_upload=${14:# Maximum size of files that can be uploaded to FortiSandbox (1 - 395 MBytes, default = 10).}
	analytics_db=${15:disable|enable}
	analytics_bl_filetype=${16:# Only submit files matching this DLP file-pattern to FortiSandbox.}
	content_disarm=${17:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	content_disarm_cover_page=${18:disable|enable}
	content_disarm_detect_only=${19:disable|enable}
	content_disarm_office_embed=${20:disable|enable}
	content_disarm_office_hylink=${21:disable|enable}
	content_disarm_office_linked=${22:disable|enable}
	content_disarm_office_macro=${23:disable|enable}
	content_disarm_original_file_destination=${24:fortisandbox|quarantine|discard}
	content_disarm_pdf_act_form=${25:disable|enable}
	content_disarm_pdf_act_gotor=${26:disable|enable}
	content_disarm_pdf_act_java=${27:disable|enable}
	content_disarm_pdf_act_launch=${28:disable|enable}
	content_disarm_pdf_act_movie=${29:disable|enable}
	content_disarm_pdf_act_sound=${30:disable|enable}
	content_disarm_pdf_embedfile=${31:disable|enable}
	content_disarm_pdf_hyperlink=${32:disable|enable}
	content_disarm_pdf_javacode=${33:disable|enable}
	ftp=${34:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ftp_archive_block=${35:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	ftp_archive_log=${36:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	ftp_emulator=${37:disable|enable}
	ftp_options=${38:scan|quarantine|avmonitor}
	ftp_outbreak_prevention=${39:disabled|files|full-archive}
	http=${40:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	http_archive_block=${41:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	http_archive_log=${42:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	http_content_disarm=${43:disable|enable}
	http_emulator=${44:disable|enable}
	http_options=${45:scan|quarantine|avmonitor}
	http_outbreak_prevention=${46:disabled|files|full-archive}
	imap=${47:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	imap_archive_block=${48:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	imap_archive_log=${49:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	imap_content_disarm=${50:disable|enable}
	imap_emulator=${51:disable|enable}
	imap_executables=${52:default|virus}
	imap_options=${53:scan|quarantine|avmonitor}
	imap_outbreak_prevention=${54:disabled|files|full-archive}
	mapi=${55:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	mapi_archive_block=${56:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	mapi_archive_log=${57:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	mapi_emulator=${58:disable|enable}
	mapi_executables=${59:default|virus}
	mapi_options=${60:scan|quarantine|avmonitor}
	mapi_outbreak_prevention=${61:disabled|files|full-archive}
	nac_quar=${62:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	nac_quar_expiry=${63:# Duration of quarantine.}
	nac_quar_infected=${64:none|quar-src-ip}
	nac_quar_log=${65:disable|enable}
	nntp=${66:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	nntp_archive_block=${67:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	nntp_archive_log=${68:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	nntp_emulator=${69:disable|enable}
	nntp_options=${70:scan|quarantine|avmonitor}
	nntp_outbreak_prevention=${71:disabled|files|full-archive}
	pop3=${72:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	pop3_archive_block=${73:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	pop3_archive_log=${74:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	pop3_content_disarm=${75:disable|enable}
	pop3_emulator=${76:disable|enable}
	pop3_executables=${77:default|virus}
	pop3_options=${78:scan|quarantine|avmonitor}
	pop3_outbreak_prevention=${79:disabled|files|full-archive}
	smb=${80:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	smb_archive_block=${81:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	smb_archive_log=${82:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	smb_emulator=${83:disable|enable}
	smb_options=${84:scan|quarantine|avmonitor}
	smb_outbreak_prevention=${85:disabled|files|full-archive}
	smtp=${86:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	smtp_archive_block=${87:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	smtp_archive_log=${88:encrypted|corrupted|multipart|nested|mailbomb|unhandled|partiallycorrupted|fileslimit|timeout}
	smtp_content_disarm=${89:disable|enable}
	smtp_emulator=${90:disable|enable}
	smtp_executables=${91:default|virus}
	smtp_options=${92:scan|quarantine|avmonitor}
	smtp_outbreak_prevention=${93:disabled|files|full-archive}

endsnippet

snippet fmgr_device_group "Alter FortiManager device groups." b
fmgr_device_group: >
	adom=${1:root}
	vdom=${2:root}
	mode=${3:#add|set|delete|update}
	grp_name=${4:# The name of the device group.}
	grp_desc=${5:# The description of the device group.}
	grp_members=${6:# A comma separated list of device names or device groups to be added as members to the device group.}

endsnippet

snippet fmgr_secprof_profile_group "Manage security profiles within FortiManager" b
fmgr_secprof_profile_group: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	webfilter_profile=${3:# Name of an existing Web filter profile.}
	waf_profile=${4:# Name of an existing Web application firewall profile.}
	voip_profile=${5:# Name of an existing VoIP profile.}
	ssl_ssh_profile=${6:# Name of an existing SSL SSH profile.}
	ssh_filter_profile=${7:# Name of an existing SSH filter profile.}
	spamfilter_profile=${8:# Name of an existing Spam filter profile.}
	profile_protocol_options=${9:# Name of an existing Protocol options profile.}
	name=${10:# Profile group name.}
	mms_profile=${11:# Name of an existing MMS profile.}
	ips_sensor=${12:# Name of an existing IPS sensor.}
	icap_profile=${13:# Name of an existing ICAP profile.}
	dnsfilter_profile=${14:# Name of an existing DNS filter profile.}
	dlp_sensor=${15:# Name of an existing DLP sensor.}
	av_profile=${16:# Name of an existing Antivirus profile.}
	application_list=${17:# Name of an existing Application list.}

endsnippet

snippet fmgr_secprof_ssl_ssh "Manage SSL and SSH security profiles in FortiManager" b
fmgr_secprof_ssl_ssh: >
	adom=${1:root}
	mode=${2:#add|set|delete|update}
	whitelist=${3:disable|enable}
	use_ssl_server=${4:disable|enable}
	untrusted_caname=${5:# Untrusted CA certificate used by SSL Inspection.}
	ssl_exemptions_log=${6:disable|enable}
	ssl_anomalies_log=${7:disable|enable}
	server_cert_mode=${8:re-sign|replace}
	server_cert=${9:# Certificate used by SSL Inspection to replace server certificate.}
	rpc_over_https=${10:disable|enable}
	name=${11:# Name.}
	mapi_over_https=${12:disable|enable}
	comment=${13:# Optional comments.}
	caname=${14:# CA certificate used by SSL Inspection.}
	ftps=${15:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ftps_allow_invalid_server_cert=${16:disable|enable}
	ftps_client_cert_request=${17:bypass|inspect|block}
	ftps_ports=${18:# Ports to use for scanning (1 - 65535, default = 443).}
	ftps_status=${19:disable|deep-inspection}
	ftps_unsupported_ssl=${20:bypass|inspect|block}
	ftps_untrusted_cert=${21:allow|block|ignore}
	https=${22:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	https_allow_invalid_server_cert=${23:disable|enable}
	https_client_cert_request=${24:bypass|inspect|block}
	https_ports=${25:# Ports to use for scanning (1 - 65535, default = 443).}
	https_status=${26:disable|certificate-inspection|deep-inspection}
	https_unsupported_ssl=${27:bypass|inspect|block}
	https_untrusted_cert=${28:allow|block|ignore}
	imaps=${29:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	imaps_allow_invalid_server_cert=${30:disable|enable}
	imaps_client_cert_request=${31:bypass|inspect|block}
	imaps_ports=${32:# Ports to use for scanning (1 - 65535, default = 443).}
	imaps_status=${33:disable|deep-inspection}
	imaps_unsupported_ssl=${34:bypass|inspect|block}
	imaps_untrusted_cert=${35:allow|block|ignore}
	pop3s=${36:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	pop3s_allow_invalid_server_cert=${37:disable|enable}
	pop3s_client_cert_request=${38:bypass|inspect|block}
	pop3s_ports=${39:# Ports to use for scanning (1 - 65535, default = 443).}
	pop3s_status=${40:disable|deep-inspection}
	pop3s_unsupported_ssl=${41:bypass|inspect|block}
	pop3s_untrusted_cert=${42:allow|block|ignore}
	smtps=${43:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	smtps_allow_invalid_server_cert=${44:disable|enable}
	smtps_client_cert_request=${45:bypass|inspect|block}
	smtps_ports=${46:# Ports to use for scanning (1 - 65535, default = 443).}
	smtps_status=${47:disable|deep-inspection}
	smtps_unsupported_ssl=${48:bypass|inspect|block}
	smtps_untrusted_cert=${49:allow|block|ignore}
	ssh=${50:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ssh_inspect_all=${51:disable|deep-inspection}
	ssh_ports=${52:# Ports to use for scanning (1 - 65535, default = 443).}
	ssh_ssh_algorithm=${53:compatible|high-encryption}
	ssh_ssh_policy_check=${54:disable|enable}
	ssh_ssh_tun_policy_check=${55:disable|enable}
	ssh_status=${56:disable|deep-inspection}
	ssh_unsupported_version=${57:block|bypass}
	ssl=${58:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ssl_allow_invalid_server_cert=${59:disable|enable}
	ssl_client_cert_request=${60:bypass|inspect|block}
	ssl_inspect_all=${61:disable|certificate-inspection|deep-inspection}
	ssl_unsupported_ssl=${62:bypass|inspect|block}
	ssl_untrusted_cert=${63:allow|block|ignore}
	ssl_exempt=${64:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ssl_exempt_address=${65:# IPv4 address object.}
	ssl_exempt_address6=${66:# IPv6 address object.}
	ssl_exempt_fortiguard_category=${67:# FortiGuard category ID.}
	ssl_exempt_regex=${68:# Exempt servers by regular expression.}
	ssl_exempt_type=${69:fortiguard-category|address|address6|wildcard-fqdn|regex}
	ssl_exempt_wildcard_fqdn=${70:# Exempt servers by wildcard FQDN.}
	ssl_server=${71:# EXPERTS ONLY! KNOWLEDGE OF FMGR JSON API IS REQUIRED!}
	ssl_server_ftps_client_cert_request=${72:bypass|inspect|block}
	ssl_server_https_client_cert_request=${73:bypass|inspect|block}
	ssl_server_imaps_client_cert_request=${74:bypass|inspect|block}
	ssl_server_ip=${75:# IPv4 address of the SSL server.}
	ssl_server_pop3s_client_cert_request=${76:bypass|inspect|block}
	ssl_server_smtps_client_cert_request=${77:bypass|inspect|block}
	ssl_server_ssl_other_client_cert_request=${78:bypass|inspect|block}

endsnippet

snippet fmgr_fwpol_package "Manages FortiManager Firewall Policies Packages." b
fmgr_fwpol_package: >
	name=${1:# Name of the FortiManager package or folder.}
	object_type=${2:pkg|folder|install}

	adom=${3:root}
	mode=${4:#add|set|delete}
	package_folder=${5:# Name of the folder you want to put the package into.}
	central_nat=${6:enable|#disable}
	fwpolicy_implicit_log=${7:enable|#disable}
	fwpolicy6_implicit_log=${8:enable|#disable}
	inspection_mode=${9:#flow|proxy}
	ngfw_mode=${10:#profile-based|policy-based}
	ssl_ssh_profile=${11:# if policy-based ngfw-mode, refer to firewall ssl-ssh-profile.}
	scope_members=${12:# The devices or scope that you want to assign this policy package to.}
	scope_members_vdom=${13:root}
	parent_folder=${14:# The parent folder name you want to add this object under.}

endsnippet

snippet fmgr_provisioning "Provision devices via FortiMananger" b
fmgr_provisioning: >
	adom=${1:# The administrative domain (admon) the configuration belongs to}
	host=${2:# The FortiManager's Address.}
	username=${3:# The username to log into the FortiManager}
	policy_package=${4:# The name of the policy package to be assigned to the device.}
	name=${5:# The name of the device to be provisioned.}
	serial=${6:# The serial number of the device that will be provisioned.}
	platform=${7:# The platform of the device, such as model number or VM.}
	os_version=${8:# The Fortinet OS version to be used for the device, such as 5.0 or 6.0.}
	os_type=${9:# The Fortinet OS type to be pushed to the device, such as 'FOS' for FortiOS.}

	vdom=${10:# The virtual domain (vdom) the configuration belongs to}
	password=${11:# The password associated with the username account.}
	group=${12:# The name of the device group the provisioned device can belong to.}
	description=${13:# Description of the device to be provisioned.}
	minor_release=${14:# The minor release number such as 6.X.1, as X being the minor release.}
	patch_release=${15:# The patch release number such as 6.0.X, as X being the patch release.}

endsnippet

snippet eric_eccli_command "Run commands on remote devices running ERICSSON ECCLI" b
eric_eccli_command: >
	commands=${1:# List of commands to send to the remote ECCLI device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired. If a command sent to the device requires answering a prompt, it is possible to pass a dict containing I(command), I(answer) and I(prompt). Common answers are 'y' or "\r" (carriage return, must be double quotes). See examples.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet iosxr_lacp "Manage Global Link Aggregation Control Protocol (LACP) on IOS-XR devices." b
iosxr_lacp: >
	config=${1:# T}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet iosxr_facts "Get facts about iosxr devices." b
iosxr_facts: >
	gather_subset=${1:!config}
	gather_network_resources=${2:# When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all and the resources like interfaces, lacp etc. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Valid subsets are 'all', 'lacp', 'lacp_interfaces', 'lldp_global', 'lldp_interfaces', 'interfaces', 'l2_interfaces', 'l3_interfaces', 'lag_interfaces'.}
	provider=${3:# B(Deprecated)}

endsnippet

snippet iosxr_bgp "Configure global BGP protocol settings on Cisco IOS-XR" b
iosxr_bgp: >
	config=${1:# Specifies the BGP related configuration.}
	operation=${2:#merge|replace|override|delete}

endsnippet

snippet iosxr_config "Manage Cisco IOS XR configuration sections" b
iosxr_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block|config}
	force=${8:no}
	config=${9:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	backup=${10:no}
	comment=${11:configured by iosxr_config}
	admin=${12:no}
	label=${13:# Allows a commit label to be specified to be included when the configuration is committed. A valid label must begin with an alphabet and not exceed 30 characters, only alphabets, digits, hyphens and underscores are allowed. If the configuration is not changed or committed, this argument is ignored.}
	backup_options=${14:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	exclusive=${15:no}
	provider=${16:# B(Deprecated)}

endsnippet

snippet iosxr_lldp_interfaces "Manage Link Layer Discovery Protocol (LLDP) attributes of interfaces on IOS-XR devices." b
iosxr_lldp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet iosxr_l3_interfaces "Manage Layer-3 interface on Cisco IOS-XR devices." b
iosxr_l3_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet iosxr_lag_interfaces "Manages attributes of LAG/Ether-Bundle interfaces on IOS-XR devices." b
iosxr_lag_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet iosxr_system "Manage the system attributes on Cisco IOS XR devices" b
iosxr_system: >
	hostname=${1:# Configure the device hostname parameter. This option takes an ASCII string value.}
	vrf=${2:# VRF name for domain services}
	domain_name=${3:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
	domain_search=${4:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
	lookup_source=${5:# The C(lookup_source) argument provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.}
	lookup_enabled=${6:# Provides administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.}
	name_servers=${7:# The C(name_serves) argument accepts a list of DNS name servers by way of either FQDN or IP address to use to perform name resolution lookups.  This argument accepts wither a list of DNS servers See examples.}
	state=${8:#present|absent}
	provider=${9:# B(Deprecated)}

endsnippet

snippet iosxr_logging "Configuration management of system logging services on network devices" b
iosxr_logging: >
	dest=${1:host|console|monitor|buffered|file}
	name=${2:# When C(dest) = I(file) name indicates file-name}
	vrf=${3:default}
	size=${4:# Size of buffer when C(dest) = C(buffered). The acceptable value is in the range I(307200 to 125000000 bytes). Default 307200}
	facility=${5:local7}
	hostnameprefix=${6:# To append a hostname prefix to system logging (syslog) messages logged to syslog servers. Optional config for C(dest) = C(host)}
	level=${7:debugging}
	aggregate=${8:# L}
	state=${9:#present|absent}
	provider=${10:# B(Deprecated)}

endsnippet

snippet iosxr_user "Manage the aggregate of local users on Cisco IOS XR device" b
iosxr_user: >
	aggregate=${1:# The set of username objects to be configured on the remote Cisco IOS XR device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.}
	name=${2:# The username to be configured on the Cisco IOS XR device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
	configured_password=${3:# The password to be configured on the Cisco IOS XR device. The password needs to be provided in clear text. Password is encrypted on the device when used with I(cli) and by Ansible when used with I(netconf) using the same MD5 hash technique with salt size of 3. Please note that this option is not same as C(provider password).}
	update_password=${4:on_create|#always}
	group=${5:# Configures the group for the username in the device running configuration. The argument accepts a string value defining the group name. This argument does not check if the group has been configured on the device.}
	groups=${6:# Configures the groups for the username in the device running configuration. The argument accepts a list of group names. This argument does not check if the group has been configured on the device. It is similar to the aggregate command for usernames, but lets you configure multiple groups for the user(s).}
	purge=${7:no}
	admin=${8:no}
	state=${9:#present|absent}
	public_key=${10:# Configures the contents of the public keyfile to upload to the IOS-XR node. This enables users to login using the accompanying private key. IOS-XR only accepts base64 decoded files, so this will be decoded and uploaded to the node. Do note that this requires an OpenSSL public key file, PuTTy generated files will not work! Mutually exclusive with public_key_contents. If used with multiple users in aggregates, then the same key file is used for all users.}
	public_key_contents=${11:# Configures the contents of the public keyfile to upload to the IOS-XR node. This enables users to login using the accompanying private key. IOS-XR only accepts base64 decoded files, so this will be decoded and uploaded to the node. Do note that this requires an OpenSSL public key file, PuTTy generated files will not work! Mutually exclusive with public_key.If used with multiple users in aggregates, then the same key file is used for all users.}
	provider=${12:# B(Deprecated)}

endsnippet

snippet iosxr_l2_interfaces "Manage Layer-2 interface on Cisco IOS-XR devices" b
iosxr_l2_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet iosxr_banner "Manage multiline banners on Cisco IOS XR devices" b
iosxr_banner: >
	banner=${1:login|motd}

	text=${2:# Banner text to be configured. Accepts multiline string, without empty lines. Requires I(state=present).}
	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet iosxr_lacp_interfaces "Manage Link Aggregation Control Protocol (LACP) attributes of interfaces on IOS-XR devices." b
iosxr_lacp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet iosxr_command "Run commands on remote devices running Cisco IOS XR" b
iosxr_command: >
	commands=${1:# List of commands to send to the remote iosxr device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# B(Deprecated)}

endsnippet

snippet iosxr_lldp_global "Manage Global Link Layer Discovery Protocol (LLDP) settings on IOS-XR devices." b
iosxr_lldp_global: >
	config=${1:# T}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet iosxr_netconf "Configures NetConf sub-system service on Cisco IOS-XR devices" b
iosxr_netconf: >
	netconf_port=${1:830}
	netconf_vrf=${2:default}
	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet iosxr_interfaces "Manage interface attributes on Cisco IOS-XR network devices" b
iosxr_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet a10_virtual_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' virtual servers." b
a10_virtual_server: >
	virtual_server=${1:# The SLB (Server Load Balancing) virtual server name.}
	host=${2:# Hostname or IP of the A10 Networks device.}
	username=${3:# An account with administrator privileges.}
	password=${4:# Password for the C(username) account.}

	state=${5:#present|absent}
	partition=${6:# set active-partition}
	virtual_server_ip=${7:# The SLB virtual server IPv4 address.}
	virtual_server_status=${8:enabled|disabled}
	virtual_server_ports=${9:# A list of ports to create for the virtual server. Each list item should be a dictionary which specifies the C(port:) and C(type:), but can also optionally specify the C(service_group:) as well as the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).}
	validate_certs=${10:yes}
	write_config=${11:no}
	url=${12:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	force=${13:no}
	http_agent=${14:ansible-httpget}
	use_proxy=${15:yes}
	url_username=${16:# The username for use in HTTP basic authentication.}
	url_password=${17:# The password for use in HTTP basic authentication.}
	force_basic_auth=${18:no}
	client_cert=${19:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${20:# PEM formatted file that contains your private key to be used for SSL client authentication.}

endsnippet

snippet a10_server_axapi3 "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices" b
a10_server_axapi3: >
	server_name=${1:# The SLB (Server Load Balancer) server name.}
	server_ip=${2:# The SLB (Server Load Balancer) server IPv4 address.}
	host=${3:# Hostname or IP of the A10 Networks device.}
	username=${4:# An account with administrator privileges.}
	password=${5:# Password for the C(username) account.}

	server_status=${6:#enable|disable}
	server_ports=${7:# A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:).}
	operation=${8:#create|update|remove}
	validate_certs=${9:yes}
	write_config=${10:no}
	url=${11:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	force=${12:no}
	http_agent=${13:ansible-httpget}
	use_proxy=${14:yes}
	url_username=${15:# The username for use in HTTP basic authentication.}
	url_password=${16:# The password for use in HTTP basic authentication.}
	force_basic_auth=${17:no}
	client_cert=${18:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${19:# PEM formatted file that contains your private key to be used for SSL client authentication.}

endsnippet

snippet a10_server "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' server object." b
a10_server: >
	server_name=${1:# The SLB (Server Load Balancer) server name.}
	host=${2:# Hostname or IP of the A10 Networks device.}
	username=${3:# An account with administrator privileges.}
	password=${4:# Password for the C(username) account.}

	partition=${5:# set active-partition}
	server_ip=${6:# The SLB server IPv4 address.}
	server_status=${7:#enabled|disabled}
	server_ports=${8:# A list of ports to create for the server. Each list item should be a dictionary which specifies the C(port:) and C(protocol:), but can also optionally specify the C(status:). See the examples below for details. This parameter is required when C(state) is C(present).}
	state=${9:#present|absent}
	validate_certs=${10:yes}
	write_config=${11:no}
	url=${12:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	force=${13:no}
	http_agent=${14:ansible-httpget}
	use_proxy=${15:yes}
	url_username=${16:# The username for use in HTTP basic authentication.}
	url_password=${17:# The password for use in HTTP basic authentication.}
	force_basic_auth=${18:no}
	client_cert=${19:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${20:# PEM formatted file that contains your private key to be used for SSL client authentication.}

endsnippet

snippet a10_service_group "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices' service groups." b
a10_service_group: >
	service_group=${1:# The SLB (Server Load Balancing) service-group name}
	host=${2:# Hostname or IP of the A10 Networks device.}
	username=${3:# An account with administrator privileges.}
	password=${4:# Password for the C(username) account.}

	state=${5:#present|absent}
	partition=${6:# set active-partition}
	service_group_protocol=${7:#tcp|udp}
	service_group_method=${8:#round-robin|weighted-rr|least-connection|weighted-least-connection|service-least-connection|service-weighted-least-connection|fastest-response|least-request|round-robin-strict|src-ip-only-hash|src-ip-hash}
	servers=${9:# A list of servers to add to the service group. Each list item should be a dictionary which specifies the C(server:) and C(port:), but can also optionally specify the C(status:). See the examples below for details.}
	validate_certs=${10:yes}
	write_config=${11:no}
	url=${12:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	force=${13:no}
	http_agent=${14:ansible-httpget}
	use_proxy=${15:yes}
	url_username=${16:# The username for use in HTTP basic authentication.}
	url_password=${17:# The password for use in HTTP basic authentication.}
	force_basic_auth=${18:no}
	client_cert=${19:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${20:# PEM formatted file that contains your private key to be used for SSL client authentication.}

endsnippet

snippet bigip_ucs_fetch "Fetches a UCS file from remote nodes" b
bigip_ucs_fetch: >
	dest=${1:# A directory to save the UCS file into.}

	backup=${2:no}
	create_on_missing=${3:yes}
	encryption_password=${4:# Password to use to encrypt the UCS file if desired.}
	fail_on_missing=${5:no}
	force=${6:yes}
	src=${7:# The name of the UCS file to create on the remote server for downloading}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_log_publisher "Manages log publishers on a BIG-IP" b
bigip_log_publisher: >
	name=${1:# Specifies the name of the log publisher.}

	description=${2:# Specifies a description for the log publisher.}
	destinations=${3:# Specifies log destinations for this log publisher to use.}
	partition=${4:Common}
	state=${5:#present|absent}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_management_route "Manage system management routes on a BIG-IP" b
bigip_management_route: >
	name=${1:# Specifies the name of the management route.}

	description=${2:# Description of the management route.}
	gateway=${3:# Specifies that the system forwards packets to the destination through the gateway with the specified IP address.}
	network=${4:# The subnet and netmask to be used for the route.}
	partition=${5:Common}
	state=${6:#present|absent}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_tcp_echo "Manages F5 BIG-IP LTM tcp echo monitors" b
bigip_monitor_tcp_echo: >
	name=${1:# Monitor name.}

	parent=${2:/Common/tcp_echo}
	description=${3:# The description of the monitor.}
	ip=${4:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	interval=${5:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
	timeout=${6:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
	time_until_up=${7:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
	partition=${8:Common}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_ucs "Manage upload, installation and removal of UCS files" b
bigip_ucs: >
	include_chassis_level_config=${1:# During restore of the UCS file, include chassis level configuration that is shared among boot volume sets. For example, cluster default configuration.}
	ucs=${2:# The path to the UCS file to install. The parameter must be provided if the C(state) is either C(installed) or C(activated). When C(state) is C(absent), the full path for this parameter will be ignored and only the filename will be used to select a UCS for removal. Therefore you could specify C(/mickey/mouse/test.ucs) and this module would only look for C(test.ucs).}
	force=${3:no}
	no_license=${4:# Performs a full restore of the UCS file and all the files it contains, with the exception of the license file. The option must be used to restore a UCS on RMA devices (Returned Materials Authorization).}
	no_platform_check=${5:# Bypasses the platform check and allows a UCS that was created using a different platform to be installed. By default (without this option), a UCS created from a different platform is not allowed to be installed.}
	passphrase=${6:# Specifies the passphrase that is necessary to load the specified UCS file.}
	reset_trust=${7:# When specified, the device and trust domain certs and keys are not loaded from the UCS. Instead, a new set is regenerated.}
	state=${8:absent|installed|#present}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_global "Manages global GTM settings" b
bigip_gtm_global: >
	synchronization=${1:# Specifies whether this system is a member of a synchronization group.}
	synchronization_group_name=${2:# Specifies the name of the synchronization group to which the system belongs.}
	synchronize_zone_files=${3:# Specifies that the system synchronizes Domain Name System (DNS) zone files among the synchronization group members.}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigiq_application_https_offload "Manages BIG-IQ HTTPS offload applications" b
bigiq_application_https_offload: >
	name=${1:# Name of the new application.}

	description=${2:# Description of the application.}
	servers=${3:# A list of servers that the application is hosted on.}
	inbound_virtual=${4:# Settings to configure the virtual which will receive the inbound connection.}
	redirect_virtual=${5:# Settings to configure the virtual which will receive the connection to be redirected.}
	client_ssl_profile=${6:# Specifies the SSL profile for managing client-side SSL traffic.}
	service_environment=${7:# Specifies the name of service environment or the hostname of the BIG-IP that the application will be deployed to.}
	add_analytics=${8:no}
	state=${9:absent|#present}
	wait=${10:yes}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet bigip_configsync_action "Perform different actions related to config-sync" b
bigip_configsync_action: >
	device_group=${1:# The device group that you want to perform config-sync actions on.}

	sync_device_to_group=${2:# Specifies that the system synchronizes configuration data from this device to other members of the device group. In this case, the device will do a "push" to all the other devices in the group. This option is mutually exclusive with the C(sync_group_to_device) option.}
	sync_most_recent_to_device=${3:# Specifies that the system synchronizes configuration data from the device with the most recent configuration. In this case, the device will do a "pull" from the most recently updated device. This option is mutually exclusive with the C(sync_device_to_group) options.}
	overwrite_config=${4:no}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigiq_application_fasthttp "Manages BIG-IQ FastHTTP applications" b
bigiq_application_fasthttp: >
	name=${1:# Name of the new application.}

	description=${2:# Description of the application.}
	servers=${3:# A list of servers that the application is hosted on.}
	inbound_virtual=${4:# Settings to configure the virtual which will receive the inbound connection.}
	service_environment=${5:# Specifies the name of service environment that the application will be deployed to.}
	add_analytics=${6:no}
	state=${7:absent|#present}
	wait=${8:yes}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_fastl4 "Manages Fast L4 profiles" b
bigip_profile_fastl4: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	idle_timeout=${3:# Specifies the length of time that a connection is idle (has no traffic) before the connection is eligible for deletion.}
	client_timeout=${4:# Specifies a timeout for Late Binding.}
	description=${5:# Description of the profile.}
	explicit_flow_migration=${6:# Specifies whether a qualified late-binding connection requires an explicit iRule command to migrate down to ePVA hardware.}
	ip_df_mode=${7:pmtu|preserve|set|clear}
	ip_tos_to_client=${8:# Specifies, for IP traffic passing through the system to clients, whether the system modifies the IP type-of-service (ToS) setting in an IP packet header.}
	ip_tos_to_server=${9:# Specifies, for IP traffic passing through the system to back-end servers, whether the system modifies the IP type-of-service (ToS) setting in an IP packet header.}
	ip_ttl_mode=${10:proxy|preserve|decrement|set}
	ip_ttl_v4=${11:# Specifies the outgoing packet's IP Header TTL value for IPv4 traffic.}
	ip_ttl_v6=${12:# Specifies the outgoing packet's IP Header TTL value for IPv6 traffic.}
	keep_alive_interval=${13:# Specifies the keep-alive probe interval, in seconds.}
	late_binding=${14:# Enables intelligent selection of a back-end server or pool, using an iRule to make the selection.}
	link_qos_to_client=${15:# Specifies, for IP traffic passing through the system to clients, whether the system modifies the link quality-of-service (QoS) setting in an IP packet header.}
	link_qos_to_server=${16:# Specifies, for IP traffic passing through the system to back-end servers, whether the system modifies the link quality-of-service (QoS) setting in an IP packet header.}
	loose_close=${17:# When C(yes), specifies, that the system closes a loosely-initiated connection when the system receives the first FIN packet from either the client or the server.}
	loose_initialization=${18:# When C(yes), specifies that the system initializes a connection when it receives any TCP packet, rather that requiring a SYN packet for connection initiation.}
	mss_override=${19:# Specifies a maximum segment size (MSS) override for server-side connections.}
	reassemble_fragments=${20:# When C(yes), specifies that the system reassembles IP fragments.}
	receive_window_size=${21:# Specifies the amount of data the BIG-IP system can accept without acknowledging the server.}
	reset_on_timeout=${22:# When C(yes), specifies that the system sends a reset packet (RST) in addition to deleting the connection, when a connection exceeds the idle timeout value.}
	rtt_from_client=${23:# When C(yes), specifies that the system uses TCP timestamp options to measure the round-trip time to the client.}
	rtt_from_server=${24:# When C(yes), specifies that the system uses TCP timestamp options to measure the round-trip time to the server.}
	server_sack=${25:# Specifies whether the BIG-IP system processes Selective ACK (Sack) packets in cookie responses from the server.}
	server_timestamp=${26:# Specifies whether the BIG-IP system processes timestamp request packets in cookie responses from the server.}
	syn_cookie_mss=${27:# Specifies a value that overrides the SYN cookie maximum segment size (MSS) value in the SYN-ACK packet that is returned to the client.}
	tcp_close_timeout=${28:# Specifies the length of time a connection can remain idle before deletion.}
	tcp_generate_isn=${29:# When C(yes), specifies that the system generates initial sequence numbers for SYN packets, according to RFC 1948.}
	tcp_handshake_timeout=${30:# Specifies the acceptable duration for a TCP handshake, that is, the maximum idle time between a client synchronization (SYN) and a client acknowledgment (ACK). If the TCP handshake takes longer than the timeout, the system automatically closes the connection.}
	tcp_strip_sack=${31:# When C(yes), specifies that the system blocks a TCP selective ACK SackOK option from passing to the server on an initiating SYN.}
	tcp_time_wait_timeout=${32:# Specifies the number of milliseconds that a connection is in the TIME-WAIT state before closing.}
	tcp_timestamp_mode=${33:preserve|rewrite|strip}
	tcp_wscale_mode=${34:preserve|rewrite|strip}
	timeout_recovery=${35:disconnect|fallback}
	partition=${36:Common}
	state=${37:#present|absent}
	provider=${38:# A dict object containing connection details.}

endsnippet

snippet bigip_vcmp_guest "Manages vCMP guests on a BIG-IP" b
bigip_vcmp_guest: >
	name=${1:# The name of the vCMP guest to manage.}

	vlans=${2:# VLANs that the guest uses to communicate with other guests, the host, and with the external network. The available VLANs in the list are those that are currently configured on the vCMP host.}
	initial_image=${3:# Specifies the base software release ISO image file for installing the TMOS hypervisor instance and any licensed BIG-IP modules onto the guest's virtual disk. When creating a new guest, this parameter is required.}
	initial_hotfix=${4:# Specifies the hotfix ISO image file which will be applied on top of the base image.}
	mgmt_network=${5:bridged|isolated|host only}
	delete_virtual_disk=${6:no}
	mgmt_address=${7:# Specifies the IP address, and subnet or subnet mask that you use to access the guest when you want to manage a module running within the guest. This parameter is required if the C(mgmt_network) parameter is C(bridged).}
	mgmt_route=${8:# Specifies the gateway address for the C(mgmt_address).}
	state=${9:configured|disabled|provisioned|#present|absent}
	cores_per_slot=${10:# Specifies the number of cores that the system allocates to the guest.}
	partition=${11:Common}
	number_of_slots=${12:# Specifies the number of slots for the system to use for creating the guest.}
	min_number_of_slots=${13:# Specifies the minimum number of slots that the guest must be assigned to in order to deploy.}
	allowed_slots=${14:# Contains those slots that the guest is allowed to be assigned to.}
	provider=${15:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_http2 "Manage HTTP2 profiles on a BIG-IP" b
bigip_profile_http2: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:/Common/http2}
	description=${3:# Description of the profile.}
	streams=${4:# Specifies the number of outstanding concurrent requests that are allowed on a single HTTP/2 connection.}
	idle_timeout=${5:# Specifies the number of seconds that an HTTP/2 connection is idly left open before being shut down.}
	insert_header=${6:# Specifies whether an HTTP header indicating the use of HTTP/2 should be inserted into the request that goes to the server.}
	insert_header_name=${7:# Specifies the name of the HTTP header controlled by C(insert_header) parameter.}
	enforce_tls_requirements=${8:# Specifies whether the system requires TLS for communications between specified senders and recipients.}
	activation_modes=${9:alpn|always}
	frame_size=${10:# Specifies the size of data frames, in bytes, that HTTP/2 sends to the client.}
	write_size=${11:# Specifies the total size of combined data frames, in bytes, that HTTP/2 sends in a single write.}
	receive_window=${12:# Specifies the way that the HTTP/2 profile performs flow control.}
	header_table_size=${13:# Specifies the size of the header table, in bytes.}
	partition=${14:Common}
	state=${15:#present|absent}
	provider=${16:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_udp "Manages F5 BIG-IP LTM udp monitors" b
bigip_monitor_udp: >
	name=${1:# Monitor name.}

	parent=${2:/Common/udp}
	description=${3:# The description of the monitor.}
	send=${4:# The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(default send string) will be used.}
	receive=${5:# The receive string for the monitor call.}
	receive_disable=${6:# This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).}
	ip=${7:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${8:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	interval=${9:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
	timeout=${10:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
	time_until_up=${11:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
	partition=${12:Common}
	state=${13:#present|absent}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet bigip_remote_syslog "Manipulate remote syslog settings on a BIG-IP" b
bigip_remote_syslog: >
	remote_host=${1:# Specifies the IP address, or hostname, for the remote system to which the system sends log messages.}

	name=${2:# Specifies the name of the syslog object.}
	remote_port=${3:# Specifies the port that the system uses to send messages to the remote logging server.}
	local_ip=${4:# Specifies the local IP address of the system that is logging. To provide no local IP, specify the value C(none).}
	state=${5:absent|#present}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_monitor_https "Manages F5 BIG-IP GTM https monitors" b
bigip_gtm_monitor_https: >
	name=${1:# Monitor name.}

	parent=${2:/Common/https}
	send=${3:# The send string for the monitor call.}
	receive=${4:# The receive string for the monitor call.}
	ip=${5:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${6:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	interval=${7:# The interval specifying how frequently the monitor instance of this template will run.}
	timeout=${8:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.}
	partition=${9:Common}
	state=${10:#present|absent}
	probe_timeout=${11:# Specifies the number of seconds after which the system times out the probe request to the system.}
	ignore_down_response=${12:# Specifies that the monitor allows more than one probe attempt per interval.}
	transparent=${13:# Specifies whether the monitor operates in transparent mode.}
	reverse=${14:# Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.}
	target_username=${15:# Specifies the user name, if the monitored target requires authentication.}
	target_password=${16:# Specifies the password, if the monitored target requires authentication.}
	update_password=${17:#always|on_create}
	cipher_list=${18:# Specifies the list of ciphers for this monitor.}
	compatibility=${19:# Specifies, when enabled, that the SSL options setting (in OpenSSL) is set to B(all).}
	client_cert=${20:# Specifies a fully-qualified path for a client certificate that the monitor sends to the target SSL server.}
	client_key=${21:# Specifies a key for a client certificate that the monitor sends to the target SSL server.}
	provider=${22:# A dict object containing connection details.}

endsnippet

snippet bigip_device_httpd "Manage HTTPD related settings on BIG-IP" b
bigip_device_httpd: >
	allow=${1:# Specifies, if you have enabled HTTPD access, the IP address or address range for other systems that can communicate with this system.}
	auth_name=${2:# Sets the BIG-IP authentication realm name.}
	auth_pam_idle_timeout=${3:# Sets the GUI timeout for automatic logout, in seconds.}
	auth_pam_validate_ip=${4:# Sets the authPamValidateIp setting.}
	auth_pam_dashboard_timeout=${5:# Sets whether or not the BIG-IP dashboard will timeout.}
	fast_cgi_timeout=${6:# Sets the timeout of FastCGI.}
	hostname_lookup=${7:# Sets whether or not to display the hostname, if possible.}
	log_level=${8:alert|crit|debug|emerg|error|info|notice|warn}
	max_clients=${9:# Sets the maximum number of clients that can connect to the GUI at once.}
	redirect_http_to_https=${10:# Whether or not to redirect http requests to the GUI to https.}
	ssl_port=${11:# The HTTPS port to listen on.}
	ssl_cipher_suite=${12:# Specifies the ciphers that the system uses.}
	ssl_protocols=${13:# The list of SSL protocols to accept on the management console.}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet bigip_cli_script "Manage CLI scripts on a BIG-IP" b
bigip_cli_script: >
	name=${1:# Specifies the name of the script.}

	content=${2:# The content of the script.}
	description=${3:# Description of the cli script.}
	partition=${4:Common}
	state=${5:#present|absent}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_apm_network_access "Manage APM Network Access resource" b
bigip_apm_network_access: >
	name=${1:# Specifies the name of the APM network access to manage/create.}

	description=${2:# User created network access description.}
	ip_version=${3:ipv4|ipv4-ipv6}
	allow_local_subnet=${4:# Enables local subnet access and local access to any host or subnet in routes specified in the client routing table.}
	allow_local_dns=${5:# Enables local access to DNS servers configured on client prior to establishing network access connection.}
	split_tunnel=${6:# Specifies that only the traffic targeted to a specified address space is sent over the network access tunnel.}
	snat_pool=${7:# Specifies the name of a SNAT pool used for implementing selective and intelligent SNATs.}
	dtls=${8:# When C(yes) the network access connection uses Datagram Transport Level Security instead of TCP, to provide better throughput for high demand applications like VoIP or streaming video.}
	dtls_port=${9:# Specifies the port number that the network access resource uses for secure UDP traffic with DTLS.}
	ipv4_lease_pool=${10:# Specifies IPV4 lease pool resource to use with network access.}
	ipv6_lease_pool=${11:# Specifies IPV6 lease pool resource to use with network access.}
	excluded_ipv6_adresses=${12:# Specifies IPV6 address spaces for which traffic is not forced through the tunnel.}
	excluded_ipv4_adresses=${13:# Specifies IPV4 address spaces for which traffic is not forced through the tunnel.}
	excluded_dns_addresses=${14:# Specifies the DNS address spaces for which traffic is not forced through the tunnel.}
	dns_address_space=${15:# Specifies a list of domain names describing the target LAN DNS addresses.}
	ipv4_address_space=${16:# Specifies a list of IPv4 hosts or networks describing the target LAN.}
	ipv6_address_space=${17:# Specifies a list of IPv6 hosts or networks describing the target LAN.}
	partition=${18:Common}
	state=${19:#present|absent}
	provider=${20:# A dict object containing connection details.}

endsnippet

snippet bigip_lx_package "Manages Javascript LX packages on a BIG-IP" b
bigip_lx_package: >
	package=${1:# The LX package that you want to upload or remove. When C(state) is C(present), and you intend to use this module in a C(role), it is recommended that you use the C({{ role_path }}) variable. An example is provided in the C(EXAMPLES) section.}
	state=${2:#present|absent}
	provider=${3:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_tcp "Manages F5 BIG-IP LTM tcp monitors" b
bigip_monitor_tcp: >
	name=${1:# Monitor name.}

	parent=${2:/Common/tcp}
	description=${3:# The description of the monitor.}
	send=${4:# The send string for the monitor call.}
	receive=${5:# The receive string for the monitor call.}
	ip=${6:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${7:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified}
	interval=${8:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
	timeout=${9:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
	time_until_up=${10:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
	partition=${11:Common}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigiq_device_discovery "Manage BIG-IP devices through BIG-IQ" b
bigiq_device_discovery: >
	device_address=${1:# The IP address of the BIG-IP device to be imported/managed.}

	device_username=${2:# The administrator username for the BIG-IP device.}
	device_password=${3:# The administrator password for the BIG-IP device.}
	device_port=${4:443}
	ha_name=${5:# DSC cluster name of the BIG-IP device to be managed.}
	use_bigiq_sync=${6:no}
	conflict_policy=${7:#use_bigiq|use_bigip}
	versioned_conflict_policy=${8:use_bigiq|use_bigip|keep_version}
	device_conflict_policy=${9:#use_bigiq|use_bigip}
	access_conflict_policy=${10:use_bigiq|use_bigip|keep_version}
	access_group_name=${11:# Access group name to import Access configuration for devices, once set it cannot be changed.}
	access_group_first_device=${12:yes}
	force=${13:no}
	modules=${14:ltm|asm|apm|afm|dns|websafe|security_shared}
	statistics=${15:# Specify the statistics collection for discovered device.}
	state=${16:absent|#present}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_wait "Wait for a BIG-IP condition before continuing" b
bigip_wait: >
	timeout=${1:7200}
	delay=${2:0}
	sleep=${3:1}
	msg=${4:# This overrides the normal error message from a failure to meet the required conditions.}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_monitor_http "Manages F5 BIG-IP GTM http monitors" b
bigip_gtm_monitor_http: >
	name=${1:# Monitor name.}

	parent=${2:/Common/http}
	send=${3:# The send string for the monitor call.}
	receive=${4:# The receive string for the monitor call.}
	ip=${5:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${6:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified}
	interval=${7:# The interval specifying how frequently the monitor instance of this template will run.}
	timeout=${8:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.}
	partition=${9:Common}
	state=${10:#present|absent}
	probe_timeout=${11:# Specifies the number of seconds after which the system times out the probe request to the system.}
	ignore_down_response=${12:# Specifies that the monitor allows more than one probe attempt per interval.}
	transparent=${13:# Specifies whether the monitor operates in transparent mode.}
	reverse=${14:# Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.}
	target_username=${15:# Specifies the user name, if the monitored target requires authentication.}
	target_password=${16:# Specifies the password, if the monitored target requires authentication.}
	update_password=${17:#always|on_create}
	provider=${18:# A dict object containing connection details.}

endsnippet

snippet bigip_static_route "Manipulate static routes on a BIG-IP" b
bigip_static_route: >
	name=${1:# Name of the static route.}

	description=${2:# Descriptive text that identifies the route.}
	destination=${3:# Specifies an IP address for the static entry in the routing table. When creating a new static route, this value is required.}
	netmask=${4:# The netmask for the static route. When creating a new static route, this value is required.}
	gateway_address=${5:# Specifies the router for the system to use when forwarding packets to the destination host or network. Also known as the next-hop router address. This can be either an IPv4 or IPv6 address. When it is an IPv6 address that starts with C(FE80:), the address will be treated as a link-local address. This requires that the C(vlan) parameter also be supplied.}
	vlan=${6:# Specifies the VLAN or Tunnel through which the system forwards packets to the destination. When C(gateway_address) is a link-local IPv6 address, this value is required.}
	pool=${7:# Specifies the pool through which the system forwards packets to the destination.}
	reject=${8:# Specifies that the system drops packets sent to the destination.}
	mtu=${9:# Specifies a specific maximum transmission unit (MTU).}
	route_domain=${10:# The route domain id of the system. When creating a new static route, if this value is not specified, a default value of C(0) will be used.}
	partition=${11:Common}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_virtual_server "Manages F5 BIG-IP GTM virtual servers" b
bigip_gtm_virtual_server: >
	name=${1:# Specifies the name of the virtual server.}
	server_name=${2:# Specifies the name of the server that the virtual server is associated with.}
	address=${3:# Specifies the IP Address of the virtual server.}
	port=${4:# Specifies the service port number for the virtual server or pool member. For example, the HTTP service is typically port 80.}
	translation_address=${5:# Specifies the translation IP address for the virtual server.}
	translation_port=${6:# Specifies the translation port number or service name for the virtual server.}
	availability_requirements=${7:# Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.}
	monitors=${8:# Specifies the health monitors that the system currently uses to monitor this resource.}
	virtual_server_dependencies=${9:# Specifies the virtual servers on which the current virtual server depends.}
	link=${10:# Specifies a link to assign to the server or virtual server.}
	limits=${11:# Specifies resource thresholds or limit requirements at the server level.}
	partition=${12:Common}
	state=${13:#present|absent|enabled|disabled}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet bigip_iapp_template "Manages TCL iApp templates on a BIG-IP" b
bigip_iapp_template: >
	force=${1:# Specifies whether or not to force the uploading of an iApp. When C(yes), will force update the iApp even if there are iApp services using it. This will not update the running service though. Use C(bigip_iapp_service) to do that. When C(no), will update the iApp only if there are no iApp services using the template.}
	name=${2:# The name of the iApp template that you want to delete. This option is only available when specifying a C(state) of C(absent) and is provided as a way to delete templates that you may no longer have the source of.}
	content=${3:# Sets the contents of an iApp template directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. C(content) must be provided when creating new templates.}
	state=${4:#present|absent}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigiq_utility_license "Manage utility licenses on a BIG-IQ" b
bigiq_utility_license: >
	license_key=${1:# The license key to install and activate.}

	accept_eula=${2:# A key that signifies that you accept the F5 EULA for this license.}
	state=${3:absent|#present}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigip_selfip "Manage Self-IPs on a BIG-IP system" b
bigip_selfip: >
	name=${1:# The self IP to create.}

	address=${2:# The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.}
	allow_service=${3:# Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.}
	description=${4:# Description of the traffic selector.}
	netmask=${5:# The netmask for the self IP. When creating a new Self IP, this value is required.}
	state=${6:absent|#present}
	traffic_group=${7:# The traffic group for the Self IP addresses in an active-active, redundant load balancer configuration. When creating a new Self IP, if this value is not specified, the default of C(/Common/traffic-group-local-only) will be used.}
	vlan=${8:# The VLAN that the new self IPs will be on. When creating a new Self IP, this value is required.}
	route_domain=${9:# The route domain id of the system. When creating a new Self IP, if this value is not specified, a default value of C(0) will be used.}
	partition=${10:Common}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet bigip_routedomain "Manage route domains on a BIG-IP" b
bigip_routedomain: >
	name=${1:# The name of the route domain.}
	bwc_policy=${2:# The bandwidth controller for the route domain.}
	connection_limit=${3:# The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.}
	description=${4:# Specifies descriptive text that identifies the route domain.}
	flow_eviction_policy=${5:# The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.}
	id=${6:# The unique identifying integer representing the route domain.}
	parent=${7:# Specifies the route domain the system searches when it cannot find a route in the configured domain.}
	partition=${8:Common}
	routing_protocol=${9:none|BFD|BGP|IS-IS|OSPFv2|OSPFv3|PIM|RIP|RIPng}
	service_policy=${10:# Service policy to associate with the route domain.}
	state=${11:#present|absent}
	strict=${12:# Specifies whether the system enforces cross-routing restrictions or not.}
	vlans=${13:# VLANs for the system to use in the route domain.}
	fw_enforced_policy=${14:# Specifies AFM policy to be attached to route domain.}
	provider=${15:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_server "Manages F5 BIG-IP GTM servers" b
bigip_gtm_server: >
	name=${1:# The name of the server.}

	state=${2:#present|absent|enabled|disabled}
	datacenter=${3:# Data center the server belongs to. When creating a new GTM server, this value is required.}
	devices=${4:# Lists the self IP addresses and translations for each device. When creating a new GTM server, this value is required. This list is a complex list that specifies a number of keys.}
	server_type=${5:alteon-ace-director|cisco-css|cisco-server-load-balancer|generic-host|radware-wsd|windows-nt-4.0|bigip|cisco-local-director-v2|extreme|generic-load-balancer|sun-solaris|cacheflow|cisco-local-director-v3|foundry-server-iron|netapp|windows-2000-server}
	link_discovery=${6:enabled|disabled|enabled-no-delete}
	virtual_server_discovery=${7:enabled|disabled|enabled-no-delete}
	partition=${8:Common}
	iquery_options=${9:# Specifies whether the Global Traffic Manager uses this BIG-IP system to conduct a variety of probes before delegating traffic to it.}
	monitors=${10:# Specifies the health monitors that the system currently uses to monitor this resource.}
	availability_requirements=${11:# Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.}
	prober_preference=${12:inside-datacenter|outside-datacenter|inherit|pool}
	prober_fallback=${13:any|inside-datacenter|outside-datacenter|inherit|pool|none}
	prober_pool=${14:# Specifies the name of the prober pool to use to monitor this server's resources.}
	limits=${15:# Specifies resource thresholds or limit requirements at the pool member level.}
	provider=${16:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_datacenter "Manage Datacenter configuration in BIG-IP" b
bigip_gtm_datacenter: >
	name=${1:# The name of the data center.}

	contact=${2:# The name of the contact for the data center.}
	description=${3:# The description of the data center.}
	location=${4:# The location of the data center.}
	state=${5:#present|absent|enabled|disabled}
	partition=${6:Common}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_address_list "Manage address lists on BIG-IP AFM" b
bigip_firewall_address_list: >
	name=${1:# Specifies the name of the address list.}

	partition=${2:Common}
	description=${3:# Description of the address list}
	geo_locations=${4:# List of geolocations specified by their C(country) and C(region).}
	addresses=${5:# Individual addresses that you want to add to the list. These addresses differ from ranges, and lists of lists such as what can be used in C(address_ranges) and C(address_lists) respectively.}
	address_ranges=${6:# A list of address ranges where the range starts with a port number, is followed by a dash (-) and then a second number.}
	address_lists=${7:# Simple list of existing address lists to add to this list. Address lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.}
	fqdns=${8:# A list of fully qualified domain names (FQDNs).}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_virtual_server "Manage LTM virtual servers on a BIG-IP" b
bigip_virtual_server: >
	name=${1:# Virtual server name.}

	state=${2:#present|absent|enabled|disabled}
	type=${3:#standard|forwarding-l2|forwarding-ip|performance-http|performance-l4|stateless|reject|dhcp|internal|message-routing}
	destination=${4:# Destination IP of the virtual server.}
	source=${5:# Specifies an IP address or network from which the virtual server accepts traffic.}
	port=${6:# Port of the virtual server. Required when C(state) is C(present) and virtual server does not exist.}
	profiles=${7:# List of profiles (HTTP, ClientSSL, ServerSSL, etc) to apply to both sides of the connection (client-side and server-side).}
	irules=${8:# List of rules to be applied in priority order.}
	enabled_vlans=${9:# List of VLANs to be enabled. When a VLAN named C(all) is used, all VLANs will be allowed. VLANs can be specified with or without the leading partition. If the partition is not specified in the VLAN, then the C(partition) option of this module will be used.}
	disabled_vlans=${10:# List of VLANs to be disabled. If the partition is not specified in the VLAN, then the C(partition) option of this module will be used.}
	pool=${11:# Default pool for the virtual server.}
	policies=${12:# Specifies the policies for the virtual server.}
	snat=${13:# Source network address policy.}
	default_persistence_profile=${14:# Default Profile which manages the session persistence.}
	description=${15:# Virtual server description.}
	fallback_persistence_profile=${16:# Specifies the persistence profile you want the system to use if it cannot use the specified default persistence profile.}
	partition=${17:Common}
	metadata=${18:# Arbitrary key/value pairs that you can attach to a virtual server. This is useful in situations where you might want to annotate a virtual to be managed by Ansible.}
	insert_metadata=${19:yes}
	address_translation=${20:# Specifies, when C(enabled), that the system translates the address of the virtual server.}
	port_translation=${21:# Specifies, when C(enabled), that the system translates the port of the virtual server.}
	source_port=${22:preserve|preserve-strict|change}
	mirror=${23:# Specifies that the system mirrors connections on each member of a redundant pair.}
	mask=${24:# Specifies the destination address network mask. This parameter will work with IPv4 and IPv6 type of addresses.}
	ip_protocol=${25:ah|any|bna|esp|etherip|gre|icmp|ipencap|ipv6|ipv6-auth|ipv6-crypt|ipv6-icmp|isp-ip|mux|ospf|sctp|tcp|udp|udplite}
	firewall_enforced_policy=${26:# Applies the specify AFM policy to the virtual in an enforcing way.}
	firewall_staged_policy=${27:# Applies the specify AFM policy to the virtual in an enforcing way.}
	security_log_profiles=${28:# Specifies the log profile applied to the virtual server.}
	security_nat_policy=${29:# Specify the Firewall NAT policies for the virtual server.}
	ip_intelligence_policy=${30:# Specifies the IP intelligence policy applied to the virtual server.}
	rate_limit=${31:# Virtual server rate limit (connections-per-second). Setting this to 0 disables the limit.}
	rate_limit_dst_mask=${32:# Specifies a mask, in bits, to be applied to the destination address as part of the rate limiting.}
	rate_limit_src_mask=${33:# Specifies a mask, in bits, to be applied to the source address as part of the rate limiting.}
	rate_limit_mode=${34:#object|object-source|object-destination|object-source-destination|destination|source|source-destination}
	clone_pools=${35:# Specifies a pool or list of pools that the virtual server uses to replicate either client-side or server-side traffic.}
	provider=${36:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_log_profile_network "Configures Network Firewall related settings of the log profile" b
bigip_firewall_log_profile_network: >
	profile_name=${1:# Specifies the name of the AFM log profile to be updated.}

	log_publisher=${2:# Specifies the name of the log publisher used for Network events.}
	rate_limit=${3:# Defines a rate limit for all combined network firewall log messages per second. Beyond this rate limit, log messages are not logged.}
	log_matches_accept_rule=${4:# Modify log settings for ACL rules configured with an "accept" or "accept decisively" action.}
	log_matches_drop_rule=${5:# Modify log settings for ACL rules configured with a drop action.}
	log_matches_reject_rule=${6:# Modify log settings for ACL rules configured with a reject action.}
	log_ip_errors=${7:# Modify log settings for logging of IP error packets.}
	log_tcp_errors=${8:# Modify log settings for logging of TCP error packets.}
	log_tcp_events=${9:# Modify log settings for logging of TCP events on the client side.}
	log_translation_fields=${10:# This option is used to enable or disable the logging of translated (i.e server side) fields in ACL match and TCP events.}
	log_storage_format=${11:field-list|none}
	log_format_delimiter=${12:# Specifies the delimiter string when using a C(log_storage_format) of C(field-list).}
	log_message_fields=${13:acl_policy_name|acl_policy_type|acl_rule_name|action|bigip_hostname|context_name|context_type|date_time|dest_fqdn|dest_geo|dest_ip|dest_port|drop_reason|management_ip_address|protocol|route_domain|sa_translation_pool|sa_translation_type|source_fqdn|source_user|src_geo|src_ip|src_port|translated_dest_ip|translated_dest_port|translated_ip_protocol|translated_route_domain|translated_src_ip|translated_src_port|translated_vlan|vlan}
	partition=${14:Common}
	state=${15:#present|absent}
	provider=${16:# A dict object containing connection details.}

endsnippet

snippet bigip_sys_daemon_log_tmm "Manage BIG-IP tmm daemon log settings" b
bigip_sys_daemon_log_tmm: >
	arp_log_level=${1:debug|error|informational|notice|warning}
	http_compression_log_level=${2:debug|error|informational|notice|warning}
	http_log_level=${3:debug|error|informational|notice|warning}
	ip_log_level=${4:debug|informational|notice|warning}
	irule_log_level=${5:debug|error|informational|notice|warning}
	layer4_log_level=${6:debug|informational|notice}
	net_log_level=${7:critical|debug|error|informational|notice|warning}
	os_log_level=${8:alert|critical|debug|emergency|error|informational|notice|warning}
	pva_log_level=${9:debug|informational|notice}
	ssl_log_level=${10:alert|critical|debug|emergency|error|informational|notice|warning}
	state=${11:#present}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_ssl_ocsp "Manage OCSP configurations on BIG-IP" b
bigip_ssl_ocsp: >
	name=${1:# Specifies the name of the OCSP certificate validator.}

	cache_error_timeout=${2:# Specifies the lifetime of an error response in the cache, in seconds.}
	proxy_server_pool=${3:# Specifies the proxy server pool the BIG-IP system uses to fetch the OCSP response.}
	cache_timeout=${4:# Specifies the lifetime of the OCSP response in the cache, in seconds.}
	clock_skew=${5:# Specifies the tolerable absolute difference in the clocks of the responder and the BIG-IP system, in seconds.}
	connections_limit=${6:# Specifies the maximum number of connections per second allowed for the OCSP certificate validator.}
	dns_resolver=${7:# Specifies the internal DNS resolver the BIG-IP system uses to fetch the OCSP response.}
	route_domain=${8:# Specifies the route domain for fetching an OCSP response using HTTP forward proxy.}
	hash_algorithm=${9:sha256|sha1}
	certificate=${10:# Specifies a certificate used to sign an OCSP request.}
	key=${11:# Specifies a key used to sign an OCSP request.}
	passphrase=${12:# Specifies a passphrase used to sign an OCSP request.}
	status_age=${13:# Specifies the maximum allowed lag time that the BIG-IP system accepts for the 'thisUpdate' time in the OCSP response.}
	strict_responder_checking=${14:# Specifies whether the responder's certificate is checked for an OCSP signing extension.}
	connection_timeout=${15:# Specifies the time interval that the BIG-IP system waits for before ending the connection to the OCSP responder, in seconds.}
	trusted_responders=${16:# Specifies the certificates used for validating the OCSP response when the responder's certificate has been omitted from the response.}
	responder_url=${17:# Specifies the absolute URL that overrides the OCSP responder URL obtained from the certificate's AIA extensions. This should be an HTTP-based URL.}
	update_password=${18:#always|on_create}
	partition=${19:Common}
	state=${20:#present|absent}
	provider=${21:# A dict object containing connection details.}

endsnippet

snippet bigip_snat_pool "Manage SNAT pools on a BIG-IP" b
bigip_snat_pool: >
	name=${1:# The name of the SNAT pool.}

	members=${2:# List of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional.}
	description=${3:# A general description of the SNAT pool, provided by the user for their benefit. It is optional.}
	state=${4:#present|absent}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_monitor_bigip "Manages F5 BIG-IP GTM BIG-IP monitors" b
bigip_gtm_monitor_bigip: >
	name=${1:# Monitor name.}

	parent=${2:/Common/bigip}
	ip=${3:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${4:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified}
	interval=${5:# Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.}
	timeout=${6:# Specifies the number of seconds the target has in which to respond to the monitor request.}
	ignore_down_response=${7:# Specifies that the monitor allows more than one probe attempt per interval.}
	aggregate_dynamic_ratios=${8:none|average-nodes|sum-nodes|average-members|sum-members}
	partition=${9:Common}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet bigip_message_routing_peer "Manage peers for routing generic message protocol messages" b
bigip_message_routing_peer: >
	name=${1:# Specifies the name of the peer to manage.}

	description=${2:# The user defined description of the peer.}
	type=${3:#generic}
	auto_init=${4:# If C(yes), the BIGIP will automatically create outbound connections to the active pool members in the specified C(pool) using the configuration of the specified C(transport_config).}
	auto_init_interval=${5:# Specifies the interval that attempts to initiate a connection occur.}
	connection_mode=${6:per-blade|per-client|per-peer|per-tmm}
	number_of_connections=${7:# Specifies the distribution of connections between the BIG-IP and a remote host.}
	pool=${8:# Specifies the name of the pool that messages will be routed towards.}
	ratio=${9:# Specifies the ratio to be used for selection of a peer within a list of peers in a ltm route.}
	transport_config=${10:# The name of the ltm virtual or ltm transport-config to use for creating an outgoing connection.}
	partition=${11:Common}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigip_remote_role "Manage remote roles on a BIG-IP" b
bigip_remote_role: >
	name=${1:# Specifies the name of the remote role.}

	line_order=${2:# Specifies the order of the line in the file C(/config/bigip/auth/remoterole).}
	attribute_string=${3:# Specifies the user account attributes saved in the group, in the format C(cn=, ou=, dc=).}
	remote_access=${4:# Enables or disables remote access for the specified group of remotely authenticated users.}
	assigned_role=${5:# Specifies the authorization (level of access) for the account.}
	partition_access=${6:# Specifies the accessible partitions for the account.}
	terminal_access=${7:# Specifies terminal-based accessibility for remote accounts not already explicitly assigned a user role.}
	state=${8:absent|#present}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_external "Manages external LTM monitors on a BIG-IP" b
bigip_monitor_external: >
	name=${1:# Specifies the name of the monitor.}

	description=${2:# The description of the monitor.}
	parent=${3:/Common/external}
	arguments=${4:# Specifies any command-line arguments that the script requires.}
	ip=${5:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${6:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	external_program=${7:# Specifies the name of the file for the monitor to use. In order to reference a file, you must first import it using options on the System > File Management > External Monitor Program File List > Import screen. The BIG-IP system automatically places the file in the proper location on the file system.}
	interval=${8:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
	timeout=${9:# The number of seconds in which the node or service must respond to the monitor request.}
	variables=${10:# Specifies any variables that the script requires.}
	partition=${11:Common}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigip_sys_db "Manage BIG-IP system database variables" b
bigip_sys_db: >
	key=${1:# The database variable to manipulate.}

	state=${2:#present|reset}
	value=${3:# The value to set the key to. At least one of value and state C(reset) are required.}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigip_asm_policy_import "Manage BIG-IP ASM policy imports" b
bigip_asm_policy_import: >
	name=${1:# The ASM policy to create or override.}

	inline=${2:# When specified the ASM policy is created from a provided string.}
	source=${3:# Full path to a policy file to be imported into the BIG-IP ASM.}
	force=${4:no}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_wide_ip "Manages F5 BIG-IP GTM wide ip" b
bigip_gtm_wide_ip: >
	pool_lb_method=${1:round-robin|ratio|topology|global-availability}
	name=${2:# Wide IP name. This name must be formatted as a fully qualified domain name (FQDN). You can also use the alias C(wide_ip) but this is deprecated and will be removed in a future Ansible version.}

	type=${3:a|aaaa|cname|mx|naptr|srv}
	state=${4:#present|absent|disabled|enabled}
	partition=${5:Common}
	pools=${6:# The pools that you want associated with the Wide IP.}
	irules=${7:# List of rules to be applied.}
	aliases=${8:# Specifies alternate domain names for the web site content you are load balancing.}
	last_resort_pool=${9:# Specifies which GTM pool, for the system to use as the last resort pool for the wide IP.}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_ipsec_policy "Manage IPSec policies on a BIG-IP" b
bigip_ipsec_policy: >
	name=${1:# Specifies the name of the IPSec policy.}

	description=${2:# Description of the policy}
	protocol=${3:esp|ah}
	mode=${4:transport|interface|isession|tunnel}
	tunnel_local_address=${5:# Specifies the local endpoint IP address of the IPsec tunnel.}
	tunnel_remote_address=${6:# Specifies the remote endpoint IP address of the IPsec tunnel.}
	encrypt_algorithm=${7:none|3des|aes128|aes192|aes256|aes-gmac256|aes-gmac192|aes-gmac128|aes-gcm256|aes-gcm192|aes-gcm256|aes-gcm128}
	route_domain=${8:# Specifies the route domain, when C(interface) is selected for the C(mode) setting.}
	auth_algorithm=${9:sha1|sha256|sha384|sha512|aes-gcm128|aes-gcm192|aes-gcm256|aes-gmac128|aes-gmac192|aes-gmac256}
	ipcomp=${10:none|null|deflate}
	lifetime=${11:# Specifies the length of time, in minutes, before the IKE security association expires.}
	kb_lifetime=${12:# Specifies the length of time, in kilobytes, before the IKE security association expires.}
	perfect_forward_secrecy=${13:none|modp768|modp1024|modp1536|modp2048|modp3072|modp4096|modp6144|modp8192}
	ipv4_interface=${14:# When C(mode) is C(interface) indicate if the IPv4 C(any) address should be used. By default C(BIG-IP) assumes C(any6) address for tunnel addresses when C(mode) is C(interface).}
	partition=${15:Common}
	state=${16:#present|absent}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_snmp_dca "Manages BIG-IP SNMP data collecting agent (DCA) monitors" b
bigip_monitor_snmp_dca: >
	name=${1:# Monitor name.}

	description=${2:# Specifies descriptive text that identifies the monitor.}
	parent=${3:/Common/snmp_dca}
	interval=${4:# Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown. When creating a new monitor, the default is C(10).}
	timeout=${5:# Specifies the number of seconds the target has in which to respond to the monitor request. When creating a new monitor, the default is C(30) seconds. If the target responds within the set time period, it is considered 'up'. If the target does not respond within the set time period, it is considered 'down'. When this value is set to 0 (zero), the system uses the interval from the parent monitor. Note that C(timeout) and C(time_until_up) combine to control when a resource is set to up.}
	time_until_up=${6:# Specifies the number of seconds to wait after a resource first responds correctly to the monitor before setting the resource to 'up'. During the interval, all responses from the resource must be correct. When the interval expires, the resource is marked 'up'. A value of 0, means that the resource is marked up immediately upon receipt of the first correct response. When creating a new monitor, the default is C(0).}
	community=${7:# Specifies the community name that the system must use to authenticate with the host server through SNMP. When creating a new monitor, the default value is C(public). Note that this value is case sensitive.}
	version=${8:v1|v2c}
	agent_type=${9:UCD|WIN2000|GENERIC}
	cpu_coefficient=${10:# Specifies the coefficient that the system uses to calculate the weight of the CPU threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(1.5).}
	cpu_threshold=${11:# Specifies the maximum acceptable CPU usage on the target server. When creating a new monitor, the default is C(80) percent.}
	memory_coefficient=${12:# Specifies the coefficient that the system uses to calculate the weight of the memory threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(1.0).}
	memory_threshold=${13:# Specifies the maximum acceptable memory usage on the target server. When creating a new monitor, the default is C(70) percent.}
	disk_coefficient=${14:# Specifies the coefficient that the system uses to calculate the weight of the disk threshold in the dynamic ratio load balancing algorithm. When creating a new monitor, the default is C(2.0).}
	disk_threshold=${15:# Specifies the maximum acceptable disk usage on the target server. When creating a new monitor, the default is C(90) percent.}
	partition=${16:Common}
	state=${17:#present|absent}
	provider=${18:# A dict object containing connection details.}

endsnippet

snippet bigiq_application_fastl4_udp "Manages BIG-IQ FastL4 UDP applications" b
bigiq_application_fastl4_udp: >
	name=${1:# Name of the new application.}

	description=${2:# Description of the application.}
	servers=${3:# A list of servers that the application is hosted on.}
	inbound_virtual=${4:# Settings to configure the virtual which will receive the inbound connection.}
	service_environment=${5:# Specifies the name of service environment that the application will be deployed to.}
	add_analytics=${6:no}
	state=${7:absent|#present}
	wait=${8:yes}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_schedule "Manage BIG-IP AFM schedule configurations" b
bigip_firewall_schedule: >
	name=${1:# Specifies the name of the AFM schedule configuration.}

	description=${2:# Specifies the user defined description text.}
	daily_hour_end=${3:# Specifies the time of day the rule will stop being used.}
	daily_hour_start=${4:# Specifies the time of day the rule will start to be in use.}
	date_valid_end=${5:# Specifies the end date/time this schedule will apply to the rule.}
	date_valid_start=${6:# Specifies the start date/time this schedule will apply to the rule.}
	days_of_week=${7:sunday|monday|tuesday|wednesday|thursday|friday|saturday|all}
	state=${8:#present|absent}
	partition=${9:Common}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_irule "Manage iRules across different modules on a BIG-IP" b
bigip_irule: >
	module=${1:ltm|gtm}
	name=${2:# The name of the iRule.}
	src=${3:# The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.}

	content=${4:# When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.}
	state=${5:#present|absent}
	partition=${6:Common}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_http_compression "Manage HTTP compression profiles on a BIG-IP" b
bigip_profile_http_compression: >
	name=${1:# Specifies the name of the compression profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	description=${3:# Description of the HTTP compression profile.}
	buffer_size=${4:# Maximum number of compressed bytes that the system buffers before inserting a Content-Length header (which specifies the compressed size) into the response.}
	gzip_level=${5:1|2|3|4|5|6|7|8|9}
	gzip_memory_level=${6:1|2|4|8|16|32|64|128|256}
	gzip_window_size=${7:1|2|4|8|16|32|64|128}
	partition=${8:Common}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_provision "Manage BIG-IP module provisioning" b
bigip_provision: >
	module=${1:am|afm|apm|asm|avr|cgnat|fps|gtm|ilx|lc|ltm|mgmt|pem|sam|sslo|swg|urldb|vcmp}

	level=${2:dedicated|#nominal|minimum}
	memory=${3:# Sets additional memory for management module. This is in addition to minimum allocated RAM of 1264MB.}
	state=${4:#present|absent}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_virtual_address "Manage LTM virtual addresses on a BIG-IP" b
bigip_virtual_address: >
	name=${1:# Name of the virtual address.}
	address=${2:# Virtual address. This value cannot be modified after it is set.}
	netmask=${3:# Netmask of the provided virtual address. This value cannot be modified after it is set.}
	connection_limit=${4:# Specifies the number of concurrent connections that the system allows on this virtual address.}
	arp_state=${5:enabled|disabled}
	arp=${6:# Specifies whether the system accepts ARP requests.}
	auto_delete=${7:# Specifies whether the system automatically deletes the virtual address with the deletion of the last associated virtual server. When C(disabled), specifies that the system leaves the virtual address even when all associated virtual servers have been deleted. When creating the virtual address, the default value is C(enabled).}
	icmp_echo=${8:enabled|disabled|selective}
	state=${9:#present|absent|enabled|disabled}
	availability_calculation=${10:always|when_all_available|when_any_available}
	route_advertisement=${11:disabled|enabled|always|selective|any|all}
	partition=${12:Common}
	traffic_group=${13:# The traffic group for the virtual address. When creating a new address, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.}
	route_domain=${14:# The route domain of the C(address) that you want to use.}
	spanning=${15:# Enables all BIG-IP systems in a device group to listen for and process traffic on the same virtual address.}
	provider=${16:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_pool_member "Manage GTM pool member settings" b
bigip_gtm_pool_member: >
	virtual_server=${1:# Specifies the name of the GTM virtual server which is assigned to the specified C(server).}
	server_name=${2:# Specifies the GTM server which contains the C(virtual_server).}
	type=${3:a|aaaa|cname|mx|naptr|srv}
	pool=${4:# Name of the GTM pool.}

	partition=${5:Common}
	member_order=${6:# Specifies the order in which the member will appear in the pool.}
	monitor=${7:# Specifies the monitor assigned to this pool member.}
	ratio=${8:# Specifies the weight of the pool member for load balancing purposes.}
	description=${9:# The description of the pool member.}
	aggregate=${10:# List of GTM pool member definitions to be created, modified or removed.}
	replace_all_with=${11:no}
	limits=${12:# Specifies resource thresholds or limit requirements at the pool member level.}
	state=${13:#present|absent|enabled|disabled}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet bigiq_application_fastl4_tcp "Manages BIG-IQ FastL4 TCP applications" b
bigiq_application_fastl4_tcp: >
	name=${1:# Name of the new application.}

	description=${2:# Description of the application.}
	servers=${3:# A list of servers that the application is hosted on.}
	inbound_virtual=${4:# Settings to configure the virtual which will receive the inbound connection.}
	service_environment=${5:# Specifies the name of service environment that the application will be deployed to.}
	add_analytics=${6:no}
	state=${7:absent|#present}
	wait=${8:yes}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_snmp_community "Manages SNMP communities on a BIG-IP." b
bigip_snmp_community: >
	state=${1:#present|absent}
	version=${2:v1|#v2c|v3}
	name=${3:# Name that identifies the SNMP community.}
	community=${4:# Specifies the community string (password) for access to the MIB.}
	source=${5:# Specifies the source address for access to the MIB.}
	port=${6:# Specifies the port for the trap destination.}
	oid=${7:# Specifies the object identifier (OID) for the record.}
	access=${8:ro|rw|read-only|read-write}
	ip_version=${9:4|6}
	snmp_username=${10:# Specifies the name of the user for whom you want to grant access to the SNMP v3 MIB.}
	snmp_auth_protocol=${11:md5|sha|none}
	snmp_auth_password=${12:# Specifies the password for the user.}
	snmp_privacy_protocol=${13:aes|des|none}
	snmp_privacy_password=${14:# Specifies the password for the user.}
	update_password=${15:#always|on_create}
	partition=${16:Common}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_user "Manage user accounts and user attributes on a BIG-IP" b
bigip_user: >
	username_credential=${1:# Name of the user to create, remove or modify.}

	full_name=${2:# Full name of the user.}
	password_credential=${3:# Set the users password to this unencrypted value. C(password_credential) is required when creating a new account.}
	shell=${4:bash|none|tmsh}
	partition_access=${5:# Specifies the administrative partition to which the user has access. C(partition_access) is required when creating a new account. Should be in the form "partition:role".}
	state=${6:#present|absent}
	update_password=${7:#always|on_create}
	partition=${8:Common}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_monitor_external "Manages external GTM monitors on a BIG-IP" b
bigip_gtm_monitor_external: >
	name=${1:# Specifies the name of the monitor.}

	parent=${2:/Common/external}
	arguments=${3:# Specifies any command-line arguments that the script requires.}
	ip=${4:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${5:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	external_program=${6:# Specifies the name of the file for the monitor to use. In order to reference a file, you must first import it using options on the System > File Management > External Monitor Program File List > Import screen. The BIG-IP system automatically places the file in the proper location on the file system.}
	interval=${7:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 30. This value B(must) be less than the C(timeout) value.}
	timeout=${8:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 120.}
	variables=${9:# Specifies any variables that the script requires.}
	partition=${10:Common}
	state=${11:#present|absent}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_policy_rule "Manage LTM policy rules on a BIG-IP" b
bigip_policy_rule: >
	policy=${1:# The name of the policy that you want to associate this rule with.}
	name=${2:# The name of the rule.}

	description=${3:# Description of the policy rule.}
	actions=${4:# The actions that you want the policy rule to perform.}
	conditions=${5:# A list of attributes that describe the condition.}
	state=${6:#present|absent}
	partition=${7:Common}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_topology_region "Manages GTM Topology Regions" b
bigip_gtm_topology_region: >
	name=${1:# Specifies the name of the region.}

	region_members=${2:# Specifies the list of region members.}
	partition=${3:Common}
	state=${4:#present|absent}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_remote_user "Manages default settings for remote user accounts on a BIG-IP" b
bigip_remote_user: >
	default_role=${1:acceleration-policy-editor|admin|application-editor|auditor|certificate-manager|firewall-manager|fraud-protection-manager|guest|irule-manager|manager|no-access|operator|resource-admin|user-manager|web-application-security-administrator|web-application-security-editor}
	default_partition=${2:# Specifies the default partition for all remote user accounts.}
	console_access=${3:# Enables or disables the default console access for all remote user accounts.}
	description=${4:# User defined description.}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_apm_policy_import "Manage BIG-IP APM policy or APM access profile imports" b
bigip_apm_policy_import: >
	name=${1:# The name of the APM policy or APM access profile to create or override.}

	type=${2:#profile_access|access_policy}
	source=${3:# Full path to a file to be imported into the BIG-IP APM.}
	force=${4:no}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_analytics "Manage HTTP analytics profiles on a BIG-IP" b
bigip_profile_analytics: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	description=${3:# Description of the profile.}
	collect_geo=${4:# Enables or disables the collection of the names of the countries from where the traffic was sent.}
	collect_ip=${5:# Enables or disables the collection of client IPs statistics.}
	collect_max_tps_and_throughput=${6:# Enables or disables the collection of maximum TPS and throughput for all collected entities.}
	collect_page_load_time=${7:# Enables or disables the collection of the page load time statistics.}
	collect_url=${8:# Enables or disables the collection of requested URL statistics.}
	collect_user_agent=${9:# Enables or disables the collection of user agents.}
	collect_user_sessions=${10:# Enables or disables the collection of the unique user sessions.}
	collected_stats_external_logging=${11:# Enables or disables the external logging of the collected statistics.}
	collected_stats_internal_logging=${12:# Enables or disables the internal logging of the collected statistics.}
	external_logging_publisher=${13:# Specifies the external logging publisher used to send statistical data to one or more destinations.}
	notification_by_syslog=${14:# Enables or disables logging of the analytics alerts into the Syslog.}
	notification_by_email=${15:# Enables or disables sending the analytics alerts by email.}
	notification_email_addresses=${16:# Specifies which email addresses receive alerts by email when C(notification_by_email) is enabled.}
	partition=${17:Common}
	state=${18:#present|absent}
	provider=${19:# A dict object containing connection details.}

endsnippet

snippet bigip_dns_cache_resolver "Manage DNS resolver cache configurations on BIG-IP" b
bigip_dns_cache_resolver: >
	name=${1:# Specifies the name of the cache.}

	answer_default_zones=${2:# Specifies whether the system answers DNS queries for the default zones localhost, reverse 127.0.0.1 and ::1, and AS112.}
	forward_zones=${3:# Forward zones associated with the cache.}
	route_domain=${4:# Specifies the route domain the resolver uses for outbound traffic.}
	state=${5:#present|absent}
	partition=${6:Common}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_password_policy "Manages the authentication password policy on a BIG-IP" b
bigip_password_policy: >
	expiration_warning=${1:# Specifies the number of days before a password expires.}
	max_duration=${2:# Specifies the maximum number of days a password is valid.}
	max_login_failures=${3:# Specifies the number of consecutive unsuccessful login attempts that the system allows before locking out the user.}
	min_duration=${4:# Specifies the minimum number of days a password is valid.}
	min_length=${5:# Specifies the minimum number of characters in a valid password.}
	policy_enforcement=${6:# Enables or disables the password policy on the BIG-IP system.}
	required_lowercase=${7:# Specifies the number of lowercase alpha characters that must be present in a password for the password to be valid.}
	required_numeric=${8:# Specifies the number of numeric characters that must be present in a password for the password to be valid.}
	required_special=${9:# Specifies the number of special characters that must be present in a password for the password to be valid.}
	required_uppercase=${10:# Specifies the number of uppercase alpha characters that must be present in a password for the password to be valid.}
	password_memory=${11:# Specifies whether the user has configured the BIG-IP system to remember a password on a specific computer and how many passwords to remember.}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_ike_peer "Manage IPSec IKE Peer configuration on BIG-IP" b
bigip_ike_peer: >
	name=${1:# Specifies the name of the IKE peer.}

	description=${2:# Description of the IKE peer.}
	version=${3:v1|v2}
	presented_id_type=${4:address|asn1dn|fqdn|keyid-tag|user-fqdn|override}
	presented_id_value=${5:# This is a required value when C(version) includes (Cv2).}
	verified_id_type=${6:address|asn1dn|fqdn|keyid-tag|user-fqdn|override}
	verified_id_value=${7:# This is a required value when C(version) includes (Cv2).}
	phase1_auth_method=${8:pre-shared-key|rsa-signature}
	phase1_cert=${9:# Specifies the digital certificate to use for the RSA signature.}
	phase1_key=${10:# Specifies the public key that the digital certificate contains.}
	phase1_verify_peer_cert=${11:# In IKEv2, specifies whether the certificate sent by the IKE peer is verified using the Trusted Certificate Authorities, a CRL, and/or a peer certificate.}
	preshared_key=${12:# Specifies a string that the IKE peers share for authenticating each other.}
	remote_address=${13:# Displays the IP address of the BIG-IP system that is remote to the system you are configuring.}
	phase1_encryption_algorithm=${14:3des|des|blowfish|cast128|aes128|aes192|aes256|camellia}
	phase1_hash_algorithm=${15:sha1|md5|sha256|sha384|sha512}
	phase1_perfect_forward_secrecy=${16:ecp256|ecp384|ecp521|modp768|modp1024|modp1536|modp2048|modp3072|modp4096|modp6144|modp8192}
	update_password=${17:#always|on_create}
	partition=${18:Common}
	state=${19:#present|absent}
	provider=${20:# A dict object containing connection details.}

endsnippet

snippet bigip_device_auth_ldap "Manage LDAP device authentication settings on BIG-IP" b
bigip_device_auth_ldap: >
	servers=${1:# Specifies the LDAP servers that the system must use to obtain authentication information. You must specify a server when you create an LDAP configuration object.}
	port=${2:# Specifies the port that the system uses for access to the remote host server.}
	remote_directory_tree=${3:# Specifies the file location (tree) of the user authentication database on the server.}
	scope=${4:sub|one|base}
	bind_dn=${5:# Specifies the distinguished name for the Active Directory or LDAP server user ID.}
	bind_password=${6:# Specifies a password for the Active Directory or LDAP server user ID.}
	user_template=${7:# Specifies the distinguished name of the user who is logging on.}
	check_member_attr=${8:# Checks the user's member attribute in the remote LDAP or AD group.}
	ssl=${9:yes|no|start-tls}
	ca_cert=${10:# Specifies the name of an SSL certificate from a certificate authority (CA).}
	client_key=${11:# Specifies the name of an SSL client key.}
	client_cert=${12:# Specifies the name of an SSL client certificate.}
	validate_certs=${13:# Specifies whether the system checks an SSL peer, as a result of which the system requires and verifies the server certificate.}
	login_ldap_attr=${14:# Specifies the LDAP directory attribute containing the local user name that is associated with the selected directory entry.}
	fallback_to_local=${15:# Specifies that the system uses the Local authentication method if the remote authentication method is not available.}
	state=${16:#present|absent}
	update_password=${17:#always|on_create}
	provider=${18:# A dict object containing connection details.}

endsnippet

snippet bigip_ssl_certificate "Import/Delete certificates from BIG-IP" b
bigip_ssl_certificate: >
	name=${1:# SSL Certificate Name. This is the cert name used when importing a certificate into the F5. It also determines the filenames of the objects on the LTM.}

	content=${2:# Sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or}
	state=${3:#present|absent}
	issuer_cert=${4:# Issuer certificate used for OCSP monitoring.}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_log_destination "Manages log destinations on a BIG-IP." b
bigip_log_destination: >
	name=${1:# Specifies the name of the log destination.}
	type=${2:remote-high-speed-log|remote-syslog|arcsight|splunk|management-port|ipfix}

	description=${3:# The description of the log destination.}
	pool_settings=${4:# This parameter is only available when C(type) is C(remote-high-speed-log).}
	syslog_settings=${5:# This parameter is only available when C(type) is C(remote-syslog).}
	syslog_format=${6:bsd-syslog|syslog|legacy-bigip|rfc5424|rfc3164}
	forward_to=${7:# When C(type) is C(remote-syslog), specifies the management port log destination, which will be used to forward the logs to a single log server, or a remote high-speed log destination, which will be used to forward the logs to a pool of remote log servers.}
	pool=${8:# When C(type) is C(remote-high-speed-log), specifies the existing pool of remote high-speed log servers where logs will be sent.}
	protocol=${9:tcp|udp|ipfix|netflow-9}
	distribution=${10:adaptive|balanced|replicated}
	address=${11:# Specifies the IP address that will receive messages from the specified local Log Destination.}
	port=${12:# Specifies the port of the IP address that will receive messages from the specified local Log Destination.}
	transport_profile=${13:# Is a transport profile based on either TCP or UDP.}
	server_ssl_profile=${14:# If the C(transport_profile) is a TCP profile, you can use this field to choose a Secure Socket Layer (SSL) profile for sending logs to the IPFIX collectors.}
	template_retransmit_interval=${15:# Enter the time (in seconds) between each transmission of IPFIX templates to the pool of IPFIX collectors.}
	template_delete_delay=${16:# Enter the time (in seconds) that the BIG-IP device should pause between deleting an obsolete IPFIX template and reusing its template ID.}
	partition=${17:Common}
	state=${18:#present|absent}
	provider=${19:# A dict object containing connection details.}

endsnippet

snippet bigip_message_routing_transport_config "Manages configuration for an outgoing connection" b
bigip_message_routing_transport_config: >
	name=${1:# Specifies the name of the transport config to manage.}

	description=${2:# The user defined description of the transport config.}
	profiles=${3:# Specifies a list profiles for the outgoing connection to use to direct and manage traffic.}
	src_addr_translation=${4:# Specifies the type of source address translation enabled for the transport config and the pool that the source address translation will use.}
	src_port=${5:# Specifies the source port to be used for the connection being created.}
	rules=${6:# The iRules you want run on this transport config. iRules help automate the intercepting, processing, and routing of application traffic.}
	type=${7:#generic}
	partition=${8:Common}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_apm_policy_fetch "Exports the APM policy or APM access profile from remote nodes." b
bigip_apm_policy_fetch: >
	name=${1:# The name of the APM policy or APM access profile exported to create a file on the remote device for downloading.}

	dest=${2:# A directory to save the file into.}
	file=${3:# The name of the file to be created on the remote device for downloading.}
	type=${4:#profile_access|access_policy}
	force=${5:yes}
	partition=${6:Common}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_tcp "Manage TCP profiles on a BIG-IP" b
bigip_profile_tcp: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	idle_timeout=${3:# Specifies the length of time that a connection is idle (has no traffic) before the connection is eligible for deletion.}
	time_wait_recycle=${4:# Specifies that connections in a TIME-WAIT state are reused, if a SYN packet, indicating a request for a new connection, is received.}
	nagle=${5:auto|enabled|disabled}
	early_retransmit=${6:# When C(yes) the system uses early fast retransmits to reduce the recovery time for connections that are receive-buffer or user-data limited.}
	proxy_options=${7:# When C(yes) the system advertises an option, such as a time-stamp to the server only if it was negotiated with the client.}
	initial_congestion_window_size=${8:# Specifies the initial congestion window size for connections to this destination. The actual window size is this value multiplied by the MSS for the same connection.}
	initial_receive_window_size=${9:# Specifies the initial receive window size for connections to this destination. The actual window size is this value multiplied by the MSS for the same connection.}
	syn_rto_base=${10:# Specifies the initial RTO C(Retransmission TimeOut) base multiplier for SYN retransmission, in C(milliseconds).}
	partition=${11:Common}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_log_profile "Manages AFM logging profiles configured in the system" b
bigip_firewall_log_profile: >
	name=${1:# Specifies the name of the log profile.}

	description=${2:# Description of the log profile.}
	dos_protection=${3:# Configures DoS related settings of the log profile.}
	ip_intelligence=${4:# Configures IP Intelligence related settings of the log profile.}
	port_misuse=${5:# Port Misuse log configuration.}
	partition=${6:Common}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_device_auth "Manage system authentication on a BIG-IP" b
bigip_device_auth: >
	type=${1:tacacs|local}
	servers=${2:# Specifies a list of the IPv4 addresses for servers using the Terminal Access Controller Access System (TACACS)+ protocol with which the system communicates to obtain authorization data.}
	secret=${3:# Secret key used to encrypt and decrypt packets sent or received from the server.}
	service_name=${4:slip|ppp|arap|shell|tty-daemon|connection|system|firewall}
	protocol_name=${5:lcp|ip|ipx|atalk|vines|lat|xremote|tn3270|telnet|rlogin|pad|vpdn|ftp|http|deccp|osicp|unknown}
	authentication=${6:use-first-server|use-all-servers}
	use_for_auth=${7:# Specifies whether or not this auth source is put in use on the system.}
	state=${8:absent|#present}
	update_secret=${9:#always|on_create}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_dns_nameserver "Manage LTM DNS nameservers on a BIG-IP" b
bigip_dns_nameserver: >
	name=${1:# Specifies the name of the nameserver.}

	address=${2:# Specifies the IP address on which the DNS nameserver (client) or back-end DNS authoritative server (DNS Express server) listens for DNS messages.}
	service_port=${3:# Specifies the service port on which the DNS nameserver (client) or back-end DNS authoritative server (DNS Express server) listens for DNS messages.}
	route_domain=${4:# Specifies the local route domain that the DNS nameserver (client) or back-end DNS authoritative server (DNS Express server) uses for outbound traffic.}
	tsig_key=${5:# Specifies the TSIG key the system uses to communicate with this DNS nameserver (client) or back-end DNS authoritative server (DNS Express server) for AXFR zone transfers.}
	state=${6:#present|absent}
	partition=${7:Common}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_hostname "Manage the hostname of a BIG-IP" b
bigip_hostname: >
	hostname=${1:# Hostname of the BIG-IP host.}

	provider=${2:# A dict object containing connection details.}

endsnippet

snippet bigip_vlan "Manage VLANs on a BIG-IP system" b
bigip_vlan: >
	name=${1:# The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.}

	description=${2:# The description to give to the VLAN.}
	tagged_interfaces=${3:# Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.}
	untagged_interfaces=${4:# Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.}
	state=${5:absent|#present}
	tag=${6:# Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.}
	mtu=${7:# Specifies the maximum transmission unit (MTU) for traffic on this VLAN. When creating a new VLAN, if this parameter is not specified, the default value used will be C(1500).}
	cmp_hash=${8:default|destination-address|source-address|dst-ip|src-ip|dest|destination|source|dst|src}
	dag_tunnel=${9:inner|outer}
	dag_round_robin=${10:# Specifies whether some of the stateless traffic on the VLAN should be disaggregated in a round-robin order instead of using a static hash. The stateless traffic includes non-IP L2 traffic, ICMP, some UDP protocols, and so on.}
	partition=${11:Common}
	source_check=${12:# When C(yes), specifies that the system verifies that the return route to an initial packet is the same VLAN from which the packet originated.}
	fail_safe=${13:# When C(yes), specifies that the VLAN takes the specified C(fail_safe_action) if the system detects a loss of traffic on this VLAN's interfaces.}
	fail_safe_timeout=${14:# Specifies the number of seconds that a system can run without detecting network traffic on this VLAN before it takes the C(fail_safe_action).}
	fail_safe_action=${15:reboot|restart-all|failover}
	sflow_poll_interval=${16:# Specifies the maximum interval in seconds between two pollings.}
	sflow_sampling_rate=${17:# Specifies the ratio of packets observed to the samples generated.}
	interfaces=${18:# Interfaces that you want added to the VLAN. This can include both tagged and untagged interfaces as the C(tagging) parameter specifies.}
	provider=${19:# A dict object containing connection details.}

endsnippet

snippet bigip_data_group "Manage data groups on a BIG-IP" b
bigip_data_group: >
	name=${1:# Specifies the name of the data group.}

	description=${2:# The description of the data group.}
	type=${3:address|addr|ip|#string|str|integer|int}
	internal=${4:no}
	external_file_name=${5:# When creating a new data group, this specifies the file name that you want to give an external data group file on the BIG-IP.}
	records=${6:# Specifies the records that you want to add to a data group.}
	records_src=${7:# Path to a file with records in it.}
	separator=${8::=}
	delete_data_group_file=${9:no}
	partition=${10:Common}
	state=${11:#present|absent}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_http "Manages F5 BIG-IP LTM http monitors" b
bigip_monitor_http: >
	name=${1:# Monitor name.}

	parent=${2:/Common/http}
	description=${3:# The description of the monitor.}
	send=${4:# The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(GET /\r\n) will be used.}
	receive=${5:# The receive string for the monitor call.}
	receive_disable=${6:# This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).}
	ip=${7:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${8:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	interval=${9:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
	timeout=${10:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
	time_until_up=${11:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
	target_username=${12:# Specifies the user name, if the monitored target requires authentication.}
	target_password=${13:# Specifies the password, if the monitored target requires authentication.}
	reverse=${14:# Specifies whether the monitor operates in reverse mode.}
	partition=${15:Common}
	state=${16:#present|absent}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_udp "Manage UDP profiles on a BIG-IP" b
bigip_profile_udp: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	idle_timeout=${3:# Specifies the length of time that a connection is idle (has no traffic) before the connection is eligible for deletion.}
	datagram_load_balancing=${4:# Specifies, when C(yes), that the system load balances UDP traffic packet-by-packet.}
	partition=${5:Common}
	state=${6:#present|absent}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_cli_alias "Manage CLI aliases on a BIG-IP" b
bigip_cli_alias: >
	name=${1:# Specifies the name of the alias.}

	scope=${2:private|#shared}
	command=${3:# The command to alias.}
	description=${4:# Description of the alias.}
	partition=${5:Common}
	state=${6:#present|absent}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_gateway_icmp "Manages F5 BIG-IP LTM gateway ICMP monitors" b
bigip_monitor_gateway_icmp: >
	name=${1:# Monitor name.}

	parent=${2:/Common/gateway_icmp}
	description=${3:# The description of the monitor.}
	ip=${4:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${5:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	interval=${6:# Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.}
	timeout=${7:# Specifies the number of seconds the target has in which to respond to the monitor request.}
	time_until_up=${8:# Specifies the number of seconds to wait after a resource first responds correctly to the monitor before setting the resource to 'up'.}
	up_interval=${9:# Specifies the interval for the system to use to perform the health check when a resource is up.}
	manual_resume=${10:# Specifies whether the system automatically changes the status of a resource to B(enabled) at the next successful monitor check.}
	adaptive=${11:# Specifies whether adaptive response time monitoring is enabled for this monitor.}
	allowed_divergence_type=${12:relative|absolute}
	allowed_divergence_value=${13:# When specifying a new monitor, if C(adaptive) is C(yes), and C(type) is C(relative), the default is C(25) percent.}
	adaptive_limit=${14:# Specifies the absolute number of milliseconds that may not be exceeded by a monitor probe, regardless of C(allowed_divergence) setting, for a probe to be considered successful.}
	sampling_timespan=${15:# Specifies the length, in seconds, of the probe history window that the system uses to calculate the mean latency and standard deviation of a monitor probe.}
	transparent=${16:# Specifies whether the monitor operates in transparent mode.}
	partition=${17:Common}
	state=${18:#present|absent}
	provider=${19:# A dict object containing connection details.}

endsnippet

snippet bigiq_device_info "Collect information from F5 BIG-IQ devices" b
bigiq_device_info: >
	gather_subset=${1:all|applications|managed-devices|purchased-pool-licenses|regkey-pools|system-info|vlans|!all|!applications|!managed-devices|!purchased-pool-licenses|!regkey-pools|!system-info|!vlans}

	provider=${2:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_dos_vector "Manage attack vector configuration in an AFM DoS profile" b
bigip_firewall_dos_vector: >
	profile=${1:# Specifies the name of the profile to manage vectors in.}
	state=${2:mitigate|detect-only|learn-only|disabled}

	name=${3:ext-hdr-too-large|hop-cnt-low|host-unreachable|icmp-frag|icmpv4-flood|icmpv6-flood|ip-frag-flood|ip-low-ttl|ip-opt-frames|ipv6-frag-flood|opt-present-with-illegal-len|sweep|tcp-bad-urg|tcp-half-open|tcp-opt-overruns-tcp-hdr|tcp-psh-flood|tcp-rst-flood|tcp-syn-flood|tcp-syn-oversize|tcp-synack-flood|tcp-window-size|tidcmp|too-many-ext-hdrs|udp-flood|unk-tcp-opt-type|a|aaaa|any|axfr|cname|dns-malformed|ixfr|mx|ns|other|ptr|qdcount|soa|srv|txt|ack|bye|cancel|invite|message|notify|options|other|prack|publish|register|sip-malformed|subscribe|uri-limit}
	auto_blacklist=${4:# Automatically blacklists detected bad actors.}
	bad_actor_detection=${5:# Whether Bad Actor detection is enabled or disabled for a vector, if available.}
	attack_ceiling=${6:# Specifies the absolute maximum allowable for packets of this type.}
	attack_floor=${7:# Specifies packets per second to identify an attack.}
	allow_advertisement=${8:# Specifies that addresses that are identified for blacklisting are advertised to BGP routers}
	simulate_auto_threshold=${9:# Specifies that results of the current automatic thresholds are logged, though manual thresholds are enforced, and no action is taken on automatic thresholds.}
	blacklist_detection_seconds=${10:# Detection, in seconds, before blacklisting occurs.}
	blacklist_duration=${11:# Duration, in seconds, that the blacklist will last.}
	per_source_ip_detection_threshold=${12:# Specifies the number of packets per second to identify an IP address as a bad actor.}
	per_source_ip_mitigation_threshold=${13:# Specifies the rate limit applied to a source IP that is identified as a bad actor.}
	detection_threshold_percent=${14:# Lists the threshold percent increase over time that the system must detect in traffic in order to detect this attack.}
	detection_threshold_eps=${15:# Lists how many packets per second the system must discover in traffic in order to detect this attack.}
	mitigation_threshold_eps=${16:# Specify the maximum number of this type of packet per second the system allows for a vector.}
	threshold_mode=${17:manual|stress-based-mitigation|fully-automatic}
	partition=${18:Common}
	provider=${19:# A dict object containing connection details.}

endsnippet

snippet bigip_message_routing_router "Manages router profiles for message-routing protocols" b
bigip_message_routing_router: >
	name=${1:# Specifies the name of the router profile.}

	description=${2:# The user defined description of the router profile.}
	type=${3:#generic}
	parent=${4:# The parent template of this router profile. Once this value has been set, it cannot be changed.}
	ignore_client_port=${5:# When C(yes), the remote port on clientside connections ie. connections where the peer connected to the BIG-IP is ignored when searching for an existing connection.}
	inherited_traffic_group=${6:# When set to C(yes) the C(traffic_group) will be inherited from the containing folder. When not specified the system sets this to C(no) when creating new router profile.}
	traffic_group=${7:# Specifies the traffic-group of the router profile.}
	use_local_connection=${8:# If C(yes), the router will route a message to an existing connection on the same TMM as the message was received on.}
	max_pending_bytes=${9:# The maximum number of bytes worth of pending messages that will be held while waiting for a connection to a peer to be created. Once reached, any additional messages to the peer will be flagged as undeliverable and returned to the originator.}
	max_pending_messages=${10:# The maximum number of pending messages that will be held while waiting for a connection to a peer to be created. Once reached, any additional messages to the peer will be flagged as undeliverable and returned to the originator.}
	max_retries=${11:# Sets the maximum number of time a message may be resubmitted for rerouting by the C(MR::retry) iRule command.}
	mirror=${12:# Enables or disables state mirroring. State mirroring can be used to maintain the same state information in the standby unit that is in the active unit.}
	mirrored_msg_sweeper_interval=${13:# Specifies the maximum time in milliseconds that a message will be held on the standby device as it waits for the active device to route the message.}
	routes=${14:# Specifies a list of static routes for the router instance to use.}
	partition=${15:Common}
	state=${16:#present|absent}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_node "Manages F5 BIG-IP LTM nodes" b
bigip_node: >
	name=${1:# Specifies the name of the node.}

	state=${2:#present|absent|enabled|disabled|offline}
	monitor_type=${3:and_list|m_of_n|single}
	quorum=${4:# Monitor quorum value when C(monitor_type) is C(m_of_n).}
	monitors=${5:# Specifies the health monitors that the system currently uses to monitor this node.}
	address=${6:# IP address of the node. This can be either IPv4 or IPv6. When creating a new node, one of either C(address) or C(fqdn) must be provided. This parameter cannot be updated after it is set.}
	fqdn=${7:# FQDN name of the node. This can be any name that is a valid RFC 1123 DNS name. Therefore, the only characters that can be used are "A" to "Z", "a" to "z", "0" to "9", the hyphen ("-") and the period (".").}
	fqdn_address_type=${8:ipv4|ipv6|all}
	fqdn_auto_populate=${9:# Specifies whether the system automatically creates ephemeral nodes using the IP addresses returned by the resolution of a DNS query for a node defined by an FQDN.}
	fqdn_up_interval=${10:# Specifies the interval in which a query occurs, when the DNS server is up. The associated monitor attempts to probe three times, and marks the server down if it there is no response within the span of three times the interval value, in seconds.}
	fqdn_down_interval=${11:# Specifies the interval in which a query occurs, when the DNS server is down. The associated monitor continues polling as long as the DNS server is down.}
	description=${12:# Specifies descriptive text that identifies the node.}
	connection_limit=${13:# Node connection limit. Setting this to 0 disables the limit.}
	rate_limit=${14:# Node rate limit (connections-per-second). Setting this to 0 disables the limit.}
	ratio=${15:# Node ratio weight. Valid values range from 1 through 100.}
	dynamic_ratio=${16:# The dynamic ratio number for the node. Used for dynamic ratio load balancing.}
	availability_requirements=${17:# Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.}
	partition=${18:Common}
	provider=${19:# A dict object containing connection details.}

endsnippet

snippet bigiq_regkey_pool "Manages registration key pools on BIG-IQ" b
bigiq_regkey_pool: >
	name=${1:# Specifies the name of the registration key pool.}

	description=${2:# A description to attach to the pool.}
	state=${3:absent|#present}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigip_traffic_selector "Manage IPSec Traffic Selectors on BIG-IP" b
bigip_traffic_selector: >
	name=${1:# Specifies the name of the traffic selector.}

	destination_address=${2:# Specifies the host or network IP address to which the application traffic is destined.}
	source_address=${3:# Specifies the host or network IP address from which the application traffic originates.}
	ipsec_policy=${4:# Specifies the IPsec policy that tells the BIG-IP system how to handle the packets.}
	order=${5:# Specifies the order in which traffic is matched, if traffic can be matched to multiple traffic selectors.}
	description=${6:# Description of the traffic selector.}
	partition=${7:Common}
	state=${8:#present|absent}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_device_syslog "Manage system-level syslog settings on BIG-IP" b
bigip_device_syslog: >
	auth_priv_from=${1:alert|crit|debug|emerg|err|info|notice|warning}
	auth_priv_to=${2:alert|crit|debug|emerg|err|info|notice|warning}
	console_log=${3:# Enables or disables logging emergency syslog messages to the console.}
	cron_from=${4:alert|crit|debug|emerg|err|info|notice|warning}
	cron_to=${5:alert|crit|debug|emerg|err|info|notice|warning}
	daemon_from=${6:alert|crit|debug|emerg|err|info|notice|warning}
	daemon_to=${7:alert|crit|debug|emerg|err|info|notice|warning}
	include=${8:# Syslog-NG configuration to include in the device syslog config.}
	iso_date=${9:# Enables or disables the ISO date format for messages in the log files.}
	kern_from=${10:alert|crit|debug|emerg|err|info|notice|warning}
	kern_to=${11:alert|crit|debug|emerg|err|info|notice|warning}
	local6_from=${12:alert|crit|debug|emerg|err|info|notice|warning}
	local6_to=${13:alert|crit|debug|emerg|err|info|notice|warning}
	mail_from=${14:alert|crit|debug|emerg|err|info|notice|warning}
	mail_to=${15:alert|crit|debug|emerg|err|info|notice|warning}
	messages_from=${16:alert|crit|debug|emerg|err|info|notice|warning}
	messages_to=${17:alert|crit|debug|emerg|err|info|notice|warning}
	user_log_from=${18:alert|crit|debug|emerg|err|info|notice|warning}
	user_log_to=${19:alert|crit|debug|emerg|err|info|notice|warning}
	provider=${20:# A dict object containing connection details.}

endsnippet

snippet bigip_device_ntp "Manage NTP servers on a BIG-IP" b
bigip_device_ntp: >
	ntp_servers=${1:# A list of NTP servers to set on the device. At least one of C(ntp_servers) or C(timezone) is required.}
	state=${2:absent|#present}
	timezone=${3:# The timezone to set for NTP lookups. At least one of C(ntp_servers) or C(timezone) is required.}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_dos_profile "Manage AFM DoS profiles on a BIG-IP" b
bigip_firewall_dos_profile: >
	name=${1:# Specifies the name of the profile.}

	description=${2:# The description of the DoS profile.}
	default_whitelist=${3:# The default whitelist address list for the system to use to determine which IP addresses are legitimate.}
	threshold_sensitivity=${4:low|medium|high}
	partition=${5:Common}
	state=${6:#present|absent}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_file_copy "Manage files in datastores on a BIG-IP" b
bigip_file_copy: >
	name=${1:# The name of the file as it should reside on the BIG-IP.}
	source=${2:# Specifies the path of the file to upload.}
	datastore=${3:external-monitor|#ifile|lw4o6-table}
	force=${4:# Force overwrite a file.}
	partition=${5:Common}
	state=${6:#present|absent}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_global_rules "Manage AFM global rule settings on BIG-IP" b
bigip_firewall_global_rules: >
	enforced_policy=${1:# Specifies an enforced firewall policy.}
	service_policy=${2:# Specifies a service policy that would apply to traffic globally.}
	staged_policy=${3:# Specifies a staged firewall policy.}
	description=${4:# Description for the global list of firewall rules.}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_rule "Manage AFM Firewall rules" b
bigip_firewall_rule: >
	name=${1:# Specifies the name of the rule.}

	parent_policy=${2:# The policy which contains the rule to be managed.}
	parent_rule_list=${3:# The rule list which contains the rule to be managed.}
	action=${4:accept|drop|reject|accept-decisively}
	status=${5:enabled|disabled|scheduled}
	schedule=${6:# Specifies a schedule for the firewall rule.}
	description=${7:# The rule description.}
	irule=${8:# Specifies an iRule that is applied to the firewall rule.}
	protocol=${9:# Specifies the protocol to which the rule applies.}
	source=${10:# Specifies packet sources to which the rule applies.}
	destination=${11:# Specifies packet destinations to which the rule applies.}
	logging=${12:# Specifies whether logging is enabled or disabled for the firewall rule.}
	rule_list=${13:# Specifies an existing rule list to use in the rule.}
	icmp_message=${14:# Specifies the Internet Control Message Protocol (ICMP) or ICMPv6 message C(type) and C(code) that the rule uses.}
	partition=${15:Common}
	state=${16:#present|absent}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_persistence_cookie "Manage cookie persistence profiles on BIG-IP" b
bigip_profile_persistence_cookie: >
	name=${1:# Specifies the name of the profile.}

	description=${2:# Description of the profile.}
	parent=${3:cookie}
	cookie_method=${4:hash|insert|passive|rewrite}
	cookie_name=${5:# Specifies a unique name for the cookie.}
	http_only=${6:# Specifies whether the httponly attribute should be enabled or disabled for the inserted cookies.}
	match_across_services=${7:# When C(yes), specifies that all persistent connections from a client IP address that go to the same virtual IP address also go to the same node.}
	match_across_virtuals=${8:# When C(yes), specifies that all persistent connections from the same client IP address go to the same node.}
	match_across_pools=${9:# When C(yes), specifies that the system can use any pool that contains this persistence record.}
	cookie_encryption=${10:disabled|preferred|required}
	override_connection_limit=${11:# When C(yes), specifies that the system allows you to specify that pool member connection limits will be overridden for persisted clients.}
	encrypt_cookie_pool_name=${12:# Specifies whether the pool-name in the inserted BIG-IP default cookie should be encrypted.}
	always_send=${13:# Send the cookie persistence entry on every reply, even if the entry has previously been supplied to the client.}
	secure=${14:# Specifies whether the secure attribute should be enabled or disabled for the inserted cookies.}
	encryption_passphrase=${15:# Specifies a passphrase to be used for cookie encryption.}
	update_password=${16:#always|on_create}
	expiration=${17:# Specifies the expiration time of the cookie. By default the system generates and uses session cookie. This cookie expires when the user session expires, that is when the browser is closed.}
	partition=${18:Common}
	state=${19:#present|absent}
	provider=${20:# A dict object containing connection details.}

endsnippet

snippet bigip_lx_package "Manages Javascript LX packages on a BIG-IP" b
bigip_lx_package: >
	package=${1:# The LX package that you want to upload or remove. When C(state) is C(present), and you intend to use this module in a C(role), it is recommended that you use the C({{ role_path }}) variable. An example is provided in the C(EXAMPLES) section.}
	state=${2:#present|absent}
	provider=${3:# A dict object containing connection details.}

endsnippet

snippet bigip_ssl_key "Import/Delete SSL keys from BIG-IP" b
bigip_ssl_key: >
	name=${1:# The name of the key.}

	content=${2:# Sets the contents of a key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. This must be provided when C(state) is C(present).}
	state=${3:#present|absent}
	passphrase=${4:# Passphrase on key.}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_appsvcs_extension "Manage application service deployments" b
bigip_appsvcs_extension: >
	content=${1:# Declaration of tenants configured on the system.}

	tenants=${2:# A list of tenants that you want to remove.}
	force=${3:no}
	state=${4:#present|absent}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_software_install "Install software images on a BIG-IP" b
bigip_software_install: >
	image=${1:# Image to install on the remote device.}
	volume=${2:# The volume to install the software image to.}
	state=${3:#activated|installed}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigiq_application_https_waf "Manages BIG-IQ HTTPS WAF applications" b
bigiq_application_https_waf: >
	name=${1:# Name of the new application.}

	description=${2:# Description of the application.}
	servers=${3:# A list of servers that the application is hosted on.}
	inbound_virtual=${4:# Settings to configure the virtual which will receive the inbound connection.}
	redirect_virtual=${5:# Settings to configure the virtual which will receive the connection to be redirected.}
	client_ssl_profile=${6:# Specifies the SSL profile for managing client-side SSL traffic.}
	service_environment=${7:# Specifies the name of service environment that the application will be deployed to.}
	add_analytics=${8:no}
	domain_names=${9:# Specifies host names that are used to access the web application that this security policy protects.}
	state=${10:absent|#present}
	wait=${11:yes}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_pool "Manages F5 BIG-IP LTM pools" b
bigip_pool: >
	name=${1:# Pool name}

	description=${2:# Specifies descriptive text that identifies the pool.}
	lb_method=${3:dynamic-ratio-member|dynamic-ratio-node|fastest-app-response|fastest-node|least-connections-member|least-connections-node|least-sessions|observed-member|observed-node|predictive-member|predictive-node|ratio-least-connections-member|ratio-least-connections-node|ratio-member|ratio-node|ratio-session|round-robin|weighted-least-connections-member|weighted-least-connections-node}
	monitor_type=${4:and_list|m_of_n|single}
	quorum=${5:# Monitor quorum value when C(monitor_type) is C(m_of_n).}
	monitors=${6:# Monitor template name list. If the partition is not provided as part of the monitor name, then the C(partition) option will be used instead.}
	slow_ramp_time=${7:# Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members.}
	reselect_tries=${8:# Sets the number of times the system tries to contact a pool member after a passive failure.}
	service_down_action=${9:none|reset|drop|reselect}
	partition=${10:Common}
	state=${11:absent|#present}
	metadata=${12:# Arbitrary key/value pairs that you can attach to a pool. This is useful in situations where you might want to annotate a pool to me managed by Ansible.}
	priority_group_activation=${13:# Specifies whether the system load balances traffic according to the priority number assigned to the pool member.}
	aggregate=${14:# List of pool definitions to be created, modified or removed.}
	replace_all_with=${15:no}
	provider=${16:# A dict object containing connection details.}

endsnippet

snippet bigip_service_policy "Manages service policies on a BIG-IP." b
bigip_service_policy: >
	name=${1:# Name of the service policy.}

	description=${2:# Description of the service policy.}
	timer_policy=${3:# The timer policy to attach to the service policy.}
	port_misuse_policy=${4:# The port misuse policy to attach to the service policy.}
	state=${5:#present|absent}
	partition=${6:Common}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_port_list "Manage port lists on BIG-IP AFM" b
bigip_firewall_port_list: >
	name=${1:# Specifies the name of the port list.}

	partition=${2:Common}
	description=${3:# Description of the port list}
	ports=${4:# Simple list of port values to add to the list}
	port_ranges=${5:# A list of port ranges where the range starts with a port number, is followed by a dash (-) and then a second number.}
	port_lists=${6:# Simple list of existing port lists to add to this list. Port lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_device_license "Manage license installation and activation on BIG-IP devices" b
bigip_device_license: >
	license_key=${1:# The registration key to use to license the BIG-IP.}
	license_server=${2:activate.f5.com}
	state=${3:absent|#present|revoked}
	accept_eula=${4:no}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_message_routing_route "Manages static routes for routing message protocol messages" b
bigip_message_routing_route: >
	name=${1:# Specifies the name of the static route.}

	description=${2:# The user defined description of the static route.}
	type=${3:#generic}
	src_address=${4:# Specifies the source address of the route.}
	dst_address=${5:# Specifies the destination address of the route.}
	peer_selection_mode=${6:ratio|sequential}
	peers=${7:# Specifies a list of ltm messagerouting-peer objects.}
	partition=${8:Common}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_tunnel "Manage tunnels on a BIG-IP" b
bigip_tunnel: >
	name=${1:# Specifies the name of the tunnel.}

	description=${2:# Description of the tunnel.}
	profile=${3:# Specifies the profile to associate with the tunnel for handling traffic.}
	key=${4:# When applied to a GRE tunnel, this value specifies an optional field in the GRE header, used to authenticate the source of the packet.}
	local_address=${5:# Specifies the IP address of the local endpoint of the tunnel.}
	remote_address=${6:# Specifies the IP address of the remote endpoint of the tunnel.}
	secondary_address=${7:# Specifies a non-floating IP address for the tunnel, to be used with host-initiated traffic.}
	mtu=${8:# Specifies the maximum transmission unit (MTU) of the tunnel.}
	use_pmtu=${9:# Enables or disables the tunnel to use the PMTU (Path MTU) information provided by ICMP NeedFrag error messages.}
	tos=${10:# Specifies the Type of Service (TOS) value to insert in the encapsulating header of transmitted packets.}
	auto_last_hop=${11:default|enabled|disabled}
	traffic_group=${12:# Specifies the traffic group to associate with the tunnel.}
	mode=${13:bidirectional|inbound|outbound}
	transparent=${14:# Specifies that the tunnel operates in transparent mode.}
	partition=${15:Common}
	state=${16:#present|absent}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_topology_record "Manages GTM Topology Records" b
bigip_gtm_topology_record: >
	source=${1:# Specifies the origination of an incoming DNS request.}
	destination=${2:# Specifies where the system directs the incoming DNS request.}

	weight=${3:# Specifies the weight of the topology record.}
	partition=${4:Common}
	state=${5:#present|absent}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_snat_translation "Manage SNAT Translations on a BIG-IP" b
bigip_snat_translation: >
	name=${1:# The name of SNAT translation.}

	address=${2:# Specifies the IP address of the SNAT translation. When a C(state) of present, enabled, or disabled is provided, this parameter is required.}
	arp=${3:# If C(yes), specifies that the NAT sends ARP requests.}
	connection_limit=${4:# Specifies a limit on the number of connections a translation address must reach before it no longer initiates a connection. The default value of 0 indicates that the setting is disabled.}
	description=${5:# Description of snat-translation. C(none or '') will set to default description of null.}
	ip_idle_timeout=${6:# Specifies the amount of time that connections to an IP address initiated using a SNAT address are allowed to remain idle before being automatically disconnected. C(indefinite) prevents the connection from timing out.}
	partition=${7:# Device partition to manage resources on.}
	state=${8:#present|absent|enabled|disabled}
	tcp_idle_timeout=${9:# Specifies the amount of time that TCP connections initiated using a SNAT address are allowed to remain idle before being automatically disconnected. C(indefinite) Prevents the connection from timing out.}
	traffic_group=${10:# The traffic group for the snat-translation address. When creating a new address, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.}
	udp_idle_timeout=${11:# Specifies the amount of time that UDP connections initiated using a SNAT address are allowed to remain idle before being automatically disconnected. C(indefinite) Prevents the connection from timing out.}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_client_ssl "Manages client SSL profiles on a BIG-IP" b
bigip_profile_client_ssl: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:/Common/clientssl}
	ciphers=${3:# Specifies the list of ciphers that the system supports. When creating a new profile, the default cipher list is provided by the parent profile.}
	cert_key_chain=${4:# One or more certificates and keys to associate with the SSL profile. This option is always a list. The keys in the list dictate the details of the client/key/chain combination. Note that BIG-IPs can only have one of each type of each certificate/key type. This means that you can only have one RSA, one DSA, and one ECDSA per profile. If you attempt to assign two RSA, DSA, or ECDSA certificate/key combo, the device will reject this.}
	partition=${5:Common}
	options=${6:netscape-reuse-cipher-change-bug|microsoft-big-sslv3-buffer|msie-sslv2-rsa-padding|ssleay-080-client-dh-bug|tls-d5-bug|tls-block-padding-bug|dont-insert-empty-fragments|no-ssl|no-dtls|no-session-resumption-on-renegotiation|no-tlsv1.1|no-tlsv1.2|no-tlsv1.3|single-dh-use|ephemeral-rsa|cipher-server-preference|tls-rollback-bug|no-sslv2|no-sslv3|no-tls|no-tlsv1|pkcs1-check-1|pkcs1-check-2|netscape-ca-dn-bug|netscape-demo-cipher-change-bug|none}
	secure_renegotiation=${7:require|require-strict|request}
	allow_non_ssl=${8:# Enables or disables acceptance of non-SSL connections.}
	server_name=${9:# Specifies the fully qualified DNS hostname of the server used in Server Name Indication communications. When creating a new profile, the setting is provided by the parent profile.}
	sni_default=${10:# Indicates that the system uses this profile as the default SSL profile when there is no match to the server name, or when the client provides no SNI extension support.}
	sni_require=${11:# Requires that the network peers also provide SNI support, this setting only takes effect when C(sni_default) is set to C(true).}
	strict_resume=${12:# Enables or disables the resumption of SSL sessions after an unclean shutdown.}
	client_certificate=${13:ignore|require|request}
	client_auth_frequency=${14:once|always}
	renegotiation=${15:# Enables or disables SSL renegotiation.}
	retain_certificate=${16:# When C(yes), client certificate is retained in SSL session.}
	cert_auth_depth=${17:# Specifies the maximum number of certificates to be traversed in a client certificate chain.}
	trusted_cert_authority=${18:# Specifies a client CA that the system trusts.}
	advertised_cert_authority=${19:# Specifies that the CAs that the system advertises to clients is being trusted by the profile.}
	client_auth_crl=${20:# Specifies the name of a file containing a list of revoked client certificates.}
	allow_expired_crl=${21:# Instructs the system to use the specified CRL file even if it has expired.}
	state=${22:#present|absent}
	provider=${23:# A dict object containing connection details.}

endsnippet

snippet bigip_asm_dos_application "Manage application settings for DOS profile" b
bigip_asm_dos_application: >
	profile=${1:# Specifies the name of the profile to manage application settings in.}

	rtbh_duration=${2:# Specifies the duration of the RTBH BGP route advertisement, in seconds.}
	rtbh_enable=${3:# Specifies whether to enable Remote Triggered Black Hole C(RTBH) of attacking IPs by advertising BGP routes.}
	scrubbing_duration=${4:# Specifies the duration of the Traffic Scrubbing BGP route advertisement, in seconds.}
	scrubbing_enable=${5:# Specifies whether to enable Traffic Scrubbing during attacks by advertising BGP routes.}
	single_page_application=${6:# Specifies, when C(yes), that the system supports a Single Page Applications.}
	trigger_irule=${7:# Specifies, when C(yes), that the system activates an Application DoS iRule event.}
	geolocations=${8:# Manages the geolocations countries whitelist, blacklist.}
	heavy_urls=${9:# Manages Heavy URL protection.}
	mobile_detection=${10:# Configures detection of mobile applications built with the Anti-Bot Mobile SDK and defines how requests from these mobile application clients are handled.}
	partition=${11:Common}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_dns "Manage DNS monitors on a BIG-IP" b
bigip_monitor_dns: >
	name=${1:# Specifies the name of the monitor.}

	parent=${2:/Common/dns}
	description=${3:# The description of the monitor.}
	interval=${4:# The interval specifying how frequently the monitor instance of this template will run.}
	up_interval=${5:# Specifies the interval for the system to use to perform the health check when a resource is up.}
	timeout=${6:# The number of seconds in which the node or service must respond to the monitor request.}
	transparent=${7:# Specifies whether the monitor operates in transparent mode.}
	reverse=${8:# Specifies whether the monitor operates in reverse mode.}
	receive=${9:# Specifies the IP address that the monitor uses from the resource record sections of the DNS response.}
	time_until_up=${10:# Specifies the amount of time in seconds after the first successful response before a node will be marked up.}
	manual_resume=${11:# Specifies whether the system automatically changes the status of a resource to B(enabled) at the next successful monitor check.}
	ip=${12:# IP address part of the IP/port definition.}
	port=${13:# Port address part of the IP/port definition.}
	query_name=${14:# Specifies a query name for the monitor to use in a DNS query.}
	query_type=${15:a|aaaa}
	answer_section_contains=${16:any-type|anything|query-type}
	accept_rcode=${17:no-error|anything}
	adaptive=${18:# Specifies whether adaptive response time monitoring is enabled for this monitor.}
	allowed_divergence_type=${19:relative|absolute}
	allowed_divergence_value=${20:# When specifying a new monitor, if C(adaptive) is C(yes), and C(type) is C(relative), the default is C(25) percent.}
	adaptive_limit=${21:# Specifies the absolute number of milliseconds that may not be exceeded by a monitor probe, regardless of C(allowed_divergence) setting, for a probe to be considered successful.}
	sampling_timespan=${22:# Specifies the length, in seconds, of the probe history window that the system uses to calculate the mean latency and standard deviation of a monitor probe.}
	partition=${23:Common}
	state=${24:#present|absent}
	provider=${25:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_port_list "Manage port lists on BIG-IP AFM" b
bigip_firewall_port_list: >
	name=${1:# Specifies the name of the port list.}

	partition=${2:Common}
	description=${3:# Description of the port list}
	ports=${4:# Simple list of port values to add to the list}
	port_ranges=${5:# A list of port ranges where the range starts with a port number, is followed by a dash (-) and then a second number.}
	port_lists=${6:# Simple list of existing port lists to add to this list. Port lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_device_traffic_group "Manages traffic groups on BIG-IP" b
bigip_device_traffic_group: >
	name=${1:# The name of the traffic group.}

	mac_address=${2:# Specifies the floating Media Access Control (MAC) address associated with the floating IP addresses defined for a traffic group.}
	ha_order=${3:# Specifies order in which you would like to assign devices for failover.}
	ha_group=${4:# Specifies a configured C(HA group) to be associated with the traffic group.}
	ha_load_factor=${5:# The value of the load the traffic-group presents the system relative to other traffic groups.}
	auto_failback=${6:# Specifies whether the traffic group fails back to the initial device specified in C(ha_order).}
	auto_failback_time=${7:# Specifies the number of seconds the system delays before failing back to the initial device specified in C(ha_order).}
	partition=${8:Common}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_rule_list "Manage AFM security firewall policies on a BIG-IP" b
bigip_firewall_rule_list: >
	name=${1:# The name of the policy to create.}

	description=${2:# The description to attach to the policy.}
	state=${3:#present|absent}
	rules=${4:# Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_pool_member "Manages F5 BIG-IP LTM pool members" b
bigip_pool_member: >
	state=${1:#present|absent|enabled|disabled|forced_offline}
	pool=${2:# Pool name. This pool must exist.}
	port=${3:# Pool member port.}

	name=${4:# Name of the node to create, or re-use, when creating a new pool member.}
	partition=${5:Common}
	address=${6:# IP address of the pool member. This can be either IPv4 or IPv6. When creating a new pool member, one of either C(address) or C(fqdn) must be provided. This parameter cannot be updated after it is set.}
	fqdn=${7:# FQDN name of the pool member. This can be any name that is a valid RFC 1123 DNS name. Therefore, the only characters that can be used are "A" to "Z", "a" to "z", "0" to "9", the hyphen ("-") and the period (".").}
	connection_limit=${8:# Pool member connection limit. Setting this to 0 disables the limit.}
	description=${9:# Pool member description.}
	rate_limit=${10:# Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.}
	ratio=${11:# Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overridden with this value -- default to 1.}
	preserve_node=${12:# When state is C(absent) attempts to remove the node that the pool member references.}
	priority_group=${13:# Specifies a number representing the priority group for the pool member.}
	fqdn_auto_populate=${14:# Specifies whether the system automatically creates ephemeral nodes using the IP addresses returned by the resolution of a DNS query for a node defined by an FQDN.}
	reuse_nodes=${15:yes}
	monitors=${16:# Specifies the health monitors that the system currently uses to monitor this resource.}
	availability_requirements=${17:# Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.}
	ip_encapsulation=${18:# Specifies the IP encapsulation using either IPIP (IP encapsulation within IP, RFC 2003) or GRE (Generic Router Encapsulation, RFC 2784) on outbound packets (from BIG-IP system to server-pool member).}
	aggregate=${19:# List of pool member definitions to be created, modified or removed.}
	replace_all_with=${20:no}
	provider=${21:# A dict object containing connection details.}

endsnippet

snippet bigip_iapp_service "Manages TCL iApp services on a BIG-IP" b
bigip_iapp_service: >
	name=${1:# The name of the iApp service that you want to deploy.}

	template=${2:# The iApp template from which to instantiate a new service. This template must exist on your BIG-IP before you can successfully create a service.}
	parameters=${3:# A hash of all the required template variables for the iApp template. If your parameters are stored in a file (the more common scenario) it is recommended you use either the C(file) or C(template) lookups to supply the expected parameters.}
	force=${4:no}
	state=${5:#present|absent}
	partition=${6:Common}
	strict_updates=${7:yes}
	traffic_group=${8:# The traffic group for the iApp service. When creating a new service, if this value is not specified, the default of C(/Common/traffic-group-1) will be used.}
	metadata=${9:# Metadata associated with the iApp service.}
	description=${10:# Description of the iApp service.}
	device_group=${11:# The device group for the iApp service.}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_asm_policy_fetch "Exports the asm policy from remote nodes." b
bigip_asm_policy_fetch: >
	name=${1:# The name of the policy exported to create a file on the remote device for downloading.}

	dest=${2:# A directory to save the policy file into.}
	file=${3:# The name of the file to be create on the remote device for downloading.}
	inline=${4:# If C(yes), the ASM policy will be exported C(inline) as a string instead of a file.}
	compact=${5:# If C(yes), only the ASM policy custom settings will be exported.}
	base64=${6:# If C(yes), the returned C(inline) ASM policy content will be Base64 encoded.}
	binary=${7:# If C(yes), the exported ASM policy will be in binary format.}
	force=${8:yes}
	partition=${9:Common}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_persistence_src_addr "Manage source address persistence profiles" b
bigip_profile_persistence_src_addr: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	match_across_services=${3:# When C(yes), specifies that all persistent connections from a client IP address that go to the same virtual IP address also go to the same node.}
	match_across_virtuals=${4:# When C(yes), specifies that all persistent connections from the same client IP address go to the same node.}
	match_across_pools=${5:# When C(yes), specifies that the system can use any pool that contains this persistence record.}
	hash_algorithm=${6:default|carp}
	entry_timeout=${7:# Specifies the duration of the persistence entries.}
	override_connection_limit=${8:# When C(yes), specifies that the system allows you to specify that pool member connection limits will be overridden for persisted clients.}
	partition=${9:Common}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet bigip_device_info "Collect information from F5 BIG-IP devices" b
bigip_device_info: >
	gather_subset=${1:all|monitors|profiles|asm-policy-stats|asm-policies|asm-server-technologies|asm-signature-sets|client-ssl-profiles|devices|device-groups|external-monitors|fasthttp-profiles|fastl4-profiles|gateway-icmp-monitors|gtm-pools|gtm-servers|gtm-wide-ips|gtm-a-pools|gtm-a-wide-ips|gtm-aaaa-pools|gtm-aaaa-wide-ips|gtm-cname-pools|gtm-cname-wide-ips|gtm-mx-pools|gtm-mx-wide-ips|gtm-naptr-pools|gtm-naptr-wide-ips|gtm-srv-pools|gtm-srv-wide-ips|http-monitors|https-monitors|http-profiles|iapp-services|iapplx-packages|icmp-monitors|interfaces|internal-data-groups|irules|ltm-pools|ltm-policies|nodes|oneconnect-profiles|partitions|provision-info|self-ips|server-ssl-profiles|software-volumes|software-images|software-hotfixes|ssl-certs|ssl-keys|system-db|system-info|tcp-monitors|tcp-half-open-monitors|tcp-profiles|traffic-groups|trunks|udp-profiles|users|vcmp-guests|virtual-addresses|virtual-servers|vlans|!all|!monitors|!profiles|!asm-policy-stats|!asm-policies|!asm-server-technologies|!asm-signature-sets|!client-ssl-profiles|!devices|!device-groups|!external-monitors|!fasthttp-profiles|!fastl4-profiles|!gateway-icmp-monitors|!gtm-pools|!gtm-servers|!gtm-wide-ips|!gtm-a-pools|!gtm-a-wide-ips|!gtm-aaaa-pools|!gtm-aaaa-wide-ips|!gtm-cname-pools|!gtm-cname-wide-ips|!gtm-mx-pools|!gtm-mx-wide-ips|!gtm-naptr-pools|!gtm-naptr-wide-ips|!gtm-srv-pools|!gtm-srv-wide-ips|!http-monitors|!https-monitors|!http-profiles|!iapp-services|!iapplx-packages|!icmp-monitors|!interfaces|!internal-data-groups|!irules|!ltm-pools|!ltm-policies|!nodes|!oneconnect-profiles|!partitions|!provision-info|!self-ips|!server-ssl-profiles|!software-volumes|!software-images|!software-hotfixes|!ssl-certs|!ssl-keys|!system-db|!system-info|!tcp-monitors|!tcp-half-open-monitors|!tcp-profiles|!traffic-groups|!trunks|!udp-profiles|!users|!vcmp-guests|!virtual-addresses|!virtual-servers|!vlans}

	provider=${2:# A dict object containing connection details.}

endsnippet

snippet bigip_dns_resolver "Manage DNS resolvers on a BIG-IP" b
bigip_dns_resolver: >
	name=${1:# Specifies the name of the DNS resolver.}

	route_domain=${2:# Specifies the route domain the resolver uses for outbound traffic.}
	cache_size=${3:# Specifies the size of the internal DNS resolver cache.}
	answer_default_zones=${4:# Specifies whether the system answers DNS queries for the default zones localhost, reverse 127.0.0.1 and ::1, and AS112.}
	randomize_query_case=${5:# When C(yes), specifies that the internal DNS resolver randomizes character case in domain name queries issued to the root DNS servers.}
	use_ipv4=${6:# Specifies whether the system can use IPv4 to query backend nameservers.}
	use_ipv6=${7:# Specifies whether the system can use IPv6 to query backend nameservers.}
	use_udp=${8:# Specifies whether the system answers and issues UDP-formatted queries.}
	use_tcp=${9:# Specifies whether the system answers and issues TCP-formatted queries.}
	state=${10:#present|absent}
	partition=${11:Common}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet bigip_policy "Manage general policy configuration on a BIG-IP" b
bigip_policy: >
	name=${1:# The name of the policy to create.}

	description=${2:# The description to attach to the policy.}
	state=${3:#present|absent|draft}
	strategy=${4:first|all|best}
	rules=${5:# Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.}
	partition=${6:Common}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_device_info "Collect information from F5 BIG-IP devices" b
bigip_device_info: >
	gather_subset=${1:all|monitors|profiles|asm-policy-stats|asm-policies|asm-server-technologies|asm-signature-sets|client-ssl-profiles|devices|device-groups|external-monitors|fasthttp-profiles|fastl4-profiles|gateway-icmp-monitors|gtm-pools|gtm-servers|gtm-wide-ips|gtm-a-pools|gtm-a-wide-ips|gtm-aaaa-pools|gtm-aaaa-wide-ips|gtm-cname-pools|gtm-cname-wide-ips|gtm-mx-pools|gtm-mx-wide-ips|gtm-naptr-pools|gtm-naptr-wide-ips|gtm-srv-pools|gtm-srv-wide-ips|http-monitors|https-monitors|http-profiles|iapp-services|iapplx-packages|icmp-monitors|interfaces|internal-data-groups|irules|ltm-pools|ltm-policies|nodes|oneconnect-profiles|partitions|provision-info|self-ips|server-ssl-profiles|software-volumes|software-images|software-hotfixes|ssl-certs|ssl-keys|system-db|system-info|tcp-monitors|tcp-half-open-monitors|tcp-profiles|traffic-groups|trunks|udp-profiles|users|vcmp-guests|virtual-addresses|virtual-servers|vlans|!all|!monitors|!profiles|!asm-policy-stats|!asm-policies|!asm-server-technologies|!asm-signature-sets|!client-ssl-profiles|!devices|!device-groups|!external-monitors|!fasthttp-profiles|!fastl4-profiles|!gateway-icmp-monitors|!gtm-pools|!gtm-servers|!gtm-wide-ips|!gtm-a-pools|!gtm-a-wide-ips|!gtm-aaaa-pools|!gtm-aaaa-wide-ips|!gtm-cname-pools|!gtm-cname-wide-ips|!gtm-mx-pools|!gtm-mx-wide-ips|!gtm-naptr-pools|!gtm-naptr-wide-ips|!gtm-srv-pools|!gtm-srv-wide-ips|!http-monitors|!https-monitors|!http-profiles|!iapp-services|!iapplx-packages|!icmp-monitors|!interfaces|!internal-data-groups|!irules|!ltm-pools|!ltm-policies|!nodes|!oneconnect-profiles|!partitions|!provision-info|!self-ips|!server-ssl-profiles|!software-volumes|!software-images|!software-hotfixes|!ssl-certs|!ssl-keys|!system-db|!system-info|!tcp-monitors|!tcp-half-open-monitors|!tcp-profiles|!traffic-groups|!trunks|!udp-profiles|!users|!vcmp-guests|!virtual-addresses|!virtual-servers|!vlans}

	provider=${2:# A dict object containing connection details.}

endsnippet

snippet bigip_device_group_member "Manages members in a device group" b
bigip_device_group_member: >
	name=${1:# Specifies the name of the device that you want to add to the device group. Often this will be the hostname of the device. This member must be trusted by the device already. Trusting can be done with the C(bigip_device_trust) module and the C(peer_hostname) option to that module.}
	device_group=${2:# The device group that you want to add the member to.}

	state=${3:#present|absent}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigip_device_certificate "Manage self-signed device certificates" b
bigip_device_certificate: >
	days_valid=${1:# Specifies the interval for which the self-signed certificate is valid.}
	transport=${2:#cli}

	cert_name=${3:server.crt}
	key_name=${4:server.key}
	key_size=${5:512|1024|#2048|4096}
	issuer=${6:# Certificate properties, required when generating new certificates.}
	add_to_trusted=${7:no}
	new_cert=${8:no}
	force=${9:no}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_pool "Manages F5 BIG-IP GTM pools" b
bigip_gtm_pool: >
	name=${1:# Name of the GTM pool.}

	state=${2:#present|absent|enabled|disabled}
	preferred_lb_method=${3:round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score}
	alternate_lb_method=${4:round-robin|return-to-dns|none|ratio|topology|static-persistence|global-availability|virtual-server-capacity|packet-rate|drop-packet|fallback-ip|virtual-server-score}
	fallback_lb_method=${5:round-robin|return-to-dns|ratio|topology|static-persistence|global-availability|virtual-server-capacity|least-connections|lowest-round-trip-time|fewest-hops|packet-rate|cpu|completion-rate|quality-of-service|kilobytes-per-second|drop-packet|fallback-ip|virtual-server-score|none}
	fallback_ip=${6:# Specifies the IPv4, or IPv6 address of the server to which the system directs requests when it cannot use one of its pools to do so. Note that the system uses the fallback IP only if you select the C(fallback_ip) load balancing method.}
	type=${7:a|aaaa|cname|mx|naptr|srv}
	partition=${8:Common}
	members=${9:# Members to assign to the pool.}
	monitors=${10:# Specifies the health monitors that the system currently uses to monitor this resource.}
	availability_requirements=${11:# Specifies, if you activate more than one health monitor, the number of health monitors that must receive successful responses in order for the link to be considered available.}
	max_answers_returned=${12:# Specifies the maximum number of available virtual servers that the system lists in a response.}
	ttl=${13:# Specifies the number of seconds that the IP address, once found, is valid.}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet bigip_snmp_trap "Manipulate SNMP trap information on a BIG-IP" b
bigip_snmp_trap: >
	name=${1:# Name of the SNMP configuration endpoint.}

	snmp_version=${2:1|2c}
	community=${3:# Specifies the community name for the trap destination.}
	destination=${4:# Specifies the address for the trap destination. This can be either an IP address or a hostname.}
	port=${5:# Specifies the port for the trap destination.}
	network=${6:other|management|default}
	state=${7:#present|absent}
	partition=${8:Common}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_software_update "Manage the software update settings of a BIG-IP" b
bigip_software_update: >
	auto_check=${1:# Specifies whether to automatically check for updates on the F5 Networks downloads server.}
	auto_phone_home=${2:# Specifies whether to automatically send phone home data to the F5 Networks PhoneHome server.}
	frequency=${3:daily|monthly|weekly}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigip_qkview "Manage qkviews on the device" b
bigip_qkview: >
	dest=${1:# Destination on your local filesystem when you want to save the qkview.}

	filename=${2:localhost.localdomain.qkview}
	asm_request_log=${3:no}
	max_file_size=${4:0}
	complete_information=${5:no}
	exclude_core=${6:no}
	exclude=${7:all|audit|secure|bash_history}
	force=${8:yes}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_tcp_half_open "Manages F5 BIG-IP LTM tcp half-open monitors" b
bigip_monitor_tcp_half_open: >
	name=${1:# Monitor name.}

	parent=${2:/Common/tcp_half_open}
	description=${3:# The description of the monitor.}
	ip=${4:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${5:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified}
	interval=${6:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
	timeout=${7:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
	time_until_up=${8:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
	partition=${9:Common}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet bigiq_regkey_license_assignment "Manage regkey license assignment on BIG-IPs from a BIG-IQ" b
bigiq_regkey_license_assignment: >
	pool=${1:# The registration key pool to use.}
	key=${2:# The registration key that you want to assign from the pool.}

	device=${3:# When C(managed) is C(no), specifies the address, or hostname, where the BIG-IQ can reach the remote device to register.}
	managed=${4:# Whether the specified device is a managed or un-managed device.}
	device_port=${5:443}
	device_username=${6:# The username used to connect to the remote device.}
	device_password=${7:# The password of the C(device_username).}
	state=${8:#present|absent}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_device_connectivity "Manages device IP configuration settings for HA on a BIG-IP" b
bigip_device_connectivity: >
	config_sync_ip=${1:# Local IP address that the system uses for ConfigSync operations.}
	mirror_primary_address=${2:# Specifies the primary IP address for the system to use to mirror connections.}
	mirror_secondary_address=${3:# Specifies the secondary IP address for the system to use to mirror connections.}
	unicast_failover=${4:# Desired addresses to use for failover operations. Options C(address) and C(port) are supported with dictionary structure where C(address) is the local IP address that the system uses for failover operations. Port specifies the port that the system uses for failover operations. If C(port) is not specified, the default value C(1026) will be used.  If you are specifying the (recommended) management IP address, use 'management-ip' in the address field.}
	failover_multicast=${5:# When C(yes), ensures that the Failover Multicast configuration is enabled and if no further multicast configuration is provided, ensures that C(multicast_interface), C(multicast_address) and C(multicast_port) are the defaults specified in each option's description. When C(no), ensures that Failover Multicast configuration is disabled.}
	multicast_interface=${6:# Interface over which the system sends multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(eth0) will be used.}
	multicast_address=${7:# IP address for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(224.0.0.245) will be used.}
	multicast_port=${8:# Port for the system to send multicast messages associated with failover. When C(failover_multicast) is C(yes) and this option is not provided, a default of C(62960) will be used. This value must be between 0 and 65535.}
	cluster_mirroring=${9:between-clusters|within-cluster}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_software_image "Manage software images on a BIG-IP" b
bigip_software_image: >
	force=${1:no}
	state=${2:absent|#present}
	image=${3:# The image to put on the remote device.}
	provider=${4:# A dict object containing connection details.}

endsnippet

snippet bigip_apm_acl "Manage user-defined APM ACLs" b
bigip_apm_acl: >
	name=${1:# Specifies the name of the ACL to manage.}

	description=${2:# User created ACL description.}
	type=${3:static|dynamic}
	acl_order=${4:# Specifies a number that indicates the order of this ACL relative to other ACLs.}
	path_match_case=${5:# Specifies whether alphabetic case is considered when matching paths in an access control entry.}
	entries=${6:# Access control entries that define the ACL matching and its respective behavior.}
	partition=${7:Common}
	state=${8:#present|absent}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_server_ssl "Manages server SSL profiles on a BIG-IP" b
bigip_profile_server_ssl: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:/Common/serverssl}
	ciphers=${3:# Specifies the list of ciphers that the system supports. When creating a new profile, the default cipher list is provided by the parent profile.}
	secure_renegotiation=${4:require|require-strict|request}
	server_name=${5:# Specifies the fully qualified DNS hostname of the server used in Server Name Indication communications. When creating a new profile, the setting is provided by the parent profile.}
	sni_default=${6:# Indicates that the system uses this profile as the default SSL profile when there is no match to the server name, or when the client provides no SNI extension support.}
	sni_require=${7:# Requires that the network peers also provide SNI support, setting only takes effect when C(sni_default) is C(yes).}
	server_certificate=${8:ignore|require}
	certificate=${9:# Specifies the name of the certificate that the system uses for server-side SSL processing.}
	key=${10:# Specifies the file name of the SSL key.}
	chain=${11:# Specifies the certificates-key chain to associate with the SSL profile.}
	passphrase=${12:# Specifies a passphrase used to encrypt the key.}
	update_password=${13:#always|on_create}
	ocsp_profile=${14:# Specifies the name of the OCSP profile for purpose of validating status of server certificate.}
	partition=${15:Common}
	state=${16:#present|absent}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_device_dns "Manage BIG-IP device DNS settings" b
bigip_device_dns: >
	cache=${1:enabled|disabled|enable|disable}
	name_servers=${2:# A list of name servers that the system uses to validate DNS lookups}
	search=${3:# A list of domains that the system searches for local domain lookups, to resolve local host names.}
	ip_version=${4:4|6}
	state=${5:absent|#present}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_imish_config "Manage BIG-IP advanced routing configuration sections" b
bigip_imish_config: >
	route_domain=${1:0}
	lines=${2:# The ordered set of commands that should be configured in the section.}
	parents=${3:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.}
	src=${4:# The I(src) argument provides a path to the configuration file to load into the remote system.}
	before=${5:# The ordered set of commands to push on to the command stack if a change needs to be made.}
	after=${6:# The ordered set of commands to append to the end of the command stack if a change needs to be made.}
	match=${7:#line|strict|exact|none}
	replace=${8:#line|block}
	backup=${9:no}
	running_config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.}
	save_when=${11:always|#never|modified|changed}
	diff_against=${12:#startup|intended|running}
	diff_ignore_lines=${13:# Use this argument to specify one or more lines that should be ignored during the diff.}
	intended_config=${14:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.}
	backup_options=${15:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${16:# A dict object containing connection details.}

endsnippet

snippet bigip_device_ha_group "Manage HA group settings on a BIG-IP system" b
bigip_device_ha_group: >
	name=${1:# Name of the HA group to create/manage.}

	enable=${2:yes}
	description=${3:# User created HA group description.}
	active_bonus=${4:# Specifies the extra value to be added to the active unit's ha score.}
	pools=${5:# Specifies pools to contribute to the ha score.}
	trunks=${6:# Specifies trunks to contribute to the ha score.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_dns "Manage DNS profiles on a BIG-IP" b
bigip_profile_dns: >
	name=${1:# Specifies the name of the DNS profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	enable_dns_express=${3:# Specifies whether the DNS Express engine is enabled.}
	enable_zone_transfer=${4:# Specifies whether the system answers zone transfer requests for a DNS zone created on the system.}
	enable_dnssec=${5:# Specifies whether the system signs responses with DNSSEC keys and replies to DNSSEC specific queries (e.g., DNSKEY query type).}
	enable_gtm=${6:# Specifies whether the system uses Global Traffic Manager to manage the response.}
	process_recursion_desired=${7:# Specifies whether to process client-side DNS packets with Recursion Desired set in the header.}
	use_local_bind=${8:# Specifies whether the system forwards non-wide IP queries to the local BIND server on the BIG-IP system.}
	enable_dns_firewall=${9:# Specifies whether DNS firewall capability is enabled.}
	enable_cache=${10:# Specifies whether the system caches DNS responses.}
	cache_name=${11:# Specifies the user-created cache that the system uses to cache DNS responses.}
	unhandled_query_action=${12:allow|drop|reject|hint|no-error}
	partition=${13:Common}
	state=${14:#present|absent}
	provider=${15:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_address_list "Manage address lists on BIG-IP AFM" b
bigip_firewall_address_list: >
	name=${1:# Specifies the name of the address list.}

	partition=${2:Common}
	description=${3:# Description of the address list}
	geo_locations=${4:# List of geolocations specified by their C(country) and C(region).}
	addresses=${5:# Individual addresses that you want to add to the list. These addresses differ from ranges, and lists of lists such as what can be used in C(address_ranges) and C(address_lists) respectively.}
	address_ranges=${6:# A list of address ranges where the range starts with a port number, is followed by a dash (-) and then a second number.}
	address_lists=${7:# Simple list of existing address lists to add to this list. Address lists can be specified in either their fully qualified name (/Common/foo) or their short name (foo). If a short name is used, the C(partition) argument will automatically be prepended to the short name.}
	fqdns=${8:# A list of fully qualified domain names (FQDNs).}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigiq_device_info "Collect information from F5 BIG-IQ devices" b
bigiq_device_info: >
	gather_subset=${1:all|applications|managed-devices|purchased-pool-licenses|regkey-pools|system-info|vlans|!all|!applications|!managed-devices|!purchased-pool-licenses|!regkey-pools|!system-info|!vlans}

	provider=${2:# A dict object containing connection details.}

endsnippet

snippet bigip_timer_policy "Manage timer policies on a BIG-IP" b
bigip_timer_policy: >
	name=${1:# Specifies the name of the timer policy.}

	description=${2:# Specifies descriptive text that identifies the timer policy.}
	rules=${3:# Rules that you want assigned to the timer policy}
	partition=${4:Common}
	state=${5:#present|absent}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_command "Run TMSH and BASH commands on F5 devices" b
bigip_command: >
	commands=${1:# The commands to send to the remote BIG-IP device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries as expired.}
	transport=${2:#rest|cli}

	wait_for=${3:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails. See examples.}
	match=${4:any|#all}
	retries=${5:10}
	interval=${6:1}
	warn=${7:yes}
	chdir=${8:# Change into this directory before running the command.}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigiq_utility_license_assignment "Manage utility license assignment on BIG-IPs from a BIG-IQ" b
bigiq_utility_license_assignment: >
	key=${1:# The registration key that you want choose an offering from.}

	unit_of_measure=${2:#hourly|daily|monthly|yearly}
	offering=${3:# Name of the license offering to assign to the device.}
	device=${4:# When C(managed) is C(no), specifies the address, or hostname, where the BIG-IQ can reach the remote device to register.}
	managed=${5:# Whether the specified device is a managed or un-managed device.}
	device_port=${6:443}
	device_username=${7:# The username used to connect to the remote device.}
	device_password=${8:# The password of the C(device_username).}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_dns_zone "Manage DNS zones on BIG-IP" b
bigip_dns_zone: >
	name=${1:# Specifies the name of the DNS zone.}

	dns_express=${2:# DNS express related settings.}
	nameservers=${3:# Specifies the DNS nameservers to which the system sends NOTIFY messages.}
	tsig_server_key=${4:# Specifies the TSIG key the system uses to authenticate the back-end DNS authoritative server that sends AXFR zone transfers to the BIG-IP system.}
	state=${5:#present|absent}
	partition=${6:Common}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_message_routing_protocol "Manage generic message parser profile." b
bigip_message_routing_protocol: >
	name=${1:# Specifies the name of the generic parser profile.}

	description=${2:# The user defined description of the generic parser profile.}
	parent=${3:# The parent template of this parser profile. Once this value has been set, it cannot be changed.}
	disable_parser=${4:# When C(yes), the generic message parser will be disabled ignoring all incoming packets and not directly send message data.}
	max_egress_buffer=${5:# Specifies the maximum size of the send buffer in bytes. If the number of bytes in the send buffer for a connection exceeds this value, the generic message protocol will stop receiving outgoing messages from the router until the size of the size of the buffer drops below this setting.}
	max_msg_size=${6:# Specifies the maximum size of a received message. If a message exceeds this size, the connection will be reset.}
	msg_terminator=${7:# The string of characters used to terminate a message. If the message-terminator is not specified, the generic message parser will not separate the input stream into messages.}
	no_response=${8:# When set, matching of responses to requests is disabled.}
	partition=${9:Common}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_monitor_tcp "Manages F5 BIG-IP GTM tcp monitors" b
bigip_gtm_monitor_tcp: >
	name=${1:# Monitor name.}

	parent=${2:/Common/tcp}
	send=${3:# The send string for the monitor call.}
	receive=${4:# The receive string for the monitor call.}
	ip=${5:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${6:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified}
	interval=${7:# The interval specifying how frequently the monitor instance of this template will run.}
	timeout=${8:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.}
	partition=${9:Common}
	state=${10:#present|absent}
	probe_timeout=${11:# Specifies the number of seconds after which the system times out the probe request to the system.}
	ignore_down_response=${12:# Specifies that the monitor allows more than one probe attempt per interval.}
	transparent=${13:# Specifies whether the monitor operates in transparent mode.}
	reverse=${14:# Instructs the system to mark the target resource down when the test is successful. This setting is useful, for example, if the content on your web site home page is dynamic and changes frequently, you may want to set up a reverse ECV service check that looks for the string Error.}
	provider=${15:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_oneconnect "Manage OneConnect profiles on a BIG-IP" b
bigip_profile_oneconnect: >
	name=${1:# Specifies the name of the OneConnect profile.}

	parent=${2:# Specifies the profile from which this profile inherits settings.}
	source_mask=${3:# Specifies a value that the system applies to the source address to determine its eligibility for reuse.}
	description=${4:# Description of the profile.}
	maximum_size=${5:# Specifies the maximum number of connections that the system holds in the connection reuse pool.}
	maximum_age=${6:# Specifies the maximum number of seconds allowed for a connection in the connection reuse pool.}
	maximum_reuse=${7:# Specifies the maximum number of times that a server-side connection can be reused.}
	idle_timeout_override=${8:# Specifies the number of seconds that a connection is idle before the connection flow is eligible for deletion.}
	limit_type=${9:none|idle|strict}
	share_pools=${10:# Indicates that connections may be shared not only within a virtual server, but also among similar virtual servers}
	partition=${11:Common}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_https "Manages F5 BIG-IP LTM https monitors" b
bigip_monitor_https: >
	name=${1:# Monitor name.}

	description=${2:# The description of the monitor.}
	parent=${3:/Common/https}
	send=${4:# The send string for the monitor call. When creating a new monitor, if this value is not provided, the default C(GET /\\r\\n) will be used.}
	receive=${5:# The receive string for the monitor call.}
	receive_disable=${6:# This setting works like C(receive), except that the system marks the node or pool member disabled when its response matches the C(receive_disable) string but not C(receive). To use this setting, you must specify both C(receive_disable) and C(receive).}
	ip=${7:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${8:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	interval=${9:# The interval specifying how frequently the monitor instance of this template will run. If this parameter is not provided when creating a new monitor, then the default value will be 5. This value B(must) be less than the C(timeout) value.}
	timeout=${10:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. If this parameter is not provided when creating a new monitor, then the default value will be 16.}
	time_until_up=${11:# Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. If this parameter is not provided when creating a new monitor, then the default value will be 0.}
	target_username=${12:# Specifies the user name, if the monitored target requires authentication.}
	target_password=${13:# Specifies the password, if the monitored target requires authentication.}
	ssl_profile=${14:# Specifies the SSL profile to use for the HTTPS monitor.}
	up_interval=${15:# Specifies the interval for the system to use to perform the health check when a resource is up.}
	partition=${16:Common}
	state=${17:#present|absent}
	provider=${18:# A dict object containing connection details.}

endsnippet

snippet bigip_device_trust "Manage the trust relationships between BIG-IPs" b
bigip_device_trust: >
	peer_server=${1:# The peer address to connect to and trust for synchronizing configuration. This is typically the management address of the remote device, but may also be a Self IP.}

	peer_hostname=${2:# The hostname that you want to associate with the device. This value will be used to easily distinguish this device in BIG-IP configuration.}
	peer_user=${3:# The API username of the remote peer device that you are trusting. Note that the CLI user cannot be used unless it too has an API account. If this value is not specified, then the value of C(user), or the environment variable C(F5_USER) will be used.}
	peer_password=${4:# The password of the API username of the remote peer device that you are trusting. If this value is not specified, then the value of C(password), or the environment variable C(F5_PASSWORD) will be used.}
	type=${5:#peer|subordinate}
	state=${6:absent|#present}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigiq_regkey_license "Manages licenses in a BIG-IQ registration key pool" b
bigiq_regkey_license: >
	regkey_pool=${1:# The registration key pool that you want to place the license in.}
	license_key=${2:# The license key to put in the pool.}

	description=${3:# Description of the license.}
	accept_eula=${4:# A key that signifies that you accept the F5 EULA for this license.}
	state=${5:absent|#present}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_device_traffic_group "Manages traffic groups on BIG-IP" b
bigip_device_traffic_group: >
	name=${1:# The name of the traffic group.}

	mac_address=${2:# Specifies the floating Media Access Control (MAC) address associated with the floating IP addresses defined for a traffic group.}
	ha_order=${3:# Specifies order in which you would like to assign devices for failover.}
	ha_group=${4:# Specifies a configured C(HA group) to be associated with the traffic group.}
	ha_load_factor=${5:# The value of the load the traffic-group presents the system relative to other traffic groups.}
	auto_failback=${6:# Specifies whether the traffic group fails back to the initial device specified in C(ha_order).}
	auto_failback_time=${7:# Specifies the number of seconds the system delays before failing back to the initial device specified in C(ha_order).}
	partition=${8:Common}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_snmp "Manipulate general SNMP settings on a BIG-IP" b
bigip_snmp: >
	allowed_addresses=${1:# Configures the IP addresses of the SNMP clients from which the snmpd daemon accepts requests.}
	contact=${2:# Specifies the name of the person who administers the SNMP service for this system.}
	agent_status_traps=${3:enabled|disabled}
	agent_authentication_traps=${4:enabled|disabled}
	device_warning_traps=${5:enabled|disabled}
	location=${6:# Specifies the description of this system's physical location.}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet bigip_firewall_policy "Manage AFM security firewall policies on a BIG-IP" b
bigip_firewall_policy: >
	name=${1:# The name of the policy to create.}

	description=${2:# The description to attach to the policy.}
	state=${3:#present|absent}
	rules=${4:# Specifies a list of rules that you want associated with this policy. The order of this list is the order they will be evaluated by BIG-IP. If the specified rules do not exist (for example when creating a new policy) then they will be created.}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigip_asm_policy_signature_set "Manages Signature Sets on ASM policy" b
bigip_asm_policy_signature_set: >
	name=${1:# Specifies the name of the signature sets to apply on or remove from the ASM policy.}
	policy_name=${2:# Specifies the name of an existing ASM policy to add or remove signature sets.}

	alarm=${3:# Specifies if the security policy logs the request data in the Statistics screen, when a request matches a signature that is included in the signature set.}
	block=${4:# Effective when the security policy`s enforcement mode is Blocking.}
	learn=${5:# Specifies if the security policy learns all requests that match a signature that is included in the signature set.}
	state=${6:#present|absent}
	partition=${7:Common}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_trunk "Manage trunks on a BIG-IP" b
bigip_trunk: >
	name=${1:# Specifies the name of the trunk.}

	interfaces=${2:# The interfaces that are part of the trunk.}
	description=${3:# Description of the trunk.}
	link_selection_policy=${4:auto|maximum-bandwidth}
	frame_distribution_hash=${5:destination-mac|source-destination-ip|source-destination-mac}
	lacp_enabled=${6:# When C(yes), specifies that the system supports the link aggregation control protocol (LACP), which monitors the trunk by exchanging control packets over the member links to determine the health of the links.}
	lacp_mode=${7:active|passive}
	lacp_timeout=${8:long|short}
	qinq_ethertype=${9:# Specifies the ether-type value used for the packets handled on this trunk when it is a member in a QinQ vlan.}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet bigip_profile_http "Manage HTTP profiles on a BIG-IP" b
bigip_profile_http: >
	name=${1:# Specifies the name of the profile.}

	parent=${2:/Common/http}
	description=${3:# Description of the profile.}
	proxy_type=${4:reverse|transparent|explicit}
	dns_resolver=${5:# Specifies the name of a configured DNS resolver, this option is mandatory when C(proxy_type) is set to C(explicit).}
	insert_xforwarded_for=${6:# When specified system inserts an X-Forwarded-For header in an HTTP request with the client IP address, to use with connection pooling.}
	redirect_rewrite=${7:none|all|matching|nodes}
	encrypt_cookies=${8:# Cookie names for the system to encrypt.}
	encrypt_cookie_secret=${9:# Passphrase for cookie encryption.}
	update_password=${10:#always|on_create}
	header_erase=${11:# The name of a header, in an HTTP request, which the system removes from request.}
	header_insert=${12:# A string that the system inserts as a header in an HTTP request.}
	server_agent_name=${13:# Specifies the string used as the server name in traffic generated by BIG-IP.}
	include_subdomains=${14:# When set to C(yes), applies the HSTS policy to the HSTS host and its sub-domains.}
	maximum_age=${15:# Specifies the maximum length of time, in seconds, that HSTS functionality requests that clients only use HTTPS to connect to the current host and any sub-domains of the current host's domain name.}
	hsts_mode=${16:# When set to C(yes), enables the HSTS settings.}
	accept_xff=${17:# Enables or disables trusting the client IP address, and statistics from the client IP address, based on the request's XFF (X-forwarded-for) headers, if they exist.}
	xff_alternative_names=${18:# Specifies alternative XFF headers instead of the default X-forwarded-for header.}
	fallback_host=${19:# Specifies an HTTP fallback host.}
	fallback_status_codes=${20:# Specifies one or more HTTP error codes from server responses that should trigger a redirection to the fallback host.}
	oneconnect_transformations=${21:# Enables the system to perform HTTP header transformations for the purpose of keeping server-side connections open. This feature requires configuration of a OneConnect profile.}
	request_chunking=${22:rechunk|selective|preserve}
	response_chunking=${23:rechunk|selective|preserve}
	enforcement=${24:# Specifies protocol enforcement settings for the HTTP profile.}
	sflow=${25:# Specifies sFlow settings for the HTTP profile.}
	partition=${26:Common}
	state=${27:#present|absent}
	provider=${28:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_monitor_tcp_half_open "Manages F5 BIG-IP GTM tcp half-open monitors" b
bigip_gtm_monitor_tcp_half_open: >
	name=${1:# Monitor name.}

	parent=${2:/Common/tcp_half_open}
	ip=${3:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${4:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified}
	interval=${5:# Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.}
	timeout=${6:# Specifies the number of seconds the target has in which to respond to the monitor request.}
	probe_interval=${7:# Specifies the number of seconds the big3d process waits before sending out a subsequent probe attempt when a probe fails and multiple probe attempts have been requested.}
	probe_timeout=${8:# Specifies the number of seconds after which the system times out the probe request to the system.}
	probe_attempts=${9:# Specifies the number of times the system attempts to probe the host server, after which the system considers the host server down or unavailable.}
	ignore_down_response=${10:# Specifies that the monitor allows more than one probe attempt per interval.}
	transparent=${11:# Specifies whether the monitor operates in transparent mode.}
	partition=${12:Common}
	state=${13:#present|absent}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet bigip_config "Manage BIG-IP configuration sections" b
bigip_config: >
	save=${1:yes}
	reset=${2:no}
	merge_content=${3:# Loads the specified configuration that you want to merge into the running configuration. This is equivalent to using the C(tmsh) command C(load sys config from-terminal merge).}
	verify=${4:no}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_device_sshd "Manage the SSHD settings of a BIG-IP" b
bigip_device_sshd: >
	allow=${1:# Specifies, if you have enabled SSH access, the IP address or address range for other systems that can use SSH to communicate with this system.}
	banner=${2:enabled|disabled}
	banner_text=${3:# Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.}
	inactivity_timeout=${4:# Specifies the number of seconds before inactivity causes an SSH session to log out.}
	log_level=${5:debug|debug1|debug2|debug3|error|fatal|info|quiet|verbose}
	login=${6:enabled|disabled}
	port=${7:# Port that you want the SSH daemon to run on.}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet bigip_gtm_monitor_firepass "Manages F5 BIG-IP GTM FirePass monitors" b
bigip_gtm_monitor_firepass: >
	name=${1:# Monitor name.}

	parent=${2:/Common/firepass_gtm}
	ip=${3:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${4:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'. Note that if specifying an IP address, a value between 1 and 65535 must be specified.}
	interval=${5:# The interval specifying how frequently the monitor instance of this template will run.}
	timeout=${6:# The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second.}
	partition=${7:Common}
	state=${8:#present|absent}
	probe_timeout=${9:# Specifies the number of seconds after which the system times out the probe request to the system.}
	ignore_down_response=${10:# Specifies that the monitor allows more than one probe attempt per interval.}
	target_username=${11:# Specifies the user name, if the monitored target requires authentication.}
	target_password=${12:# Specifies the password, if the monitored target requires authentication.}
	update_password=${13:#always|on_create}
	cipher_list=${14:# Specifies the list of ciphers for this monitor.}
	max_load_average=${15:# Specifies the number that the monitor uses to mark the Secure Access Manager system up or down.}
	concurrency_limit=${16:# Specifies the maximum percentage of licensed connections currently in use under which the monitor marks the Secure Access Manager system up.}
	provider=${17:# A dict object containing connection details.}

endsnippet

snippet bigip_smtp "Manages SMTP settings on the BIG-IP" b
bigip_smtp: >
	name=${1:# Specifies the name of the SMTP server configuration.}

	partition=${2:Common}
	smtp_server=${3:# SMTP server host name in the format of a fully qualified domain name.}
	smtp_server_port=${4:# Specifies the SMTP port number.}
	local_host_name=${5:# Host name used in SMTP headers in the format of a fully qualified domain name. This setting does not refer to the BIG-IP system's hostname.}
	from_address=${6:# Email address that the email is being sent from. This is the "Reply-to" address that the recipient sees.}
	encryption=${7:none|ssl|tls}
	authentication=${8:# Credentials can be set on an SMTP server's configuration even if that authentication is not used (think staging configs or emergency changes). This parameter acts as a switch to make the specified C(smtp_server_username) and C(smtp_server_password) parameters active or not.}
	smtp_server_username=${9:# User name that the SMTP server requires when validating a user.}
	smtp_server_password=${10:# Password that the SMTP server requires when validating a user.}
	state=${11:#present|absent}
	update_password=${12:#always|on_create}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet bigip_device_group "Manage device groups on a BIG-IP" b
bigip_device_group: >
	name=${1:# Specifies the name of the device group.}

	type=${2:sync-failover|sync-only}
	description=${3:# Description of the device group.}
	auto_sync=${4:# Indicates whether configuration synchronization occurs manually or automatically.}
	save_on_auto_sync=${5:# When performing an auto-sync, specifies whether the configuration will be saved or not.}
	full_sync=${6:# Specifies whether the system synchronizes the entire configuration during synchronization operations.}
	max_incremental_sync_size=${7:# Specifies the size of the changes cache for incremental sync.}
	state=${8:#present|absent}
	network_failover=${9:# Indicates whether failover occurs over the network or is hard-wired.}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_partition "Manage BIG-IP partitions" b
bigip_partition: >
	name=${1:# Name of the partition}

	description=${2:# The description to attach to the Partition.}
	route_domain=${3:# The default Route Domain to assign to the Partition. If no route domain is specified, then the default route domain for the system (typically zero) will be used only when creating a new partition.}
	state=${4:#present|absent}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_asm_policy_server_technology "Manages Server Technology on ASM policy" b
bigip_asm_policy_server_technology: >
	name=${1:jQuery|Java Servlets/JSP|ASP|WebDAV|IIS|Front Page Server Extensions (FPSE)|ASP.NET|Microsoft Windows|Unix/Linux|Macromedia ColdFusion|WordPress|Apache Tomcat|Apache/NCSA HTTP Server|Outlook Web Access|PHP|Microsoft SQL Server|Oracle|MySQL|Lotus Domino|BEA Systems WebLogic Server|Macromedia JRun|Novell|Cisco|SSI (Server Side Includes)|Proxy Servers|CGI|Sybase/ASE|IBM DB2|PostgreSQL|XML|Apache Struts|Elasticsearch|JBoss|Citrix|Node.js|Django|MongoDB|Ruby|JavaServer Faces (JSF)|Joomla|Jetty}
	policy_name=${2:# Specifies the name of an existing ASM policy to add or remove server technology.}

	state=${3:#present|absent}
	partition=${4:Common}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet bigip_asm_policy_manage "Manage BIG-IP ASM policies" b
bigip_asm_policy_manage: >
	name=${1:# The ASM policy to manage or create.}

	active=${2:no}
	state=${3:#present|absent}
	template=${4:ActiveSync v1.0 v2.0 (http)|ActiveSync v1.0 v2.0 (https)|Comprehensive|Drupal|Fundamental|Joomla|LotusDomino 6.5 (http)|LotusDomino 6.5 (https)|OWA Exchange 2003 (http)|OWA Exchange 2003 (https)|OWA Exchange 2003 with ActiveSync (http)|OWA Exchange 2003 with ActiveSync (https)|OWA Exchange 2007 (http)|OWA Exchange 2007 (https)|OWA Exchange 2007 with ActiveSync (http)|OWA Exchange 2007 with ActiveSync (https)|OWA Exchange 2010 (http)|OWA Exchange 2010 (https)|Oracle 10g Portal (http)|Oracle 10g Portal (https)|Oracle Applications 11i (http)|Oracle Applications 11i (https)|PeopleSoft Portal 9 (http)|PeopleSoft Portal 9 (https)|Rapid Deployment Policy|SAP NetWeaver 7 (http)|SAP NetWeaver 7 (https)|SharePoint 2003 (http)|SharePoint 2003 (https)|SharePoint 2007 (http)|SharePoint 2007 (https)|SharePoint 2010 (http)|SharePoint 2010 (https)|Vulnerability Assessment Baseline|Wordpress}
	partition=${5:Common}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet bigiq_application_http "Manages BIG-IQ HTTP applications" b
bigiq_application_http: >
	name=${1:# Name of the new application.}

	description=${2:# Description of the application.}
	servers=${3:# A list of servers that the application is hosted on.}
	inbound_virtual=${4:# Settings to configure the virtual which will receive the inbound connection.}
	service_environment=${5:# Specifies the name of service environment that the application will be deployed to.}
	add_analytics=${6:no}
	state=${7:absent|#present}
	wait=${8:yes}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet bigip_sys_global "Manage BIG-IP global settings" b
bigip_sys_global: >
	banner_text=${1:# Specifies the text to present in the advisory banner.}
	console_timeout=${2:# Specifies the number of seconds of inactivity before the system logs off a user that is logged on.}
	gui_setup=${3:# C(yes) or C(no) the Setup utility in the browser-based Configuration utility.}
	lcd_display=${4:# Specifies, when C(yes), that the system menu displays on the LCD screen on the front of the unit. This setting has no effect when used on the VE platform.}
	mgmt_dhcp=${5:# Specifies whether or not to enable DHCP client on the management interface}
	net_reboot=${6:# Specifies, when C(yes), that the next time you reboot the system, the system boots to an ISO image on the network, rather than an internal media drive.}
	quiet_boot=${7:# Specifies, when C(yes), that the system suppresses informational text on the console during the boot cycle. When C(no), the system presents messages and informational text on the console during the boot cycle.}
	security_banner=${8:# Specifies whether the system displays an advisory message on the login screen.}
	state=${9:#present}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet bigip_monitor_ldap "Manages BIG-IP LDAP monitors" b
bigip_monitor_ldap: >
	name=${1:# Monitor name.}

	description=${2:# Specifies descriptive text that identifies the monitor.}
	parent=${3:/Common/ldap}
	ip=${4:# IP address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	port=${5:# Port address part of the IP/port definition. If this parameter is not provided when creating a new monitor, then the default value will be '*'.}
	interval=${6:# Specifies, in seconds, the frequency at which the system issues the monitor check when either the resource is down or the status of the resource is unknown.}
	timeout=${7:# Specifies the number of seconds the target has in which to respond to the monitor request.}
	time_until_up=${8:# Specifies the number of seconds to wait after a resource first responds correctly to the monitor before setting the resource to 'up'.}
	up_interval=${9:# Specifies the interval for the system to use to perform the health check when a resource is up.}
	manual_resume=${10:# Specifies whether the system automatically changes the status of a resource to B(enabled) at the next successful monitor check.}
	target_username=${11:# Specifies the user name, if the monitored target requires authentication.}
	target_password=${12:# Specifies the password, if the monitored target requires authentication.}
	base=${13:# Specifies the location in the LDAP tree from which the monitor starts the health check.}
	filter=${14:# Specifies an LDAP key for which the monitor searches.}
	security=${15:none|ssl|tls}
	mandatory_attributes=${16:# Specifies whether the target must include attributes in its response to be considered up.}
	chase_referrals=${17:# Specifies whether, upon receipt of an LDAP referral entry, the target follows (or chases) that referral.}
	debug=${18:# Specifies whether the monitor sends error messages and additional information to a log file created and labeled specifically for this monitor.}
	update_password=${19:#always|on_create}
	partition=${20:Common}
	state=${21:#present|absent}
	provider=${22:# A dict object containing connection details.}

endsnippet

snippet nxos_udld "Manages UDLD global configuration params." b
nxos_udld: >
	aggressive=${1:enabled|disabled}
	msg_time=${2:# Message time in seconds for UDLD packets or keyword 'default'.}
	reset=${3:no}
	state=${4:#present|absent}
	provider=${5:# B(Deprecated)}

endsnippet

snippet nxos_igmp "Manages IGMP global configuration." b
nxos_igmp: >
	flush_routes=${1:# Removes routes when the IGMP process is restarted. By default, routes are not flushed.}
	enforce_rtr_alert=${2:# Enables or disables the enforce router alert option check for IGMPv2 and IGMPv3 packets.}
	restart=${3:# Restarts the igmp process (using an exec config command).}
	state=${4:#present|default}
	provider=${5:# B(Deprecated)}

endsnippet

snippet nxos_overlay_global "Configures anycast gateway MAC of the switch." b
nxos_overlay_global: >
	anycast_gateway_mac=${1:# Anycast gateway mac of the switch.}

	provider=${2:# B(Deprecated)}

endsnippet

snippet nxos_ntp_auth "Manages NTP authentication." b
nxos_ntp_auth: >
	key_id=${1:# Authentication key identifier (numeric).}
	md5string=${2:# MD5 String.}
	auth_type=${3:#text|encrypt}
	trusted_key=${4:#false|true}
	authentication=${5:on|off}
	state=${6:#present|absent}
	provider=${7:# B(Deprecated)}

endsnippet

snippet nxos_install_os "Set boot options like boot, kickstart image and issu." b
nxos_install_os: >
	system_image_file=${1:# Name of the system (or combined) image file on flash.}

	kickstart_image_file=${2:# Name of the kickstart image file on flash. (Not required on all Nexus platforms)}
	issu=${3:required|desired|yes|#no}
	provider=${4:# B(Deprecated)}

endsnippet

snippet nxos_acl_interface "Manages applying ACLs to interfaces." b
nxos_acl_interface: >
	name=${1:# Case sensitive name of the access list (ACL).}
	interface=${2:# Full name of interface, e.g. I(Ethernet1/1).}
	direction=${3:ingress|egress}

	state=${4:#present|absent}
	provider=${5:# B(Deprecated)}

endsnippet

snippet nxos_igmp_snooping "Manages IGMP snooping global configuration." b
nxos_igmp_snooping: >
	snooping=${1:# Enables/disables IGMP snooping on the switch.}
	group_timeout=${2:# Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, I(never) and I(default).}
	link_local_grp_supp=${3:# Global link-local groups suppression.}
	report_supp=${4:# Global IGMPv1/IGMPv2 Report Suppression.}
	v3_report_supp=${5:# Global IGMPv3 Report Suppression and Proxy Reporting.}
	state=${6:#present|default}
	provider=${7:# B(Deprecated)}

endsnippet

snippet nxos_igmp_interface "Manages IGMP interface configuration." b
nxos_igmp_interface: >
	interface=${1:# The full interface name for IGMP configuration. e.g. I(Ethernet1/2).}

	version=${2:2|3|default}
	startup_query_interval=${3:# Query interval used when the IGMP process starts up. The range is from 1 to 18000 or keyword 'default'. The default is 31.}
	startup_query_count=${4:# Query count used when the IGMP process starts up. The range is from 1 to 10 or keyword 'default'. The default is 2.}
	robustness=${5:# Sets the robustness variable. Values can range from 1 to 7 or keyword 'default'. The default is 2.}
	querier_timeout=${6:# Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds or keyword 'default'. The default is 255 seconds.}
	query_mrt=${7:# Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds or keyword 'default'. The default is 10 seconds.}
	query_interval=${8:# Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds or keyword 'default'. The default is 125 seconds.}
	last_member_qrt=${9:# Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds or keyword 'default'. The default is 1 second.}
	last_member_query_count=${10:# Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5 or keyword 'default'. The default is 2.}
	group_timeout=${11:# Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds or keyword 'default'. The default is 260 seconds.}
	report_llg=${12:# Configures report-link-local-groups. Enables sending reports for groups in 224.0.0.0/24. Reports are always sent for nonlink local groups. By default, reports are not sent for link local groups.}
	immediate_leave=${13:# Enables the device to remove the group entry from the multicast routing table immediately upon receiving a leave message for the group. Use this command to minimize the leave latency of IGMPv2 group memberships on a given IGMP interface because the device does not send group-specific queries. The default is disabled.}
	oif_routemap=${14:# Configure a routemap for static outgoing interface (OIF) or keyword 'default'.}
	oif_prefix=${15:# This argument is deprecated, please use oif_ps instead. Configure a prefix for static outgoing interface (OIF).}
	oif_source=${16:# This argument is deprecated, please use oif_ps instead. Configure a source for static outgoing interface (OIF).}
	oif_ps=${17:# Configure prefixes and sources for static outgoing interface (OIF). This is a list of dict where each dict has source and prefix defined or just prefix if source is not needed. The specified values will be configured on the device and if any previous prefix/sources exist, they will be removed. Keyword 'default' is also accepted which removes all existing prefix/sources.}
	restart=${18:no}
	state=${19:#present|absent|default}
	provider=${20:# B(Deprecated)}

endsnippet

snippet nxos_acl "Manages access list entries for ACLs." b
nxos_acl: >
	name=${1:# Case sensitive name of the access list (ACL).}

	seq=${2:# Sequence number of the entry (ACE).}
	action=${3:permit|deny|remark}
	remark=${4:# If action is set to remark, this is the description.}
	proto=${5:# Port number or protocol (as supported by the switch).}
	src=${6:# Source ip and mask using IP/MASK notation and supports keyword 'any'.}
	src_port_op=${7:any|eq|gt|lt|neq|range}
	src_port1=${8:# Port/protocol and also first (lower) port when using range operand.}
	src_port2=${9:# Second (end) port when using range operand.}
	dest=${10:# Destination ip and mask using IP/MASK notation and supports the keyword 'any'.}
	dest_port_op=${11:any|eq|gt|lt|neq|range}
	dest_port1=${12:# Port/protocol and also first (lower) port when using range operand.}
	dest_port2=${13:# Second (end) port when using range operand.}
	log=${14:enable}
	urg=${15:enable}
	ack=${16:enable}
	psh=${17:enable}
	rst=${18:enable}
	syn=${19:enable}
	fin=${20:enable}
	established=${21:enable}
	fragments=${22:enable}
	time_range=${23:# Name of time-range to apply.}
	precedence=${24:critical|flash|flash-override|immediate|internet|network|priority|routine}
	dscp=${25:af11|af12|af13|af21|af22|af23|af31|af32|af33|af41|af42|af43|cs1|cs2|cs3|cs4|cs5|cs6|cs7|default|ef}
	state=${26:#present|absent|delete_acl}
	provider=${27:# B(Deprecated)}

endsnippet

snippet nxos_aaa_server_host "Manages AAA server host-specific configuration." b
nxos_aaa_server_host: >
	server_type=${1:radius|tacacs}
	address=${2:# Address or name of the radius or tacacs host.}

	key=${3:# Shared secret for the specified host or keyword 'default'.}
	encrypt_type=${4:0|7}
	host_timeout=${5:# Timeout period for specified host, in seconds or keyword 'default. Range is 1-60.}
	auth_port=${6:# Alternate UDP port for RADIUS authentication or keyword 'default'.}
	acct_port=${7:# Alternate UDP port for RADIUS accounting or keyword 'default'.}
	tacacs_port=${8:# Alternate TCP port TACACS Server or keyword 'default'.}
	state=${9:#present|absent}
	provider=${10:# B(Deprecated)}

endsnippet

snippet nxos_l3_interfaces "Manages Layer-3 Interfaces attributes of NX-OS Interfaces" b
nxos_l3_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet nxos_feature "Manage features in NX-OS switches." b
nxos_feature: >
	feature=${1:# Name of feature.}

	state=${2:#enabled|disabled}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_ospf_vrf "Manages a VRF for an OSPF router." b
nxos_ospf_vrf: >
	ospf=${1:# Name of the OSPF instance.}

	vrf=${2:default}
	router_id=${3:# Router Identifier (ID) of the OSPF router VRF instance.}
	default_metric=${4:# Specify the default Metric value. Valid values are an integer or the keyword 'default'.}
	log_adjacency=${5:log|detail|default}
	timer_throttle_lsa_start=${6:# Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
	timer_throttle_lsa_hold=${7:# Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
	timer_throttle_lsa_max=${8:# Specify the max interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.}
	timer_throttle_spf_start=${9:# Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.}
	timer_throttle_spf_hold=${10:# Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.}
	timer_throttle_spf_max=${11:# Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.}
	auto_cost=${12:# Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.}
	bfd=${13:enable|disable}
	passive_interface=${14:# Setting to C(yes) will suppress routing update on interface.}
	state=${15:#present|absent}
	provider=${16:# B(Deprecated)}

endsnippet

snippet nxos_lacp_interfaces "Manage Link Aggregation Control Protocol (LACP) attributes of interfaces on Cisco NX-OS devices." b
nxos_lacp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet nxos_vtp_password "Manages VTP password configuration." b
nxos_vtp_password: >
	vtp_password=${1:# VTP password}
	state=${2:#present|absent}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_reboot "Reboot a network device." b
nxos_reboot: >
	confirm=${1:no}
	provider=${2:# B(Deprecated)}

endsnippet

snippet nxos_lldp_global "Configure and manage Link Layer Discovery Protocol(LLDP) attributes on NX-OS platforms." b
nxos_lldp_global: >
	config=${1:# A list of link layer discovery configurations}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet nxos_bgp_neighbor "Manages BGP neighbors configurations." b
nxos_bgp_neighbor: >
	asn=${1:# BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.}
	neighbor=${2:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}

	vrf=${3:default}
	description=${4:# Description of the neighbor.}
	bfd=${5:enable|disable}
	connected_check=${6:# Configure whether or not to check for directly connected peer.}
	capability_negotiation=${7:# Configure whether or not to negotiate capability with this neighbor.}
	dynamic_capability=${8:# Configure whether or not to enable dynamic capability.}
	ebgp_multihop=${9:# Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.}
	local_as=${10:# Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.}
	log_neighbor_changes=${11:enable|disable|inherit}
	low_memory_exempt=${12:# Specify whether or not to shut down this neighbor under memory pressure.}
	maximum_peers=${13:# Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit. Note that this parameter is accepted only on neighbors with address/prefix.}
	pwd=${14:# Specify the password for neighbor. Valid value is string.}
	pwd_type=${15:3des|cisco_type_7|default}
	remote_as=${16:# Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.}
	remove_private_as=${17:enable|disable|all|replace-as}
	shutdown=${18:# Configure to administratively shutdown this neighbor.}
	suppress_4_byte_as=${19:# Configure to suppress 4-byte AS Capability.}
	timers_keepalive=${20:# Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.}
	timers_holdtime=${21:# Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.}
	transport_passive_only=${22:# Specify whether or not to only allow passive connection setup. Valid values are 'true', 'false', and 'default', which defaults to 'false'. This property can only be configured when the neighbor is in 'ip' address format without prefix length.}
	update_source=${23:# Specify source interface of BGP session and updates.}
	state=${24:#present|absent}
	provider=${25:# B(Deprecated)}

endsnippet

snippet nxos_rpm "Install patch or feature rpms on Cisco NX-OS devices." b
nxos_rpm: >
	pkg=${1:# Name of the RPM package.}

	file_system=${2:bootflash}
	aggregate=${3:# List of RPM/patch definitions.}
	state=${4:#present|absent}
	provider=${5:# B(Deprecated)}

endsnippet

snippet nxos_evpn_vni "Manages Cisco EVPN VXLAN Network Identifier (VNI)." b
nxos_evpn_vni: >
	vni=${1:# The EVPN VXLAN Network Identifier.}
	route_distinguisher=${2:# The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.}

	route_target_both=${3:# Enables/Disables route-target settings for both import and export target communities using a single property.}
	route_target_import=${4:# Sets the route-target 'import' extended communities.}
	route_target_export=${5:# Sets the route-target 'export' extended communities.}
	state=${6:#present|absent}
	provider=${7:# B(Deprecated)}

endsnippet

snippet nxos_user "Manage the collection of local users on Nexus devices" b
nxos_user: >
	aggregate=${1:# The set of username objects to be configured on the remote Cisco Nexus device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(name) argument.}
	name=${2:# The username to be configured on the remote Cisco Nexus device.  This argument accepts a string value and is mutually exclusive with the C(aggregate) argument.}
	configured_password=${3:# The password to be configured on the network device. The password needs to be provided in cleartext and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
	update_password=${4:on_create|#always}
	role=${5:# The C(role) argument configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.}
	sshkey=${6:# The C(sshkey) argument defines the SSH public key to configure for the username.  This argument accepts a valid SSH key value.}
	purge=${7:no}
	state=${8:#present|absent}
	provider=${9:# B(Deprecated)}

endsnippet

snippet nxos_gir "Trigger a graceful removal or insertion (GIR) of the switch." b
nxos_gir: >
	state=${1:#present|absent}

	system_mode_maintenance=${2:# When C(system_mode_maintenance=true) it puts all enabled protocols in maintenance mode (using the isolate command). When C(system_mode_maintenance=false) it puts all enabled protocols in normal mode (using the no isolate command).}
	system_mode_maintenance_dont_generate_profile=${3:# When C(system_mode_maintenance_dont_generate_profile=true) it prevents the dynamic searching of enabled protocols and executes commands configured in a maintenance-mode profile. Use this option if you want the system to use a maintenance-mode profile that you have created. When C(system_mode_maintenance_dont_generate_profile=false) it prevents the dynamic searching of enabled protocols and executes commands configured in a normal-mode profile. Use this option if you want the system to use a normal-mode profile that you have created.}
	system_mode_maintenance_timeout=${4:# Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.}
	system_mode_maintenance_shutdown=${5:# Shuts down all protocols, vPC domains, and interfaces except the management interface (using the shutdown command). This option is disruptive while C(system_mode_maintenance) (which uses the isolate command) is not.}
	system_mode_maintenance_on_reload_reset_reason=${6:hw_error|svc_failure|kern_failure|wdog_timeout|fatal_error|lc_failure|match_any|manual_reload|any_other|maintenance}
	provider=${7:# B(Deprecated)}

endsnippet

snippet nxos_logging "Manage logging on network devices" b
nxos_logging: >
	dest=${1:console|logfile|module|monitor|server}
	remote_server=${2:# Hostname or IP Address for remote logging (when dest is 'server').}
	use_vrf=${3:# VRF to be used while configuring remote logging (when dest is 'server').}
	interface=${4:# Interface to be used while configuring source-interface for logging (e.g., 'Ethernet1/2', 'mgmt0')}
	name=${5:# If value of C(dest) is I(logfile) it indicates file-name.}
	facility=${6:# Facility name for logging.}
	dest_level=${7:# Set logging severity levels.}
	facility_level=${8:# Set logging severity levels for facility based log messages.}
	aggregate=${9:# L}
	state=${10:#present|absent}
	event=${11:link-enable|link-default|trunk-enable|trunk-default}
	interface_message=${12:add-interface-description}
	file_size=${13:# Set logfile size}
	facility_link_status=${14:link-down-notif|link-down-error|link-up-notif|link-up-error}
	timestamp=${15:microseconds|milliseconds|seconds}
	purge=${16:no}
	provider=${17:# B(Deprecated)}

endsnippet

snippet nxos_interfaces "Manages interface attributes of NX-OS Interfaces" b
nxos_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet nxos_interface_ospf "Manages configuration of an OSPF interface instance." b
nxos_interface_ospf: >
	interface=${1:# Name of this cisco_interface resource. Valid value is a string.}
	ospf=${2:# Name of the ospf instance.}
	area=${3:# Ospf area associated with this cisco_interface_ospf instance. Valid values are a string, formatted as an IP address (i.e. "0.0.0.0") or as an integer.}

	bfd=${4:enable|disable|default}
	cost=${5:# The cost associated with this cisco_interface_ospf instance.}
	hello_interval=${6:# Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.}
	dead_interval=${7:# Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.}
	passive_interface=${8:# Enable or disable passive-interface state on this interface. true - (enable) Prevent OSPF from establishing an adjacency or sending routing updates on this interface. false - (disable) Override global 'passive-interface default' for this interface.}
	network=${9:point-to-point|broadcast}
	message_digest=${10:# Enables or disables the usage of message digest authentication.}
	message_digest_key_id=${11:# Md5 authentication key-id associated with the ospf instance. If this is present, message_digest_encryption_type, message_digest_algorithm_type and message_digest_password are mandatory. Valid value is an integer and 'default'.}
	message_digest_algorithm_type=${12:md5|default}
	message_digest_encryption_type=${13:cisco_type_7|3des|default}
	message_digest_password=${14:# Specifies the message_digest password. Valid value is a string.}
	state=${15:#present|absent}
	provider=${16:# B(Deprecated)}

endsnippet

snippet nxos_telemetry "Telemetry Monitoring Service (TMS) configuration" b
nxos_telemetry: >
	config=${1:# T}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet nxos_aaa_server "Manages AAA server global configuration." b
nxos_aaa_server: >
	server_type=${1:radius|tacacs}

	global_key=${2:# Global AAA shared secret or keyword 'default'.}
	encrypt_type=${3:0|7}
	deadtime=${4:# Duration for which a non-reachable AAA server is skipped, in minutes or keyword 'default. Range is 1-1440. Device default is 0.}
	server_timeout=${5:# Global AAA server timeout period, in seconds or keyword 'default. Range is 1-60. Device default is 5.}
	directed_request=${6:enabled|disabled}
	state=${7:#present|default}
	provider=${8:# B(Deprecated)}

endsnippet

snippet nxos_rollback "Set a checkpoint or rollback to a checkpoint." b
nxos_rollback: >
	checkpoint_file=${1:# Name of checkpoint file to create. Mutually exclusive with rollback_to.}
	rollback_to=${2:# Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_vlans "Create VLAN and manage VLAN configurations on NX-OS Interfaces" b
nxos_vlans: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet nxos_pim "Manages configuration of a PIM instance." b
nxos_pim: >
	ssm_range=${1:# Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword C(none) or keyword C(default). C(none) removes all SSM group ranges. C(default) will set ssm_range to the default multicast address. If you set multicast address, please ensure that it is not the same as the C(default), otherwise use the C(default) option.}

	bfd=${2:enable|disable}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_file_copy "Copy a file to a remote NXOS device." b
nxos_file_copy: >
	local_file=${1:# When (file_pull is False) this is the path to the local file on the Ansible controller. The local directory must exist.}
	remote_file=${2:# When (file_pull is False) this is the remote file path on the NXOS device. If omitted, the name of the local file will be used. The remote directory must exist.}
	file_system=${3:bootflash:}
	connect_ssh_port=${4:22}
	file_pull=${5:no}
	file_pull_compact=${6:no}
	file_pull_kstack=${7:no}
	local_file_directory=${8:# When (file_pull is True) file is copied from a remote SCP server to the NXOS device, and written to this directory on the NXOS device. If the directory does not exist, it will be created under the file_system. This is an optional parameter.}
	file_pull_timeout=${9:300}
	remote_scp_server=${10:# The remote scp server address when file_pull is True. This is required if file_pull is True.}
	remote_scp_server_user=${11:# The remote scp server username when file_pull is True. This is required if file_pull is True.}
	remote_scp_server_password=${12:# The remote scp server password when file_pull is True. This is required if file_pull is True.}
	vrf=${13:management}
	provider=${14:# B(Deprecated)}

endsnippet

snippet nxos_gir_profile_management "Create a maintenance-mode or normal-mode profile for GIR." b
nxos_gir_profile_management: >
	mode=${1:maintenance|normal}

	commands=${2:# List of commands to be included into the profile.}
	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet nxos_static_route "Manages static route configuration" b
nxos_static_route: >
	prefix=${1:# Destination prefix of static route.}
	next_hop=${2:# Next hop address or interface of static route. If interface, it must be the fully-qualified interface name.}

	vrf=${3:default}
	tag=${4:# Route tag value (numeric) or keyword 'default'.}
	route_name=${5:# Name of the route or keyword 'default'. Used with the name parameter on the CLI.}
	pref=${6:# Preference or administrative difference of route (range 1-255) or keyword 'default'.}
	aggregate=${7:# L}
	track=${8:# Track value (range 1 - 512). Track must already be configured on the device before adding the route.}
	state=${9:#present|absent}
	provider=${10:# B(Deprecated)}

endsnippet

snippet nxos_snmp_traps "Manages SNMP traps." b
nxos_snmp_traps: >
	group=${1:aaa|bfd|bgp|bridge|callhome|cfs|config|eigrp|entity|feature-control|generic|hsrp|license|link|lldp|mmode|ospf|pim|rf|rmon|snmp|storm-control|stpx|switchfabric|syslog|sysmgr|system|upgrade|vtp|all}

	state=${2:#enabled|disabled}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_command "Run arbitrary command on Cisco NXOS devices" b
nxos_command: >
	commands=${1:# The commands to send to the remote NXOS device.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}

	wait_for=${2:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
	match=${3:all}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# B(Deprecated)}

endsnippet

snippet nxos_banner "Manage multiline banners on Cisco NXOS devices" b
nxos_banner: >
	banner=${1:exec|motd}

	text=${2:# The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet nxos_vpc "Manages global VPC configuration" b
nxos_vpc: >
	domain=${1:# VPC domain}
	state=${2:present|absent}

	role_priority=${3:# Role priority for device. Remember lower is better.}
	system_priority=${4:# System priority device.  Remember they must match between peers.}
	pkl_src=${5:# Source IP address used for peer keepalive link}
	pkl_dest=${6:# Destination (remote) IP address used for peer keepalive link}
	pkl_vrf=${7:management}
	peer_gw=${8:# Enables/Disables peer gateway}
	auto_recovery=${9:# Enables/Disables auto recovery on platforms that support disable}
	auto_recovery_reload_delay=${10:# Manages auto-recovery reload-delay timer in seconds}
	delay_restore=${11:# manages delay restore command and config value in seconds}
	delay_restore_interface_vlan=${12:# manages delay restore interface-vlan command and config value in seconds}
	delay_restore_orphan_port=${13:# manages delay restore orphan-port command and config value in seconds}
	provider=${14:# B(Deprecated)}

endsnippet

snippet nxos_vtp_domain "Manages VTP domain configuration." b
nxos_vtp_domain: >
	domain=${1:# VTP domain name.}

	provider=${2:# B(Deprecated)}

endsnippet

snippet nxos_bgp_af "Manages BGP Address-family configuration." b
nxos_bgp_af: >
	asn=${1:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
	vrf=${2:# Name of the VRF. The name 'default' is a valid VRF representing the global bgp.}
	afi=${3:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
	safi=${4:unicast|multicast|evpn}

	additional_paths_install=${5:# Install a backup path into the forwarding table and provide prefix independent convergence (PIC) in case of a PE-CE link failure.}
	additional_paths_receive=${6:# Enables the receive capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.}
	additional_paths_selection=${7:# Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.}
	additional_paths_send=${8:# Enables the send capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.}
	advertise_l2vpn_evpn=${9:# Advertise evpn routes.}
	client_to_client=${10:# Configure client-to-client route reflection.}
	dampen_igp_metric=${11:# Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.}
	dampening_state=${12:# Enable/disable route-flap dampening.}
	dampening_half_time=${13:# Specify decay half-life in minutes for route-flap dampening. Valid values are integer and keyword 'default'.}
	dampening_max_suppress_time=${14:# Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.}
	dampening_reuse_time=${15:# Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.}
	dampening_routemap=${16:# Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.}
	dampening_suppress_time=${17:# Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.}
	default_information_originate=${18:# Default information originate.}
	default_metric=${19:# Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'}
	distance_ebgp=${20:# Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.}
	distance_ibgp=${21:# Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.}
	distance_local=${22:# Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.}
	inject_map=${23:# An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy-attributes keyword which indicates that attributes should be copied from the aggregate. For example [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']].}
	maximum_paths=${24:# Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.}
	maximum_paths_ibgp=${25:# Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.}
	networks=${26:# Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route-map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192.168.2.0/24'], ['192.168.3.0/24', 'routemap_NYC']].}
	next_hop_route_map=${27:# Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.}
	redistribute=${28:# A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].}
	suppress_inactive=${29:# Advertises only active routes to peers.}
	table_map=${30:# Apply table-map to filter routes downloaded into URIB. Valid values are a string.}
	table_map_filter=${31:# Filters routes rejected by the route-map and does not download them to the RIB.}
	state=${32:#present|absent}
	provider=${33:# B(Deprecated)}

endsnippet

snippet nxos_lag_interfaces "Manages link aggregation groups of NX-OS Interfaces" b
nxos_lag_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet nxos_system "Manage the system attributes on Cisco NXOS devices" b
nxos_system: >
	hostname=${1:# Configure the device hostname parameter. This option takes an ASCII string value or keyword 'default'}
	domain_name=${2:# Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.}
	domain_lookup=${3:# Enables or disables the DNS lookup feature in Cisco NXOS.  This argument accepts boolean values.  When enabled, the system will try to resolve hostnames using DNS and when disabled, hostnames will not be resolved.}
	domain_search=${4:# Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.}
	name_servers=${5:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name or keyword 'default'. See examples.}
	system_mtu=${6:# Specifies the mtu, must be an integer or keyword 'default'.}
	state=${7:#present|absent}
	provider=${8:# B(Deprecated)}

endsnippet

snippet nxos_vrf_af "Manages VRF AF." b
nxos_vrf_af: >
	vrf=${1:# Name of the VRF.}
	afi=${2:ipv4|ipv6}

	route_target_both_auto_evpn=${3:# Enable/Disable the EVPN route-target 'auto' setting for both import and export target communities.}
	state=${4:#present|absent}
	provider=${5:# B(Deprecated)}

endsnippet

snippet nxos_vxlan_vtep "Manages VXLAN Network Virtualization Endpoint (NVE)." b
nxos_vxlan_vtep: >
	interface=${1:# Interface name for the VXLAN Network Virtualization Endpoint.}

	description=${2:# Description of the NVE interface.}
	host_reachability=${3:# Specify mechanism for host reachability advertisement.}
	shutdown=${4:# Administratively shutdown the NVE interface.}
	source_interface=${5:# Specify the loopback interface whose IP address should be used for the NVE interface.}
	source_interface_hold_down_time=${6:# Suppresses advertisement of the NVE loopback address until the overlay has converged.}
	global_mcast_group_L3=${7:# Global multicast ip prefix for L3 VNIs or the keyword 'default' This is available on NX-OS 9K series running 9.2.x or higher.}
	global_mcast_group_L2=${8:# Global multicast ip prefix for L2 VNIs or the keyword 'default' This is available on NX-OS 9K series running 9.2.x or higher.}
	global_suppress_arp=${9:# Enables ARP suppression for all VNIs This is available on NX-OS 9K series running 9.2.x or higher.}
	global_ingress_replication_bgp=${10:# Configures ingress replication protocol as bgp for all VNIs This is available on NX-OS 9K series running 9.2.x or higher.}
	state=${11:#present|absent}
	provider=${12:# B(Deprecated)}

endsnippet

snippet nxos_ospf "Manages configuration of an ospf instance." b
nxos_ospf: >
	ospf=${1:# Name of the ospf instance.}

	state=${2:#present|absent}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_facts "Gets facts about NX-OS switches" b
nxos_facts: >
	gather_subset=${1:!config}
	gather_network_resources=${2:# When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all and the resources like interfaces, vlans etc. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Valid subsets are 'all', 'bfd_interfaces', 'lag_interfaces', 'telemetry', 'vlans', 'lacp', 'lacp_interfaces', 'interfaces', 'l3_interfaces', 'l2_interfaces', 'lldp_global'.}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_bgp_neighbor_af "Manages BGP address-family's neighbors configuration." b
nxos_bgp_neighbor_af: >
	asn=${1:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}
	neighbor=${2:# Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.}
	afi=${3:ipv4|ipv6|vpnv4|vpnv6|l2vpn}
	safi=${4:unicast|multicast|evpn}

	vrf=${5:default}
	additional_paths_receive=${6:enable|disable|inherit}
	additional_paths_send=${7:enable|disable|inherit}
	advertise_map_exist=${8:# Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_exist_map']. This command is mutually exclusive with the advertise_map_non_exist property.}
	advertise_map_non_exist=${9:# Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non-exist-map name, or simply 'default' e.g. ['my_advertise_map', 'my_non_exist_map']. This command is mutually exclusive with the advertise_map_exist property.}
	allowas_in=${10:# Activate allowas-in property}
	allowas_in_max=${11:# Max-occurrences value for allowas_in. Valid values are an integer value or 'default'. This is mutually exclusive with allowas_in.}
	as_override=${12:# Activate the as-override feature.}
	default_originate=${13:# Activate the default-originate feature.}
	default_originate_route_map=${14:# Route-map for the default_originate property. Valid values are a string defining a route-map name, or 'default'. This is mutually exclusive with default_originate.}
	disable_peer_as_check=${15:# Disable checking of peer AS-number while advertising}
	filter_list_in=${16:# Valid values are a string defining a filter-list name, or 'default'.}
	filter_list_out=${17:# Valid values are a string defining a filter-list name, or 'default'.}
	max_prefix_limit=${18:# maximum-prefix limit value. Valid values are an integer value or 'default'.}
	max_prefix_interval=${19:# Optional restart interval. Valid values are an integer. Requires max_prefix_limit. May not be combined with max_prefix_warning.}
	max_prefix_threshold=${20:# Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.}
	max_prefix_warning=${21:# Optional warning-only keyword. Requires max_prefix_limit. May not be combined with max_prefix_interval.}
	next_hop_self=${22:# Activate the next-hop-self feature.}
	next_hop_third_party=${23:# Activate the next-hop-third-party feature.}
	prefix_list_in=${24:# Valid values are a string defining a prefix-list name, or 'default'.}
	prefix_list_out=${25:# Valid values are a string defining a prefix-list name, or 'default'.}
	route_map_in=${26:# Valid values are a string defining a route-map name, or 'default'.}
	route_map_out=${27:# Valid values are a string defining a route-map name, or 'default'.}
	route_reflector_client=${28:# Router reflector client.}
	send_community=${29:none|both|extended|standard|default}
	soft_reconfiguration_in=${30:enable|always|inherit}
	soo=${31:# Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.}
	suppress_inactive=${32:# suppress-inactive feature.}
	unsuppress_map=${33:# unsuppress-map. Valid values are a string defining a route-map name or 'default'.}
	weight=${34:# Weight value. Valid values are an integer value or 'default'.}
	state=${35:#present|absent}
	provider=${36:# B(Deprecated)}

endsnippet

snippet nxos_hsrp "Manages HSRP configuration on NX-OS switches." b
nxos_hsrp: >
	group=${1:# HSRP group number.}
	interface=${2:# Full name of interface that is being managed for HSRP.}

	version=${3:1|2}
	priority=${4:# HSRP priority or keyword 'default'.}
	preempt=${5:enabled|disabled}
	vip=${6:# HSRP virtual IP address or keyword 'default'}
	auth_string=${7:# Authentication string. If this needs to be hidden(for md5 type), the string should be 7 followed by the key string. Otherwise, it can be 0 followed by key string or just key string (for backward compatibility). For text type, this should be just be a key string. if this is 'default', authentication is removed.}
	auth_type=${8:text|md5}
	state=${9:#present|absent}
	provider=${10:# B(Deprecated)}

endsnippet

snippet nxos_snmp_user "Manages SNMP users for monitoring." b
nxos_snmp_user: >
	user=${1:# Name of the user.}

	group=${2:# Group to which the user will belong to. If state = present, and the user is existing, the group is added to the user. If the user is not existing, user entry is created with this group argument. If state = absent, only the group is removed from the user entry. However, to maintain backward compatibility, if the existing user belongs to only one group, and if group argument is same as the existing user's group, then the user entry also is deleted.}
	authentication=${3:md5|sha}
	pwd=${4:# Authentication password when using md5 or sha. This is not idempotent}
	privacy=${5:# Privacy password for the user. This is not idempotent}
	encrypt=${6:# Enables AES-128 bit encryption when using privacy password.}
	state=${7:#present|absent}
	provider=${8:# B(Deprecated)}

endsnippet

snippet nxos_bfd_global "Bidirectional Forwarding Detection (BFD) global-level configuration" b
nxos_bfd_global: >
	echo_interface=${1:# Loopback interface used for echo frames.}
	echo_rx_interval=${2:# BFD Echo receive interval in milliseconds.}
	interval=${3:# BFD interval timer values.}
	slow_timer=${4:# BFD slow rate timer in milliseconds.}
	startup_timer=${5:# BFD delayed startup timer in seconds.}
	ipv4_echo_rx_interval=${6:# BFD IPv4 session echo receive interval in milliseconds.}
	ipv4_interval=${7:# BFD IPv4 interval timer values.}
	ipv4_slow_timer=${8:# BFD IPv4 slow rate timer in milliseconds.}
	ipv6_echo_rx_interval=${9:# BFD IPv6 session echo receive interval in milliseconds.}
	ipv6_interval=${10:# BFD IPv6 interval timer values.}
	ipv6_slow_timer=${11:# BFD IPv6 slow rate timer in milliseconds.}
	fabricpath_interval=${12:# BFD fabricpath interval timer values.}
	fabricpath_slow_timer=${13:# BFD fabricpath slow rate timer in milliseconds.}
	fabricpath_vlan=${14:# BFD fabricpath control vlan.}
	provider=${15:# B(Deprecated)}

endsnippet

snippet nxos_vxlan_vtep_vni "Creates a Virtual Network Identifier member (VNI)" b
nxos_vxlan_vtep_vni: >
	interface=${1:# Interface name for the VXLAN Network Virtualization Endpoint.}
	vni=${2:# ID of the Virtual Network Identifier.}

	assoc_vrf=${3:# This attribute is used to identify and separate processing VNIs that are associated with a VRF and used for routing. The VRF and VNI specified with this command must match the configuration of the VNI under the VRF.}
	ingress_replication=${4:bgp|static|default}
	multicast_group=${5:# The multicast group (range) of the VNI. Valid values are string and keyword 'default'.}
	peer_list=${6:# Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.}
	suppress_arp=${7:# Suppress arp under layer 2 VNI.}
	suppress_arp_disable=${8:# Overrides the global ARP suppression config. This is available on NX-OS 9K series running 9.2.x or higher.}
	state=${9:#present|absent}
	provider=${10:# B(Deprecated)}

endsnippet

snippet nxos_smu "Perform SMUs on Cisco NX-OS devices." b
nxos_smu: >
	pkg=${1:# Name of the remote package.}

	file_system=${2:# The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_udld_interface "Manages UDLD interface configuration params." b
nxos_udld_interface: >
	mode=${1:enabled|disabled|aggressive}
	interface=${2:# FULL name of the interface, i.e. Ethernet1/1-}

	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet nxos_snmp_location "Manages SNMP location information." b
nxos_snmp_location: >
	location=${1:# Location information.}

	state=${2:#present|absent}
	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_ping "Tests reachability using ping from Nexus switch." b
nxos_ping: >
	dest=${1:# IP address or hostname (resolvable by switch) of remote node.}

	count=${2:5}
	source=${3:# Source IP Address or hostname (resolvable by switch)}
	vrf=${4:# Outgoing VRF.}
	state=${5:absent|#present}
	provider=${6:# B(Deprecated)}

endsnippet

snippet nxos_config "Manage Cisco NXOS configuration sections" b
nxos_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments.}
	replace_src=${4:# The I(replace_src) argument provides path to the configuration file to load into the remote system. This argument is used to replace the entire config with a flat-file. This is used with argument I(replace) with value I(config). This is mutually exclusive with the I(lines) and I(src) arguments. This argument is supported on Nexus 9K device. Use I(nxos_file_copy) module to copy the flat file to remote device and then use the path with this argument.}
	before=${5:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${6:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${7:#line|strict|exact|none}
	replace=${8:#line|block|config}
	backup=${9:no}
	running_config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	defaults=${11:no}
	save_when=${12:always|#never|modified|changed}
	diff_against=${13:#startup|intended|running}
	diff_ignore_lines=${14:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${15:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${16:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(True), if C(backup) is set to I(false) this option will be silently ignored.}
	provider=${17:# B(Deprecated)}

endsnippet

snippet nxos_vrf "Manages global VRF configuration." b
nxos_vrf: >
	name=${1:# Name of VRF to be managed.}

	admin_state=${2:#up|down}
	vni=${3:# Specify virtual network identifier. Valid values are Integer or keyword 'default'.}
	rd=${4:# VPN Route Distinguisher (RD). Valid values are a string in one of the route-distinguisher formats (ASN2:NN, ASN4:NN, or IPV4:NN); the keyword 'auto', or the keyword 'default'.}
	interfaces=${5:# List of interfaces to check the VRF has been configured correctly or keyword 'default'.}
	associated_interfaces=${6:# This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.}
	aggregate=${7:# L}
	purge=${8:no}
	state=${9:#present|absent}
	description=${10:# Description of the VRF or keyword 'default'.}
	delay=${11:10}
	provider=${12:# B(Deprecated)}

endsnippet

snippet nxos_nxapi "Manage NXAPI configuration on an NXOS device." b
nxos_nxapi: >
	http_port=${1:80}
	http=${2:yes}
	https_port=${3:443}
	https=${4:no}
	sandbox=${5:no}
	state=${6:#present|absent}
	ssl_strong_ciphers=${7:no}
	tlsv1_0=${8:yes}
	tlsv1_1=${9:no}
	tlsv1_2=${10:no}
	provider=${11:# B(Deprecated)}

endsnippet

snippet nxos_vrf_interface "Manages interface specific VRF configuration." b
nxos_vrf_interface: >
	vrf=${1:# Name of VRF to be managed.}
	interface=${2:# Full name of interface to be managed, i.e. Ethernet1/1.}

	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet nxos_ntp_options "Manages NTP options." b
nxos_ntp_options: >
	master=${1:# Sets whether the device is an authoritative NTP server.}
	stratum=${2:# If C(master=true), an optional stratum can be supplied (1-15). The device default is 8.}
	logging=${3:# Sets whether NTP logging is enabled on the device.}
	state=${4:#present|absent}
	provider=${5:# B(Deprecated)}

endsnippet

snippet nxos_bgp "Manages BGP configuration." b
nxos_bgp: >
	asn=${1:# BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.}

	vrf=${2:# Name of the VRF. The name 'default' is a valid VRF representing the global BGP.}
	bestpath_always_compare_med=${3:# Enable/Disable MED comparison on paths from different autonomous systems.}
	bestpath_aspath_multipath_relax=${4:# Enable/Disable load sharing across the providers with different (but equal-length) AS paths.}
	bestpath_compare_routerid=${5:# Enable/Disable comparison of router IDs for identical eBGP paths.}
	bestpath_compare_neighborid=${6:# Enable/Disable neighborid. Use this when more paths available than max path config.}
	bestpath_cost_community_ignore=${7:# Enable/Disable Ignores the cost community for BGP best-path calculations.}
	bestpath_med_confed=${8:# Enable/Disable enforcement of bestpath to do a MED comparison only between paths originated within a confederation.}
	bestpath_med_missing_as_worst=${9:# Enable/Disable assigns the value of infinity to received routes that do not carry the MED attribute, making these routes the least desirable.}
	bestpath_med_non_deterministic=${10:# Enable/Disable deterministic selection of the best MED pat from among the paths from the same autonomous system.}
	cluster_id=${11:# Route Reflector Cluster-ID.}
	confederation_id=${12:# Routing domain confederation AS.}
	confederation_peers=${13:# AS confederation parameters.}
	disable_policy_batching=${14:# Enable/Disable the batching evaluation of prefix advertisement to all peers.}
	disable_policy_batching_ipv4_prefix_list=${15:# Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.}
	disable_policy_batching_ipv6_prefix_list=${16:# Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.}
	enforce_first_as=${17:# Enable/Disable enforces the neighbor autonomous system to be the first AS number listed in the AS path attribute for eBGP. On NX-OS, this property is only supported in the global BGP context.}
	event_history_cli=${18:size_small|size_medium|size_large|size_disable|default}
	event_history_detail=${19:size_small|size_medium|size_large|size_disable|default}
	event_history_events=${20:size_small|size_medium|size_large|size_disable|default}
	event_history_periodic=${21:size_small|size_medium|size_large|size_disable|default}
	fast_external_fallover=${22:# Enable/Disable immediately reset the session if the link to a directly connected BGP peer goes down.  Only supported in the global BGP context.}
	flush_routes=${23:# Enable/Disable flush routes in RIB upon controlled restart. On NX-OS, this property is only supported in the global BGP context.}
	graceful_restart=${24:# Enable/Disable graceful restart.}
	graceful_restart_helper=${25:# Enable/Disable graceful restart helper mode.}
	graceful_restart_timers_restart=${26:# Set maximum time for a restart sent to the BGP peer.}
	graceful_restart_timers_stalepath_time=${27:# Set maximum time that BGP keeps the stale routes from the restarting BGP peer.}
	isolate=${28:# Enable/Disable isolate this router from BGP perspective.}
	local_as=${29:# Local AS number to be used within a VRF instance.}
	log_neighbor_changes=${30:# Enable/Disable message logging for neighbor up/down event.}
	maxas_limit=${31:# Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.}
	neighbor_down_fib_accelerate=${32:# Enable/Disable handle BGP neighbor down event, due to various reasons.}
	reconnect_interval=${33:# The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.}
	router_id=${34:# Router Identifier (ID) of the BGP router VRF instance.}
	shutdown=${35:# Administratively shutdown the BGP protocol.}
	suppress_fib_pending=${36:# Enable/Disable advertise only routes programmed in hardware to peers.}
	timer_bestpath_limit=${37:# Specify timeout for the first best path after a restart, in seconds.}
	timer_bgp_hold=${38:# Set BGP hold timer.}
	timer_bgp_keepalive=${39:# Set BGP keepalive timer.}
	state=${40:#present|absent}
	provider=${41:# B(Deprecated)}

endsnippet

snippet nxos_l2_interfaces "Manages Layer-2 Interfaces attributes of NX-OS Interfaces" b
nxos_l2_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet nxos_pim_interface "Manages PIM interface configuration." b
nxos_pim_interface: >
	interface=${1:# Full name of the interface such as Ethernet1/33.}

	sparse=${2:no}
	bfd=${3:enable|disable|default}
	dr_prio=${4:# Configures priority for PIM DR election on interface.}
	hello_auth_key=${5:# Authentication for hellos on this interface.}
	hello_interval=${6:# Hello interval in milliseconds for this interface.}
	jp_policy_out=${7:# Policy for join-prune messages (outbound).}
	jp_policy_in=${8:# Policy for join-prune messages (inbound).}
	jp_type_out=${9:prefix|routemap}
	jp_type_in=${10:prefix|routemap}
	border=${11:no}
	neighbor_policy=${12:# Configures a neighbor policy for filtering adjacencies.}
	neighbor_type=${13:prefix|routemap}
	state=${14:#present|default}
	provider=${15:# B(Deprecated)}

endsnippet

snippet nxos_snmp_contact "Manages SNMP contact info." b
nxos_snmp_contact: >
	contact=${1:# Contact information.}
	state=${2:#present|absent}

	provider=${3:# B(Deprecated)}

endsnippet

snippet nxos_bfd_interfaces "Manages BFD attributes of nxos interfaces." b
nxos_bfd_interfaces: >
	config=${1:# T}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet nxos_lacp "Manage Global Link Aggregation Control Protocol (LACP) on Cisco NX-OS devices." b
nxos_lacp: >
	config=${1:# L}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet nxos_lldp "Manage LLDP configuration on Cisco NXOS network devices." b
nxos_lldp: >
	state=${1:#present|absent}
	provider=${2:# B(Deprecated)}

endsnippet

snippet nxos_evpn_global "Handles the EVPN control plane for VXLAN." b
nxos_evpn_global: >
	nv_overlay_evpn=${1:# EVPN control plane.}

	provider=${2:# B(Deprecated)}

endsnippet

snippet nxos_ntp "Manages core NTP configuration." b
nxos_ntp: >
	server=${1:# Network address of NTP server.}
	peer=${2:# Network address of NTP peer.}
	key_id=${3:# Authentication key identifier to use with given NTP server or peer or keyword 'default'.}
	prefer=${4:enabled|disabled}
	vrf_name=${5:# Makes the device communicate with the given NTP server or peer over a specific VRF or keyword 'default'.}
	source_addr=${6:# Local source address from which NTP messages are sent or keyword 'default'}
	source_int=${7:# Local source interface from which NTP messages are sent. Must be fully qualified interface name or keyword 'default'}
	state=${8:#present|absent}
	provider=${9:# B(Deprecated)}

endsnippet

snippet nxos_snmp_host "Manages SNMP host configuration." b
nxos_snmp_host: >
	snmp_host=${1:# IP address of hostname of target host.}

	version=${2:v1|v2c|v3}
	v3=${3:noauth|auth|priv}
	community=${4:# Community string or v3 username.}
	udp=${5:162}
	snmp_type=${6:trap|inform}
	vrf=${7:# VRF to use to source traffic to source. If state = absent, the vrf is removed.}
	vrf_filter=${8:# Name of VRF to filter. If state = absent, the vrf is removed from the filter.}
	src_intf=${9:# Source interface. Must be fully qualified interface name. If state = absent, the interface is removed.}
	state=${10:#present|absent}
	provider=${11:# B(Deprecated)}

endsnippet

snippet nxos_vrrp "Manages VRRP configuration on NX-OS switches." b
nxos_vrrp: >
	group=${1:# VRRP group number.}
	interface=${2:# Full name of interface that is being managed for VRRP.}

	interval=${3:1}
	priority=${4:100}
	preempt=${5:yes}
	vip=${6:# VRRP virtual IP address or 'default' keyword}
	authentication=${7:# Clear text authentication string or 'default' keyword}
	admin_state=${8:#shutdown|no shutdown|default}
	state=${9:#present|absent}
	provider=${10:# B(Deprecated)}

endsnippet

snippet nxos_pim_rp_address "Manages configuration of an PIM static RP address instance." b
nxos_pim_rp_address: >
	rp_address=${1:# Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.}
	state=${2:#present|absent|default}

	group_list=${3:# Group range for static RP. Valid values are multicast addresses.}
	prefix_list=${4:# Prefix list policy for static RP. Valid values are prefix-list policy names.}
	route_map=${5:# Route map policy for static RP. Valid values are route-map policy names.}
	bidir=${6:# Group range is treated in PIM bidirectional mode.}
	provider=${7:# B(Deprecated)}

endsnippet

snippet nxos_vpc_interface "Manages interface VPC configuration" b
nxos_vpc_interface: >
	portchannel=${1:# Group number of the portchannel that will be configured.}
	state=${2:#present|absent}

	vpc=${3:# VPC group/id that will be configured on associated portchannel.}
	peer_link=${4:# Set to true/false for peer link config on associated portchannel.}
	provider=${5:# B(Deprecated)}

endsnippet

snippet nxos_vtp_version "Manages VTP version configuration." b
nxos_vtp_version: >
	version=${1:1|2}

	provider=${2:# B(Deprecated)}

endsnippet

snippet nxos_snapshot "Manage snapshots of the running states of selected features." b
nxos_snapshot: >
	action=${1:add|compare|create|delete|delete_all}

	snapshot_name=${2:# Snapshot name, to be used when C(action=create) or C(action=delete).}
	description=${3:# Snapshot description to be used when C(action=create).}
	snapshot1=${4:# First snapshot to be used when C(action=compare).}
	snapshot2=${5:# Second snapshot to be used when C(action=compare).}
	comparison_results_file=${6:# Name of the file where snapshots comparison will be stored when C(action=compare).}
	compare_option=${7:summary|ipv4routes|ipv6routes}
	section=${8:# Used to name the show command output, to be used when C(action=add).}
	show_command=${9:# Specify a new show command, to be used when C(action=add).}
	row_id=${10:# Specifies the tag of each row entry of the show command's XML output, to be used when C(action=add).}
	element_key1=${11:# Specify the tags used to distinguish among row entries, to be used when C(action=add).}
	element_key2=${12:# Specify the tags used to distinguish among row entries, to be used when C(action=add).}
	save_snapshot_locally=${13:no}
	path=${14:./}
	provider=${15:# B(Deprecated)}

endsnippet

snippet nxos_snmp_community "Manages SNMP community configs." b
nxos_snmp_community: >
	community=${1:# Case-sensitive community string.}

	access=${2:ro|rw}
	group=${3:# Group to which the community belongs.}
	acl=${4:# ACL name to filter snmp requests or keyword 'default'.}
	state=${5:#present|absent}
	provider=${6:# B(Deprecated)}

endsnippet

snippet nuage_vspk "Manage Nuage VSP environments" b
nuage_vspk: >
	auth=${1:# Dict with the authentication information required to connect to a Nuage VSP environment.}
	type=${2:# The type of entity you want to work on (example Enterprise).}

	id=${3:# The ID of the entity you want to work on.}
	parent_id=${4:# The ID of the parent of the entity you want to work on.}
	parent_type=${5:# The type of parent the ID is specified for (example Enterprise).}
	state=${6:present|absent}
	command=${7:find|change_password|wait_for_job|get_csp_enterprise}
	match_filter=${8:# A filter used when looking (both in I(command) and I(state) for entities, in the format the Nuage VSP API expects.}
	properties=${9:# Properties are the key, value pairs of the different properties an entity has.}
	children=${10:# Can be used to specify a set of child entities.}

endsnippet

snippet netact_cm_command "Manage network configuration data in Nokia Core and Radio networks" b
netact_cm_command: >
	operation=${1:upload|provision|import|export|Provision_Mass_Modification}

	opsName=${2:# user specified operation name}
	DN=${3:# S}
	WS=${4:# S}
	MR=${5:# S}
	planName=${6:# Specifies a plan name.}
	typeOption=${7:plan|actual|reference|template|siteTemplate}
	fileFormat=${8:RAML2|CSV|XLSX}
	fileName=${9:# Specifies a file name. Valid for Import and Export operations.}
	inputFile=${10:# S}
	createBackupPlan=${11:# Specifies if backup plan generation is enabled.}
	backupPlanName=${12:# Specifies a backup plan name}
	verbose=${13:# N}
	extra_opts=${14:# E}

endsnippet

snippet nso_show "Displays data from Cisco NSO." b
nso_show: >
	path=${1:# P}
	url=${2:# N}
	username=${3:# N}
	password=${4:# N}

	operational=${5:no}
	timeout=${6:300}
	validate_certs=${7:no}

endsnippet

snippet nso_config "Manage Cisco NSO configuration and service synchronization." b
nso_config: >
	data=${1:# N}
	url=${2:# N}
	username=${3:# N}
	password=${4:# N}

	timeout=${5:300}
	validate_certs=${6:no}

endsnippet

snippet nso_action "Executes Cisco NSO actions and verifies output." b
nso_action: >
	path=${1:# P}
	url=${2:# N}
	username=${3:# N}
	password=${4:# N}

	input=${5:# N}
	output_required=${6:# R}
	output_invalid=${7:# L}
	validate_strict=${8:# I}
	timeout=${9:300}
	validate_certs=${10:no}

endsnippet

snippet nso_query "Query data from Cisco NSO." b
nso_query: >
	xpath=${1:# X}
	fields=${2:# L}
	url=${3:# N}
	username=${4:# N}
	password=${5:# N}

	timeout=${6:300}
	validate_certs=${7:no}

endsnippet

snippet nso_verify "Verifies Cisco NSO configuration." b
nso_verify: >
	data=${1:# N}
	url=${2:# N}
	username=${3:# N}
	password=${4:# N}

	timeout=${5:300}
	validate_certs=${6:no}

endsnippet

snippet restconf_get "Fetch configuration/state data from RESTCONF enabled devices." b
restconf_get: >
	path=${1:# URI being used to execute API calls.}

	content=${2:config|nonconfig|all}
	output=${3:#json|xml}

endsnippet

snippet restconf_config "Handles create, update, read and delete of configuration data on RESTCONF enabled devices." b
restconf_config: >
	path=${1:# URI being used to execute API calls.}

	content=${2:# The configuration data in format as specififed in C(format) option. Required unless C(method) is I(delete).}
	method=${3:#post|put|patch|delete}
	format=${4:#json|xml}

endsnippet

snippet faz_device "Add or remove device" b
faz_device: >
	adom=${1:root}
	os_type=${2:unknown|fos|fsw|foc|fml|faz|fwb|fch|fct|log|fmg|fsa|fdd|fac}
	mgmt_mode=${3:unreg|fmg|faz|fmgfaz}
	os_minor_vers=${4:# Minor OS rev of the device.}
	os_ver=${5:unknown|0.0|1.0|2.0|3.0|4.0|5.0|6.0}

	mode=${6:#add|delete|promote}
	device_username=${7:# The username of the device being added to FortiAnalyzer.}
	device_password=${8:# The password of the device being added to FortiAnalyzer.}
	device_ip=${9:# The IP of the device being added to FortiAnalyzer.}
	device_unique_name=${10:# The desired "friendly" name of the device being added to FortiAnalyzer.}
	device_serial=${11:# The serial number of the device being added to FortiAnalyzer.}
	platform_str=${12:# Required for determine the platform for VM platforms. ie FortiGate-VM64}
	faz_quota=${13:# Specifies the quota for the device in FAZ}

endsnippet

snippet sros_config "Manage Nokia SR OS device configuration" b
sros_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.  The I(lines) argument only supports current context lines.  See EXAMPLES}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|none}
	replace=${7:#line|block}
	force=${8:# The force argument instructs the module to not consider the current devices running-config.  When set to true, this will cause the module to push the contents of I(src) into the device without first checking if already configured.}
	backup=${9:no}
	config=${10:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
	defaults=${11:no}
	save=${12:no}
	backup_options=${13:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${14:# A dict object containing connection details.}

endsnippet

snippet sros_command "Run commands on remote devices running Nokia SR OS" b
sros_command: >
	commands=${1:# List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet sros_rollback "Configure Nokia SR OS rollback" b
sros_rollback: >
	rollback_location=${1:# The I(rollback_location) specifies the location and filename of the rollback checkpoint files.   This argument supports any valid local or remote URL as specified in SR OS}
	remote_max_checkpoints=${2:# The I(remote_max_checkpoints) argument configures the maximum number of rollback files that can be transferred and saved to a remote location.  Valid values for this argument are in the range of 1 to 50}
	local_max_checkpoints=${3:# The I(local_max_checkpoints) argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50}
	rescue_location=${4:# The I(rescue_location) specifies the location of the rescue file.  This argument supports any valid local or remote URL as specified in SR OS}
	state=${5:#present|absent}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet mso_schema_template_contract_filter "Manage contract filters in schema templates" b
mso_schema_template_contract_filter: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	contract=${3:# The name of the contract to manage.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	contract_display_name=${6:# The name as displayed on the MSO web interface.}
	contract_filter_type=${7:both-way|one-way}
	contract_scope=${8:application-profile|global|tenant|vrf}
	filter=${9:# The filter to associate with this contract.}
	filter_template=${10:# The template name in which the filter is located.}
	filter_schema=${11:# The schema name in which the filter is located.}
	filter_type=${12:#both-way|consumer-to-provider|provider-to-consumer}
	filter_directives=${13:log|none}
	state=${14:absent|#present|query}
	port=${15:# Port number to be used for the REST connection.}
	username=${16:admin}
	output_level=${17:debug|info|#normal}
	timeout=${18:30}
	use_proxy=${19:yes}
	use_ssl=${20:yes}
	validate_certs=${21:yes}

endsnippet

snippet aci_vlan_pool "Manage VLAN pools (fvns:VlanInstP)" b
aci_vlan_pool: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	pool_allocation_mode=${4:dynamic|static}
	description=${5:# Description for the C(pool).}
	pool=${6:# The name of the pool.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet mso_schema_site_anp_epg_staticport "Manage site-local EPG static ports in schema template" b
mso_schema_site_anp_epg_staticport: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	anp=${6:# The name of the ANP.}
	epg=${7:# The name of the EPG.}
	type=${8:#port}
	pod=${9:# The pod of the static port.}
	leaf=${10:# The leaf of the static port.}
	path=${11:# The path of the static port.}
	vlan=${12:# The port encap VLAN id of the static port.}
	deployment_immediacy=${13:immediate|lazy}
	mode=${14:native|regular|untagged}
	state=${15:absent|#present|query}
	port=${16:# Port number to be used for the REST connection.}
	username=${17:admin}
	output_level=${18:debug|info|#normal}
	timeout=${19:30}
	use_proxy=${20:yes}
	use_ssl=${21:yes}
	validate_certs=${22:yes}

endsnippet

snippet mso_schema_site_anp "Manage site-local Application Network Profiles (ANPs) in schema template" b
mso_schema_site_anp: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	anp=${6:# The name of the ANP to manage.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for the REST connection.}
	username=${9:admin}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_domain_to_encap_pool "Bind Domain to Encap Pools (infra:RsVlanNs)" b
aci_domain_to_encap_pool: >
	pool_type=${1:vlan|vsan|vxlan}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	domain=${5:# Name of the domain being associated with the Encap Pool.}
	domain_type=${6:fc|l2dom|l3dom|phys|vmm}
	pool=${7:# The name of the pool.}
	pool_allocation_mode=${8:dynamic|static}
	state=${9:absent|#present|query}
	vm_provider=${10:cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet aci_tenant_span_src_group_to_dst_group "Bind SPAN source groups to destination groups (span:SpanLbl)" b
aci_tenant_span_src_group_to_dst_group: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${4:# The description for Span source group to destination group binding.}
	dst_group=${5:# The Span destination group to associate with the source group.}
	src_group=${6:# The name of the Span source group.}
	state=${7:absent|#present|query}
	tenant=${8:# The name of the Tenant.}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet aci_domain_to_vlan_pool "Bind Domain to VLAN Pools (infra:RsVlanNs)" b
aci_domain_to_vlan_pool: >
	pool_allocation_mode=${1:dynamic|static}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	domain=${5:# Name of the domain being associated with the VLAN Pool.}
	domain_type=${6:fc|l2dom|l3dom|phys|vmm}
	pool=${7:# The name of the pool.}
	state=${8:absent|#present|query}
	vm_provider=${9:cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware}
	port=${10:# Port number to be used for REST connection.}
	username=${11:admin}
	certificate_name=${12:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet aci_l3out_extsubnet "Manage External Subnet objects (l3extSubnet:extsubnet)" b
aci_l3out_extsubnet: >
	tenant=${1:# Name of an existing tenant.}
	l3out=${2:# Name of an existing L3Out.}
	extepg=${3:# Name of an existing ExtEpg.}
	network=${4:# The network address for the Subnet.}
	host=${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${6:# The password to use for authentication.}
	private_key=${7:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	subnet_name=${8:# Name of External Subnet being created.}
	description=${9:# Description for the External Subnet.}
	scope=${10:export-rtctrl|import-security|shared-rtctrl|shared-security}
	state=${11:absent|#present|query}
	port=${12:# Port number to be used for REST connection.}
	username=${13:admin}
	certificate_name=${14:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${15:debug|info|#normal}
	timeout=${16:30}
	use_proxy=${17:yes}
	use_ssl=${18:yes}
	validate_certs=${19:yes}

endsnippet

snippet aci_epg "Manage End Point Groups (EPG) objects (fv:AEPg)" b
aci_epg: >
	ap=${1:# Name of an existing application network profile, that will contain the EPGs.}
	epg=${2:# Name of the end point group.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	tenant=${6:# Name of an existing tenant.}
	bd=${7:# Name of the bridge domain being associated with the EPG.}
	priority=${8:level1|level2|level3|unspecified}
	intra_epg_isolation=${9:enforced|unenforced}
	description=${10:# Description for the EPG.}
	fwd_control=${11:none|proxy-arp}
	preferred_group=${12:# Whether ot not the EPG is part of the Preferred Group and can communicate without contracts.}
	state=${13:absent|#present|query}
	port=${14:# Port number to be used for REST connection.}
	username=${15:admin}
	certificate_name=${16:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${17:debug|info|#normal}
	timeout=${18:30}
	use_proxy=${19:yes}
	use_ssl=${20:yes}
	validate_certs=${21:yes}

endsnippet

snippet aci_aep_to_domain "Bind AEPs to Physical or Virtual Domains (infra:RsDomP)" b
aci_aep_to_domain: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	aep=${4:# The name of the Attachable Access Entity Profile.}
	domain=${5:# Name of the physical or virtual domain being associated with the AEP.}
	domain_type=${6:fc|l2dom|l3dom|phys|vmm}
	state=${7:absent|#present|query}
	vm_provider=${8:cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet aci_aaa_user_certificate "Manage AAA user certificates (aaa:UserCert)" b
aci_aaa_user_certificate: >
	aaa_user=${1:# The name of the user to add a certificate to.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	aaa_user_type=${5:appuser|#user}
	certificate=${6:# The PEM format public key extracted from the X.509 certificate.}
	certificate_name=${7:# The name of the user certificate entry in ACI.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_firmware_group_node "This modules adds and remove nodes from the firmware group" b
aci_firmware_group_node: >
	group=${1:# This is the name of the firmware group}
	node=${2:# The node to be added to the firmware group - the value equals the NodeID}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_filter "Manages top level filter objects (vz:Filter)" b
aci_filter: >
	filter=${1:# The name of the filter.}
	tenant=${2:# The name of the tenant.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# Description for the filter.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_config_snapshot "Manage Config Snapshots (config:Snapshot, config:ExportP)" b
aci_config_snapshot: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${4:# The description for the Config Export Policy.}
	export_policy=${5:# The name of the Export Policy to use for Config Snapshots.}
	format=${6:json|xml}
	include_secure=${7:# Determines if secure information should be included in the backup.}
	max_count=${8:# Determines how many snapshots can exist for the Export Policy before the APIC starts to rollover.}
	snapshot=${9:# The name of the snapshot to delete.}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet mso_schema_site_anp_epg "Manage site-local Endpoint Groups (EPGs) in schema template" b
mso_schema_site_anp_epg: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	anp=${6:# The name of the ANP.}
	epg=${7:# The name of the EPG to manage.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet mso_schema_site_bd_subnet "Manage site-local BD subnets in schema template" b
mso_schema_site_bd_subnet: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	subnet=${4:# The IP range in CIDR notation.}
	host=${5:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${6:# The password to use for authentication.}

	bd=${7:# The name of the BD.}
	description=${8:# The description of this subnet.}
	scope=${9:private|public}
	shared=${10:# Whether this subnet is shared between VRFs.}
	no_default_gateway=${11:# Whether this subnet has a default gateway.}
	state=${12:absent|#present|query}
	port=${13:# Port number to be used for the REST connection.}
	username=${14:admin}
	output_level=${15:debug|info|#normal}
	timeout=${16:30}
	use_proxy=${17:yes}
	use_ssl=${18:yes}
	validate_certs=${19:yes}

endsnippet

snippet aci_interface_policy_lldp "Manage LLDP interface policies (lldp:IfPol)" b
aci_interface_policy_lldp: >
	lldp_policy=${1:# The LLDP interface policy name.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the LLDP interface policy name.}
	receive_state=${6:# Enable or disable Receive state.}
	transmit_state=${7:# Enable or Disable Transmit state.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet mso_schema_template_anp "Manage Application Network Profiles (ANPs) in schema templates" b
mso_schema_template_anp: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	host=${3:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${4:# The password to use for authentication.}

	anp=${5:# The name of the ANP to manage.}
	display_name=${6:# The name as displayed on the MSO web interface.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for the REST connection.}
	username=${9:admin}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet mso_schema_template_bd_subnet "Manage BD subnets in schema templates" b
mso_schema_template_bd_subnet: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template to change.}
	bd=${3:# The name of the BD to manage.}
	subnet=${4:# The IP range in CIDR notation.}
	host=${5:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${6:# The password to use for authentication.}

	description=${7:# The description of this subnet.}
	scope=${8:private|public}
	shared=${9:# Whether this subnet is shared between VRFs.}
	no_default_gateway=${10:# Whether this subnet has a default gateway.}
	state=${11:absent|#present|query}
	port=${12:# Port number to be used for the REST connection.}
	username=${13:admin}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet aci_interface_policy_port_security "Manage port security (l2:PortSecurityPol)" b
aci_interface_policy_port_security: >
	port_security=${1:# The name of the port security.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the contract.}
	max_end_points=${6:# Maximum number of end points.}
	port_security_timeout=${7:# The delay time in seconds before MAC learning is re-enabled}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet aci_tenant_span_src_group "Manage SPAN source groups (span:SrcGrp)" b
aci_tenant_span_src_group: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	admin_state=${4:# Enable or disable the span sources.}
	description=${5:# The description for Span source group.}
	dst_group=${6:# The Span destination group to associate with the source group.}
	src_group=${7:# The name of the Span source group.}
	state=${8:absent|#present|query}
	tenant=${9:# The name of the Tenant.}
	port=${10:# Port number to be used for REST connection.}
	username=${11:admin}
	certificate_name=${12:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet mso_schema_template_deploy "Deploy schema templates to sites" b
mso_schema_template_deploy: >
	schema=${1:# The name of the schema.}
	host=${2:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${3:# The password to use for authentication.}

	template=${4:# The name of the template.}
	site=${5:# The name of the site B(to undeploy).}
	state=${6:#deploy|status|undeploy}
	port=${7:# Port number to be used for the REST connection.}
	username=${8:admin}
	output_level=${9:debug|info|#normal}
	timeout=${10:30}
	use_proxy=${11:yes}
	use_ssl=${12:yes}
	validate_certs=${13:yes}

endsnippet

snippet aci_static_binding_to_epg "Bind static paths to EPGs (fv:RsPathAtt)" b
aci_static_binding_to_epg: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	tenant=${4:# Name of an existing tenant.}
	ap=${5:# Name of an existing application network profile, that will contain the EPGs.}
	epg=${6:# The name of the end point group.}
	description=${7:# Description for the static path to EPG binding.}
	encap_id=${8:# The encapsulation ID associating the C(epg) with the interface path.}
	primary_encap_id=${9:# Determines the primary encapsulation ID associating the C(epg) with the interface path when using micro-segmentation.}
	deploy_immediacy=${10:immediate|lazy}
	interface_mode=${11:802.1p|access|native|regular|tagged|trunk|untagged}
	interface_type=${12:fex|port_channel|#switch_port|vpc}
	pod_id=${13:# The pod number part of the tDn.}
	leafs=${14:# The switch ID(s) that the C(interface) belongs to.}
	interface=${15:# The C(interface) string value part of the tDn.}
	extpaths=${16:# The C(extpaths) integer value part of the tDn.}
	state=${17:absent|#present|query}
	port=${18:# Port number to be used for REST connection.}
	username=${19:admin}
	certificate_name=${20:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${21:debug|info|#normal}
	timeout=${22:30}
	use_proxy=${23:yes}
	use_ssl=${24:yes}
	validate_certs=${25:yes}

endsnippet

snippet aci_contract_subject "Manage initial Contract Subjects (vz:Subj)" b
aci_contract_subject: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	tenant=${4:# The name of the tenant.}
	subject=${5:# The contract subject name.}
	contract=${6:# The name of the Contract.}
	reverse_filter=${7:# Determines if the APIC should reverse the src and dst ports to allow the return traffic back, since ACI is stateless filter.}
	priority=${8:level1|level2|level3|unspecified}
	dscp=${9:AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified}
	description=${10:# Description for the contract subject.}
	consumer_match=${11:all|at_least_one|at_most_one|none}
	provider_match=${12:all|at_least_one|at_most_one|none}
	state=${13:absent|#present|query}
	port=${14:# Port number to be used for REST connection.}
	username=${15:admin}
	certificate_name=${16:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${17:debug|info|#normal}
	timeout=${18:30}
	use_proxy=${19:yes}
	use_ssl=${20:yes}
	validate_certs=${21:yes}

endsnippet

snippet mso_tenant "Manage tenants" b
mso_tenant: >
	tenant=${1:# The name of the tenant.}
	display_name=${2:# The name of the tenant to be displayed in the web UI.}
	host=${3:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${4:# The password to use for authentication.}

	description=${5:# The description for this tenant.}
	users=${6:# A list of associated users for this tenant.}
	sites=${7:# A list of associated sites for this tenant.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet mso_schema_site_vrf_region_cidr_subnet "Manage site-local VRF regions in schema template" b
mso_schema_site_vrf_region_cidr_subnet: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	vrf=${6:# The name of the VRF.}
	region=${7:# The name of the region.}
	cidr=${8:# The IP range of for the region CIDR.}
	subnet=${9:# The IP subnet of this region CIDR.}
	zone=${10:# The name of the zone for the region CIDR subnet.}
	state=${11:absent|#present|query}
	port=${12:# Port number to be used for the REST connection.}
	username=${13:admin}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet mso_schema_site_vrf "Manage site-local VRFs in schema template" b
mso_schema_site_vrf: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	vrf=${6:# The name of the VRF to manage.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for the REST connection.}
	username=${9:admin}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet mso_schema_site_anp_epg_staticleaf "Manage site-local EPG static leafs in schema template" b
mso_schema_site_anp_epg_staticleaf: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	anp=${6:# The name of the ANP.}
	epg=${7:# The name of the EPG.}
	pod=${8:# The pod of the static leaf.}
	leaf=${9:# The path of the static leaf.}
	vlan=${10:# The VLAN id of the static leaf.}
	state=${11:absent|#present|query}
	port=${12:# Port number to be used for the REST connection.}
	username=${13:admin}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet aci_interface_policy_l2 "Manage Layer 2 interface policies (l2:IfPol)" b
aci_interface_policy_l2: >
	l2_policy=${1:# The name of the Layer 2 interface policy.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description of the Layer 2 interface policy.}
	qinq=${6:core|disabled|edge}
	vepa=${7:# Determines if Virtual Ethernet Port Aggregator is disabled or enabled.}
	vlan_scope=${8:global|portlocal}
	state=${9:absent|#present|query}
	port=${10:# Port number to be used for REST connection.}
	username=${11:admin}
	certificate_name=${12:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet aci_interface_policy_l2 "Manage Layer 2 interface policies (l2:IfPol)" b
aci_interface_policy_l2: >
	l2_policy=${1:# The name of the Layer 2 interface policy.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description of the Layer 2 interface policy.}
	qinq=${6:core|disabled|edge}
	vepa=${7:# Determines if Virtual Ethernet Port Aggregator is disabled or enabled.}
	vlan_scope=${8:global|portlocal}
	state=${9:absent|#present|query}
	port=${10:# Port number to be used for REST connection.}
	username=${11:admin}
	certificate_name=${12:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet aci_filter_entry "Manage filter entries (vz:Entry)" b
aci_filter_entry: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	arp_flag=${4:arp_reply|arp_request|unspecified}
	description=${5:# Description for the Filter Entry.}
	dst_port=${6:# Used to set both destination start and end ports to the same value when ip_protocol is tcp or udp.}
	dst_port_end=${7:# Used to set the destination end port when ip_protocol is tcp or udp.}
	dst_port_start=${8:# Used to set the destination start port when ip_protocol is tcp or udp.}
	entry=${9:# Then name of the Filter Entry.}
	ether_type=${10:arp|fcoe|ip|mac_security|mpls_ucast|trill|unspecified}
	filter=${11:# The name of Filter that the entry should belong to.}
	icmp_msg_type=${12:dst_unreachable|echo|echo_reply|src_quench|time_exceeded|unspecified}
	icmp6_msg_type=${13:dst_unreachable|echo_request|echo_reply|neighbor_advertisement|neighbor_solicitation|redirect|time_exceeded|unspecified}
	ip_protocol=${14:eigrp|egp|icmp|icmpv6|igmp|igp|l2tp|ospfigp|pim|tcp|udp|unspecified}
	state=${15:absent|#present|query}
	stateful=${16:# Determines the statefulness of the filter entry.}
	tenant=${17:# The name of the tenant.}
	port=${18:# Port number to be used for REST connection.}
	username=${19:admin}
	certificate_name=${20:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${21:debug|info|#normal}
	timeout=${22:30}
	use_proxy=${23:yes}
	use_ssl=${24:yes}
	validate_certs=${25:yes}

endsnippet

snippet aci_vrf "Manage contexts or VRFs (fv:Ctx)" b
aci_vrf: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	tenant=${4:# The name of the Tenant the VRF should belong to.}
	vrf=${5:# The name of the VRF.}
	policy_control_direction=${6:egress|ingress}
	policy_control_preference=${7:enforced|unenforced}
	description=${8:# The description for the VRF.}
	state=${9:absent|#present|query}
	port=${10:# Port number to be used for REST connection.}
	username=${11:admin}
	certificate_name=${12:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet aci_interface_policy_leaf_profile "Manage fabric interface policy leaf profiles (infra:AccPortP)" b
aci_interface_policy_leaf_profile: >
	leaf_interface_profile=${1:# The name of the Fabric access policy leaf interface profile.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# Description for the Fabric access policy leaf interface profile.}
	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_l3out "Manage Layer 3 Outside (L3Out) objects (l3ext:Out)" b
aci_l3out: >
	tenant=${1:# Name of an existing tenant.}
	l3out=${2:# Name of L3Out being created.}
	vrf=${3:# Name of the VRF being associated with the L3Out.}
	domain=${4:# Name of the external L3 domain being associated with the L3Out.}
	host=${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${6:# The password to use for authentication.}
	private_key=${7:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	dscp=${8:AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified}
	route_control=${9:export|import}
	l3protocol=${10:bgp|eigrp|ospf|pim|static}
	asn=${11:# The AS number for the L3Out.}
	description=${12:# Description for the L3Out.}
	state=${13:absent|#present|query}
	port=${14:# Port number to be used for REST connection.}
	username=${15:admin}
	certificate_name=${16:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${17:debug|info|#normal}
	timeout=${18:30}
	use_proxy=${19:yes}
	use_ssl=${20:yes}
	validate_certs=${21:yes}

endsnippet

snippet aci_interface_policy_fc "Manage Fibre Channel interface policies (fc:IfPol)" b
aci_interface_policy_fc: >
	fc_policy=${1:# The name of the Fiber Channel interface policy.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description of the Fiber Channel interface policy.}
	port_mode=${6:f|np}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_interface_policy_fc "Manage Fibre Channel interface policies (fc:IfPol)" b
aci_interface_policy_fc: >
	fc_policy=${1:# The name of the Fiber Channel interface policy.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description of the Fiber Channel interface policy.}
	port_mode=${6:f|np}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_switch_policy_vpc_protection_group "Manage switch policy explicit vPC protection groups (fabric:ExplicitGEp, fabric:NodePEp)." b
aci_switch_policy_vpc_protection_group: >
	protection_group=${1:# The name of the Explicit vPC Protection Group.}
	protection_group_id=${2:# The Explicit vPC Protection Group ID.}
	switch_1_id=${3:# The ID of the first Leaf Switch for the Explicit vPC Protection Group.}
	switch_2_id=${4:# The ID of the Second Leaf Switch for the Explicit vPC Protection Group.}
	host=${5:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${6:# The password to use for authentication.}
	private_key=${7:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	vpc_domain_policy=${8:# The vPC domain policy to be associated with the Explicit vPC Protection Group.}
	state=${9:absent|#present|query}
	port=${10:# Port number to be used for REST connection.}
	username=${11:admin}
	certificate_name=${12:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet mso_schema_site_vrf_region_cidr "Manage site-local VRF region CIDRs in schema template" b
mso_schema_site_vrf_region_cidr: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	vrf=${6:# The name of the VRF.}
	region=${7:# The name of the region.}
	cidr=${8:# The name of the region CIDR to manage.}
	primary=${9:# Whether this is the primary CIDR.}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for the REST connection.}
	username=${12:admin}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet aci_tenant_action_rule_profile "Manage action rule profiles (rtctrl:AttrP)" b
aci_tenant_action_rule_profile: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	action_rule=${4:# The name of the action rule profile.}
	description=${5:# The description for the action rule profile.}
	tenant=${6:# The name of the tenant.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_interface_policy_mcp "Manage MCP interface policies (mcp:IfPol)" b
aci_interface_policy_mcp: >
	mcp=${1:# The name of the MCP interface.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the MCP interface.}
	admin_state=${6:# Enable or disable admin state.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet mso_schema_template_anp_epg "Manage Endpoint Groups (EPGs) in schema templates" b
mso_schema_template_anp_epg: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	anp=${3:# The name of the ANP.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	epg=${6:# The name of the EPG to manage.}
	display_name=${7:# The name as displayed on the MSO web interface.}
	bd=${8:# The BD associated to this ANP.}
	vrf=${9:# The VRF associated to this ANP.}
	subnets=${10:# The subnets associated to this ANP.}
	useg_epg=${11:# Whether this is a USEG EPG.}
	intra_epg_isolation=${12:enforced|unenforced}
	intersite_multicaste_source=${13:# Whether intersite multicast source is enabled.}
	preferred_group=${14:# Whether this EPG is added to preferred group or not.}
	state=${15:absent|#present|query}
	port=${16:# Port number to be used for the REST connection.}
	username=${17:admin}
	output_level=${18:debug|info|#normal}
	timeout=${19:30}
	use_proxy=${20:yes}
	use_ssl=${21:yes}
	validate_certs=${22:yes}

endsnippet

snippet aci_maintenance_policy "Manage firmware maintenance policies" b
aci_maintenance_policy: >
	name=${1:# The name for the maintenance policy.}
	scheduler=${2:# The name of scheduler that is applied to the policy.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	runmode=${6:#pauseOnlyOnFailures|pauseNever}
	graceful=${7:# Whether the system will bring down the nodes gracefully during an upgrade, which reduces traffic lost.}
	adminst=${8:triggered|#untriggered}
	ignoreCompat=${9:# To check whether compatibility checks should be ignored}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet mso_schema_template_anp_epg_contract "Manage EPG contracts in schema templates" b
mso_schema_template_anp_epg_contract: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template to change.}
	anp=${3:# The name of the ANP.}
	epg=${4:# The name of the EPG to manage.}
	host=${5:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${6:# The password to use for authentication.}

	contract=${7:# A contract associated to this EPG.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_ap "Manage top level Application Profile (AP) objects (fv:Ap)" b
aci_ap: >
	tenant=${1:# The name of an existing tenant.}
	ap=${2:# The name of the application network profile.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# Description for the AP.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_tenant_span_dst_group "Manage SPAN destination groups (span:DestGrp)" b
aci_tenant_span_dst_group: >
	dst_group=${1:# The name of the SPAN destination group.}
	tenant=${2:# The name of the tenant.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# The description of the SPAN destination group.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_interface_policy_port_security "Manage port security (l2:PortSecurityPol)" b
aci_interface_policy_port_security: >
	port_security=${1:# The name of the port security.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the contract.}
	max_end_points=${6:# Maximum number of end points.}
	port_security_timeout=${7:# The delay time in seconds before MAC learning is re-enabled}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet mso_site "Manage sites" b
mso_site: >
	apic_password=${1:# The password for the APICs.}
	apic_site_id=${2:# The site ID of the APICs.}
	apic_username=${3:admin}
	site=${4:# The name of the site.}
	host=${5:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${6:# The password to use for authentication.}

	labels=${7:# The labels for this site.}
	location=${8:# Location of the site.}
	urls=${9:# A list of URLs to reference the APICs.}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for the REST connection.}
	username=${12:admin}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet aci_taboo_contract "Manage taboo contracts (vz:BrCP)" b
aci_taboo_contract: >
	taboo_contract=${1:# The name of the Taboo Contract.}
	tenant=${2:# The name of the tenant.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# The description for the Taboo Contract.}
	scope=${7:application-profile|context|global|tenant}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet aci_contract "Manage contract resources (vz:BrCP)" b
aci_contract: >
	contract=${1:# The name of the contract.}
	tenant=${2:# The name of the tenant.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# Description for the contract.}
	scope=${7:application-profile|context|global|tenant}
	priority=${8:level1|level2|level3|unspecified}
	dscp=${9:AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet aci_fabric_node "Manage Fabric Node Members (fabric:NodeIdentP)" b
aci_fabric_node: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	pod_id=${4:# The pod id of the new Fabric Node Member.}
	serial=${5:# Serial Number for the new Fabric Node Member.}
	node_id=${6:# Node ID Number for the new Fabric Node Member.}
	switch=${7:# Switch Name for the new Fabric Node Member.}
	description=${8:# Description for the new Fabric Node Member.}
	role=${9:leaf|spine|unspecified}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet aci_firmware_group "This module creates a firmware group" b
aci_firmware_group: >
	group=${1:# This the name of the firmware group}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	firmwarepol=${5:# This is the name of the firmware policy, which was create by aci_firmware_policy. It is important that}
	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_firmware_policy "This creates a firmware policy" b
aci_firmware_policy: >
	name=${1:# Name of the firmware policy}
	version=${2:# The version of the firmware associated with this policy. This value is very import as well as constructing}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	ignoreCompat=${6:# Check if compatibility checks should be ignored}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_interface_policy_ospf "Manage OSPF interface policies (ospf:IfPol)" b
aci_interface_policy_ospf: >
	tenant=${1:# The name of the Tenant the OSPF interface policy should belong to.}
	ospf=${2:# The OSPF interface policy name.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# The description for the OSPF interface.}
	network_type=${7:bcast|p2p}
	cost=${8:# The OSPF cost of the interface.}
	controls=${9:advert-subnet|bfd|mtu-ignore|passive}
	dead_interval=${10:# The interval between hello packets from a neighbor before the router declares the neighbor as down.}
	hello_interval=${11:# The interval between hello packets that OSPF sends on the interface.}
	prefix_suppression=${12:# Whether prefix suppressions is enabled or disabled.}
	priority=${13:# The priority for the OSPF interface profile.}
	retransmit_interval=${14:# The interval between LSA retransmissions.}
	transmit_delay=${15:# The delay time needed to send an LSA update packet.}
	state=${16:absent|#present|query}
	port=${17:# Port number to be used for REST connection.}
	username=${18:admin}
	certificate_name=${19:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${20:debug|info|#normal}
	timeout=${21:30}
	use_proxy=${22:yes}
	use_ssl=${23:yes}
	validate_certs=${24:yes}

endsnippet

snippet aci_epg_to_contract "Bind EPGs to Contracts (fv:RsCons, fv:RsProv)" b
aci_epg_to_contract: >
	contract_type=${1:consumer|provider}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	ap=${5:# Name of an existing application network profile, that will contain the EPGs.}
	contract=${6:# The name of the contract.}
	epg=${7:# The name of the end point group.}
	priority=${8:level1|level2|level3|unspecified}
	provider_match=${9:all|at_least_one|at_most_one|none}
	state=${10:absent|#present|query}
	tenant=${11:# Name of an existing tenant.}
	port=${12:# Port number to be used for REST connection.}
	username=${13:admin}
	certificate_name=${14:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${15:debug|info|#normal}
	timeout=${16:30}
	use_proxy=${17:yes}
	use_ssl=${18:yes}
	validate_certs=${19:yes}

endsnippet

snippet mso_schema_template_vrf "Manage VRFs in schema templates" b
mso_schema_template_vrf: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	host=${3:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${4:# The password to use for authentication.}

	vrf=${5:# The name of the VRF to manage.}
	display_name=${6:# The name as displayed on the MSO web interface.}
	layer3_multicast=${7:# Whether to enable L3 multicast.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_encap_pool_range "Manage encap ranges assigned to pools (fvns:EncapBlk, fvns:VsanEncapBlk)" b
aci_encap_pool_range: >
	pool_type=${1:vlan|vxlan|vsan}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	allocation_mode=${5:dynamic|inherit|static}
	description=${6:# Description for the pool range.}
	pool=${7:# The name of the pool that the range should be assigned to.}
	pool_allocation_mode=${8:dynamic|static}
	range_end=${9:# The end of encap range.}
	range_name=${10:# The name to give to the encap range.}
	range_start=${11:# The start of the encap range.}
	state=${12:absent|#present|query}
	port=${13:# Port number to be used for REST connection.}
	username=${14:admin}
	certificate_name=${15:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${16:debug|info|#normal}
	timeout=${17:30}
	use_proxy=${18:yes}
	use_ssl=${19:yes}
	validate_certs=${20:yes}

endsnippet

snippet aci_interface_policy_port_channel "Manage port channel interface policies (lacp:LagPol)" b
aci_interface_policy_port_channel: >
	port_channel=${1:# Name of the port channel.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the port channel.}
	max_links=${6:# Maximum links.}
	min_links=${7:# Minimum links.}
	mode=${8:active|mac-pin|mac-pin-nicload|off|passive}
	fast_select=${9:# Determines if Fast Select is enabled for Hot Standby Ports.}
	graceful_convergence=${10:# Determines if Graceful Convergence is enabled.}
	load_defer=${11:# Determines if Load Defer is enabled.}
	suspend_individual=${12:# Determines if Suspend Individual is enabled.}
	symmetric_hash=${13:# Determines if Symmetric Hashing is enabled.}
	state=${14:absent|#present|query}
	port=${15:# Port number to be used for REST connection.}
	username=${16:admin}
	certificate_name=${17:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${18:debug|info|#normal}
	timeout=${19:30}
	use_proxy=${20:yes}
	use_ssl=${21:yes}
	validate_certs=${22:yes}

endsnippet

snippet aci_switch_policy_leaf_profile "Manage switch policy leaf profiles (infra:NodeP)" b
aci_switch_policy_leaf_profile: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	leaf_profile=${4:# The name of the Leaf Profile.}
	description=${5:# Description for the Leaf Profile.}
	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_vlan_pool_encap_block "Manage encap blocks assigned to VLAN pools (fvns:EncapBlk)" b
aci_vlan_pool_encap_block: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	allocation_mode=${4:dynamic|inherit|static}
	description=${5:# Description for the pool encap block.}
	pool=${6:# The name of the pool that the encap block should be assigned to.}
	pool_allocation_mode=${7:dynamic|static}
	block_end=${8:# The end of encap block.}
	block_name=${9:# The name to give to the encap block.}
	block_start=${10:# The start of the encap block.}
	state=${11:absent|#present|query}
	port=${12:# Port number to be used for REST connection.}
	username=${13:admin}
	certificate_name=${14:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${15:debug|info|#normal}
	timeout=${16:30}
	use_proxy=${17:yes}
	use_ssl=${18:yes}
	validate_certs=${19:yes}

endsnippet

snippet aci_maintenance_group_node "Manage maintenance group nodes" b
aci_maintenance_group_node: >
	group=${1:# The maintenance group name that you want to add the node to.}
	node=${2:# The node to be added to the maintenance group.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet mso_schema "Manage schemas" b
mso_schema: >
	schema=${1:# The name of the schema.}
	host=${2:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${3:# The password to use for authentication.}

	templates=${4:# A list of templates for this schema.}
	sites=${5:# A list of sites mapped to templates in this schema.}
	state=${6:absent|#present|query}
	port=${7:# Port number to be used for the REST connection.}
	username=${8:admin}
	output_level=${9:debug|info|#normal}
	timeout=${10:30}
	use_proxy=${11:yes}
	use_ssl=${12:yes}
	validate_certs=${13:yes}

endsnippet

snippet mso_schema_site_bd_l3out "Manage site-local BD l3out's in schema template" b
mso_schema_site_bd_l3out: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	bd=${6:# The name of the BD.}
	l3out=${7:# The name of the l3out.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_maintenance_group "This creates an ACI maintenance group" b
aci_maintenance_group: >
	group=${1:# This is the name of the group}
	policy=${2:# This is the name of the policy that was created using aci_maintenance_policy}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet mso_schema_site_anp_epg_domain "Manage site-local EPG domains in schema template" b
mso_schema_site_anp_epg_domain: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	anp=${6:# The name of the ANP.}
	epg=${7:# The name of the EPG.}
	domain_association_type=${8:vmmDomain|l3ExtDomain|l2ExtDomain|physicalDomain|fibreChannel}
	domain_profile=${9:# The domain profile name.}
	deployment_immediacy=${10:immediate|lazy}
	resolution_immediacy=${11:immediate|lazy|pre-provision}
	micro_seg_vlan_type=${12:# Virtual LAN type for microsegmentation. This attribute can only be used with vmmDomain domain association.}
	micro_seg_vlan=${13:# Virtual LAN for microsegmentation. This attribute can only be used with vmmDomain domain association.}
	port_encap_vlan_type=${14:# Virtual LAN type for port encap. This attribute can only be used with vmmDomain domain association.}
	port_encap_vlan=${15:# Virtual LAN type for port encap. This attribute can only be used with vmmDomain domain association.}
	vlan_encap_mode=${16:static|dynamic}
	allow_micro_segmentation=${17:# Specifies microsegmentation is enabled or not. This attribute can only be used with vmmDomain domain association.}
	switch_type=${18:# Which switch type to use with this domain association. This attribute can only be used with vmmDomain domain association.}
	switching_mode=${19:# Which switching mode to use with this domain association. This attribute can only be used with vmmDomain domain association.}
	enhanced_lagpolicy_name=${20:# EPG enhanced lagpolicy name. This attribute can only be used with vmmDomain domain association.}
	enhanced_lagpolicy_dn=${21:# Distinguished name of EPG lagpolicy. This attribute can only be used with vmmDomain domain association.}
	state=${22:absent|#present|query}
	port=${23:# Port number to be used for the REST connection.}
	username=${24:admin}
	output_level=${25:debug|info|#normal}
	timeout=${26:30}
	use_proxy=${27:yes}
	use_ssl=${28:yes}
	validate_certs=${29:yes}

endsnippet

snippet aci_interface_selector_to_switch_policy_leaf_profile "Bind interface selector profiles to switch policy leaf profiles (infra:RsAccPortP)" b
aci_interface_selector_to_switch_policy_leaf_profile: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	leaf_profile=${4:# Name of the Leaf Profile to which we add a Selector.}
	interface_selector=${5:# Name of Interface Profile Selector to be added and associated with the Leaf Profile.}
	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_access_sub_port_block_to_access_port "Manage sub port blocks of Fabric interface policy leaf profile interface selectors (infra:HPortS, infra:SubPortBlk)" b
aci_access_sub_port_block_to_access_port: >
	leaf_interface_profile=${1:# The name of the Fabric access policy leaf interface profile.}
	access_port_selector=${2:# The name of the Fabric access policy leaf interface profile access port selector.}
	leaf_port_blk=${3:# The name of the Fabric access policy leaf interface profile access port block.}
	from_port=${4:# The beginning (from-range) of the port range block for the leaf access port block.}
	to_port=${5:# The end (to-range) of the port range block for the leaf access port block.}
	from_sub_port=${6:# The beginning (from-range) of the sub port range block for the leaf access port block.}
	to_sub_port=${7:# The end (to-range) of the sub port range block for the leaf access port block.}
	host=${8:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${9:# The password to use for authentication.}
	private_key=${10:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	leaf_port_blk_description=${11:# The description to assign to the C(leaf_port_blk).}
	from_card=${12:# The beginning (from-range) of the card range block for the leaf access port block.}
	to_card=${13:# The end (to-range) of the card range block for the leaf access port block.}
	state=${14:absent|#present|query}
	port=${15:# Port number to be used for REST connection.}
	username=${16:admin}
	certificate_name=${17:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${18:debug|info|#normal}
	timeout=${19:30}
	use_proxy=${20:yes}
	use_ssl=${21:yes}
	validate_certs=${22:yes}

endsnippet

snippet mso_role "Manage roles" b
mso_role: >
	role=${1:# The name of the role.}
	host=${2:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${3:# The password to use for authentication.}

	display_name=${4:# The name of the role to be displayed in the web UI.}
	description=${5:# The description of the role.}
	permissions=${6:backup-db|manage-audit-records|manage-labels|manage-roles|manage-schemas|manage-sites|manage-tenants|manage-tenant-schemas|manage-users|platform-logs|view-all-audit-records|view-labels|view-roles|view-schemas|view-sites|view-tenants|view-tenant-schemas|view-users}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for the REST connection.}
	username=${9:admin}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet mso_schema_template_externalepg "Manage external EPGs in schema templates" b
mso_schema_template_externalepg: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	host=${3:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${4:# The password to use for authentication.}

	externalepg=${5:# The name of the external EPG to manage.}
	display_name=${6:# The name as displayed on the MSO web interface.}
	vrf=${7:# The VRF associated to this ANP.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_bd_subnet "Manage Subnets (fv:Subnet)" b
aci_bd_subnet: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	bd=${4:# The name of the Bridge Domain.}
	description=${5:# The description for the Subnet.}
	enable_vip=${6:# Determines if the Subnet should be treated as a VIP; used when the BD is extended to multiple sites.}
	gateway=${7:# The IPv4 or IPv6 gateway address for the Subnet.}
	mask=${8:# The subnet mask for the Subnet.}
	nd_prefix_policy=${9:# The IPv6 Neighbor Discovery Prefix Policy to associate with the Subnet.}
	preferred=${10:# Determines if the Subnet is preferred over all available Subnets. Only one Subnet per Address Family (IPv4/IPv6). can be preferred in the Bridge Domain.}
	route_profile=${11:# The Route Profile to the associate with the Subnet.}
	route_profile_l3_out=${12:# The L3 Out that contains the associated Route Profile.}
	scope=${13:private|public|shared}
	subnet_control=${14:nd_ra|no_gw|querier_ip|unspecified}
	subnet_name=${15:# The name of the Subnet.}
	tenant=${16:# The name of the Tenant.}
	state=${17:absent|#present|query}
	port=${18:# Port number to be used for REST connection.}
	username=${19:admin}
	certificate_name=${20:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${21:debug|info|#normal}
	timeout=${22:30}
	use_proxy=${23:yes}
	use_ssl=${24:yes}
	validate_certs=${25:yes}

endsnippet

snippet mso_schema_template_filter_entry "Manage filter entries in schema templates" b
mso_schema_template_filter_entry: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	filter=${3:# The name of the filter to manage.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	filter_display_name=${6:# The name as displayed on the MSO web interface.}
	entry=${7:# The filter entry name to manage.}
	display_name=${8:# The name as displayed on the MSO web interface.}
	description=${9:# The description of this filer entry.}
	ethertype=${10:arp|fcoe|ip|ipv4|ipv6|mac-security|mpls-unicast|trill|unspecified}
	ip_protocol=${11:eigrp|egp|icmp|icmpv6|igmp|igp|l2tp|ospfigp|pim|tcp|udp|unspecified}
	tcp_session_rules=${12:acknowledgement|established|finish|synchronize|reset|unspecified}
	source_from=${13:# The source port range from.}
	source_to=${14:# The source port range to.}
	destination_from=${15:# The destination port range from.}
	destination_to=${16:# The destination port range to.}
	arp_flag=${17:reply|request|unspecified}
	stateful=${18:no}
	fragments_only=${19:no}
	state=${20:absent|#present|query}
	port=${21:# Port number to be used for the REST connection.}
	username=${22:admin}
	output_level=${23:debug|info|#normal}
	timeout=${24:30}
	use_proxy=${25:yes}
	use_ssl=${26:yes}
	validate_certs=${27:yes}

endsnippet

snippet aci_encap_pool "Manage encap pools (fvns:VlanInstP, fvns:VxlanInstP, fvns:VsanInstP)" b
aci_encap_pool: >
	pool_type=${1:vlan|vsan|vxlan}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# Description for the C(pool).}
	pool=${6:# The name of the pool.}
	pool_allocation_mode=${7:dynamic|static}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet aci_contract_subject_to_filter "Bind Contract Subjects to Filters (vz:RsSubjFiltAtt)" b
aci_contract_subject_to_filter: >
	tenant=${1:# The name of the tenant.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	contract=${5:# The name of the contract.}
	filter=${6:# The name of the Filter to bind to the Subject.}
	log=${7:log|none}
	subject=${8:# The name of the Contract Subject.}
	state=${9:absent|#present|query}
	port=${10:# Port number to be used for REST connection.}
	username=${11:admin}
	certificate_name=${12:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${13:debug|info|#normal}
	timeout=${14:30}
	use_proxy=${15:yes}
	use_ssl=${16:yes}
	validate_certs=${17:yes}

endsnippet

snippet aci_domain "Manage physical, virtual, bridged, routed or FC domain profiles (phys:DomP, vmm:DomP, l2ext:DomP, l3ext:DomP, fc:DomP)" b
aci_domain: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	domain=${4:# Name of the physical, virtual, bridged routed or FC domain profile.}
	domain_type=${5:fc|l2dom|l3dom|phys|vmm}
	dscp=${6:AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified}
	encap_mode=${7:unknown|vlan|vxlan}
	multicast_address=${8:# The multicast IP address to use for the virtual switch.}
	state=${9:absent|#present|query}
	vm_provider=${10:cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware}
	vswitch=${11:avs|default|dvs|unknown}
	port=${12:# Port number to be used for REST connection.}
	username=${13:admin}
	certificate_name=${14:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${15:debug|info|#normal}
	timeout=${16:30}
	use_proxy=${17:yes}
	use_ssl=${18:yes}
	validate_certs=${19:yes}

endsnippet

snippet aci_access_port_to_interface_policy_leaf_profile "Manage Fabric interface policy leaf profile interface selectors (infra:HPortS, infra:RsAccBaseGrp, infra:PortBlk)" b
aci_access_port_to_interface_policy_leaf_profile: >
	leaf_interface_profile=${1:# The name of the Fabric access policy leaf interface profile.}
	access_port_selector=${2:# The name of the Fabric access policy leaf interface profile access port selector.}
	leaf_port_blk=${3:# B(Deprecated)}
	from_port=${4:# B(Deprecated)}
	to_port=${5:# B(Deprecated)}
	host=${6:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${7:# The password to use for authentication.}
	private_key=${8:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${9:# The description to assign to the C(access_port_selector)}
	leaf_port_blk_description=${10:# B(Deprecated)}
	from_card=${11:# B(Deprecated)}
	to_card=${12:# B(Deprecated)}
	policy_group=${13:# The name of the fabric access policy group to be associated with the leaf interface profile interface selector.}
	interface_type=${14:breakout|fex|port_channel|#switch_port|vpc}
	state=${15:absent|#present|query}
	port=${16:# Port number to be used for REST connection.}
	username=${17:admin}
	certificate_name=${18:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${19:debug|info|#normal}
	timeout=${20:30}
	use_proxy=${21:yes}
	use_ssl=${22:yes}
	validate_certs=${23:yes}

endsnippet

snippet aci_interface_policy_cdp "Manage CDP interface policies (cdp:IfPol)" b
aci_interface_policy_cdp: >
	cdp_policy=${1:# The CDP interface policy name.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the CDP interface policy name.}
	admin_state=${6:# Enable or Disable CDP state.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_config_rollback "Provides rollback and rollback preview functionality (config:ImportP)" b
aci_config_rollback: >
	export_policy=${1:# The export policy that the C(snapshot) is associated to.}
	snapshot=${2:# The name of the snapshot to rollback to, or the base snapshot to use for comparison.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	compare_export_policy=${6:# The export policy that the C(compare_snapshot) is associated to.}
	compare_snapshot=${7:# The name of the snapshot to compare with C(snapshot).}
	description=${8:# The description for the Import Policy.}
	fail_on_decrypt=${9:# Determines if the APIC should fail the rollback if unable to decrypt secured data.}
	import_mode=${10:atomic|best-effort}
	import_policy=${11:# The name of the Import Policy to use for config rollback.}
	import_type=${12:merge|replace}
	state=${13:preview|#rollback}
	port=${14:# Port number to be used for REST connection.}
	username=${15:admin}
	certificate_name=${16:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${17:debug|info|#normal}
	timeout=${18:30}
	use_proxy=${19:yes}
	use_ssl=${20:yes}
	validate_certs=${21:yes}

endsnippet

snippet aci_tenant_ep_retention_policy "Manage End Point (EP) retention protocol policies (fv:EpRetPol)" b
aci_tenant_ep_retention_policy: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	tenant=${4:# The name of an existing tenant.}
	epr_policy=${5:# The name of the end point retention policy.}
	bounce_age=${6:# Bounce entry aging interval in seconds.}
	bounce_trigger=${7:coop|flood}
	hold_interval=${8:# Hold interval in seconds.}
	local_ep_interval=${9:# Local end point aging interval in seconds.}
	remote_ep_interval=${10:# Remote end point aging interval in seconds.}
	move_frequency=${11:# Move frequency per second.}
	description=${12:# Description for the End point retention policy.}
	state=${13:absent|#present|query}
	port=${14:# Port number to be used for REST connection.}
	username=${15:admin}
	certificate_name=${16:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${17:debug|info|#normal}
	timeout=${18:30}
	use_proxy=${19:yes}
	use_ssl=${20:yes}
	validate_certs=${21:yes}

endsnippet

snippet mso_schema_site_bd "Manage site-local Bridge Domains (BDs) in schema template" b
mso_schema_site_bd: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	bd=${6:# The name of the BD to manage.}
	host_route=${7:# Whether host-based routing is enabled.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_access_port_block_to_access_port "Manage port blocks of Fabric interface policy leaf profile interface selectors (infra:HPortS, infra:PortBlk)" b
aci_access_port_block_to_access_port: >
	leaf_interface_profile=${1:# The name of the Fabric access policy leaf interface profile.}
	access_port_selector=${2:# The name of the Fabric access policy leaf interface profile access port selector.}
	leaf_port_blk=${3:# The name of the Fabric access policy leaf interface profile access port block.}
	from_port=${4:# The beginning (from-range) of the port range block for the leaf access port block.}
	to_port=${5:# The end (to-range) of the port range block for the leaf access port block.}
	host=${6:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${7:# The password to use for authentication.}
	private_key=${8:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	leaf_port_blk_description=${9:# The description to assign to the C(leaf_port_blk).}
	from_card=${10:# The beginning (from-range) of the card range block for the leaf access port block.}
	to_card=${11:# The end (to-range) of the card range block for the leaf access port block.}
	state=${12:absent|#present|query}
	port=${13:# Port number to be used for REST connection.}
	username=${14:admin}
	certificate_name=${15:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${16:debug|info|#normal}
	timeout=${17:30}
	use_proxy=${18:yes}
	use_ssl=${19:yes}
	validate_certs=${20:yes}

endsnippet

snippet mso_schema_site_anp_epg_subnet "Manage site-local EPG subnets in schema template" b
mso_schema_site_anp_epg_subnet: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	subnet=${4:# The IP range in CIDR notation.}
	host=${5:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${6:# The password to use for authentication.}

	anp=${7:# The name of the ANP.}
	epg=${8:# The name of the EPG.}
	description=${9:# The description of this subnet.}
	scope=${10:private|public}
	shared=${11:# Whether this subnet is shared between VRFs.}
	no_default_gateway=${12:# Whether this subnet has a default gateway.}
	state=${13:absent|#present|query}
	port=${14:# Port number to be used for the REST connection.}
	username=${15:admin}
	output_level=${16:debug|info|#normal}
	timeout=${17:30}
	use_proxy=${18:yes}
	use_ssl=${19:yes}
	validate_certs=${20:yes}

endsnippet

snippet aci_bd_to_l3out "Bind Bridge Domain to L3 Out (fv:RsBDToOut)" b
aci_bd_to_l3out: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	bd=${4:# The name of the Bridge Domain.}
	l3out=${5:# The name of the l3out to associate with th Bridge Domain.}
	tenant=${6:# The name of the Tenant.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_rest "Direct access to the Cisco APIC REST API" b
aci_rest: >
	path=${1:# URI being used to execute API calls.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	method=${5:delete|#get|post}
	content=${6:# When used instead of C(src), sets the payload of the API request directly.}
	src=${7:# Name of the absolute path of the filename that includes the body of the HTTP request being sent to the ACI fabric.}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_tenant "Manage tenants (fv:Tenant)" b
aci_tenant: >
	tenant=${1:# The name of the tenant.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# Description for the tenant.}
	state=${6:absent|#present|query}
	port=${7:# Port number to be used for REST connection.}
	username=${8:admin}
	certificate_name=${9:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_interface_policy_leaf_policy_group "Manage fabric interface policy leaf policy groups (infra:AccBndlGrp, infra:AccPortGrp)" b
aci_interface_policy_leaf_policy_group: >
	lag_type=${1:leaf|link|node}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	policy_group=${5:# Name of the leaf policy group to be added/deleted.}
	description=${6:# Description for the leaf policy group to be created.}
	link_level_policy=${7:# Choice of link_level_policy to be used as part of the leaf policy group to be created.}
	cdp_policy=${8:# Choice of cdp_policy to be used as part of the leaf policy group to be created.}
	mcp_policy=${9:# Choice of mcp_policy to be used as part of the leaf policy group to be created.}
	lldp_policy=${10:# Choice of lldp_policy to be used as part of the leaf policy group to be created.}
	stp_interface_policy=${11:# Choice of stp_interface_policy to be used as part of the leaf policy group to be created.}
	egress_data_plane_policing_policy=${12:# Choice of egress_data_plane_policing_policy to be used as part of the leaf policy group to be created.}
	ingress_data_plane_policing_policy=${13:# Choice of ingress_data_plane_policing_policy to be used as part of the leaf policy group to be created.}
	priority_flow_control_policy=${14:# Choice of priority_flow_control_policy to be used as part of the leaf policy group to be created.}
	fibre_channel_interface_policy=${15:# Choice of fibre_channel_interface_policy to be used as part of the leaf policy group to be created.}
	slow_drain_policy=${16:# Choice of slow_drain_policy to be used as part of the leaf policy group to be created.}
	port_channel_policy=${17:# Choice of port_channel_policy to be used as part of the leaf policy group to be created.}
	monitoring_policy=${18:# Choice of monitoring_policy to be used as part of the leaf policy group to be created.}
	storm_control_interface_policy=${19:# Choice of storm_control_interface_policy to be used as part of the leaf policy group to be created.}
	l2_interface_policy=${20:# Choice of l2_interface_policy to be used as part of the leaf policy group to be created.}
	port_security_policy=${21:# Choice of port_security_policy to be used as part of the leaf policy group to be created.}
	aep=${22:# Choice of attached_entity_profile (AEP) to be used as part of the leaf policy group to be created.}
	state=${23:absent|#present|query}
	port=${24:# Port number to be used for REST connection.}
	username=${25:admin}
	certificate_name=${26:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${27:debug|info|#normal}
	timeout=${28:30}
	use_proxy=${29:yes}
	use_ssl=${30:yes}
	validate_certs=${31:yes}

endsnippet

snippet aci_aaa_user "Manage AAA users (aaa:User)" b
aci_aaa_user: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	aaa_password=${4:# The password of the locally-authenticated user.}
	aaa_password_lifetime=${5:# The lifetime of the locally-authenticated user password.}
	aaa_password_update_required=${6:# Whether this account needs password update.}
	aaa_user=${7:# The name of the locally-authenticated user user to add.}
	clear_password_history=${8:# Whether to clear the password history of a locally-authenticated user.}
	description=${9:# Description for the AAA user.}
	email=${10:# The email address of the locally-authenticated user.}
	enabled=${11:# The status of the locally-authenticated user account.}
	expiration=${12:# The expiration date of the locally-authenticated user account.}
	expires=${13:# Whether to enable an expiration date for the locally-authenticated user account.}
	first_name=${14:# The first name of the locally-authenticated user.}
	last_name=${15:# The last name of the locally-authenticated user.}
	phone=${16:# The phone number of the locally-authenticated user.}
	state=${17:absent|#present|query}
	port=${18:# Port number to be used for REST connection.}
	username=${19:admin}
	certificate_name=${20:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${21:debug|info|#normal}
	timeout=${22:30}
	use_proxy=${23:yes}
	use_ssl=${24:yes}
	validate_certs=${25:yes}

endsnippet

snippet aci_fabric_scheduler "This modules creates ACI schedulers." b
aci_fabric_scheduler: >
	name=${1:# The name of the Scheduler.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# Description for the Scheduler.}
	recurring=${6:no}
	windowname=${7:# This is the name for your what recurring or oneTime execution}
	concurCap=${8:# This is the amount of devices that can be executed on at a time}
	maxTime=${9:# This is the amount MAX amount of time a process can be executed}
	date=${10:# This is the date and time that the scheduler will execute}
	hour=${11:# This set the hour of execution}
	minute=${12:# This sets the minute of execution, used in conjunction with hour}
	day=${13:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday|even-day|odd-day|#every-day}
	state=${14:absent|#present|query}
	port=${15:# Port number to be used for REST connection.}
	username=${16:admin}
	certificate_name=${17:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${18:debug|info|#normal}
	timeout=${19:30}
	use_proxy=${20:yes}
	use_ssl=${21:yes}
	validate_certs=${22:yes}

endsnippet

snippet aci_aep "Manage attachable Access Entity Profile (AEP) objects (infra:AttEntityP, infra:ProvAcc)" b
aci_aep: >
	aep=${1:# The name of the Attachable Access Entity Profile.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# Description for the AEP.}
	infra_vlan=${6:# Enable infrastructure VLAN.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_l3out_extepg "Manage External Network Instance Profile (ExtEpg) objects (l3extInstP:instP)" b
aci_l3out_extepg: >
	tenant=${1:# Name of an existing tenant.}
	l3out=${2:# Name of an existing L3Out.}
	extepg=${3:# Name of ExtEpg being created.}
	host=${4:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${5:# The password to use for authentication.}
	private_key=${6:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${7:# Description for the ExtEpg.}
	preferred_group=${8:# Whether ot not the EPG is part of the Preferred Group and can communicate without contracts.}
	dscp=${9:AF11|AF12|AF13|AF21|AF22|AF23|AF31|AF32|AF33|AF41|AF42|AF43|CS0|CS1|CS2|CS3|CS4|CS5|CS6|CS7|EF|VA|unspecified}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet mso_label "Manage labels" b
mso_label: >
	label=${1:# The name of the label.}
	host=${2:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${3:# The password to use for authentication.}

	type=${4:#site}
	state=${5:absent|#present|query}
	port=${6:# Port number to be used for the REST connection.}
	username=${7:admin}
	output_level=${8:debug|info|#normal}
	timeout=${9:30}
	use_proxy=${10:yes}
	use_ssl=${11:yes}
	validate_certs=${12:yes}

endsnippet

snippet mso_schema_site_vrf_region "Manage site-local VRF regions in schema template" b
mso_schema_site_vrf_region: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	vrf=${6:# The name of the VRF.}
	region=${7:# The name of the region to manage.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet mso_schema_template_l3out "Manage l3outs in schema templates" b
mso_schema_template_l3out: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	host=${3:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${4:# The password to use for authentication.}

	l3out=${5:# The name of the l3out to manage.}
	display_name=${6:# The name as displayed on the MSO web interface.}
	vrf=${7:# The VRF associated to this L3out.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for the REST connection.}
	username=${10:admin}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet mso_schema_template_anp_epg_subnet "Manage EPG subnets in schema templates" b
mso_schema_template_anp_epg_subnet: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template to change.}
	anp=${3:# The name of the ANP.}
	epg=${4:# The name of the EPG to manage.}
	subnet=${5:# The IP range in CIDR notation.}
	host=${6:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${7:# The password to use for authentication.}

	description=${8:# The description of this subnet.}
	scope=${9:private|public}
	shared=${10:# Whether this subnet is shared between VRFs.}
	no_default_gateway=${11:# Whether this subnet has a default gateway.}
	state=${12:absent|#present|query}
	port=${13:# Port number to be used for the REST connection.}
	username=${14:admin}
	output_level=${15:debug|info|#normal}
	timeout=${16:30}
	use_proxy=${17:yes}
	use_ssl=${18:yes}
	validate_certs=${19:yes}

endsnippet

snippet aci_epg_monitoring_policy "Manage monitoring policies (mon:EPGPol)" b
aci_epg_monitoring_policy: >
	monitoring_policy=${1:# The name of the monitoring policy.}
	tenant=${2:# The name of the tenant.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# Description for the monitoring policy.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet aci_interface_policy_port_channel "Manage port channel interface policies (lacp:LagPol)" b
aci_interface_policy_port_channel: >
	port_channel=${1:# Name of the port channel.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the port channel.}
	max_links=${6:# Maximum links.}
	min_links=${7:# Minimum links.}
	mode=${8:active|mac-pin|mac-pin-nicload|off|passive}
	fast_select=${9:# Determines if Fast Select is enabled for Hot Standby Ports.}
	graceful_convergence=${10:# Determines if Graceful Convergence is enabled.}
	load_defer=${11:# Determines if Load Defer is enabled.}
	suspend_individual=${12:# Determines if Suspend Individual is enabled.}
	symmetric_hash=${13:# Determines if Symmetric Hashing is enabled.}
	state=${14:absent|#present|query}
	port=${15:# Port number to be used for REST connection.}
	username=${16:admin}
	certificate_name=${17:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${18:debug|info|#normal}
	timeout=${19:30}
	use_proxy=${20:yes}
	use_ssl=${21:yes}
	validate_certs=${22:yes}

endsnippet

snippet aci_l3out_route_tag_policy "Manage route tag policies (l3ext:RouteTagPol)" b
aci_l3out_route_tag_policy: >
	rtp=${1:# The name of the route tag policy.}
	tenant=${2:# The name of the tenant.}
	host=${3:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${4:# The password to use for authentication.}
	private_key=${5:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${6:# The description for the route tag policy.}
	tag=${7:# The value of the route tag.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet aci_epg_to_domain "Bind EPGs to Domains (fv:RsDomAtt)" b
aci_epg_to_domain: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	allow_useg=${4:encap|useg}
	ap=${5:# Name of an existing application network profile, that will contain the EPGs.}
	deploy_immediacy=${6:immediate|lazy}
	domain=${7:# Name of the physical or virtual domain being associated with the EPG.}
	domain_type=${8:l2dom|phys|vmm}
	encap=${9:# The VLAN encapsulation for the EPG when binding a VMM Domain with static C(encap_mode).}
	encap_mode=${10:auto|vlan|vxlan}
	switching_mode=${11:AVE|#native}
	epg=${12:# Name of the end point group.}
	netflow=${13:# Determines if netflow should be enabled.}
	primary_encap=${14:# Determines the primary VLAN ID when using useg.}
	resolution_immediacy=${15:immediate|lazy|pre-provision}
	state=${16:absent|#present|query}
	tenant=${17:# Name of an existing tenant.}
	vm_provider=${18:cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware}
	port=${19:# Port number to be used for REST connection.}
	username=${20:admin}
	certificate_name=${21:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${22:debug|info|#normal}
	timeout=${23:30}
	use_proxy=${24:yes}
	use_ssl=${25:yes}
	validate_certs=${26:yes}

endsnippet

snippet aci_bd "Manage Bridge Domains (BD) objects (fv:BD)" b
aci_bd: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	arp_flooding=${4:# Determines if the Bridge Domain should flood ARP traffic.}
	bd=${5:# The name of the Bridge Domain.}
	bd_type=${6:ethernet|fc}
	description=${7:# Description for the Bridge Domain.}
	enable_multicast=${8:# Determines if PIM is enabled.}
	enable_routing=${9:# Determines if IP forwarding should be allowed.}
	endpoint_clear=${10:# Clears all End Points in all Leaves when C(yes).}
	endpoint_move_detect=${11:default|garp}
	endpoint_retention_action=${12:inherit|resolve}
	endpoint_retention_policy=${13:# The name of the End Point Retention Policy the Bridge Domain should use when overriding the default End Point Retention Policy.}
	igmp_snoop_policy=${14:# The name of the IGMP Snooping Policy the Bridge Domain should use when overriding the default IGMP Snooping Policy.}
	ip_learning=${15:# Determines if the Bridge Domain should learn End Point IPs.}
	ipv6_nd_policy=${16:# The name of the IPv6 Neighbor Discovery Policy the Bridge Domain should use when overridding the default IPV6 ND Policy.}
	l2_unknown_unicast=${17:proxy|flood}
	l3_unknown_multicast=${18:flood|opt-flood}
	limit_ip_learn=${19:# Determines if the BD should limit IP learning to only subnets owned by the Bridge Domain.}
	mac_address=${20:# The MAC Address to assign to the C(bd) instead of using the default.}
	multi_dest=${21:bd-flood|drop|encap-flood}
	state=${22:absent|#present|query}
	tenant=${23:# The name of the Tenant.}
	vrf=${24:# The name of the VRF.}
	port=${25:# Port number to be used for REST connection.}
	username=${26:admin}
	certificate_name=${27:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${28:debug|info|#normal}
	timeout=${29:30}
	use_proxy=${30:yes}
	use_ssl=${31:yes}
	validate_certs=${32:yes}

endsnippet

snippet aci_interface_policy_lldp "Manage LLDP interface policies (lldp:IfPol)" b
aci_interface_policy_lldp: >
	lldp_policy=${1:# The LLDP interface policy name.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the LLDP interface policy name.}
	receive_state=${6:# Enable or disable Receive state.}
	transmit_state=${7:# Enable or Disable Transmit state.}
	state=${8:absent|#present|query}
	port=${9:# Port number to be used for REST connection.}
	username=${10:admin}
	certificate_name=${11:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${12:debug|info|#normal}
	timeout=${13:30}
	use_proxy=${14:yes}
	use_ssl=${15:yes}
	validate_certs=${16:yes}

endsnippet

snippet mso_user "Manage users" b
mso_user: >
	user=${1:# The name of the user.}
	host=${2:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${3:# The password to use for authentication.}

	user_password=${4:# The password of the user.}
	first_name=${5:# The first name of the user.}
	last_name=${6:# The last name of the user.}
	email=${7:# The email address of the user.}
	phone=${8:# The phone number of the user.}
	account_status=${9:active}
	domain=${10:# The domain this user belongs to.}
	roles=${11:# The roles for this user.}
	state=${12:absent|#present|query}
	port=${13:# Port number to be used for the REST connection.}
	username=${14:admin}
	output_level=${15:debug|info|#normal}
	timeout=${16:30}
	use_proxy=${17:yes}
	use_ssl=${18:yes}
	validate_certs=${19:yes}

endsnippet

snippet aci_interface_policy_mcp "Manage MCP interface policies (mcp:IfPol)" b
aci_interface_policy_mcp: >
	mcp=${1:# The name of the MCP interface.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${5:# The description for the MCP interface.}
	admin_state=${6:# Enable or disable admin state.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for REST connection.}
	username=${9:admin}
	certificate_name=${10:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${11:debug|info|#normal}
	timeout=${12:30}
	use_proxy=${13:yes}
	use_ssl=${14:yes}
	validate_certs=${15:yes}

endsnippet

snippet mso_schema_template_bd "Manage Bridge Domains (BDs) in schema templates" b
mso_schema_template_bd: >
	schema=${1:# The name of the schema.}
	template=${2:# The name of the template.}
	host=${3:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${4:# The password to use for authentication.}

	bd=${5:# The name of the BD to manage.}
	display_name=${6:# The name as displayed on the MSO web interface.}
	vrf=${7:# The VRF associated to this BD. This is required only when creating a new BD.}
	subnets=${8:# The subnets associated to this BD.}
	intersite_bum_traffic=${9:# Whether to allow intersite BUM traffic.}
	optimize_wan_bandwidth=${10:# Whether to optimize WAN bandwidth.}
	layer2_stretch=${11:# Whether to enable L2 stretch.}
	layer2_unknown_unicast=${12:flood|proxy}
	layer3_multicast=${13:# Whether to enable L3 multicast.}
	state=${14:absent|#present|query}
	port=${15:# Port number to be used for the REST connection.}
	username=${16:admin}
	output_level=${17:debug|info|#normal}
	timeout=${18:30}
	use_proxy=${19:yes}
	use_ssl=${20:yes}
	validate_certs=${21:yes}

endsnippet

snippet mso_schema_site "Manage sites in schemas" b
mso_schema_site: >
	schema=${1:# The name of the schema.}
	site=${2:# The name of the site to manage.}
	template=${3:# The name of the template.}
	host=${4:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${5:# The password to use for authentication.}

	state=${6:absent|#present|query}
	port=${7:# Port number to be used for the REST connection.}
	username=${8:admin}
	output_level=${9:debug|info|#normal}
	timeout=${10:30}
	use_proxy=${11:yes}
	use_ssl=${12:yes}
	validate_certs=${13:yes}

endsnippet

snippet mso_schema_template "Manage templates in schemas" b
mso_schema_template: >
	tenant=${1:# The tenant used for this template.}
	schema=${2:# The name of the schema.}
	host=${3:# IP Address or hostname of the ACI Multi Site Orchestrator host.}
	password=${4:# The password to use for authentication.}

	template=${5:# The name of the template.}
	display_name=${6:# The name as displayed on the MSO web interface.}
	state=${7:absent|#present|query}
	port=${8:# Port number to be used for the REST connection.}
	username=${9:admin}
	output_level=${10:debug|info|#normal}
	timeout=${11:30}
	use_proxy=${12:yes}
	use_ssl=${13:yes}
	validate_certs=${14:yes}

endsnippet

snippet aci_vmm_credential "Manage virtual domain credential profiles (vmm:UsrAccP)" b
aci_vmm_credential: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	name=${4:# Name of the credential profile.}
	credential_password=${5:# VMM controller password.}
	credential_username=${6:# VMM controller username.}
	description=${7:# Description for the tenant.}
	domain=${8:# Name of the virtual domain profile.}
	state=${9:absent|#present|query}
	vm_provider=${10:cloudfoundry|kubernetes|microsoft|openshift|openstack|redhat|vmware}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet aci_firmware_source "Manage firmware image sources (firmware:OSource)" b
aci_firmware_source: >
	source=${1:# The identifying name for the outside source of images, such as an HTTP or SCP server.}
	host=${2:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${3:# The password to use for authentication.}
	private_key=${4:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	polling_interval=${5:# Polling interval in minutes.}
	url_protocol=${6:http|local|#scp|usbkey}
	url=${7:# T}
	url_password=${8:# T}
	url_username=${9:# T}
	state=${10:absent|#present|query}
	port=${11:# Port number to be used for REST connection.}
	username=${12:admin}
	certificate_name=${13:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${14:debug|info|#normal}
	timeout=${15:30}
	use_proxy=${16:yes}
	use_ssl=${17:yes}
	validate_certs=${18:yes}

endsnippet

snippet aci_switch_leaf_selector "Bind leaf selectors to switch policy leaf profiles (infra:LeafS, infra:NodeBlk, infra:RsAccNodePGrep)" b
aci_switch_leaf_selector: >
	host=${1:# IP Address or hostname of APIC resolvable by Ansible control host.}
	password=${2:# The password to use for authentication.}
	private_key=${3:# Either a PEM-formatted private key file or the private key content used for signature-based authentication.}

	description=${4:# The description to assign to the C(leaf).}
	leaf_profile=${5:# Name of the Leaf Profile to which we add a Selector.}
	leaf=${6:# Name of Leaf Selector.}
	leaf_node_blk=${7:# Name of Node Block range to be added to Leaf Selector of given Leaf Profile.}
	leaf_node_blk_description=${8:# The description to assign to the C(leaf_node_blk)}
	from=${9:# Start of Node Block range.}
	to=${10:# Start of Node Block range.}
	policy_group=${11:# Name of the Policy Group to be added to Leaf Selector of given Leaf Profile.}
	state=${12:absent|#present|query}
	port=${13:# Port number to be used for REST connection.}
	username=${14:admin}
	certificate_name=${15:# The X.509 certificate name attached to the APIC AAA user used for signature-based authentication.}
	output_level=${16:debug|info|#normal}
	timeout=${17:30}
	use_proxy=${18:yes}
	use_ssl=${19:yes}
	validate_certs=${20:yes}

endsnippet

snippet cli_config "Push text based configuration to network devices over network_cli" b
cli_config: >
	config=${1:# The config to be pushed to the network device. This argument is mutually exclusive with C(rollback) and either one of the option should be given as input. The config should have indentation that the device uses.}
	commit=${2:# The C(commit) argument instructs the module to push the configuration to the device. This is mapped to module check mode.}
	replace=${3:# If the C(replace) argument is set to C(yes), it will replace the entire running-config of the device with the C(config) argument value. For devices that support replacing running configuration from file on device like NXOS/JUNOS, the C(replace) argument takes path to the file on the device that will be used for replacing the entire running-config. The value of C(config) option should be I(None) for such devices. Nexus 9K devices only support replace. Use I(net_put) or I(nxos_file_copy) in case of NXOS module to copy the flat file to remote device and then use set the fullpath to this argument.}
	backup=${4:no}
	rollback=${5:# The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail. To rollback to the most recent commit, set the C(rollback) argument to 0. This option is mutually exclusive with C(config).}
	commit_comment=${6:# The C(commit_comment) argument specifies a text string to be used when committing the configuration. If the C(commit) argument is set to False, this argument is silently ignored. This argument is only valid for the platforms that support commit operation with comment.}
	defaults=${7:no}
	multiline_delimiter=${8:# This argument is used when pushing a multiline configuration element to the device. It specifies the character to use as the delimiting character. This only applies to the configuration action.}
	diff_replace=${9:line|block|config}
	diff_match=${10:line|strict|exact|none}
	diff_ignore_lines=${11:# Use this argument to specify one or more lines that should be ignored during the diff. This is used for lines in the configuration that are automatically updated by the system. This argument takes a list of regular expressions or exact line matches. Note that this parameter will be ignored if the platform has onbox diff support.}
	backup_options=${12:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet cli_command "Run a cli command on cli-based network devices" b
cli_command: >
	command=${1:# The command to send to the remote network device.  The resulting output from the command is returned, unless I(sendonly) is set.}

	prompt=${2:# A single regex pattern or a sequence of patterns to evaluate the expected prompt from I(command).}
	answer=${3:# The answer to reply with if I(prompt) is matched. The value can be a single answer or a list of answer for multiple prompts. In case the command execution results in multiple prompts the sequence of the prompt and excepted answer should be in same order.}
	sendonly=${4:no}
	newline=${5:yes}
	check_all=${6:no}

endsnippet

snippet icx_linkagg "Manage link aggregation groups on Ruckus ICX 7000 series switches" b
icx_linkagg: >
	group=${1:# Channel-group number for the port-channel Link aggregation group. Range 1-255 or set to 'auto' to auto-generates a LAG ID}
	name=${2:# Name of the LAG}
	mode=${3:dynamic|static}
	members=${4:# List of port members or ranges of the link aggregation group.}
	state=${5:#present|absent}
	check_running_config=${6:yes}
	aggregate=${7:# List of link aggregation definitions.}
	purge=${8:no}

endsnippet

snippet icx_interface "Manage Interface on Ruckus ICX 7000 series switches" b
icx_interface: >
	name=${1:# Name of the Interface.}
	description=${2:# Name of the description.}
	enabled=${3:yes}
	speed=${4:10-full|10-half|100-full|100-half|1000-full|1000-full-master|1000-full-slave|10g-full|10g-full-master|10g-full-slave|2500-full|2500-full-master|2500-full-slave|5g-full|5g-full-master|5g-full-slave|auto}
	stp=${5:# enable/disable stp for the interface}
	tx_rate=${6:# Transmit rate in bits per second (bps).}
	rx_rate=${7:# Receiver rate in bits per second (bps).}
	neighbors=${8:# Check the operational state of given interface C(name) for CDP/LLDP neighbor.}
	delay=${9:10}
	state=${10:#present|absent|up|down}
	power=${11:# Inline power on Power over Ethernet (PoE) ports.}
	aggregate=${12:# List of Interfaces definitions.}
	check_running_config=${13:yes}

endsnippet

snippet icx_ping "Tests reachability using ping from Ruckus ICX 7000 series switches" b
icx_ping: >
	dest=${1:# ip-addr | host-name | vrf vrf-name | ipv6 [ ipv6-addr | host-name | vrf vrf-name]  (resolvable by switch) of the remote node.}

	count=${2:# Number of packets to send. Default is 1.}
	timeout=${3:# Specifies the time, in milliseconds for which the device waits for a reply from the pinged device. The value can range from 1 to 4294967296. The default is 5000 (5 seconds).}
	ttl=${4:# Specifies the time to live as a maximum number of hops. The value can range from 1 to 255. The default is 64.}
	size=${5:# Specifies the size of the ICMP data portion of the packet, in bytes. This is the payload and does not include the header. The value can range from 0 to 10000. The default is 16..}
	source=${6:# IP address to be used as the origin of the ping packets.}
	vrf=${7:# Specifies the Virtual Routing and Forwarding (VRF) instance of the device to be pinged.}
	state=${8:absent|#present}

endsnippet

snippet icx_static_route "Manage static IP routes on Ruckus ICX 7000 series switches" b
icx_static_route: >
	prefix=${1:# Network prefix of the static route.}
	mask=${2:# Network prefix mask of the static route.}
	next_hop=${3:# Next hop IP of the static route.}
	admin_distance=${4:# Admin distance of the static route. Range is 1 to 255.}
	aggregate=${5:# L}
	purge=${6:no}
	state=${7:#present|absent}
	check_running_config=${8:yes}

endsnippet

snippet icx_lldp "Manage LLDP configuration on Ruckus ICX 7000 series switches" b
icx_lldp: >
	interfaces=${1:# specify interfaces}
	check_running_config=${2:yes}
	state=${3:present|absent|enabled|disabled}

endsnippet

snippet icx_l3_interface "Manage Layer-3 interfaces on Ruckus ICX 7000 series switches" b
icx_l3_interface: >
	name=${1:# Name of the Layer-3 interface to be configured eg. GigabitEthernet0/2, ve 10, ethernet 1/1/1}
	ipv4=${2:# IPv4 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 192.168.0.1/24}
	ipv6=${3:# IPv6 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64.}
	mode=${4:dynamic|ospf-ignore|ospf-passive}
	replace=${5:yes|no}
	secondary=${6:yes|no}
	aggregate=${7:# List of Layer-3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.}
	state=${8:#present|absent}
	check_running_config=${9:yes}

endsnippet

snippet icx_banner "Manage multiline banners on Ruckus ICX 7000 series switches" b
icx_banner: >
	banner=${1:motd|exec|incoming}

	text=${2:# The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines.}
	state=${3:#present|absent}
	enterkey=${4:no}
	check_running_config=${5:yes}

endsnippet

snippet icx_system "Manage the system attributes on Ruckus ICX 7000 series switches" b
icx_system: >
	hostname=${1:# Configure the device hostname parameter. This option takes an ASCII string value.}
	domain_name=${2:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the hostname to create a fully-qualified domain name.}
	domain_search=${3:# Provides the list of domain names to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
	name_servers=${4:# List of DNS name servers by IP address to use to perform name resolution lookups.}
	aaa_servers=${5:# Configures radius/tacacs server}
	state=${6:#present|absent}
	check_running_config=${7:yes}

endsnippet

snippet icx_facts "Collect facts from remote Ruckus ICX 7000 series switches" b
icx_facts: >
	gather_subset=${1:!config}

endsnippet

snippet icx_copy "Transfer files from or to remote Ruckus ICX 7000 series switches" b
icx_copy: >
	protocol=${1:scp|https}
	remote_server=${2:# IP address of the remote server}
	remote_filename=${3:# The name or path of the remote file/resource to be uploaded or downloaded.}

	upload=${4:running-config|startup-config|flash_primary|flash_secondary}
	download=${5:running-config|startup-config|flash_primary|flash_secondary|bootrom|fips-primary-sig|fips-secondary-sig|fips-bootrom-sig}
	remote_port=${6:# The port number of the remote host. Default values will be selected based on protocol type. Default scp:22, http:443}
	remote_user=${7:# remote username to be used for scp login.}
	remote_pass=${8:# remote password to be used for scp login.}
	public_key=${9:rsa|dsa}

endsnippet

snippet icx_config "Manage configuration sections of Ruckus ICX 7000 series switches" b
icx_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	multiline_delimiter=${8:@}
	backup=${9:no}
	defaults=${10:no}
	running_config=${11:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	save_when=${12:always|#never|modified|changed}
	diff_against=${13:running|startup|intended}
	diff_ignore_lines=${14:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${15:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}

endsnippet

snippet icx_command "Run arbitrary commands on remote Ruckus ICX 7000 series switches" b
icx_command: >
	commands=${1:# List of commands to send to the remote ICX device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired. If a command sent to the device requires answering a prompt, checkall and newline if multiple prompts, it is possible to pass a dict containing I(command), I(answer), I(prompt), I(check_all) and I(newline).Common answers are 'y' or "\r" (carriage return, must be double quotes). See examples.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet icx_user "Manage the user accounts on Ruckus ICX 7000 series switches." b
icx_user: >
	name=${1:# The username to be configured on the ICX device.}

	aggregate=${2:# The set of username objects to be configured on the remote ICX device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.}
	configured_password=${3:# T}
	update_password=${4:on_create|#always}
	privilege=${5:0|4|5}
	nopassword=${6:# Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.}
	purge=${7:no}
	state=${8:#present|absent}
	access_time=${9:# This parameter indicates the time the file's access time should be set to. Should be preserve when no modification is required, YYYYMMDDHHMM.SS when using default time format, or now. Default is None meaning that preserve is the default for state=[file,directory,link,hard] and now is default for state=touch}
	check_running_config=${10:yes}

endsnippet

snippet icx_logging "Manage logging on Ruckus ICX 7000 series switches" b
icx_logging: >
	dest=${1:on|host|console|buffered|persistence|rfc5424}
	name=${2:# ipv4 address/ipv6 address/name of  syslog server.}
	udp_port=${3:# UDP port of destination host(syslog server).}
	facility=${4:auth|cron|daemon|kern|local0|local1|local2|local3|local4|local5|local6|local7|user|lpr|mail|news|syslog|sys9|sys10|sys11|sys12|sys13|sys14|user|uucp}
	level=${5:alerts|critical|debugging|emergencies|errors|informational|notifications|warnings}
	aggregate=${6:# List of logging definitions.}
	state=${7:#present|absent}
	check_running_config=${8:yes}

endsnippet

snippet icx_vlan "Manage VLANs on Ruckus ICX 7000 series switches" b
icx_vlan: >
	vlan_id=${1:# ID of the VLAN. Range 1-4094.}

	name=${2:# Name of the VLAN.}
	interfaces=${3:# List of ethernet ports or LAGS to be added as access(untagged) ports to the vlan. To add a range of ports use 'to' keyword. See the example.}
	tagged=${4:# List of ethernet ports or LAGS to be added as trunk(tagged) ports to the vlan. To add a range of ports use 'to' keyword. See the example.}
	ip_dhcp_snooping=${5:# Enables DHCP snooping on a VLAN.}
	ip_arp_inspection=${6:# Enables dynamic ARP inspection on a VLAN.}
	associated_interfaces=${7:# This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.}
	associated_tagged=${8:# This is a intent option and checks the operational state of  given vlan C(name) for associated tagged ports and lags. If the value in the C(associated_tagged) does not match with the operational state of vlan interfaces on device it will result in failure.}
	delay=${9:10}
	stp=${10:# Enable spanning-tree 802-1w/rstp for this vlan.}
	aggregate=${11:# List of VLANs definitions.}
	purge=${12:no}
	state=${13:#present|absent}
	check_running_config=${14:yes}

endsnippet

snippet ios_system "Manage the system attributes on Cisco IOS devices" b
ios_system: >
	hostname=${1:# Configure the device hostname parameter. This option takes an ASCII string value.}
	domain_name=${2:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
	domain_search=${3:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
	lookup_source=${4:# Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) must be a valid interface configured on the device.}
	lookup_enabled=${5:# Administrative control for enabling or disabling DNS lookups.  When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.}
	name_servers=${6:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.}
	state=${7:#present|absent}
	authorize=${8:no}
	auth_pass=${9:# B(Deprecated)}
	provider=${10:# B(Deprecated)}

endsnippet

snippet ios_logging "Manage logging on network devices" b
ios_logging: >
	dest=${1:on|host|console|monitor|buffered|trap}
	name=${2:# The hostname or IP address of the destination.}
	size=${3:4096}
	facility=${4:# Set logging facility.}
	level=${5:emergencies|alerts|critical|errors|warnings|notifications|informational|#debugging}
	aggregate=${6:# L}
	state=${7:#present|absent}
	authorize=${8:no}
	auth_pass=${9:# B(Deprecated)}
	provider=${10:# B(Deprecated)}

endsnippet

snippet ios_command "Run commands on remote devices running Cisco IOS" b
ios_command: >
	commands=${1:# List of commands to send to the remote ios device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired. If a command sent to the device requires answering a prompt, it is possible to pass a dict containing I(command), I(answer) and I(prompt). Common answers are 'y' or "\r" (carriage return, must be double quotes). See examples.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	authorize=${6:no}
	auth_pass=${7:# B(Deprecated)}
	provider=${8:# B(Deprecated)}

endsnippet

snippet ios_vrf "Manage the collection of VRF definitions on Cisco IOS devices" b
ios_vrf: >
	vrfs=${1:# The set of VRF definition objects to be configured on the remote IOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.}
	name=${2:# The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(vrfs) argument}
	description=${3:# Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.}
	rd=${4:# The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.}
	interfaces=${5:# Identifies the set of interfaces that should be configured in the VRF.  Interfaces must be routed interfaces in order to be placed into a VRF.}
	associated_interfaces=${6:# This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.}
	delay=${7:10}
	purge=${8:no}
	state=${9:#present|absent}
	route_both=${10:# Adds an export and import list of extended route target communities to the VRF.}
	route_export=${11:# Adds an export list of extended route target communities to the VRF.}
	route_import=${12:# Adds an import list of extended route target communities to the VRF.}
	route_both_ipv4=${13:# Adds an export and import list of extended route target communities in address-family configuration submode to the VRF.}
	route_export_ipv4=${14:# Adds an export list of extended route target communities in address-family configuration submode to the VRF.}
	route_import_ipv4=${15:# Adds an import list of extended route target communities in address-family configuration submode to the VRF.}
	route_both_ipv6=${16:# Adds an export and import list of extended route target communities in address-family configuration submode to the VRF.}
	route_export_ipv6=${17:# Adds an export list of extended route target communities in address-family configuration submode to the VRF.}
	route_import_ipv6=${18:# Adds an import list of extended route target communities in address-family configuration submode to the VRF.}
	authorize=${19:no}
	auth_pass=${20:# B(Deprecated)}
	provider=${21:# B(Deprecated)}

endsnippet

snippet ios_lldp_global "Configure and manage Link Layer Discovery Protocol(LLDP) attributes on IOS platforms." b
ios_lldp_global: >
	config=${1:# A}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet ios_l2_interfaces "Manage Layer-2 interface on Cisco IOS devices." b
ios_l2_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet ios_lacp_interfaces "Manage Link Aggregation Control Protocol (LACP) on Cisco IOS devices interface." b
ios_lacp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet ios_ping "Tests reachability using ping from Cisco IOS network devices" b
ios_ping: >
	dest=${1:# The IP Address or hostname (resolvable by switch) of the remote node.}

	count=${2:5}
	source=${3:# The source IP Address.}
	state=${4:absent|#present}
	vrf=${5:default}
	authorize=${6:no}
	auth_pass=${7:# B(Deprecated)}
	provider=${8:# B(Deprecated)}

endsnippet

snippet ios_vlans "Manage VLANs on Cisco IOS devices." b
ios_vlans: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet ios_config "Manage Cisco IOS configuration sections" b
ios_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	multiline_delimiter=${8:@}
	backup=${9:no}
	running_config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source. There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	defaults=${11:no}
	save_when=${12:always|#never|modified|changed}
	diff_against=${13:running|startup|intended}
	diff_ignore_lines=${14:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${15:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against. This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${16:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	authorize=${17:no}
	auth_pass=${18:# B(Deprecated)}
	provider=${19:# B(Deprecated)}

endsnippet

snippet ios_static_route "Manage static IP routes on Cisco IOS network devices" b
ios_static_route: >
	prefix=${1:# Network prefix of the static route.}
	mask=${2:# Network prefix mask of the static route.}
	next_hop=${3:# Next hop IP of the static route.}
	vrf=${4:# VRF of the static route.}
	interface=${5:# Interface of the static route.}
	name=${6:# Name of the static route}
	admin_distance=${7:# Admin distance of the static route.}
	tag=${8:# Set tag of the static route.}
	track=${9:# Tracked item to depend on for the static route.}
	aggregate=${10:# L}
	state=${11:#present|absent}
	authorize=${12:no}
	auth_pass=${13:# B(Deprecated)}
	provider=${14:# B(Deprecated)}

endsnippet

snippet ios_lldp "Manage LLDP configuration on Cisco IOS network devices." b
ios_lldp: >
	state=${1:#present|absent}
	authorize=${2:no}
	auth_pass=${3:# B(Deprecated)}
	provider=${4:# B(Deprecated)}

endsnippet

snippet ios_lacp "Manage Global Link Aggregation Control Protocol (LACP) on Cisco IOS devices." b
ios_lacp: >
	config=${1:# T}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet ios_interfaces "Manages interface attributes of Cisco IOS network devices" b
ios_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet ios_bgp "Configure global BGP protocol settings on Cisco IOS." b
ios_bgp: >
	config=${1:# Specifies the BGP related configuration.}
	operation=${2:#merge|replace|override|delete}

endsnippet

snippet ios_ntp "Manages core NTP configuration." b
ios_ntp: >
	server=${1:# Network address of NTP server.}
	source_int=${2:# Source interface for NTP packets.}
	acl=${3:# ACL for peer/server access restricition.}
	logging=${4:no}
	auth=${5:no}
	auth_key=${6:# md5 NTP authentication key of tye 7.}
	key_id=${7:# auth_key id. Data type string}
	state=${8:#present|absent}
	authorize=${9:no}
	auth_pass=${10:# B(Deprecated)}
	provider=${11:# B(Deprecated)}

endsnippet

snippet ios_lag_interfaces "Manage Link Aggregation on Cisco IOS devices." b
ios_lag_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet ios_user "Manage the aggregate of local users on Cisco IOS device" b
ios_user: >
	aggregate=${1:# The set of username objects to be configured on the remote Cisco IOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.}
	name=${2:# The username to be configured on the Cisco IOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
	configured_password=${3:# The password to be configured on the Cisco IOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
	update_password=${4:on_create|#always}
	password_type=${5:#secret|password}
	hashed_password=${6:# This option allows configuring hashed passwords on Cisco IOS devices.}
	privilege=${7:# The C(privilege) argument configures the privilege level of the user when logged into the system. This argument accepts integer values in the range of 1 to 15.}
	view=${8:# Configures the view for the username in the device running configuration. The argument accepts a string value defining the view name. This argument does not check if the view has been configured on the device.}
	sshkey=${9:# Specifies one or more SSH public key(s) to configure for the given username.}
	nopassword=${10:# Defines the username without assigning a password. This will allow the user to login to the system without being authenticated by a password.}
	purge=${11:no}
	state=${12:#present|absent}
	authorize=${13:no}
	auth_pass=${14:# B(Deprecated)}
	provider=${15:# B(Deprecated)}

endsnippet

snippet ios_l3_interfaces "Manage Layer-3 interface on Cisco IOS devices." b
ios_l3_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet ios_facts "Collect facts from remote devices running Cisco IOS" b
ios_facts: >
	gather_subset=${1:!config}
	gather_network_resources=${2:# When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all and the resources like interfaces, vlans etc. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Valid subsets are 'all', 'interfaces', 'l2_interfaces', 'vlans', 'lag_interfaces', 'lacp', 'lacp_interfaces', 'lldp_global', 'lldp_interfaces', 'l3_interfaces'.}
	authorize=${3:no}
	auth_pass=${4:# B(Deprecated)}
	provider=${5:# B(Deprecated)}

endsnippet

snippet ios_linkagg "Manage link aggregation groups on Cisco IOS network devices" b
ios_linkagg: >
	group=${1:# Channel-group number for the port-channel Link aggregation group. Range 1-255.}
	mode=${2:active|on|passive|auto|desirable}
	members=${3:# List of members of the link aggregation group.}
	aggregate=${4:# L}
	state=${5:#present|absent}
	purge=${6:no}
	authorize=${7:no}
	auth_pass=${8:# B(Deprecated)}
	provider=${9:# B(Deprecated)}

endsnippet

snippet ios_lldp_interfaces "Manage link layer discovery protocol (LLDP) attributes of interfaces on Cisco IOS devices." b
ios_lldp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet ios_banner "Manage multiline banners on Cisco IOS devices" b
ios_banner: >
	banner=${1:login|motd|exec|incoming|slip-ppp}

	text=${2:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
	state=${3:#present|absent}
	authorize=${4:no}
	auth_pass=${5:# B(Deprecated)}
	provider=${6:# B(Deprecated)}

endsnippet

snippet cv_server_provision "Provision server port by applying or removing template configuration to an Arista CloudVision Portal configlet that is applied to a switch." b
cv_server_provision: >
	host=${1:# The hostname or IP address of the CVP node being connected to.}
	username=${2:# The user that will be used to connect to CVP for making API calls.}
	password=${3:# The password of the user that will be used to connect to CVP for API calls.}
	server_name=${4:# The hostname or identifier for the server that is having it's switch port provisioned.}
	switch_name=${5:# The hostname of the switch is being configured for the server being provisioned.}
	switch_port=${6:# The physical port number on the switch that the new server is connected to.}
	template=${7:# A path to a Jinja formatted template file that contains the configuration block that will be applied to the specified switch port. This template will have variable fields replaced by the module before being applied to the switch configuration.}

	port=${8:# The port number to use when making API calls to the CVP node. This will default to the default port for the specified protocol. Port 80 for http and port 443 for https.}
	protocol=${9:#https|http}
	port_vlan=${10:# The vlan that should be applied to the port for this server. This parameter is dependent on a proper template that supports single vlan provisioning with it. If a port vlan is specified by the template specified does not support this the module will exit out with no changes. If a template is specified that requires a port vlan but no port vlan is specified the module will exit out with no changes.}
	action=${11:#show|add|remove}
	auto_run=${12:no}

endsnippet

snippet vdirect_commit "Commits pending configuration changes on Radware devices" b
vdirect_commit: >
	vdirect_ip=${1:# Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.}
	vdirect_user=${2:# vDirect server username, may be set as C(VDIRECT_USER) environment variable.}
	vdirect_password=${3:# vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.}
	devices=${4:# List of Radware Alteon device names for commit operations.}

	vdirect_secondary_ip=${5:# Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.}
	vdirect_wait=${6:yes}
	vdirect_https_port=${7:2189}
	vdirect_http_port=${8:2188}
	vdirect_timeout=${9:60}
	vdirect_use_ssl=${10:yes}
	validate_certs=${11:yes}
	apply=${12:yes}
	save=${13:yes}
	sync=${14:yes}

endsnippet

snippet vdirect_file "Uploads a new or updates an existing runnable file into Radware vDirect server" b
vdirect_file: >
	vdirect_ip=${1:# Primary vDirect server IP address, may be set as VDIRECT_IP environment variable.}
	vdirect_user=${2:# vDirect server username, may be set as VDIRECT_USER environment variable.}
	vdirect_password=${3:# vDirect server password, may be set as VDIRECT_PASSWORD environment variable.}
	file_name=${4:# vDirect runnable file name to be uploaded.}

	vdirect_secondary_ip=${5:# Secondary vDirect server IP address, may be set as VDIRECT_SECONDARY_IP environment variable.}
	vdirect_wait=${6:yes}
	vdirect_https_port=${7:2189}
	vdirect_http_port=${8:2188}
	vdirect_timeout=${9:60}
	vdirect_use_ssl=${10:yes}
	validate_certs=${11:yes}

endsnippet

snippet vdirect_runnable "Runs templates and workflow actions in Radware vDirect server" b
vdirect_runnable: >
	vdirect_ip=${1:# Primary vDirect server IP address, may be set as C(VDIRECT_IP) environment variable.}
	vdirect_user=${2:# vDirect server username, may be set as C(VDIRECT_USER) environment variable.}
	vdirect_password=${3:# vDirect server password, may be set as C(VDIRECT_PASSWORD) environment variable.}
	runnable_type=${4:ConfigurationTemplate|Workflow|WorkflowTemplate}
	runnable_name=${5:# vDirect runnable name to run.}

	vdirect_secondary_ip=${6:# Secondary vDirect server IP address, may be set as C(VDIRECT_SECONDARY_IP) environment variable.}
	vdirect_wait=${7:yes}
	vdirect_https_port=${8:2189}
	vdirect_http_port=${9:2188}
	vdirect_timeout=${10:60}
	vdirect_use_ssl=${11:yes}
	validate_certs=${12:yes}
	action_name=${13:# Workflow action name to run.}
	parameters=${14:# Action parameters dictionary. In case of C(ConfigurationTemplate) runnable type,}

endsnippet

snippet onyx_l2_interface "Manage Layer-2 interface on Mellanox ONYX network devices" b
onyx_l2_interface: >
	name=${1:# Name of the interface.}
	aggregate=${2:# List of Layer-2 interface definitions.}
	mode=${3:#access|trunk|hybrid}
	access_vlan=${4:# Configure given VLAN in access port.}
	trunk_allowed_vlans=${5:# List of allowed VLANs in a given trunk port.}
	state=${6:#present|absent}

endsnippet

snippet onyx_mlag_vip "Configures MLAG VIP on Mellanox ONYX network devices" b
onyx_mlag_vip: >
	ipaddress=${1:# Virtual IP address of the MLAG. Required if I(state=present).}
	group_name=${2:# MLAG group name. Required if I(state=present).}
	mac_address=${3:# MLAG system MAC address. Required if I(state=present).}
	state=${4:present|absent}
	delay=${5:12}

endsnippet

snippet onyx_ospf "Manage OSPF protocol on Mellanox ONYX network devices" b
onyx_ospf: >
	ospf=${1:# OSPF instance number 1-65535}

	router_id=${2:# OSPF router ID. Required if I(state=present).}
	interfaces=${3:# List of interfaces and areas. Required if I(state=present).}
	state=${4:#present|absent}

endsnippet

snippet onyx_linkagg "Manage link aggregation groups on Mellanox ONYX network devices" b
onyx_linkagg: >
	name=${1:# Name of the link aggregation group.}
	members=${2:# List of members interfaces of the link aggregation group. The value can be single interface or list of interfaces.}

	mode=${3:on|active|passive}
	aggregate=${4:# L}
	purge=${5:no}
	state=${6:#present|absent|up|down}

endsnippet

snippet onyx_l3_interface "Manage L3 interfaces on Mellanox ONYX network devices" b
onyx_l3_interface: >
	name=${1:# Name of the L3 interface.}
	ipv4=${2:# IPv4 of the L3 interface.}
	ipv6=${3:# IPv6 of the L3 interface (not supported for now).}
	aggregate=${4:# L}
	purge=${5:no}
	state=${6:#present|absent}

endsnippet

snippet onyx_igmp_interface "Configures IGMP interface parameters" b
onyx_igmp_interface: >
	name=${1:# interface name that we want to configure IGMP on it}

	state=${2:#enabled|disabled}

endsnippet

snippet onyx_igmp_vlan "Configures IGMP Vlan parameters" b
onyx_igmp_vlan: >
	vlan_id=${1:# VLAN ID, vlan should exist.}

	state=${2:#enabled|disabled}
	mrouter=${3:# Configure ip igmp snooping mrouter port on vlan}
	querier=${4:# Configure the IGMP querier parameters}
	static_groups=${5:# List of IGMP static groups.}
	version=${6:V2|V3}

endsnippet

snippet onyx_magp "Manage MAGP protocol on Mellanox ONYX network devices" b
onyx_magp: >
	magp_id=${1:# MAGP instance number 1-255}
	interface=${2:# VLAN Interface name.}

	state=${3:#present|absent|enabled|disabled}
	router_ip=${4:# MAGP router IP address.}
	router_mac=${5:# MAGP router MAC address.}

endsnippet

snippet onyx_protocol "Enables/Disables protocols on Mellanox ONYX network devices" b
onyx_protocol: >
	mlag=${1:enabled|disabled}
	magp=${2:enabled|disabled}
	spanning_tree=${3:enabled|disabled}
	dcb_pfc=${4:enabled|disabled}
	igmp_snooping=${5:enabled|disabled}
	lacp=${6:enabled|disabled}
	ip_l3=${7:enabled|disabled}
	ip_routing=${8:enabled|disabled}
	lldp=${9:enabled|disabled}
	bgp=${10:enabled|disabled}
	ospf=${11:enabled|disabled}
	nve=${12:enabled|disabled}

endsnippet

snippet onyx_ptp_global "Configures PTP Global parameters" b
onyx_ptp_global: >
	ptp_state=${1:#enabled|disabled}
	ntp_state=${2:enabled|disabled}
	domain=${3:# set PTP domain number Range 0-127}
	primary_priority=${4:# set PTP primary priority Range 0-225}
	secondary_priority=${5:# set PTP secondary priority Range 0-225}

endsnippet

snippet onyx_lldp "Manage LLDP configuration on Mellanox ONYX network devices" b
onyx_lldp: >
	state=${1:#present|absent}

endsnippet

snippet onyx_vxlan "Configures Vxlan" b
onyx_vxlan: >
	nve_id=${1:# nve interface ID.}

	loopback_id=${2:# loopback interface ID.}
	bgp=${3:yes}
	mlag_tunnel_ip=${4:# vxlan Mlag tunnel IP}
	vni_vlan_list=${5:# Each item in the list has two attributes vlan_id, vni_id.}
	arp_suppression=${6:no}

endsnippet

snippet onyx_wjh "Configure what-just-happend module" b
onyx_wjh: >
	group=${1:all|forwarding|acl}
	enabled=${2:# wjh group status}
	auto_export=${3:# wjh group auto export pcap file status}
	export_group=${4:all|forwarding|acl}
	clear_group=${5:all|user|auto-export}

endsnippet

snippet onyx_igmp "Configures IGMP global parameters" b
onyx_igmp: >
	state=${1:enabled|disabled}

	last_member_query_interval=${2:# Configure the last member query interval, range 1-25}
	mrouter_timeout=${3:# Configure the mrouter timeout, range 60-600}
	port_purge_timeout=${4:# Configure the host port purge timeout, range 130-1225}
	proxy_reporting=${5:enabled|disabled}
	report_suppression_interval=${6:# Configure the report suppression interval, range 1-25}
	unregistered_multicast=${7:flood|forward-to-mrouter-ports}
	default_version=${8:V2|V3}

endsnippet

snippet onyx_bgp "Configures BGP on Mellanox ONYX network devices" b
onyx_bgp: >
	as_number=${1:# Local AS number.}

	router_id=${2:# Router IP address.}
	neighbors=${3:# List of neighbors. Required if I(state=present).}
	networks=${4:# List of advertised networks.}
	fast_external_fallover=${5:# will configure fast_external_fallover when it is True.}
	max_paths=${6:# Maximum bgp paths.}
	ecmp_bestpath=${7:# Enables ECMP across AS paths.}
	evpn=${8:# Configure evpn peer-group.}
	vrf=${9:# vrf name.}
	state=${10:#present|absent}
	purge=${11:no}

endsnippet

snippet onyx_config "Manage Mellanox ONYX configuration sections" b
onyx_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	backup=${8:no}
	config=${9:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
	save=${10:no}
	backup_options=${11:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${12:# A dict object containing connection details.}

endsnippet

snippet onyx_mlag_ipl "Manage IPL (inter-peer link) on Mellanox ONYX network devices" b
onyx_mlag_ipl: >
	name=${1:# Name of the interface (port-channel) IPL should be configured on.}

	vlan_interface=${2:# Name of the IPL vlan interface.}
	state=${3:#present|absent}
	peer_address=${4:# IPL peer IP address.}

endsnippet

snippet onyx_ptp_interface "Configures PTP on interface" b
onyx_ptp_interface: >
	name=${1:# ethernet or vlan interface name that we want to configure PTP on it}

	state=${2:#enabled|disabled}
	delay_request=${3:# configure PTP delay request interval, Range 0-5}
	announce_interval=${4:# configure PTP announce setting for interval, Range -3-1}
	announce_timeout=${5:# configure PTP announce setting for timeout, Range 2-10}
	sync_interval=${6:# configure PTP sync interval, Range -7--1}

endsnippet

snippet onyx_traffic_class "Configures Traffic Class" b
onyx_traffic_class: >
	interfaces=${1:# list of interfaces name.}
	tc=${2:# traffic class, range 0-7.}

	state=${3:#enabled|disabled}
	congestion_control=${4:# configure congestion control on interface.}
	dcb=${5:# configure dcb control on interface.}

endsnippet

snippet onyx_pfc_interface "Manage priority flow control on ONYX network devices" b
onyx_pfc_interface: >
	name=${1:# Name of the interface PFC should be configured on.}
	aggregate=${2:# L}
	purge=${3:no}
	state=${4:#enabled|disabled}

endsnippet

snippet onyx_lldp_interface "Manage LLDP interfaces configuration on Mellanox ONYX network devices" b
onyx_lldp_interface: >
	name=${1:# Name of the interface LLDP should be configured on.}
	aggregate=${2:# L}
	purge=${3:no}
	state=${4:#present|absent|enabled|disabled}

endsnippet

snippet onyx_facts "Collect facts from Mellanox ONYX network devices" b
onyx_facts: >
	gather_subset=${1:version}

endsnippet

snippet onyx_command "Run commands on remote devices running Mellanox ONYX" b
onyx_command: >
	commands=${1:# List of commands to send to the remote Mellanox ONYX network device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet onyx_interface "Manage Interfaces on Mellanox ONYX network devices" b
onyx_interface: >
	name=${1:# Name of the Interface.}

	description=${2:# Description of Interface.}
	enabled=${3:# Interface link status.}
	speed=${4:1G|10G|25G|40G|50G|56G|100G}
	mtu=${5:# Maximum size of transmit packet.}
	aggregate=${6:# L}
	duplex=${7:full|half|#auto}
	tx_rate=${8:# Transmit rate in bits per second (bps).}
	rx_rate=${9:# Receiver rate in bits per second (bps).}
	delay=${10:10}
	purge=${11:no}
	state=${12:#present|absent|up|down}

endsnippet

snippet onyx_buffer_pool "Configures Buffer Pool" b
onyx_buffer_pool: >
	name=${1:# pool name.}

	pool_type=${2:lossless|#lossy}
	memory_percent=${3:# memory percent.}
	switch_priority=${4:# switch priority, range 1-7.}

endsnippet

snippet onyx_qos "Configures QoS" b
onyx_qos: >
	interfaces=${1:# list of interfaces name.}

	trust=${2:#L2|L3|both}
	rewrite_pcp=${3:enabled|#disabled}
	rewrite_dscp=${4:enabled|#disabled}

endsnippet

snippet onyx_vlan "Manage VLANs on Mellanox ONYX network devices" b
onyx_vlan: >
	name=${1:# Name of the VLAN.}
	vlan_id=${2:# ID of the VLAN.}
	aggregate=${3:# L}
	purge=${4:no}
	state=${5:#present|absent}

endsnippet

snippet net_ping "Tests reachability using ping from a network device" b
net_ping: >
	dest=${1:# The IP Address or hostname (resolvable by switch) of the remote node.}

	count=${2:5}
	source=${3:# The source IP Address.}
	state=${4:absent|#present}
	vrf=${5:default}

endsnippet

snippet vyos_command "Run one or more commands on VyOS devices" b
vyos_command: >
	commands=${1:# The ordered set of commands to execute on the remote device running VyOS.  The output from the command execution is returned to the playbook.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has been exceeded.}

	wait_for=${2:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.  If the conditional is not true by the configured I(retries), the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# B(Deprecated)}

endsnippet

snippet vyos_lldp_global "Manage link layer discovery protocol (LLDP) attributes on VyOS devices.." b
vyos_lldp_global: >
	config=${1:# T}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet vyos_config "Manage VyOS configuration on remote device" b
vyos_config: >
	lines=${1:# The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.}
	src=${2:# The C(src) argument specifies the path to the source config file to load.  The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.}
	match=${3:#line|none}
	backup=${4:no}
	comment=${5:configured by vyos_config}
	config=${6:# The C(config) argument specifies the base configuration to use to compare against the desired configuration.  If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.}
	save=${7:no}
	backup_options=${8:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${9:# B(Deprecated)}

endsnippet

snippet vyos_system "Run `set system` commands on VyOS devices" b
vyos_system: >
	host_name=${1:# Configure the device hostname parameter. This option takes an ASCII string value.}
	domain_name=${2:# The new domain name to apply to the device.}
	name_servers=${3:# A list of name servers to use with the device. Mutually exclusive with I(domain_search)}
	domain_search=${4:# A list of domain names to search. Mutually exclusive with I(name_server)}
	state=${5:#present|absent}
	provider=${6:# B(Deprecated)}

endsnippet

snippet vyos_ping "Tests reachability using ping from VyOS network devices" b
vyos_ping: >
	dest=${1:# The IP Address or hostname (resolvable by the device) of the remote node.}

	count=${2:5}
	source=${3:# The source interface or IP Address to use while sending the ping packet(s).}
	ttl=${4:# The time-to-live value for the ICMP packet(s).}
	size=${5:# Determines the size (in bytes) of the ping packet(s).}
	interval=${6:# Determines the interval (in seconds) between consecutive pings.}
	state=${7:absent|#present}
	provider=${8:# B(Deprecated)}

endsnippet

snippet vyos_logging "Manage logging on network devices" b
vyos_logging: >
	dest=${1:console|file|global|host|user}
	name=${2:# If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.}
	facility=${3:# Set logging facility.}
	level=${4:# Set logging severity levels.}
	aggregate=${5:# L}
	state=${6:#present|absent}
	provider=${7:# B(Deprecated)}

endsnippet

snippet vyos_lldp_interfaces "Manages attributes of lldp interfaces on VyOS devices." b
vyos_lldp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet vyos_lag_interfaces "Manages attributes of link aggregation groups on VyOS network devices." b
vyos_lag_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet vyos_static_route "Manage static IP routes on Vyatta VyOS network devices" b
vyos_static_route: >
	prefix=${1:# Network prefix of the static route. C(mask) param should be ignored if C(prefix) is provided with C(mask) value C(prefix/mask).}
	mask=${2:# Network prefix mask of the static route.}
	next_hop=${3:# Next hop IP of the static route.}
	admin_distance=${4:# Admin distance of the static route.}
	aggregate=${5:# L}
	state=${6:#present|absent}
	provider=${7:# B(Deprecated)}

endsnippet

snippet vyos_l3_interfaces "Manages L3 interface attributes of VyOS network devices." b
vyos_l3_interfaces: >
	config=${1:# T}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet vyos_user "Manage the collection of local users on VyOS device" b
vyos_user: >
	aggregate=${1:# The set of username objects to be configured on the remote VyOS device. The list entries can either be the username or a hash of username and properties. This argument is mutually exclusive with the C(name) argument.}
	name=${2:# The username to be configured on the VyOS device. This argument accepts a string value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
	full_name=${3:# The C(full_name) argument provides the full name of the user account to be created on the remote device. This argument accepts any text string value.}
	configured_password=${4:# The password to be configured on the VyOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
	update_password=${5:on_create|#always}
	level=${6:# The C(level) argument configures the level of the user when logged into the system. This argument accepts string values admin or operator.}
	purge=${7:no}
	state=${8:#present|absent}
	provider=${9:# B(Deprecated)}

endsnippet

snippet vyos_facts "Get facts about vyos devices." b
vyos_facts: >
	gather_subset=${1:!config}
	gather_network_resources=${2:# When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all and the resources like interfaces. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Valid subsets are 'all', 'interfaces', 'l3_interfaces', 'lag_interfaces', 'lldp_global', 'lldp_interfaces'.}
	provider=${3:# B(Deprecated)}

endsnippet

snippet vyos_interfaces "Manages interface attributes of VyOS network devices." b
vyos_interfaces: >
	config=${1:# T}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet vyos_banner "Manage multiline banners on VyOS devices" b
vyos_banner: >
	banner=${1:pre-login|post-login}

	text=${2:# The banner text that should be present in the remote device running configuration. This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet vyos_vlan "Manage VLANs on VyOS network devices" b
vyos_vlan: >
	vlan_id=${1:# ID of the VLAN. Range 0-4094.}
	interfaces=${2:# List of interfaces that should be associated to the VLAN.}

	name=${3:# Name of the VLAN.}
	address=${4:# Configure Virtual interface address.}
	associated_interfaces=${5:# This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan on device it will result in failure.}
	delay=${6:10}
	aggregate=${7:# L}
	purge=${8:no}
	state=${9:#present|absent}
	provider=${10:# B(Deprecated)}

endsnippet

snippet meraki_organization "Manage organizations in the Meraki cloud" b
meraki_organization: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:#present|query}
	clone=${3:# Organization to clone to a new organization.}
	org_name=${4:# Name of organization.}
	org_id=${5:# ID of organization.}
	host=${6:api.meraki.com}
	use_proxy=${7:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${8:yes}
	output_format=${9:#snakecase|camelcase}
	output_level=${10:debug|#normal}
	timeout=${11:30}
	validate_certs=${12:yes}
	rate_limit_retry_time=${13:165}
	internal_error_retry_time=${14:60}

endsnippet

snippet meraki_config_template "Manage configuration templates in the Meraki cloud" b
meraki_config_template: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|#query|present}
	org_name=${3:# Name of organization containing the configuration template.}
	org_id=${4:# ID of organization associated to a configuration template.}
	config_template=${5:# Name of the configuration template within an organization to manipulate.}
	net_name=${6:# Name of the network to bind or unbind configuration template to.}
	net_id=${7:# ID of the network to bind or unbind configuration template to.}
	auto_bind=${8:# Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model.}
	host=${9:api.meraki.com}
	use_proxy=${10:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${11:yes}
	output_format=${12:#snakecase|camelcase}
	output_level=${13:debug|#normal}
	timeout=${14:30}
	validate_certs=${15:yes}
	rate_limit_retry_time=${16:165}
	internal_error_retry_time=${17:60}

endsnippet

snippet meraki_device "Manage devices in the Meraki cloud" b
meraki_device: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|present|#query}
	net_name=${3:# Name of a network.}
	net_id=${4:# ID of a network.}
	serial=${5:# Serial number of a device to query.}
	hostname=${6:# Hostname of network device to search for.}
	model=${7:# Model of network device to search for.}
	tags=${8:# Space delimited list of tags to assign to device.}
	lat=${9:# Latitude of device's geographic location.}
	lng=${10:# Longitude of device's geographic location.}
	address=${11:# Postal address of device's location.}
	move_map_marker=${12:# Whether or not to set the latitude and longitude of a device based on the new address.}
	serial_lldp_cdp=${13:# Serial number of device to query LLDP/CDP information from.}
	lldp_cdp_timespan=${14:# Timespan, in seconds, used to query LLDP and CDP information.}
	serial_uplink=${15:# Serial number of device to query uplink information from.}
	note=${16:# Informational notes about a device.}
	host=${17:api.meraki.com}
	use_proxy=${18:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${19:yes}
	output_format=${20:#snakecase|camelcase}
	output_level=${21:debug|#normal}
	timeout=${22:30}
	validate_certs=${23:yes}
	org_name=${24:# Name of organization.}
	org_id=${25:# ID of organization.}
	rate_limit_retry_time=${26:165}
	internal_error_retry_time=${27:60}

endsnippet

snippet meraki_network "Manage networks in the Meraki cloud" b
meraki_network: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|#present|query}
	net_name=${3:# Name of a network.}
	net_id=${4:# ID number of a network.}
	type=${5:appliance|switch|wireless}
	tags=${6:# List of tags to assign to network.}
	timezone=${7:# Timezone associated to network.}
	enable_vlans=${8:# Boolean value specifying whether VLANs should be supported on a network.}
	disable_my_meraki=${9:# -}
	enable_my_meraki=${10:# -}
	enable_remote_status_page=${11:# Enables access to the device status page (U(http://device LAN IP)).}
	host=${12:api.meraki.com}
	use_proxy=${13:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${14:yes}
	output_format=${15:#snakecase|camelcase}
	output_level=${16:debug|#normal}
	timeout=${17:30}
	validate_certs=${18:yes}
	org_name=${19:# Name of organization.}
	org_id=${20:# ID of organization.}
	rate_limit_retry_time=${21:165}
	internal_error_retry_time=${22:60}

endsnippet

snippet meraki_content_filtering "Edit Meraki MX content filtering policies" b
meraki_content_filtering: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.}

	net_name=${2:# Name of a network.}
	net_id=${3:# ID number of a network.}
	state=${4:#present|query}
	allowed_urls=${5:# List of URL patterns which should be allowed.}
	blocked_urls=${6:# List of URL patterns which should be blocked.}
	blocked_categories=${7:# List of content categories which should be blocked.}
	category_list_size=${8:top sites|full list}
	subset=${9:categories|policy}
	host=${10:api.meraki.com}
	use_proxy=${11:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${12:yes}
	output_format=${13:#snakecase|camelcase}
	output_level=${14:debug|#normal}
	timeout=${15:30}
	validate_certs=${16:yes}
	org_name=${17:# Name of organization.}
	org_id=${18:# ID of organization.}
	rate_limit_retry_time=${19:165}
	internal_error_retry_time=${20:60}

endsnippet

snippet meraki_mr_l3_firewall "Manage MR access point layer 3 firewalls in the Meraki cloud" b
meraki_mr_l3_firewall: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:#present|query}
	net_name=${3:# Name of network containing access points.}
	net_id=${4:# ID of network containing access points.}
	number=${5:# Number of SSID to apply firewall rule to.}
	ssid_name=${6:# Name of SSID to apply firewall rule to.}
	allow_lan_access=${7:yes}
	rules=${8:# List of firewall rules.}
	host=${9:api.meraki.com}
	use_proxy=${10:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${11:yes}
	output_format=${12:#snakecase|camelcase}
	output_level=${13:debug|#normal}
	timeout=${14:30}
	validate_certs=${15:yes}
	org_name=${16:# Name of organization.}
	org_id=${17:# ID of organization.}
	rate_limit_retry_time=${18:165}
	internal_error_retry_time=${19:60}

endsnippet

snippet meraki_switchport "Manage switchports on a switch in the Meraki cloud" b
meraki_switchport: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:#query|present}
	access_policy_number=${3:# Number of the access policy to apply.}
	allowed_vlans=${4:all}
	enabled=${5:yes}
	isolation_enabled=${6:no}
	link_negotiation=${7:#Auto negotiate|100Megabit (auto)|100 Megabit full duplex (forced)}
	name=${8:# Switchport description.}
	number=${9:# Port number.}
	poe_enabled=${10:yes}
	rstp_enabled=${11:yes}
	serial=${12:# Serial nubmer of the switch.}
	stp_guard=${13:#disabled|root guard|bpdu guard|loop guard}
	tags=${14:# Space delimited list of tags to assign to a port.}
	type=${15:#access|trunk}
	vlan=${16:# VLAN number assigned to port.}
	voice_vlan=${17:# VLAN number assigned to a port for voice traffic.}
	host=${18:api.meraki.com}
	use_proxy=${19:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${20:yes}
	output_format=${21:#snakecase|camelcase}
	output_level=${22:debug|#normal}
	timeout=${23:30}
	validate_certs=${24:yes}
	org_name=${25:# Name of organization.}
	org_id=${26:# ID of organization.}
	rate_limit_retry_time=${27:165}
	internal_error_retry_time=${28:60}

endsnippet

snippet meraki_mx_l3_firewall "Manage MX appliance layer 3 firewalls in the Meraki cloud" b
meraki_mx_l3_firewall: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:#present|query}
	net_name=${3:# Name of network which MX firewall is in.}
	net_id=${4:# ID of network which MX firewall is in.}
	rules=${5:# List of firewall rules.}
	syslog_default_rule=${6:no}
	host=${7:api.meraki.com}
	use_proxy=${8:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${9:yes}
	output_format=${10:#snakecase|camelcase}
	output_level=${11:debug|#normal}
	timeout=${12:30}
	validate_certs=${13:yes}
	org_name=${14:# Name of organization.}
	org_id=${15:# ID of organization.}
	rate_limit_retry_time=${16:165}
	internal_error_retry_time=${17:60}

endsnippet

snippet meraki_vlan "Manage VLANs in the Meraki cloud" b
meraki_vlan: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|present|#query}
	net_name=${3:# Name of network which VLAN is in or should be in.}
	net_id=${4:# ID of network which VLAN is in or should be in.}
	vlan_id=${5:# ID number of VLAN.}
	name=${6:# Name of VLAN.}
	subnet=${7:# CIDR notation of network subnet.}
	appliance_ip=${8:# IP address of appliance.}
	dns_nameservers=${9:# Semi-colon delimited list of DNS IP addresses.}
	reserved_ip_range=${10:# IP address ranges which should be reserve and not distributed via DHCP.}
	vpn_nat_subnet=${11:# The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN.}
	fixed_ip_assignments=${12:# Static IP address assignments to be distributed via DHCP by MAC address.}
	host=${13:api.meraki.com}
	use_proxy=${14:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${15:yes}
	output_format=${16:#snakecase|camelcase}
	output_level=${17:debug|#normal}
	timeout=${18:30}
	validate_certs=${19:yes}
	org_name=${20:# Name of organization.}
	org_id=${21:# ID of organization.}
	rate_limit_retry_time=${22:165}
	internal_error_retry_time=${23:60}

endsnippet

snippet meraki_nat "Manage NAT rules in Meraki cloud" b
meraki_nat: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:#present|query}
	net_name=${3:# Name of a network.}
	net_id=${4:# ID number of a network.}
	org_id=${5:# ID of organization associated to a network.}
	subset=${6:1:1|1:many|#all|port_forwarding}
	one_to_one=${7:# List of 1:1 NAT rules.}
	one_to_many=${8:# List of 1:many NAT rules.}
	port_forwarding=${9:# List of port forwarding rules.}
	host=${10:api.meraki.com}
	use_proxy=${11:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${12:yes}
	output_format=${13:#snakecase|camelcase}
	output_level=${14:debug|#normal}
	timeout=${15:30}
	validate_certs=${16:yes}
	org_name=${17:# Name of organization.}
	rate_limit_retry_time=${18:165}
	internal_error_retry_time=${19:60}

endsnippet

snippet meraki_static_route "Manage static routes in the Meraki cloud" b
meraki_static_route: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|query|#present}
	net_name=${3:# Name of a network.}
	net_id=${4:# ID number of a network.}
	name=${5:# Descriptive name of the static route.}
	subnet=${6:# CIDR notation based subnet for static route.}
	gateway_ip=${7:# IP address of the gateway for the subnet.}
	route_id=${8:# Unique ID of static route.}
	fixed_ip_assignments=${9:# List of fixed MAC to IP bindings for DHCP.}
	reserved_ip_ranges=${10:# List of IP ranges reserved for static IP assignments.}
	enabled=${11:# Indicates whether static route is enabled within a network.}
	host=${12:api.meraki.com}
	use_proxy=${13:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${14:yes}
	output_format=${15:#snakecase|camelcase}
	output_level=${16:debug|#normal}
	timeout=${17:30}
	validate_certs=${18:yes}
	org_name=${19:# Name of organization.}
	org_id=${20:# ID of organization.}
	rate_limit_retry_time=${21:165}
	internal_error_retry_time=${22:60}

endsnippet

snippet meraki_firewalled_services "Edit firewall policies for administrative network services" b
meraki_firewalled_services: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.}

	net_name=${2:# Name of a network.}
	net_id=${3:# ID number of a network.}
	org_name=${4:# Name of organization associated to a network.}
	org_id=${5:# ID of organization associated to a network.}
	state=${6:#present|query}
	service=${7:ICMP|SNMP|web}
	access=${8:blocked|restricted|unrestricted}
	allowed_ips=${9:# List of IP addresses allowed to access a service.}
	host=${10:api.meraki.com}
	use_proxy=${11:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${12:yes}
	output_format=${13:#snakecase|camelcase}
	output_level=${14:debug|#normal}
	timeout=${15:30}
	validate_certs=${16:yes}
	rate_limit_retry_time=${17:165}
	internal_error_retry_time=${18:60}

endsnippet

snippet meraki_webhook "Manage webhooks configured in the Meraki cloud" b
meraki_webhook: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|present|#query}
	net_name=${3:# Name of network which configuration is applied to.}
	net_id=${4:# ID of network which configuration is applied to.}
	name=${5:# Name of webhook.}
	shared_secret=${6:# Secret password to use when accessing webhook.}
	url=${7:# URL to access when calling webhook.}
	webhook_id=${8:# Unique ID of webhook.}
	test=${9:test|status}
	test_id=${10:# ID of webhook test query.}
	host=${11:api.meraki.com}
	use_proxy=${12:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${13:yes}
	output_format=${14:#snakecase|camelcase}
	output_level=${15:debug|#normal}
	timeout=${16:30}
	validate_certs=${17:yes}
	org_name=${18:# Name of organization.}
	org_id=${19:# ID of organization.}
	rate_limit_retry_time=${20:165}
	internal_error_retry_time=${21:60}

endsnippet

snippet meraki_admin "Manage administrators in the Meraki cloud" b
meraki_admin: >
	state=${1:absent|present|query}
	auth_key=${2:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	name=${3:# Name of the dashboard administrator.}
	email=${4:# Email address for the dashboard administrator.}
	org_access=${5:full|none|read-only}
	tags=${6:# Tags the administrator has privileges on.}
	networks=${7:# List of networks the administrator has privileges on.}
	org_name=${8:# Name of organization.}
	host=${9:api.meraki.com}
	use_proxy=${10:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${11:yes}
	output_format=${12:#snakecase|camelcase}
	output_level=${13:debug|#normal}
	timeout=${14:30}
	validate_certs=${15:yes}
	org_id=${16:# ID of organization.}
	rate_limit_retry_time=${17:165}
	internal_error_retry_time=${18:60}

endsnippet

snippet meraki_ssid "Manage wireless SSIDs in the Meraki cloud" b
meraki_ssid: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|query|#present}
	number=${3:# SSID number within network.}
	name=${4:# Name of SSID.}
	net_name=${5:# Name of network.}
	net_id=${6:# ID of network.}
	enabled=${7:# Enable or disable SSID network.}
	auth_mode=${8:open|psk|open-with-radius|8021x-meraki|8021x-radius}
	encryption_mode=${9:wpa|eap|wpa-eap}
	psk=${10:# Password for wireless network.}
	wpa_encryption_mode=${11:WPA1 and WPA2|WPA2 only}
	splash_page=${12:None|Click-through splash page|Billing|Password-protected with Meraki RADIUS|Password-protected with custom RADIUS|Password-protected with Active Directory|Password-protected with LDAP|SMS authentication|Systems Manager Sentry|Facebook Wi-Fi|Google OAuth|Sponsored guest}
	radius_servers=${13:# List of RADIUS servers.}
	radius_coa_enabled=${14:# Enable or disable RADIUS CoA (Change of Authorization) on SSID.}
	radius_failover_policy=${15:Deny access|Allow access}
	radius_load_balancing_policy=${16:Strict priority order|Round robin}
	radius_accounting_enabled=${17:# Enable or disable RADIUS accounting.}
	radius_accounting_servers=${18:# List of RADIUS servers for RADIUS accounting.}
	ip_assignment_mode=${19:NAT mode|Bridge mode|Layer 3 roaming|Layer 3 roaming with a concentrator|VPN}
	use_vlan_tagging=${20:# Set whether to use VLAN tagging.}
	default_vlan_id=${21:# Default VLAN ID.}
	vlan_id=${22:# ID number of VLAN on SSID.}
	ap_tags_vlan_ids=${23:# List of VLAN tags.}
	walled_garden_enabled=${24:# Enable or disable walled garden functionality.}
	walled_garden_ranges=${25:# List of walled garden ranges.}
	min_bitrate=${26:1|2|5.5|6|9|11|12|18|24|36|48|54}
	band_selection=${27:Dual band operation|5 GHz band only|Dual band operation with Band Steering}
	per_client_bandwidth_limit_up=${28:# Maximum bandwidth in Mbps devices on SSID can upload.}
	per_client_bandwidth_limit_down=${29:# Maximum bandwidth in Mbps devices on SSID can download.}
	concentrator_network_id=${30:# The concentrator to use for 'Layer 3 roaming with a concentrator' or 'VPN'.}
	host=${31:api.meraki.com}
	use_proxy=${32:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${33:yes}
	output_format=${34:#snakecase|camelcase}
	output_level=${35:debug|#normal}
	timeout=${36:30}
	validate_certs=${37:yes}
	org_name=${38:# Name of organization.}
	org_id=${39:# ID of organization.}
	rate_limit_retry_time=${40:165}
	internal_error_retry_time=${41:60}

endsnippet

snippet meraki_mx_l7_firewall "Manage MX appliance layer 7 firewalls in the Meraki cloud" b
meraki_mx_l7_firewall: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:#present|query}
	net_name=${3:# Name of network which MX firewall is in.}
	net_id=${4:# ID of network which MX firewall is in.}
	rules=${5:# List of layer 7 firewall rules.}
	categories=${6:# When C(True), specifies that applications and application categories should be queried instead of firewall rules.}
	host=${7:api.meraki.com}
	use_proxy=${8:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${9:yes}
	output_format=${10:#snakecase|camelcase}
	output_level=${11:debug|#normal}
	timeout=${12:30}
	validate_certs=${13:yes}
	org_name=${14:# Name of organization.}
	org_id=${15:# ID of organization.}
	rate_limit_retry_time=${16:165}
	internal_error_retry_time=${17:60}

endsnippet

snippet meraki_malware "Manage Malware Protection in the Meraki cloud" b
meraki_malware: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:absent|present|#query}
	net_name=${3:# Name of network which configuration is applied to.}
	net_id=${4:# ID of network which configuration is applied to.}
	allowed_urls=${5:# List of URLs to whitelist.}
	allowed_files=${6:# List of files to whitelist.}
	mode=${7:disabled|enabled}
	host=${8:api.meraki.com}
	use_proxy=${9:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${10:yes}
	output_format=${11:#snakecase|camelcase}
	output_level=${12:debug|#normal}
	timeout=${13:30}
	validate_certs=${14:yes}
	org_name=${15:# Name of organization.}
	org_id=${16:# ID of organization.}
	rate_limit_retry_time=${17:165}
	internal_error_retry_time=${18:60}

endsnippet

snippet meraki_syslog "Manage syslog server settings in the Meraki cloud." b
meraki_syslog: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable MERAKI_KEY is not set.}

	state=${2:#present|query}
	net_name=${3:# Name of a network.}
	net_id=${4:# ID number of a network.}
	servers=${5:# List of syslog server settings}
	host=${6:api.meraki.com}
	use_proxy=${7:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${8:yes}
	output_format=${9:#snakecase|camelcase}
	output_level=${10:debug|#normal}
	timeout=${11:30}
	validate_certs=${12:yes}
	org_name=${13:# Name of organization.}
	org_id=${14:# ID of organization.}
	rate_limit_retry_time=${15:165}
	internal_error_retry_time=${16:60}

endsnippet

snippet meraki_snmp "Manage organizations in the Meraki cloud" b
meraki_snmp: >
	auth_key=${1:# Authentication key provided by the dashboard. Required if environmental variable C(MERAKI_KEY) is not set.}

	state=${2:query|#present}
	v2c_enabled=${3:# Specifies whether SNMPv2c is enabled.}
	v3_enabled=${4:# Specifies whether SNMPv3 is enabled.}
	v3_auth_mode=${5:MD5|SHA}
	v3_auth_pass=${6:# Authentication password for SNMPv3.}
	v3_priv_mode=${7:DES|AES128}
	v3_priv_pass=${8:# Privacy password for SNMPv3.}
	peer_ips=${9:# Semi-colon delimited IP addresses which can perform SNMP queries.}
	net_name=${10:# Name of network.}
	net_id=${11:# ID of network.}
	access=${12:community|none|users}
	community_string=${13:# SNMP community string.}
	users=${14:# Information about users with access to SNMP.}
	host=${15:api.meraki.com}
	use_proxy=${16:# If C(no), it will not use a proxy, even if one is defined in an environment variable on the target hosts.}
	use_https=${17:yes}
	output_format=${18:#snakecase|camelcase}
	output_level=${19:debug|#normal}
	timeout=${20:30}
	validate_certs=${21:yes}
	org_name=${22:# Name of organization.}
	org_id=${23:# ID of organization.}
	rate_limit_retry_time=${24:165}
	internal_error_retry_time=${25:60}

endsnippet

snippet ordnance_config "Manage Ordnance configuration sections" b
ordnance_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	multiline_delimiter=${8:@}
	backup=${9:no}
	config=${10:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
	defaults=${11:no}
	save=${12:no}

endsnippet

snippet ordnance_facts "Collect facts from Ordnance Virtual Routers over SSH" b
ordnance_facts: >
	gather_subset=${1:!config}

endsnippet

snippet ig_unit_information "Get unit information from an Ingate SBC." b
ig_unit_information: >
	client=${1:# A dict object containing connection details.}

endsnippet

snippet ig_config "Manage the configuration database on an Ingate SBC." b
ig_config: >
	add=${1:# Add a row to a table.}
	delete=${2:# Delete all rows in a table or a specific row.}
	get=${3:# Return all rows in a table or a specific row.}
	modify=${4:# Modify a row in a table.}
	revert=${5:# Reset the preliminary configuration.}
	factory=${6:# Reset the preliminary configuration to its factory defaults.}
	store=${7:# Store the preliminary configuration.}
	no_response=${8:# Expect no response when storing the preliminary configuration. Refer to the C(store) option.}
	return_rowid=${9:# Get rowid(s) from a table where the columns match.}
	download=${10:# Download the configuration database from the unit.}
	store_download=${11:no}
	path=${12:# Where in the filesystem to store the downloaded configuration. Refer to the C(download) option.}
	filename=${13:# The name of the file to store the downloaded configuration in. Refer to the C(download) option.}
	table=${14:# The name of the table.}
	rowid=${15:# A row id.}
	columns=${16:# A dict containing column names/values.}
	client=${17:# A dict object containing connection details.}

endsnippet

snippet net_get "Copy a file from a network device to Ansible Controller" b
net_get: >
	src=${1:# Specifies the source file. The path to the source file can either be the full path on the network device or a relative path as per path supported by destination network device.}

	protocol=${2:#scp|sftp}
	dest=${3:['Same filename as specified in I(src). The path will be playbook root or role root directory if playbook is part of a role.']}

endsnippet

snippet net_put "Copy a file from Ansible Controller to a network device" b
net_put: >
	src=${1:# Specifies the source file. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.}

	protocol=${2:#scp|sftp}
	dest=${3:['Filename from src and at default directory of user shell on network_os.']}
	mode=${4:#binary|text}

endsnippet

snippet asa_og "Manage object groups on a Cisco ASA" b
asa_og: >
	name=${1:# Name of the object group.}
	group_type=${2:network-object|service-object|port-object}

	protocol=${3:udp|tcp|tcp-udp}
	host_ip=${4:# The host IP address for object-group network.}
	description=${5:# The description for the object-group.}
	group_object=${6:# The group-object for network object-group.}
	ip_mask=${7:# The IP address and mask for network object-group.}
	port_range=${8:# The port range for port-object.}
	port_eq=${9:# The single port for port-object.}
	service_cfg=${10:# The service-object configuration protocol, direction, range or port.}
	state=${11:#present|absent|replace}

endsnippet

snippet asa_acl "Manage access-lists on a Cisco ASA" b
asa_acl: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}

	before=${2:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${3:# The ordered set of commands to append to the end of the command stack if a changed needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${4:#line|strict|exact}
	replace=${5:#line|block}
	force=${6:no}
	config=${7:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	authorize=${8:no}
	context=${9:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
	provider=${10:# B(Deprecated)}

endsnippet

snippet asa_command "Run arbitrary commands on Cisco ASA devices" b
asa_command: >
	commands=${1:# List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	authorize=${6:no}
	context=${7:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
	provider=${8:# B(Deprecated)}

endsnippet

snippet asa_config "Manage configuration sections on Cisco ASA devices" b
asa_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	backup=${8:no}
	config=${9:# The C(config) argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.}
	defaults=${10:no}
	passwords=${11:no}
	save=${12:no}
	backup_options=${13:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	authorize=${14:no}
	context=${15:# Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.}
	provider=${16:# B(Deprecated)}

endsnippet

snippet fortios_system_external_resource "Configure external resource in Fortinet's FortiOS and FortiGate." b
fortios_system_external_resource: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_external_resource=${8:# Configure external resource.}

endsnippet

snippet fortios_firewall_multicast_address "Configure multicast addresses in Fortinet's FortiOS and FortiGate." b
fortios_firewall_multicast_address: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_multicast_address=${8:# Configure multicast addresses.}

endsnippet

snippet fortios_log_custom_field "Configure custom log fields in Fortinet's FortiOS and FortiGate." b
fortios_log_custom_field: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	log_custom_field=${8:# Configure custom log fields.}

endsnippet

snippet fortios_user_ldap "Configure LDAP server entries in Fortinet's FortiOS and FortiGate." b
fortios_user_ldap: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_ldap=${8:# Configure LDAP server entries.}

endsnippet

snippet fortios_system_snmp_user "SNMP user configuration in Fortinet's FortiOS and FortiGate." b
fortios_system_snmp_user: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_snmp_user=${8:# SNMP user configuration.}

endsnippet

snippet fortios_system_sit_tunnel "Configure IPv6 tunnel over IPv4 in Fortinet's FortiOS and FortiGate." b
fortios_system_sit_tunnel: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_sit_tunnel=${8:# Configure IPv6 tunnel over IPv4.}

endsnippet

snippet fortios_system_mac_address_table "Configure MAC address tables in Fortinet's FortiOS and FortiGate." b
fortios_system_mac_address_table: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_mac_address_table=${8:# Configure MAC address tables.}

endsnippet

snippet fortios_firewall_ippool6 "Configure IPv6 IP pools in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ippool6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ippool6=${8:# Configure IPv6 IP pools.}

endsnippet

snippet fortios_system_ntp "Configure system NTP information in Fortinet's FortiOS and FortiGate." b
fortios_system_ntp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_ntp=${7:# Configure system NTP information.}

endsnippet

snippet fortios_wireless_controller_hotspot20_h2qp_conn_capability "Configure connection capability in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_h2qp_conn_capability: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_h2qp_conn_capability=${8:# Configure connection capability.}

endsnippet

snippet fortios_switch_controller_vlan "Configure VLANs for switch controller in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_vlan: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_vlan=${8:# Configure VLANs for switch controller.}

endsnippet

snippet fortios_application_custom "Configure custom application signatures in Fortinet's FortiOS and FortiGate." b
fortios_application_custom: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	application_custom=${8:# Configure custom application signatures.}

endsnippet

snippet fortios_system_vdom_property "Configure VDOM property in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom_property: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_vdom_property=${8:# Configure VDOM property.}

endsnippet

snippet fortios_user_device_group "Configure device groups in Fortinet's FortiOS and FortiGate." b
fortios_user_device_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_device_group=${8:# Configure device groups.}

endsnippet

snippet fortios_voip_profile "Configure VoIP profiles in Fortinet's FortiOS and FortiGate." b
fortios_voip_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	voip_profile=${8:# Configure VoIP profiles.}

endsnippet

snippet fortios_router_policy6 "Configure IPv6 routing policies in Fortinet's FortiOS and FortiGate." b
fortios_router_policy6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	router_policy6=${8:# Configure IPv6 routing policies.}

endsnippet

snippet fortios_firewall_ttl_policy "Configure TTL policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ttl_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ttl_policy=${8:# Configure TTL policies.}

endsnippet

snippet fortios_web_proxy_debug_url "Configure debug URL addresses in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_debug_url: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	web_proxy_debug_url=${8:# Configure debug URL addresses.}

endsnippet

snippet fortios_wanopt_remote_storage "Configure a remote cache device as Web cache storage in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_remote_storage: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wanopt_remote_storage=${7:# Configure a remote cache device as Web cache storage.}

endsnippet

snippet fortios_router_ospf6 "Configure IPv6 OSPF in Fortinet's FortiOS and FortiGate." b
fortios_router_ospf6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_ospf6=${7:# Configure IPv6 OSPF.}

endsnippet

snippet fortios_router_prefix_list "Configure IPv4 prefix lists in Fortinet's FortiOS and FortiGate." b
fortios_router_prefix_list: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	router_prefix_list=${8:# Configure IPv4 prefix lists.}

endsnippet

snippet fortios_vpn_certificate_setting "VPN certificate setting in Fortinet's FortiOS and FortiGate." b
fortios_vpn_certificate_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	vpn_certificate_setting=${7:# VPN certificate setting.}

endsnippet

snippet fortios_firewall_vip6 "Configure virtual IP for IPv6 in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vip6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vip6=${8:# Configure virtual IP for IPv6.}

endsnippet

snippet fortios_firewall_DoS_policy "Configure IPv4 DoS policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_DoS_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_DoS_policy=${8:# Configure IPv4 DoS policies.}

endsnippet

snippet fortios_system_automation_trigger "Trigger for automation stitches in Fortinet's FortiOS and FortiGate." b
fortios_system_automation_trigger: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_automation_trigger=${8:# Trigger for automation stitches.}

endsnippet

snippet fortios_user_group "Configure user groups in Fortinet's FortiOS and FortiGate." b
fortios_user_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_group=${8:# Configure user groups.}

endsnippet

snippet fortios_wireless_controller_hotspot20_anqp_ip_address_type "Configure IP address type availability in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_anqp_ip_address_type: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_anqp_ip_address_type=${8:# Configure IP address type availability.}

endsnippet

snippet fortios_system_replacemsg_http "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_http: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_http=${8:# Replacement messages.}

endsnippet

snippet fortios_firewall_multicast_address6 "Configure IPv6 multicast address in Fortinet's FortiOS and FortiGate." b
fortios_firewall_multicast_address6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_multicast_address6=${8:# Configure IPv6 multicast address.}

endsnippet

snippet fortios_spamfilter_bword "Configure AntiSpam banned word list in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_bword: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	spamfilter_bword=${8:# Configure AntiSpam banned word list.}

endsnippet

snippet fortios_icap_server "Configure ICAP servers in Fortinet's FortiOS and FortiGate." b
fortios_icap_server: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	icap_server=${8:# Configure ICAP servers.}

endsnippet

snippet fortios_system_replacemsg_alertmail "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_alertmail: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_alertmail=${8:# Replacement messages.}

endsnippet

snippet fortios_system_vdom_exception "Global configuration objects that can be configured independently for all VDOMs or for the defined VDOM scope in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom_exception: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_vdom_exception=${8:# Global configuration objects that can be configured independently for all VDOMs or for the defined VDOM scope.}

endsnippet

snippet fortios_authentication_scheme "Configure Authentication Schemes in Fortinet's FortiOS and FortiGate." b
fortios_authentication_scheme: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	authentication_scheme=${8:# Configure Authentication Schemes.}

endsnippet

snippet fortios_router_rip "Configure RIP in Fortinet's FortiOS and FortiGate." b
fortios_router_rip: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_rip=${7:# Configure RIP.}

endsnippet

snippet fortios_system_storage "Configure logical storage in Fortinet's FortiOS and FortiGate." b
fortios_system_storage: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_storage=${8:# Configure logical storage.}

endsnippet

snippet fortios_system_replacemsg_ec "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_ec: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_ec=${8:# Replacement messages.}

endsnippet

snippet fortios_endpoint_control_client "Configure endpoint control client lists in Fortinet's FortiOS and FortiGate." b
fortios_endpoint_control_client: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	endpoint_control_client=${8:# Configure endpoint control client lists.}

endsnippet

snippet fortios_switch_controller_802_1X_settings "Configure global 802.1X settings in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_802_1X_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_802_1X_settings=${7:# Configure global 802.1X settings.}

endsnippet

snippet fortios_firewall_policy46 "Configure IPv4 to IPv6 policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_policy46: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_policy46=${8:# Configure IPv4 to IPv6 policies.}

endsnippet

snippet fortios_wireless_controller_inter_controller "Configure inter wireless controller operation in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_inter_controller: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wireless_controller_inter_controller=${7:# Configure inter wireless controller operation.}

endsnippet

snippet fortios_switch_controller_network_monitor_settings "Configure network monitor settings in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_network_monitor_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_network_monitor_settings=${7:# Configure network monitor settings.}

endsnippet

snippet fortios_firewall_vipgrp46 "Configure IPv4 to IPv6 virtual IP groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vipgrp46: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vipgrp46=${8:# Configure IPv4 to IPv6 virtual IP groups.}

endsnippet

snippet fortios_system_password_policy_guest_admin "Configure the password policy for guest administrators in Fortinet's FortiOS and FortiGate." b
fortios_system_password_policy_guest_admin: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_password_policy_guest_admin=${7:# Configure the password policy for guest administrators.}

endsnippet

snippet fortios_wanopt_content_delivery_network_rule "Configure WAN optimization content delivery network rules in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_content_delivery_network_rule: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wanopt_content_delivery_network_rule=${8:# Configure WAN optimization content delivery network rules.}

endsnippet

snippet fortios_antivirus_settings "Configure AntiVirus settings in Fortinet's FortiOS and FortiGate." b
fortios_antivirus_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	antivirus_settings=${7:# Configure AntiVirus settings.}

endsnippet

snippet fortios_firewall_schedule_group "Schedule group configuration in Fortinet's FortiOS and FortiGate." b
fortios_firewall_schedule_group: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_schedule_group=${8:# Schedule group configuration.}

endsnippet

snippet fortios_switch_controller_switch_group "Configure FortiSwitch switch groups in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_switch_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_switch_group=${8:# Configure FortiSwitch switch groups.}

endsnippet

snippet fortios_log_syslogd4_setting "Global settings for remote syslog server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd4_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd4_setting=${7:# Global settings for remote syslog server.}

endsnippet

snippet fortios_switch_controller_security_policy_captive_portal "Names of VLANs that use captive portal authentication in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_security_policy_captive_portal: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_security_policy_captive_portal=${8:# Names of VLANs that use captive portal authentication.}

endsnippet

snippet fortios_system_vdom_sflow "Configure sFlow per VDOM to add or change the IP address and UDP port that FortiGate sFlow agents in this VDOM use to send sFlow datagrams to an sFlow collector in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom_sflow: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_vdom_sflow=${7:# Configure sFlow per VDOM to add or change the IP address and UDP port that FortiGate sFlow agents in this VDOM use to send sFlow datagrams to an sFlow collector.}

endsnippet

snippet fortios_system_vdom_dns "Configure DNS servers for a non-management VDOM in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom_dns: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_vdom_dns=${7:# Configure DNS servers for a non-management VDOM.}

endsnippet

snippet fortios_log_fortianalyzer_override_setting "Override FortiAnalyzer settings in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer_override_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer_override_setting=${7:# Override FortiAnalyzer settings.}

endsnippet

snippet fortios_system_vdom "Configure virtual domain in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	system_vdom=${8:# Configure virtual domain.}

endsnippet

snippet fortios_webfilter_urlfilter "Configure URL filter lists in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_urlfilter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_urlfilter=${8:# Configure URL filter lists.}

endsnippet

snippet fortios_web_proxy_global "Configure Web proxy global settings in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_global: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	web_proxy_global=${7:# Configure Web proxy global settings.}

endsnippet

snippet fortios_router_policy "Configure IPv4 routing policies in Fortinet's FortiOS and FortiGate." b
fortios_router_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	router_policy=${8:# Configure IPv4 routing policies.}

endsnippet

snippet fortios_user_radius "Configure RADIUS server entries in Fortinet's FortiOS and FortiGate." b
fortios_user_radius: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	user_radius=${8:# Configure RADIUS server entries.}

endsnippet

snippet fortios_waf_sub_class "Hidden table for datasource in Fortinet's FortiOS and FortiGate." b
fortios_waf_sub_class: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	waf_sub_class=${8:# Hidden table for datasource.}

endsnippet

snippet fortios_system_mobile_tunnel "Configure Mobile tunnels, an implementation of Network Mobility (NEMO) extensions for Mobile IPv4 RFC5177 in Fortinet's FortiOS and FortiGate." b
fortios_system_mobile_tunnel: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_mobile_tunnel=${8:# Configure Mobile tunnels, an implementation of Network Mobility (NEMO) extensions for Mobile IPv4 RFC5177.}

endsnippet

snippet fortios_spamfilter_fortishield "Configure FortiGuard - AntiSpam in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_fortishield: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	spamfilter_fortishield=${7:# Configure FortiGuard - AntiSpam.}

endsnippet

snippet fortios_log_memory_global_setting "Global settings for memory logging in Fortinet's FortiOS and FortiGate." b
fortios_log_memory_global_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_memory_global_setting=${7:# Global settings for memory logging.}

endsnippet

snippet fortios_spamfilter_iptrust "Configure AntiSpam IP trust in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_iptrust: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	spamfilter_iptrust=${8:# Configure AntiSpam IP trust.}

endsnippet

snippet fortios_endpoint_control_profile "Configure FortiClient endpoint control profiles in Fortinet's FortiOS and FortiGate." b
fortios_endpoint_control_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	endpoint_control_profile=${8:# Configure FortiClient endpoint control profiles.}

endsnippet

snippet fortios_wireless_controller_hotspot20_h2qp_osu_provider "Configure online sign up (OSU) provider list in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_h2qp_osu_provider: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_h2qp_osu_provider=${8:# Configure online sign up (OSU) provider list.}

endsnippet

snippet fortios_firewall_multicast_policy6 "Configure IPv6 multicast NAT policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_multicast_policy6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_multicast_policy6=${8:# Configure IPv6 multicast NAT policies.}

endsnippet

snippet fortios_vpn_certificate_local "Local keys and certificates in Fortinet's FortiOS and FortiGate." b
fortios_vpn_certificate_local: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_certificate_local=${8:# Local keys and certificates.}

endsnippet

snippet fortios_vpn_ssl_settings "Configure SSL VPN in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ssl_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	vpn_ssl_settings=${7:# Configure SSL VPN.}

endsnippet

snippet fortios_vpn_ssl_web_user_group_bookmark "Configure SSL VPN user group bookmark in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ssl_web_user_group_bookmark: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_ssl_web_user_group_bookmark=${8:# Configure SSL VPN user group bookmark.}

endsnippet

snippet fortios_facts "Get facts about fortios devices." b
fortios_facts: >
	gather_subset=${1:# When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include system_current-admins_select, system_firmware_select, system_fortimanager_status, system_ha-checksums_select, system_interface_select, system_status_select and system_time_select}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:no}

endsnippet

snippet fortios_system_autoupdate_tunneling "Configure web proxy tunnelling for the FDN in Fortinet's FortiOS and FortiGate." b
fortios_system_autoupdate_tunneling: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_autoupdate_tunneling=${7:# Configure web proxy tunnelling for the FDN.}

endsnippet

snippet fortios_ips_decoder "Configure IPS decoder in Fortinet's FortiOS and FortiGate." b
fortios_ips_decoder: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	ips_decoder=${8:# Configure IPS decoder.}

endsnippet

snippet fortios_vpn_pptp "Configure PPTP in Fortinet's FortiOS and FortiGate." b
fortios_vpn_pptp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	vpn_pptp=${7:# Configure PPTP.}

endsnippet

snippet fortios_system_replacemsg_sslvpn "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_sslvpn: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_sslvpn=${8:# Replacement messages.}

endsnippet

snippet fortios_log_fortiguard_override_filter "Override filters for FortiCloud in Fortinet's FortiOS and FortiGate." b
fortios_log_fortiguard_override_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortiguard_override_filter=${7:# Override filters for FortiCloud.}

endsnippet

snippet fortios_vpn_ssl_web_realm "Realm in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ssl_web_realm: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_ssl_web_realm=${8:# Realm.}

endsnippet

snippet fortios_switch_controller_stp_settings "Configure FortiSwitch spanning tree protocol (STP) in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_stp_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_stp_settings=${7:# Configure FortiSwitch spanning tree protocol (STP).}

endsnippet

snippet fortios_switch_controller_qos_qos_policy "Configure FortiSwitch QoS policy in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_qos_qos_policy: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_qos_qos_policy=${8:# Configure FortiSwitch QoS policy.}

endsnippet

snippet fortios_application_group "Configure firewall application groups in Fortinet's FortiOS and FortiGate." b
fortios_application_group: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	application_group=${8:# Configure firewall application groups.}

endsnippet

snippet fortios_system_global "Configure global attributes in Fortinet's FortiOS and FortiGate." b
fortios_system_global: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_global=${7:# Configure global attributes.}

endsnippet

snippet fortios_system_virtual_wan_link "Configure redundant internet connections using SD-WAN (formerly virtual WAN link) in Fortinet's FortiOS and FortiGate." b
fortios_system_virtual_wan_link: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_virtual_wan_link=${7:# Configure redundant internet connections using SD-WAN (formerly virtual WAN link).}

endsnippet

snippet fortios_firewall_ssh_local_ca "SSH proxy local CA in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ssh_local_ca: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ssh_local_ca=${8:# SSH proxy local CA.}

endsnippet

snippet fortios_system_fortimanager "Configure FortiManager in Fortinet's FortiOS and FortiGate." b
fortios_system_fortimanager: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_fortimanager=${7:# Configure FortiManager.}

endsnippet

snippet fortios_system_alarm "Configure alarm in Fortinet's FortiOS and FortiGate." b
fortios_system_alarm: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_alarm=${7:# Configure alarm.}

endsnippet

snippet fortios_router_static6 "Configure IPv6 static routing tables in Fortinet's FortiOS and FortiGate." b
fortios_router_static6: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	router_static6=${8:# Configure IPv6 static routing tables.}

endsnippet

snippet fortios_system_snmp_community "SNMP community configuration in Fortinet's FortiOS and FortiGate." b
fortios_system_snmp_community: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_snmp_community=${8:# SNMP community configuration.}

endsnippet

snippet fortios_dlp_fp_doc_source "Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints in Fortinet's FortiOS and FortiGate." b
fortios_dlp_fp_doc_source: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	dlp_fp_doc_source=${8:# Create a DLP fingerprint database by allowing the FortiGate to access a file server containing files from which to create fingerprints.}

endsnippet

snippet fortios_webfilter_content "Configure Web filter banned word table in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_content: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_content=${8:# Configure Web filter banned word table.}

endsnippet

snippet fortios_system_zone "Configure zones to group two or more interfaces. When a zone is created you can configure policies for the zone instead of individual interfaces in the zone in Fortinet's FortiOS and FortiGate." b
fortios_system_zone: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_zone=${8:# Configure zones to group two or more interfaces. When a zone is created you can configure policies for the zone instead of individual interfaces in the zone.}

endsnippet

snippet fortios_web_proxy_forward_server_group "Configure a forward server group consisting or multiple forward servers. Supports failover and load balancing in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_forward_server_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	web_proxy_forward_server_group=${8:# Configure a forward server group consisting or multiple forward servers. Supports failover and load balancing.}

endsnippet

snippet fortios_user_password_policy "Configure user password policy in Fortinet's FortiOS and FortiGate." b
fortios_user_password_policy: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_password_policy=${8:# Configure user password policy.}

endsnippet

snippet fortios_switch_controller_qos_ip_dscp_map "Configure FortiSwitch QoS IP precedence/DSCP in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_qos_ip_dscp_map: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_qos_ip_dscp_map=${8:# Configure FortiSwitch QoS IP precedence/DSCP.}

endsnippet

snippet fortios_extender_controller_extender "Extender controller configuration in Fortinet's FortiOS and FortiGate." b
fortios_extender_controller_extender: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	extender_controller_extender=${8:# Extender controller configuration.}

endsnippet

snippet fortios_router_prefix_list6 "Configure IPv6 prefix lists in Fortinet's FortiOS and FortiGate." b
fortios_router_prefix_list6: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	router_prefix_list6=${8:# Configure IPv6 prefix lists.}

endsnippet

snippet fortios_dnsfilter_domain_filter "Configure DNS domain filters in Fortinet's FortiOS and FortiGate." b
fortios_dnsfilter_domain_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	dnsfilter_domain_filter=${8:# Configure DNS domain filters.}

endsnippet

snippet fortios_application_rule_settings "Configure application rule settings in Fortinet's FortiOS and FortiGate." b
fortios_application_rule_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	application_rule_settings=${8:# Configure application rule settings.}

endsnippet

snippet fortios_log_webtrends_setting "Settings for WebTrends in Fortinet's FortiOS and FortiGate." b
fortios_log_webtrends_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_webtrends_setting=${7:# Settings for WebTrends.}

endsnippet

snippet fortios_user_adgrp "Configure FSSO groups in Fortinet's FortiOS and FortiGate." b
fortios_user_adgrp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	user_adgrp=${8:# Configure FSSO groups.}

endsnippet

snippet fortios_log_memory_setting "Settings for memory buffer in Fortinet's FortiOS and FortiGate." b
fortios_log_memory_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_memory_setting=${7:# Settings for memory buffer.}

endsnippet

snippet fortios_system_auto_script "Configure auto script in Fortinet's FortiOS and FortiGate." b
fortios_system_auto_script: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_auto_script=${8:# Configure auto script.}

endsnippet

snippet fortios_system_ftm_push "Configure FortiToken Mobile push services in Fortinet's FortiOS and FortiGate." b
fortios_system_ftm_push: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_ftm_push=${7:# Configure FortiToken Mobile push services.}

endsnippet

snippet fortios_firewall_local_in_policy6 "Configure user defined IPv6 local-in policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_local_in_policy6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_local_in_policy6=${8:# Configure user defined IPv6 local-in policies.}

endsnippet

snippet fortios_vpn_ipsec_forticlient "Configure FortiClient policy realm in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_forticlient: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_forticlient=${8:# Configure FortiClient policy realm.}

endsnippet

snippet fortios_firewall_vipgrp6 "Configure IPv6 virtual IP groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vipgrp6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vipgrp6=${8:# Configure IPv6 virtual IP groups.}

endsnippet

snippet fortios_switch_controller_switch_log "Configure FortiSwitch logging (logs are transferred to and inserted into FortiGate event log) in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_switch_log: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_switch_log=${7:# Configure FortiSwitch logging (logs are transferred to and inserted into FortiGate event log).}

endsnippet

snippet fortios_vpn_ipsec_phase2 "Configure VPN autokey tunnel in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_phase2: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_phase2=${8:# Configure VPN autokey tunnel.}

endsnippet

snippet fortios_system_gre_tunnel "Configure GRE tunnel in Fortinet's FortiOS and FortiGate." b
fortios_system_gre_tunnel: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_gre_tunnel=${8:# Configure GRE tunnel.}

endsnippet

snippet fortios_vpn_l2tp "Configure L2TP in Fortinet's FortiOS and FortiGate." b
fortios_vpn_l2tp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	vpn_l2tp=${7:# Configure L2TP.}

endsnippet

snippet fortios_vpn_ipsec_manualkey "Configure IPsec manual keys in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_manualkey: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_manualkey=${8:# Configure IPsec manual keys.}

endsnippet

snippet fortios_firewall_local_in_policy "Configure user defined IPv4 local-in policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_local_in_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_local_in_policy=${8:# Configure user defined IPv4 local-in policies.}

endsnippet

snippet fortios_system_alias "Configure alias command in Fortinet's FortiOS and FortiGate." b
fortios_system_alias: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_alias=${8:# Configure alias command.}

endsnippet

snippet fortios_system_replacemsg_traffic_quota "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_traffic_quota: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_traffic_quota=${8:# Replacement messages.}

endsnippet

snippet fortios_spamfilter_mheader "Configure AntiSpam MIME header in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_mheader: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	spamfilter_mheader=${8:# Configure AntiSpam MIME header.}

endsnippet

snippet fortios_webfilter_fortiguard "Configure FortiGuard Web Filter service in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_fortiguard: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	webfilter_fortiguard=${7:# Configure FortiGuard Web Filter service.}

endsnippet

snippet fortios_log_fortiguard_override_setting "Override global FortiCloud logging settings for this VDOM in Fortinet's FortiOS and FortiGate." b
fortios_log_fortiguard_override_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortiguard_override_setting=${7:# Override global FortiCloud logging settings for this VDOM.}

endsnippet

snippet fortios_log_fortianalyzer_filter "Filters for FortiAnalyzer in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer_filter=${7:# Filters for FortiAnalyzer.}

endsnippet

snippet fortios_wireless_controller_timers "Configure CAPWAP timers in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_timers: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wireless_controller_timers=${7:# Configure CAPWAP timers.}

endsnippet

snippet fortios_user_device_access_list "Configure device access control lists in Fortinet's FortiOS and FortiGate." b
fortios_user_device_access_list: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_device_access_list=${8:# Configure device access control lists.}

endsnippet

snippet fortios_log_gui_display "Configure how log messages are displayed on the GUI in Fortinet's FortiOS and FortiGate." b
fortios_log_gui_display: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_gui_display=${7:# Configure how log messages are displayed on the GUI.}

endsnippet

snippet fortios_firewall_proxy_address "Web proxy address configuration in Fortinet's FortiOS and FortiGate." b
fortios_firewall_proxy_address: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_proxy_address=${8:# Web proxy address configuration.}

endsnippet

snippet fortios_firewall_multicast_policy "Configure multicast NAT policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_multicast_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_multicast_policy=${8:# Configure multicast NAT policies.}

endsnippet

snippet fortios_wireless_controller_hotspot20_anqp_roaming_consortium "Configure roaming consortium in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_anqp_roaming_consortium: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_anqp_roaming_consortium=${8:# Configure roaming consortium.}

endsnippet

snippet fortios_firewall_schedule_recurring "Recurring schedule configuration in Fortinet's FortiOS and FortiGate." b
fortios_firewall_schedule_recurring: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_schedule_recurring=${8:# Recurring schedule configuration.}

endsnippet

snippet fortios_system_object_tagging "Configure object tagging in Fortinet's FortiOS and FortiGate." b
fortios_system_object_tagging: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_object_tagging=${8:# Configure object tagging.}

endsnippet

snippet fortios_system_geoip_override "Configure geographical location mapping for IP address(es) to override mappings from FortiGuard in Fortinet's FortiOS and FortiGate." b
fortios_system_geoip_override: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_geoip_override=${8:# Configure geographical location mapping for IP address(es) to override mappings from FortiGuard.}

endsnippet

snippet fortios_system_csf "Add this FortiGate to a Security Fabric or set up a new Security Fabric on this FortiGate in Fortinet's FortiOS and FortiGate." b
fortios_system_csf: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_csf=${7:# Add this FortiGate to a Security Fabric or set up a new Security Fabric on this FortiGate.}

endsnippet

snippet fortios_system_nat64 "Configure NAT64 in Fortinet's FortiOS and FortiGate." b
fortios_system_nat64: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_nat64=${7:# Configure NAT64.}

endsnippet

snippet fortios_router_bgp "Configure BGP in Fortinet's FortiOS and FortiGate." b
fortios_router_bgp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_bgp=${7:# Configure BGP.}

endsnippet

snippet fortios_dlp_settings "Designate logical storage for DLP fingerprint database in Fortinet's FortiOS and FortiGate." b
fortios_dlp_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	dlp_settings=${7:# Designate logical storage for DLP fingerprint database.}

endsnippet

snippet fortios_firewall_addrgrp6 "Configure IPv6 address groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_addrgrp6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_addrgrp6=${8:# Configure IPv6 address groups.}

endsnippet

snippet fortios_system_fsso_polling "Configure Fortinet Single Sign On (FSSO) server in Fortinet's FortiOS and FortiGate." b
fortios_system_fsso_polling: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_fsso_polling=${7:# Configure Fortinet Single Sign On (FSSO) server.}

endsnippet

snippet fortios_system_dns "Configure DNS in Fortinet's FortiOS and FortiGate." b
fortios_system_dns: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_dns=${7:# Configure DNS.}

endsnippet

snippet fortios_firewall_schedule_onetime "Onetime schedule configuration in Fortinet's FortiOS and FortiGate." b
fortios_firewall_schedule_onetime: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_schedule_onetime=${8:# Onetime schedule configuration.}

endsnippet

snippet fortios_firewall_ssh_local_key "SSH proxy local keys in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ssh_local_key: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ssh_local_key=${8:# SSH proxy local keys.}

endsnippet

snippet fortios_spamfilter_dnsbl "Configure AntiSpam DNSBL/ORBL in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_dnsbl: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	spamfilter_dnsbl=${8:# Configure AntiSpam DNSBL/ORBL.}

endsnippet

snippet fortios_system_fortisandbox "Configure FortiSandbox in Fortinet's FortiOS and FortiGate." b
fortios_system_fortisandbox: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_fortisandbox=${7:# Configure FortiSandbox.}

endsnippet

snippet fortios_firewall_vip "Configure virtual IP for IPv4 in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vip: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vip=${8:# Configure virtual IP for IPv4.}

endsnippet

snippet fortios_firewall_ip_translation "Configure firewall IP-translation in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ip_translation: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ip_translation=${8:# Configure firewall IP-translation.}

endsnippet

snippet fortios_firewall_addrgrp "Configure IPv4 address groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_addrgrp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_addrgrp=${8:# Configure IPv4 address groups.}

endsnippet

snippet fortios_user_security_exempt_list "Configure security exemption list in Fortinet's FortiOS and FortiGate." b
fortios_user_security_exempt_list: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_security_exempt_list=${8:# Configure security exemption list.}

endsnippet

snippet fortios_firewall_vipgrp "Configure IPv4 virtual IP groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vipgrp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vipgrp=${8:# Configure IPv4 virtual IP groups.}

endsnippet

snippet fortios_firewall_dnstranslation "Configure DNS translation in Fortinet's FortiOS and FortiGate." b
fortios_firewall_dnstranslation: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_dnstranslation=${8:# Configure DNS translation.}

endsnippet

snippet fortios_vpn_ipsec_manualkey_interface "Configure IPsec manual keys in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_manualkey_interface: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_manualkey_interface=${8:# Configure IPsec manual keys.}

endsnippet

snippet fortios_log_fortianalyzer_override_filter "Override filters for FortiAnalyzer in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer_override_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer_override_filter=${7:# Override filters for FortiAnalyzer.}

endsnippet

snippet fortios_user_device_category "Configure device categories in Fortinet's FortiOS and FortiGate." b
fortios_user_device_category: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_device_category=${8:# Configure device categories.}

endsnippet

snippet fortios_router_setting "Configure router settings in Fortinet's FortiOS and FortiGate." b
fortios_router_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_setting=${7:# Configure router settings.}

endsnippet

snippet fortios_firewall_policy6 "Configure IPv6 policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_policy6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_policy6=${8:# Configure IPv6 policies.}

endsnippet

snippet fortios_system_ips_urlfilter_dns "Configure IPS URL filter DNS servers in Fortinet's FortiOS and FortiGate." b
fortios_system_ips_urlfilter_dns: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_ips_urlfilter_dns=${8:# Configure IPS URL filter DNS servers.}

endsnippet

snippet fortios_system_dns_database "Configure DNS databases in Fortinet's FortiOS and FortiGate." b
fortios_system_dns_database: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_dns_database=${8:# Configure DNS databases.}

endsnippet

snippet fortios_system_dhcp_server "Configure DHCP servers in Fortinet's FortiOS and FortiGate." b
fortios_system_dhcp_server: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	system_dhcp_server=${8:# Configure DHCP servers.}

endsnippet

snippet fortios_system_dhcp6_server "Configure DHCPv6 servers in Fortinet's FortiOS and FortiGate." b
fortios_system_dhcp6_server: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_dhcp6_server=${8:# Configure DHCPv6 servers.}

endsnippet

snippet fortios_switch_controller_sflow "Configure FortiSwitch sFlow in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_sflow: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_sflow=${7:# Configure FortiSwitch sFlow.}

endsnippet

snippet fortios_log_syslogd3_setting "Global settings for remote syslog server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd3_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd3_setting=${7:# Global settings for remote syslog server.}

endsnippet

snippet fortios_system_pppoe_interface "Configure the PPPoE interfaces in Fortinet's FortiOS and FortiGate." b
fortios_system_pppoe_interface: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_pppoe_interface=${8:# Configure the PPPoE interfaces.}

endsnippet

snippet fortios_report_setting "Report setting configuration in Fortinet's FortiOS and FortiGate." b
fortios_report_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	report_setting=${7:# Report setting configuration.}

endsnippet

snippet fortios_waf_signature "Hidden table for datasource in Fortinet's FortiOS and FortiGate." b
fortios_waf_signature: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	waf_signature=${8:# Hidden table for datasource.}

endsnippet

snippet fortios_firewall_DoS_policy6 "Configure IPv6 DoS policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_DoS_policy6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_DoS_policy6=${8:# Configure IPv6 DoS policies.}

endsnippet

snippet fortios_webfilter_ips_urlfilter_setting6 "Configure IPS URL filter settings for IPv6 in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_ips_urlfilter_setting6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	webfilter_ips_urlfilter_setting6=${7:# Configure IPS URL filter settings for IPv6.}

endsnippet

snippet fortios_waf_profile "Web application firewall configuration in Fortinet's FortiOS and FortiGate." b
fortios_waf_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	waf_profile=${8:# Web application firewall configuration.}

endsnippet

snippet fortios_firewall_profile_group "Configure profile groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_profile_group: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_profile_group=${8:# Configure profile groups.}

endsnippet

snippet fortios_firewall_ssl_setting "SSL proxy settings in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ssl_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	firewall_ssl_setting=${7:# SSL proxy settings.}

endsnippet

snippet fortios_firewall_ipv6_eh_filter "Configure IPv6 extension header filter in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ipv6_eh_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	firewall_ipv6_eh_filter=${7:# Configure IPv6 extension header filter.}

endsnippet

snippet fortios_system_link_monitor "Configure Link Health Monitor in Fortinet's FortiOS and FortiGate." b
fortios_system_link_monitor: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_link_monitor=${8:# Configure Link Health Monitor.}

endsnippet

snippet fortios_firewall_auth_portal "Configure firewall authentication portals in Fortinet's FortiOS and FortiGate." b
fortios_firewall_auth_portal: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	firewall_auth_portal=${7:# Configure firewall authentication portals.}

endsnippet

snippet fortios_firewall_address6 "Configure IPv6 firewall addresses in Fortinet's FortiOS and FortiGate." b
fortios_firewall_address6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_address6=${8:# Configure IPv6 firewall addresses.}

endsnippet

snippet fortios_webfilter_content_header "Configure content types used by Web filter in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_content_header: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_content_header=${8:# Configure content types used by Web filter.}

endsnippet

snippet fortios_wireless_controller_vap_group "Configure virtual Access Point (VAP) groups in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_vap_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_vap_group=${8:# Configure virtual Access Point (VAP) groups.}

endsnippet

snippet fortios_firewall_service_category "Configure service categories in Fortinet's FortiOS and FortiGate." b
fortios_firewall_service_category: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_service_category=${8:# Configure service categories.}

endsnippet

snippet fortios_log_null_device_filter "Filters for null device logging in Fortinet's FortiOS and FortiGate." b
fortios_log_null_device_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_null_device_filter=${7:# Filters for null device logging.}

endsnippet

snippet fortios_firewall_wildcard_fqdn_custom "Config global/VDOM Wildcard FQDN address in Fortinet's FortiOS and FortiGate." b
fortios_firewall_wildcard_fqdn_custom: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_wildcard_fqdn_custom=${8:# Config global/VDOM Wildcard FQDN address.}

endsnippet

snippet fortios_switch_controller_lldp_profile "Configure FortiSwitch LLDP profiles in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_lldp_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	switch_controller_lldp_profile=${8:# Configure FortiSwitch LLDP profiles.}

endsnippet

snippet fortios_wireless_controller_hotspot20_hs_profile "Configure hotspot profile in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_hs_profile: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_hs_profile=${8:# Configure hotspot profile.}

endsnippet

snippet fortios_vpn_ssl_web_host_check_software "SSL-VPN host check software in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ssl_web_host_check_software: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_ssl_web_host_check_software=${8:# SSL-VPN host check software.}

endsnippet

snippet fortios_router_multicast_flow "Configure multicast-flow in Fortinet's FortiOS and FortiGate." b
fortios_router_multicast_flow: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	router_multicast_flow=${8:# Configure multicast-flow.}

endsnippet

snippet fortios_log_syslogd_override_filter "Override filters for remote system server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd_override_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd_override_filter=${7:# Override filters for remote system server.}

endsnippet

snippet fortios_application_name "Configure application signatures in Fortinet's FortiOS and FortiGate." b
fortios_application_name: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	application_name=${8:# Configure application signatures.}

endsnippet

snippet fortios_system_switch_interface "Configure software switch interfaces by grouping physical and WiFi interfaces in Fortinet's FortiOS and FortiGate." b
fortios_system_switch_interface: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_switch_interface=${8:# Configure software switch interfaces by grouping physical and WiFi interfaces.}

endsnippet

snippet fortios_firewall_proxy_addrgrp "Web proxy address group configuration in Fortinet's FortiOS and FortiGate." b
fortios_firewall_proxy_addrgrp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_proxy_addrgrp=${8:# Web proxy address group configuration.}

endsnippet

snippet fortios_config "Manage config on Fortinet FortiOS firewall devices" b
fortios_config: >
	src=${1:# The I(src) argument provides a path to the configuration template to load into the remote device.}
	filter=${2:}
	file_mode=${3:no}
	config_file=${4:# Path to configuration file. Required when I(file_mode) is True.}
	host=${5:# Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.}
	username=${6:# Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.}
	password=${7:# Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.}
	timeout=${8:60}
	vdom=${9:# Specifies on which vdom to apply configuration}
	backup=${10:no}
	backup_path=${11:# Specifies where to store backup files. Required if I(backup=yes).}
	backup_filename=${12:# Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS}

endsnippet

snippet fortios_system_ddns "Configure DDNS in Fortinet's FortiOS and FortiGate." b
fortios_system_ddns: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_ddns=${8:# Configure DDNS.}

endsnippet

snippet fortios_log_eventfilter "Configure log event filters in Fortinet's FortiOS and FortiGate." b
fortios_log_eventfilter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_eventfilter=${7:# Configure log event filters.}

endsnippet

snippet fortios_alertemail_setting "Configure alert email settings in Fortinet's FortiOS and FortiGate." b
fortios_alertemail_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	alertemail_setting=${7:# Configure alert email settings.}

endsnippet

snippet fortios_wireless_controller_bonjour_profile "Configure Bonjour profiles. Bonjour is Apple's zero configuration networking protocol. Bonjour profiles allow APs and FortiAPs to connect to networks using Bonjour in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_bonjour_profile: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_bonjour_profile=${8:# Configure Bonjour profiles. Bonjour is Apple's zero configuration networking protocol. Bonjour profiles allow APs and FortiAPs to connect to networks using Bonjour.}

endsnippet

snippet fortios_switch_controller_qos_queue_policy "Configure FortiSwitch QoS egress queue policy in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_qos_queue_policy: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_qos_queue_policy=${8:# Configure FortiSwitch QoS egress queue policy.}

endsnippet

snippet fortios_system_automation_destination "Automation destinations in Fortinet's FortiOS and FortiGate." b
fortios_system_automation_destination: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_automation_destination=${8:# Automation destinations.}

endsnippet

snippet fortios_log_fortianalyzer3_setting "Global FortiAnalyzer settings in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer3_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer3_setting=${7:# Global FortiAnalyzer settings.}

endsnippet

snippet fortios_system_cluster_sync "Configure FortiGate Session Life Support Protocol (FGSP) session synchronization in Fortinet's FortiOS and FortiGate." b
fortios_system_cluster_sync: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_cluster_sync=${8:# Configure FortiGate Session Life Support Protocol (FGSP) session synchronization.}

endsnippet

snippet fortios_webfilter_ftgd_local_cat "Configure FortiGuard Web Filter local categories in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_ftgd_local_cat: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_ftgd_local_cat=${8:# Configure FortiGuard Web Filter local categories.}

endsnippet

snippet fortios_ssh_filter_profile "SSH filter profile in Fortinet's FortiOS and FortiGate." b
fortios_ssh_filter_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	ssh_filter_profile=${8:# SSH filter profile.}

endsnippet

snippet fortios_firewall_vip64 "Configure IPv6 to IPv4 virtual IPs in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vip64: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vip64=${8:# Configure IPv6 to IPv4 virtual IPs.}

endsnippet

snippet fortios_router_community_list "Configure community lists in Fortinet's FortiOS and FortiGate." b
fortios_router_community_list: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	router_community_list=${8:# Configure community lists.}

endsnippet

snippet fortios_system_ipv6_neighbor_cache "Configure IPv6 neighbor cache table in Fortinet's FortiOS and FortiGate." b
fortios_system_ipv6_neighbor_cache: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_ipv6_neighbor_cache=${8:# Configure IPv6 neighbor cache table.}

endsnippet

snippet fortios_firewall_address "Configure IPv4 addresses in Fortinet's FortiOS and FortiGate." b
fortios_firewall_address: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_address=${8:# Configure IPv4 addresses.}

endsnippet

snippet fortios_web_proxy_explicit "Configure explicit Web proxy settings in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_explicit: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	web_proxy_explicit=${7:# Configure explicit Web proxy settings.}

endsnippet

snippet fortios_system_nd_proxy "Configure IPv6 neighbor discovery proxy (RFC4389) in Fortinet's FortiOS and FortiGate." b
fortios_system_nd_proxy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_nd_proxy=${7:# Configure IPv6 neighbor discovery proxy (RFC4389).}

endsnippet

snippet fortios_firewall_ldb_monitor "Configure server load balancing health monitors in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ldb_monitor: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ldb_monitor=${8:# Configure server load balancing health monitors.}

endsnippet

snippet fortios_wireless_controller_hotspot20_qos_map "Configure QoS map set in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_qos_map: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_qos_map=${8:# Configure QoS map set.}

endsnippet

snippet fortios_vpn_ipsec_phase2_interface "Configure VPN autokey tunnel in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_phase2_interface: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_phase2_interface=${8:# Configure VPN autokey tunnel.}

endsnippet

snippet fortios_wireless_controller_wids_profile "Configure wireless intrusion detection system (WIDS) profiles in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_wids_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	wireless_controller_wids_profile=${8:# Configure wireless intrusion detection system (WIDS) profiles.}

endsnippet

snippet fortios_system_automation_stitch "Automation stitches in Fortinet's FortiOS and FortiGate." b
fortios_system_automation_stitch: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_automation_stitch=${8:# Automation stitches.}

endsnippet

snippet fortios_system_probe_response "Configure system probe response in Fortinet's FortiOS and FortiGate." b
fortios_system_probe_response: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_probe_response=${7:# Configure system probe response.}

endsnippet

snippet fortios_web_proxy_url_match "Exempt URLs from web proxy forwarding and caching in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_url_match: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	web_proxy_url_match=${8:# Exempt URLs from web proxy forwarding and caching.}

endsnippet

snippet fortios_vpn_certificate_remote "Remote certificate as a PEM file in Fortinet's FortiOS and FortiGate." b
fortios_vpn_certificate_remote: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_certificate_remote=${8:# Remote certificate as a PEM file.}

endsnippet

snippet fortios_log_fortianalyzer3_filter "Filters for FortiAnalyzer in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer3_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer3_filter=${7:# Filters for FortiAnalyzer.}

endsnippet

snippet fortios_firewall_internet_service_custom "Configure custom Internet Services in Fortinet's FortiOS and FortiGate." b
fortios_firewall_internet_service_custom: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_internet_service_custom=${8:# Configure custom Internet Services.}

endsnippet

snippet fortios_system_dscp_based_priority "Configure DSCP based priority table in Fortinet's FortiOS and FortiGate." b
fortios_system_dscp_based_priority: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_dscp_based_priority=${8:# Configure DSCP based priority table.}

endsnippet

snippet fortios_webfilter_override "Configure FortiGuard Web Filter administrative overrides in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_override: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_override=${8:# Configure FortiGuard Web Filter administrative overrides.}

endsnippet

snippet fortios_switch_controller_switch_profile "Configure FortiSwitch switch profile in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_switch_profile: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_switch_profile=${8:# Configure FortiSwitch switch profile.}

endsnippet

snippet fortios_firewall_policy "Configure IPv4 policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_policy=${8:# Configure IPv4 policies.}

endsnippet

snippet fortios_system_vdom_netflow "Configure NetFlow per VDOM in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom_netflow: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_vdom_netflow=${7:# Configure NetFlow per VDOM.}

endsnippet

snippet fortios_system_ips_urlfilter_dns6 "Configure IPS URL filter IPv6 DNS servers in Fortinet's FortiOS and FortiGate." b
fortios_system_ips_urlfilter_dns6: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_ips_urlfilter_dns6=${8:# Configure IPS URL filter IPv6 DNS servers.}

endsnippet

snippet fortios_log_fortianalyzer_setting "Global FortiAnalyzer settings in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer_setting=${7:# Global FortiAnalyzer settings.}

endsnippet

snippet fortios_switch_controller_security_policy_802_1X "Configure 802.1x MAC Authentication Bypass (MAB) policies in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_security_policy_802_1X: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_security_policy_802_1X=${8:# Configure 802.1x MAC Authentication Bypass (MAB) policies.}

endsnippet

snippet fortios_vpn_certificate_ca "CA certificate in Fortinet's FortiOS and FortiGate." b
fortios_vpn_certificate_ca: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_certificate_ca=${8:# CA certificate.}

endsnippet

snippet fortios_switch_controller_switch_interface_tag "Configure switch object tags in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_switch_interface_tag: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_switch_interface_tag=${8:# Configure switch object tags.}

endsnippet

snippet fortios_spamfilter_options "Configure AntiSpam options in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_options: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	spamfilter_options=${7:# Configure AntiSpam options.}

endsnippet

snippet fortios_wireless_controller_hotspot20_h2qp_wan_metric "Configure WAN metrics in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_h2qp_wan_metric: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_h2qp_wan_metric=${8:# Configure WAN metrics.}

endsnippet

snippet fortios_system_autoupdate_push_update "Configure push updates in Fortinet's FortiOS and FortiGate." b
fortios_system_autoupdate_push_update: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_autoupdate_push_update=${7:# Configure push updates.}

endsnippet

snippet fortios_log_syslogd_filter "Filters for remote system server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd_filter=${7:# Filters for remote system server.}

endsnippet

snippet fortios_switch_controller_quarantine "Configure FortiSwitch quarantine support in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_quarantine: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_quarantine=${7:# Configure FortiSwitch quarantine support.}

endsnippet

snippet fortios_firewall_internet_service "Show Internet Service application in Fortinet's FortiOS and FortiGate." b
fortios_firewall_internet_service: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_internet_service=${8:# Show Internet Service application.}

endsnippet

snippet fortios_application_list "Configure application control lists in Fortinet's FortiOS and FortiGate." b
fortios_application_list: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	application_list=${8:# Configure application control lists.}

endsnippet

snippet fortios_system_replacemsg_image "Configure replacement message images in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_image: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_image=${8:# Configure replacement message images.}

endsnippet

snippet fortios_vpn_ssl_web_portal "Portal in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ssl_web_portal: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ssl_web_portal=${8:# Portal.}

endsnippet

snippet fortios_system_network_visibility "Configure network visibility settings in Fortinet's FortiOS and FortiGate." b
fortios_system_network_visibility: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_network_visibility=${7:# Configure network visibility settings.}

endsnippet

snippet fortios_firewall_sniffer "Configure sniffer in Fortinet's FortiOS and FortiGate." b
fortios_firewall_sniffer: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_sniffer=${8:# Configure sniffer.}

endsnippet

snippet fortios_system_replacemsg_nac_quar "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_nac_quar: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_nac_quar=${8:# Replacement messages.}

endsnippet

snippet fortios_ips_global "Configure IPS global parameter in Fortinet's FortiOS and FortiGate." b
fortios_ips_global: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	ips_global=${7:# Configure IPS global parameter.}

endsnippet

snippet fortios_log_syslogd_setting "Global settings for remote syslog server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd_setting=${7:# Global settings for remote syslog server.}

endsnippet

snippet fortios_vpn_ipsec_concentrator "Concentrator configuration in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_concentrator: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_concentrator=${8:# Concentrator configuration.}

endsnippet

snippet fortios_vpn_ssl_web_user_bookmark "Configure SSL VPN user bookmark in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ssl_web_user_bookmark: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_ssl_web_user_bookmark=${8:# Configure SSL VPN user bookmark.}

endsnippet

snippet fortios_system_sms_server "Configure SMS server for sending SMS messages to support user authentication in Fortinet's FortiOS and FortiGate." b
fortios_system_sms_server: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_sms_server=${8:# Configure SMS server for sending SMS messages to support user authentication.}

endsnippet

snippet fortios_icap_profile "Configure ICAP profiles in Fortinet's FortiOS and FortiGate." b
fortios_icap_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	icap_profile=${8:# Configure ICAP profiles.}

endsnippet

snippet fortios_switch_controller_managed_switch "Configure FortiSwitch devices that are managed by this FortiGate in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_managed_switch: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	switch_controller_managed_switch=${8:# Configure FortiSwitch devices that are managed by this FortiGate.}

endsnippet

snippet fortios_user_domain_controller "Configure domain controller entries in Fortinet's FortiOS and FortiGate." b
fortios_user_domain_controller: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_domain_controller=${8:# Configure domain controller entries.}

endsnippet

snippet fortios_log_fortiguard_setting "Configure logging to FortiCloud in Fortinet's FortiOS and FortiGate." b
fortios_log_fortiguard_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortiguard_setting=${7:# Configure logging to FortiCloud.}

endsnippet

snippet fortios_switch_controller_lldp_settings "Configure FortiSwitch LLDP settings in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_lldp_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_lldp_settings=${7:# Configure FortiSwitch LLDP settings.}

endsnippet

snippet fortios_endpoint_control_forticlient_ems "Configure FortiClient Enterprise Management Server (EMS) entries in Fortinet's FortiOS and FortiGate." b
fortios_endpoint_control_forticlient_ems: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	endpoint_control_forticlient_ems=${8:# Configure FortiClient Enterprise Management Server (EMS) entries.}

endsnippet

snippet fortios_system_proxy_arp "Configure proxy-ARP in Fortinet's FortiOS and FortiGate." b
fortios_system_proxy_arp: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_proxy_arp=${8:# Configure proxy-ARP.}

endsnippet

snippet fortios_log_syslogd3_filter "Filters for remote system server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd3_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd3_filter=${7:# Filters for remote system server.}

endsnippet

snippet fortios_authentication_rule "Configure Authentication Rules in Fortinet's FortiOS and FortiGate." b
fortios_authentication_rule: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	authentication_rule=${8:# Configure Authentication Rules.}

endsnippet

snippet fortios_wireless_controller_wtp "Configure Wireless Termination Points (WTPs), that is, FortiAPs or APs to be managed by FortiGate in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_wtp: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	wireless_controller_wtp=${8:# Configure Wireless Termination Points (WTPs), that is, FortiAPs or APs to be managed by FortiGate.}

endsnippet

snippet fortios_router_isis "Configure IS-IS in Fortinet's FortiOS and FortiGate." b
fortios_router_isis: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_isis=${7:# Configure IS-IS.}

endsnippet

snippet fortios_firewall_wildcard_fqdn_group "Config global Wildcard FQDN address groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_wildcard_fqdn_group: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_wildcard_fqdn_group=${8:# Config global Wildcard FQDN address groups.}

endsnippet

snippet fortios_ips_rule "Configure IPS rules in Fortinet's FortiOS and FortiGate." b
fortios_ips_rule: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	ips_rule=${8:# Configure IPS rules.}

endsnippet

snippet fortios_dnsfilter_profile "Configure DNS domain filter profiles in Fortinet's FortiOS and FortiGate." b
fortios_dnsfilter_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	dnsfilter_profile=${8:# Configure DNS domain filter profiles.}

endsnippet

snippet fortios_log_disk_setting "Settings for local disk logging in Fortinet's FortiOS and FortiGate." b
fortios_log_disk_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_disk_setting=${7:# Settings for local disk logging.}

endsnippet

snippet fortios_wireless_controller_hotspot20_anqp_venue_name "Configure venue name duple in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_anqp_venue_name: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_anqp_venue_name=${8:# Configure venue name duple.}

endsnippet

snippet fortios_system_virtual_wire_pair "Configure virtual wire pairs in Fortinet's FortiOS and FortiGate." b
fortios_system_virtual_wire_pair: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_virtual_wire_pair=${8:# Configure virtual wire pairs.}

endsnippet

snippet fortios_report_dataset "Report dataset configuration in Fortinet's FortiOS and FortiGate." b
fortios_report_dataset: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	report_dataset=${8:# Report dataset configuration.}

endsnippet

snippet fortios_router_route_map "Configure route maps in Fortinet's FortiOS and FortiGate." b
fortios_router_route_map: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	router_route_map=${8:# Configure route maps.}

endsnippet

snippet fortios_firewall_internet_service_group "Configure group of Internet Service in Fortinet's FortiOS and FortiGate." b
fortios_firewall_internet_service_group: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_internet_service_group=${8:# Configure group of Internet Service.}

endsnippet

snippet fortios_system_sflow "Configure sFlow in Fortinet's FortiOS and FortiGate." b
fortios_system_sflow: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_sflow=${7:# Configure sFlow.}

endsnippet

snippet fortios_vpn_certificate_ocsp_server "OCSP server configuration in Fortinet's FortiOS and FortiGate." b
fortios_vpn_certificate_ocsp_server: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_certificate_ocsp_server=${8:# OCSP server configuration.}

endsnippet

snippet fortios_ips_rule_settings "Configure IPS rule setting in Fortinet's FortiOS and FortiGate." b
fortios_ips_rule_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	ips_rule_settings=${8:# Configure IPS rule setting.}

endsnippet

snippet fortios_system_replacemsg_icap "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_icap: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_icap=${8:# Replacement messages.}

endsnippet

snippet fortios_ips_custom "Configure IPS custom signature in Fortinet's FortiOS and FortiGate." b
fortios_ips_custom: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	ips_custom=${8:# Configure IPS custom signature.}

endsnippet

snippet fortios_system_accprofile "Configure access profiles for system administrators in Fortinet's FortiOS and FortiGate." b
fortios_system_accprofile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	system_accprofile=${8:# Configure access profiles for system administrators.}

endsnippet

snippet fortios_wireless_controller_global "Configure wireless controller global settings in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_global: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wireless_controller_global=${7:# Configure wireless controller global settings.}

endsnippet

snippet fortios_system_tos_based_priority "Configure Type of Service (ToS) based priority table to set network traffic priorities in Fortinet's FortiOS and FortiGate." b
fortios_system_tos_based_priority: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_tos_based_priority=${8:# Configure Type of Service (ToS) based priority table to set network traffic priorities.}

endsnippet

snippet fortios_user_peergrp "Configure peer groups in Fortinet's FortiOS and FortiGate." b
fortios_user_peergrp: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_peergrp=${8:# Configure peer groups.}

endsnippet

snippet fortios_user_setting "Configure user authentication setting in Fortinet's FortiOS and FortiGate." b
fortios_user_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	user_setting=${7:# Configure user authentication setting.}

endsnippet

snippet fortios_router_ripng "Configure RIPng in Fortinet's FortiOS and FortiGate." b
fortios_router_ripng: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_ripng=${7:# Configure RIPng.}

endsnippet

snippet fortios_user_peer "Configure peer users in Fortinet's FortiOS and FortiGate." b
fortios_user_peer: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_peer=${8:# Configure peer users.}

endsnippet

snippet fortios_router_multicast "Configure router multicast in Fortinet's FortiOS and FortiGate." b
fortios_router_multicast: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_multicast=${7:# Configure router multicast.}

endsnippet

snippet fortios_router_bfd6 "Configure IPv6 BFD in Fortinet's FortiOS and FortiGate." b
fortios_router_bfd6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_bfd6=${7:# Configure IPv6 BFD.}

endsnippet

snippet fortios_vpn_ipsec_phase1 "Configure VPN remote gateway in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_phase1: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_phase1=${8:# Configure VPN remote gateway.}

endsnippet

snippet fortios_endpoint_control_settings "Configure endpoint control settings in Fortinet's FortiOS and FortiGate." b
fortios_endpoint_control_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	endpoint_control_settings=${7:# Configure endpoint control settings.}

endsnippet

snippet fortios_dlp_sensor "Configure DLP sensors in Fortinet's FortiOS and FortiGate." b
fortios_dlp_sensor: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	dlp_sensor=${8:# Configure DLP sensors.}

endsnippet

snippet fortios_wireless_controller_hotspot20_anqp_network_auth_type "Configure network authentication type in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_anqp_network_auth_type: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_anqp_network_auth_type=${8:# Configure network authentication type.}

endsnippet

snippet fortios_wireless_controller_ble_profile "Configure Bluetooth Low Energy profile in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_ble_profile: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_ble_profile=${8:# Configure Bluetooth Low Energy profile.}

endsnippet

snippet fortios_user_pop3 "POP3 server entry configuration in Fortinet's FortiOS and FortiGate." b
fortios_user_pop3: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_pop3=${8:# POP3 server entry configuration.}

endsnippet

snippet fortios_antivirus_profile "Configure AntiVirus profiles in Fortinet's FortiOS and FortiGate." b
fortios_antivirus_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	antivirus_profile=${8:# Configure AntiVirus profiles.}

endsnippet

snippet fortios_firewall_shaper_per_ip_shaper "Configure per-IP traffic shaper in Fortinet's FortiOS and FortiGate." b
fortios_firewall_shaper_per_ip_shaper: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_shaper_per_ip_shaper=${8:# Configure per-IP traffic shaper.}

endsnippet

snippet fortios_log_webtrends_filter "Filters for WebTrends in Fortinet's FortiOS and FortiGate." b
fortios_log_webtrends_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_webtrends_filter=${7:# Filters for WebTrends.}

endsnippet

snippet fortios_log_memory_filter "Filters for memory buffer in Fortinet's FortiOS and FortiGate." b
fortios_log_memory_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_memory_filter=${7:# Filters for memory buffer.}

endsnippet

snippet fortios_system_console "Configure console in Fortinet's FortiOS and FortiGate." b
fortios_system_console: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_console=${7:# Configure console.}

endsnippet

snippet fortios_system_replacemsg_device_detection_portal "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_device_detection_portal: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_device_detection_portal=${8:# Replacement messages.}

endsnippet

snippet fortios_dlp_filepattern "Configure file patterns used by DLP blocking in Fortinet's FortiOS and FortiGate." b
fortios_dlp_filepattern: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	dlp_filepattern=${8:# Configure file patterns used by DLP blocking.}

endsnippet

snippet fortios_router_access_list6 "Configure IPv6 access lists in Fortinet's FortiOS and FortiGate." b
fortios_router_access_list6: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	router_access_list6=${8:# Configure IPv6 access lists.}

endsnippet

snippet fortios_report_chart "Report chart widget configuration in Fortinet's FortiOS and FortiGate." b
fortios_report_chart: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	report_chart=${8:# Report chart widget configuration.}

endsnippet

snippet fortios_wanopt_profile "Configure WAN optimization profiles in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	wanopt_profile=${8:# Configure WAN optimization profiles.}

endsnippet

snippet fortios_ips_sensor "Configure IPS sensor in Fortinet's FortiOS and FortiGate." b
fortios_ips_sensor: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	ips_sensor=${8:# Configure IPS sensor.}

endsnippet

snippet fortios_wanopt_settings "Configure WAN optimization settings in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wanopt_settings=${7:# Configure WAN optimization settings.}

endsnippet

snippet fortios_firewall_ipmacbinding_setting "Configure IP to MAC binding settings in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ipmacbinding_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	firewall_ipmacbinding_setting=${7:# Configure IP to MAC binding settings.}

endsnippet

snippet fortios_wireless_controller_qos_profile "Configure WiFi quality of service (QoS) profiles in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_qos_profile: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_qos_profile=${8:# Configure WiFi quality of service (QoS) profiles.}

endsnippet

snippet fortios_ips_settings "Configure IPS VDOM parameter in Fortinet's FortiOS and FortiGate." b
fortios_ips_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	ips_settings=${7:# Configure IPS VDOM parameter.}

endsnippet

snippet fortios_report_layout "Report layout configuration in Fortinet's FortiOS and FortiGate." b
fortios_report_layout: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	report_layout=${8:# Report layout configuration.}

endsnippet

snippet fortios_user_fsso_polling "Configure FSSO active directory servers for polling mode in Fortinet's FortiOS and FortiGate." b
fortios_user_fsso_polling: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_fsso_polling=${8:# Configure FSSO active directory servers for polling mode.}

endsnippet

snippet fortios_spamfilter_bwl "Configure anti-spam black/white list in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_bwl: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	spamfilter_bwl=${8:# Configure anti-spam black/white list.}

endsnippet

snippet fortios_wanopt_webcache "Configure global Web cache settings in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_webcache: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wanopt_webcache=${7:# Configure global Web cache settings.}

endsnippet

snippet fortios_system_session_helper "Configure session helper in Fortinet's FortiOS and FortiGate." b
fortios_system_session_helper: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_session_helper=${8:# Configure session helper.}

endsnippet

snippet fortios_system_affinity_interrupt "Configure interrupt affinity in Fortinet's FortiOS and FortiGate." b
fortios_system_affinity_interrupt: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_affinity_interrupt=${8:# Configure interrupt affinity.}

endsnippet

snippet fortios_system_replacemsg_auth "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_auth: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_auth=${8:# Replacement messages.}

endsnippet

snippet fortios_firewall_central_snat_map "Configure central SNAT policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_central_snat_map: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_central_snat_map=${8:# Configure central SNAT policies.}

endsnippet

snippet fortios_vpn_ipsec_phase1_interface "Configure VPN remote gateway in Fortinet's FortiOS and FortiGate." b
fortios_vpn_ipsec_phase1_interface: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	vpn_ipsec_phase1_interface=${8:# Configure VPN remote gateway.}

endsnippet

snippet fortios_webfilter_ips_urlfilter_cache_setting "Configure IPS URL filter cache settings in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_ips_urlfilter_cache_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	webfilter_ips_urlfilter_cache_setting=${7:# Configure IPS URL filter cache settings.}

endsnippet

snippet fortios_system_replacemsg_spam "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_spam: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_spam=${8:# Replacement messages.}

endsnippet

snippet fortios_wireless_controller_vap "Configure Virtual Access Points (VAPs) in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_vap: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	wireless_controller_vap=${8:# Configure Virtual Access Points (VAPs).}

endsnippet

snippet fortios_firewall_vip46 "Configure IPv4 to IPv6 virtual IPs in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vip46: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vip46=${8:# Configure IPv4 to IPv6 virtual IPs.}

endsnippet

snippet fortios_system_replacemsg_mail "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_mail: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_mail=${8:# Replacement messages.}

endsnippet

snippet fortios_system_fm "Configure FM in Fortinet's FortiOS and FortiGate." b
fortios_system_fm: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_fm=${7:# Configure FM.}

endsnippet

snippet fortios_firewall_shaper_traffic_shaper "Configure shared traffic shaper in Fortinet's FortiOS and FortiGate." b
fortios_firewall_shaper_traffic_shaper: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_shaper_traffic_shaper=${8:# Configure shared traffic shaper.}

endsnippet

snippet fortios_system_auto_install "Configure USB auto installation in Fortinet's FortiOS and FortiGate." b
fortios_system_auto_install: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_auto_install=${7:# Configure USB auto installation.}

endsnippet

snippet fortios_webfilter_search_engine "Configure web filter search engines in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_search_engine: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_search_engine=${8:# Configure web filter search engines.}

endsnippet

snippet fortios_switch_controller_mac_sync_settings "Configure global MAC synchronization settings in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_mac_sync_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_mac_sync_settings=${7:# Configure global MAC synchronization settings.}

endsnippet

snippet fortios_firewall_service_custom "Configure custom services in Fortinet's FortiOS and FortiGate." b
fortios_firewall_service_custom: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_service_custom=${8:# Configure custom services.}

endsnippet

snippet fortios_wanopt_cache_service "Designate cache-service for wan-optimization and webcache in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_cache_service: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wanopt_cache_service=${7:# Designate cache-service for wan-optimization and webcache.}

endsnippet

snippet fortios_system_affinity_packet_redistribution "Configure packet redistribution in Fortinet's FortiOS and FortiGate." b
fortios_system_affinity_packet_redistribution: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_affinity_packet_redistribution=${8:# Configure packet redistribution.}

endsnippet

snippet fortios_system_replacemsg_ftp "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_ftp: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_ftp=${8:# Replacement messages.}

endsnippet

snippet fortios_system_replacemsg_fortiguard_wf "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_fortiguard_wf: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_fortiguard_wf=${8:# Replacement messages.}

endsnippet

snippet fortios_address "Manage fortios firewall address objects" b
fortios_address: >
	state=${1:present|absent}
	name=${2:# Name of the address to add or delete.}

	type=${3:iprange|fqdn|ipmask|geography}
	value=${4:# Address value, based on type. If type=fqdn, something like www.google.com. If type=ipmask, you can use simple ip (192.168.0.1), ip+mask (192.168.0.1 255.255.255.0) or CIDR (192.168.0.1/32).}
	start_ip=${5:# First ip in range (used only with type=iprange).}
	end_ip=${6:# Last ip in range (used only with type=iprange).}
	country=${7:# 2 letter country code (like FR).}
	interface=${8:any}
	comment=${9:# free text to describe address.}
	file_mode=${10:no}
	config_file=${11:# Path to configuration file. Required when I(file_mode) is True.}
	host=${12:# Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.}
	username=${13:# Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.}
	password=${14:# Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.}
	timeout=${15:60}
	vdom=${16:# Specifies on which vdom to apply configuration}
	backup=${17:no}
	backup_path=${18:# Specifies where to store backup files. Required if I(backup=yes).}
	backup_filename=${19:# Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS}

endsnippet

snippet fortios_firewall_address6_template "Configure IPv6 address templates in Fortinet's FortiOS and FortiGate." b
fortios_firewall_address6_template: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_address6_template=${8:# Configure IPv6 address templates.}

endsnippet

snippet fortios_authentication_setting "Configure authentication setting in Fortinet's FortiOS and FortiGate." b
fortios_authentication_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	authentication_setting=${7:# Configure authentication setting.}

endsnippet

snippet fortios_endpoint_control_forticlient_registration_sync "Configure FortiClient registration synchronization settings in Fortinet's FortiOS and FortiGate." b
fortios_endpoint_control_forticlient_registration_sync: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	endpoint_control_forticlient_registration_sync=${8:# Configure FortiClient registration synchronization settings.}

endsnippet

snippet fortios_firewall_proxy_policy "Configure proxy policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_proxy_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_proxy_policy=${8:# Configure proxy policies.}

endsnippet

snippet fortios_system_vdom_radius_server "Configure a RADIUS server to use as a RADIUS Single Sign On (RSSO) server for this VDOM in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom_radius_server: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_vdom_radius_server=${8:# Configure a RADIUS server to use as a RADIUS Single Sign On (RSSO) server for this VDOM.}

endsnippet

snippet fortios_log_threat_weight "Configure threat weight settings in Fortinet's FortiOS and FortiGate." b
fortios_log_threat_weight: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_threat_weight=${7:# Configure threat weight settings.}

endsnippet

snippet fortios_log_syslogd2_setting "Global settings for remote syslog server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd2_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd2_setting=${7:# Global settings for remote syslog server.}

endsnippet

snippet fortios_router_key_chain "Configure key-chain in Fortinet's FortiOS and FortiGate." b
fortios_router_key_chain: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	router_key_chain=${8:# Configure key-chain.}

endsnippet

snippet fortios_log_disk_filter "Configure filters for local disk logging. Use these filters to determine the log messages to record according to severity and type in Fortinet's FortiOS and FortiGate." b
fortios_log_disk_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_disk_filter=${7:# Configure filters for local disk logging. Use these filters to determine the log messages to record according to severity and type.}

endsnippet

snippet fortios_firewall_ipmacbinding_table "Configure IP to MAC address pairs in the IP/MAC binding table in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ipmacbinding_table: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ipmacbinding_table=${8:# Configure IP to MAC address pairs in the IP/MAC binding table.}

endsnippet

snippet fortios_user_krb_keytab "Configure Kerberos keytab entries in Fortinet's FortiOS and FortiGate." b
fortios_user_krb_keytab: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_krb_keytab=${8:# Configure Kerberos keytab entries.}

endsnippet

snippet fortios_system_fortiguard "Configure FortiGuard services in Fortinet's FortiOS and FortiGate." b
fortios_system_fortiguard: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_fortiguard=${7:# Configure FortiGuard services.}

endsnippet

snippet fortios_system_sdn_connector "Configure connection to SDN Connector in Fortinet's FortiOS and FortiGate." b
fortios_system_sdn_connector: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	system_sdn_connector=${8:# Configure connection to SDN Connector.}

endsnippet

snippet fortios_wireless_controller_hotspot20_anqp_nai_realm "Configure network access identifier (NAI) realm in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_anqp_nai_realm: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_anqp_nai_realm=${8:# Configure network access identifier (NAI) realm.}

endsnippet

snippet fortios_log_fortianalyzer2_filter "Filters for FortiAnalyzer in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer2_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer2_filter=${7:# Filters for FortiAnalyzer.}

endsnippet

snippet fortios_system_replacemsg_webproxy "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_webproxy: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_webproxy=${8:# Replacement messages.}

endsnippet

snippet fortios_wireless_controller_wtp_group "Configure WTP groups in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_wtp_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_wtp_group=${8:# Configure WTP groups.}

endsnippet

snippet fortios_system_email_server "Configure the email server used by the FortiGate various things. For example, for sending email messages to users to support user authentication features in Fortinet's FortiOS and FortiGate." b
fortios_system_email_server: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_email_server=${7:# Configure the email server used by the FortiGate various things. For example, for sending email messages to users to support user authentication features.}

endsnippet

snippet fortios_system_wccp "Configure WCCP in Fortinet's FortiOS and FortiGate." b
fortios_system_wccp: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_wccp=${8:# Configure WCCP.}

endsnippet

snippet fortios_system_interface "Configure interfaces in Fortinet's FortiOS and FortiGate." b
fortios_system_interface: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	system_interface=${8:# Configure interfaces.}

endsnippet

snippet fortios_firewall_ippool "Configure IPv4 IP pools in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ippool: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ippool=${8:# Configure IPv4 IP pools.}

endsnippet

snippet fortios_user_quarantine "Configure quarantine support in Fortinet's FortiOS and FortiGate." b
fortios_user_quarantine: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	user_quarantine=${7:# Configure quarantine support.}

endsnippet

snippet fortios_firewall_identity_based_route "Configure identity based routing in Fortinet's FortiOS and FortiGate." b
fortios_firewall_identity_based_route: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_identity_based_route=${8:# Configure identity based routing.}

endsnippet

snippet fortios_system_firmware_upgrade "Perform firmware upgrade on FortiGate or FortiOS (FOS) device." b
fortios_system_firmware_upgrade: >
	system_firmware=${1:# Possible parameters to go in the body for the request. Specify firmware upgrade source, filename and whether format boot partition before upgrade}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}

endsnippet

snippet fortios_system_replacemsg_utm "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_utm: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_utm=${8:# Replacement messages.}

endsnippet

snippet fortios_user_fortitoken "Configure FortiToken in Fortinet's FortiOS and FortiGate." b
fortios_user_fortitoken: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_fortitoken=${8:# Configure FortiToken.}

endsnippet

snippet fortios_web_proxy_profile "Configure web proxy profiles in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	web_proxy_profile=${8:# Configure web proxy profiles.}

endsnippet

snippet fortios_system_vdom_link "Configure VDOM links in Fortinet's FortiOS and FortiGate." b
fortios_system_vdom_link: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_vdom_link=${8:# Configure VDOM links.}

endsnippet

snippet fortios_dlp_fp_sensitivity "Create self-explanatory DLP sensitivity levels to be used when setting sensitivity under config fp-doc-source in Fortinet's FortiOS and FortiGate." b
fortios_dlp_fp_sensitivity: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	dlp_fp_sensitivity=${8:# Create self-explanatory DLP sensitivity levels to be used when setting sensitivity under config fp-doc-source.}

endsnippet

snippet fortios_vpn_certificate_crl "Certificate Revocation List as a PEM file in Fortinet's FortiOS and FortiGate." b
fortios_vpn_certificate_crl: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	vpn_certificate_crl=${8:# Certificate Revocation List as a PEM file.}

endsnippet

snippet fortios_log_setting "Configure general log settings in Fortinet's FortiOS and FortiGate." b
fortios_log_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_setting=${7:# Configure general log settings.}

endsnippet

snippet fortios_system_dedicated_mgmt "Configure dedicated management in Fortinet's FortiOS and FortiGate." b
fortios_system_dedicated_mgmt: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_dedicated_mgmt=${7:# Configure dedicated management.}

endsnippet

snippet fortios_user_fsso "Configure Fortinet Single Sign On (FSSO) agents in Fortinet's FortiOS and FortiGate." b
fortios_user_fsso: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_fsso=${8:# Configure Fortinet Single Sign On (FSSO) agents.}

endsnippet

snippet fortios_system_snmp_sysinfo "SNMP system info configuration in Fortinet's FortiOS and FortiGate." b
fortios_system_snmp_sysinfo: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_snmp_sysinfo=${7:# SNMP system info configuration.}

endsnippet

snippet fortios_log_fortianalyzer2_setting "Global FortiAnalyzer settings in Fortinet's FortiOS and FortiGate." b
fortios_log_fortianalyzer2_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortianalyzer2_setting=${7:# Global FortiAnalyzer settings.}

endsnippet

snippet fortios_wanopt_peer "Configure WAN optimization peers in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_peer: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wanopt_peer=${8:# Configure WAN optimization peers.}

endsnippet

snippet fortios_system_ipip_tunnel "Configure IP in IP Tunneling in Fortinet's FortiOS and FortiGate." b
fortios_system_ipip_tunnel: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_ipip_tunnel=${8:# Configure IP in IP Tunneling.}

endsnippet

snippet fortios_router_aspath_list "Configure Autonomous System (AS) path lists in Fortinet's FortiOS and FortiGate." b
fortios_router_aspath_list: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	router_aspath_list=${8:# Configure Autonomous System (AS) path lists.}

endsnippet

snippet fortios_router_bfd "Configure BFD in Fortinet's FortiOS and FortiGate." b
fortios_router_bfd: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_bfd=${7:# Configure BFD.}

endsnippet

snippet fortios_system_password_policy "Configure password policy for locally defined administrator passwords and IPsec VPN pre-shared keys in Fortinet's FortiOS and FortiGate." b
fortios_system_password_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_password_policy=${7:# Configure password policy for locally defined administrator passwords and IPsec VPN pre-shared keys.}

endsnippet

snippet fortios_system_replacemsg_group "Configure replacement message groups in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_group=${8:# Configure replacement message groups.}

endsnippet

snippet fortios_switch_controller_qos_dot1p_map "Configure FortiSwitch QoS 802.1p in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_qos_dot1p_map: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_qos_dot1p_map=${8:# Configure FortiSwitch QoS 802.1p.}

endsnippet

snippet fortios_log_syslogd2_filter "Filters for remote system server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd2_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd2_filter=${7:# Filters for remote system server.}

endsnippet

snippet fortios_system_ha "Configure HA in Fortinet's FortiOS and FortiGate." b
fortios_system_ha: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_ha=${7:# Configure HA.}

endsnippet

snippet fortios_switch_controller_igmp_snooping "Configure FortiSwitch IGMP snooping global settings in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_igmp_snooping: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_igmp_snooping=${7:# Configure FortiSwitch IGMP snooping global settings.}

endsnippet

snippet fortios_firewall_interface_policy "Configure IPv4 interface policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_interface_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_interface_policy=${8:# Configure IPv4 interface policies.}

endsnippet

snippet fortios_log_fortiguard_filter "Filters for FortiCloud in Fortinet's FortiOS and FortiGate." b
fortios_log_fortiguard_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_fortiguard_filter=${7:# Filters for FortiCloud.}

endsnippet

snippet fortios_firewall_service_group "Configure service groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_service_group: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_service_group=${8:# Configure service groups.}

endsnippet

snippet fortios_system_vxlan "Configure VXLAN devices in Fortinet's FortiOS and FortiGate." b
fortios_system_vxlan: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_vxlan=${8:# Configure VXLAN devices.}

endsnippet

snippet fortios_system_settings "Configure VDOM settings in Fortinet's FortiOS and FortiGate." b
fortios_system_settings: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_settings=${7:# Configure VDOM settings.}

endsnippet

snippet fortios_firewall_policy64 "Configure IPv6 to IPv4 policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_policy64: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_policy64=${8:# Configure IPv6 to IPv4 policies.}

endsnippet

snippet fortios_system_autoupdate_schedule "Configure update schedule in Fortinet's FortiOS and FortiGate." b
fortios_system_autoupdate_schedule: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_autoupdate_schedule=${7:# Configure update schedule.}

endsnippet

snippet fortios_spamfilter_profile "Configure AntiSpam profiles in Fortinet's FortiOS and FortiGate." b
fortios_spamfilter_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	spamfilter_profile=${8:# Configure AntiSpam profiles.}

endsnippet

snippet fortios_firewall_ssh_host_key "SSH proxy host public keys in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ssh_host_key: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ssh_host_key=${8:# SSH proxy host public keys.}

endsnippet

snippet fortios_system_automation_action "Action for automation stitches in Fortinet's FortiOS and FortiGate." b
fortios_system_automation_action: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_automation_action=${8:# Action for automation stitches.}

endsnippet

snippet fortios_firewall_vipgrp64 "Configure IPv6 to IPv4 virtual IP groups in Fortinet's FortiOS and FortiGate." b
fortios_firewall_vipgrp64: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_vipgrp64=${8:# Configure IPv6 to IPv4 virtual IP groups.}

endsnippet

snippet fortios_router_access_list "Configure access lists in Fortinet's FortiOS and FortiGate." b
fortios_router_access_list: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	router_access_list=${8:# Configure access lists.}

endsnippet

snippet fortios_webfilter_ftgd_local_rating "Configure local FortiGuard Web Filter local ratings in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_ftgd_local_rating: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_ftgd_local_rating=${8:# Configure local FortiGuard Web Filter local ratings.}

endsnippet

snippet fortios_switch_controller_global "Configure FortiSwitch global settings in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_global: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_global=${7:# Configure FortiSwitch global settings.}

endsnippet

snippet fortios_system_api_user "Configure API users in Fortinet's FortiOS and FortiGate." b
fortios_system_api_user: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	system_api_user=${8:# Configure API users.}

endsnippet

snippet fortios_log_syslogd_override_setting "Override settings for remote syslog server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd_override_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd_override_setting=${7:# Override settings for remote syslog server.}

endsnippet

snippet fortios_web_proxy_forward_server "Configure forward-server addresses in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_forward_server: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	web_proxy_forward_server=${8:# Configure forward-server addresses.}

endsnippet

snippet fortios_ipv4_policy "Manage IPv4 policy objects on Fortinet FortiOS firewall devices" b
fortios_ipv4_policy: >
	id=${1:# Policy ID. Warning: policy ID number is different than Policy sequence number. The policy ID is the number assigned at policy creation. The sequence number represents the order in which the Fortigate will evaluate the rule for policy enforcement, and also the order in which rules are listed in the GUI and CLI. These two numbers do not necessarily correlate: this module is based off policy ID. TIP: policy ID can be viewed in the GUI by adding 'ID' to the display columns}

	state=${2:#present|absent}
	src_intf=${3:any}
	dst_intf=${4:any}
	src_addr=${5:# Specifies source address (or group) object name(s). Required when I(state=present).}
	src_addr_negate=${6:no}
	dst_addr=${7:# Specifies destination address (or group) object name(s). Required when I(state=present).}
	dst_addr_negate=${8:no}
	policy_action=${9:accept|deny}
	service=${10:# Specifies policy service(s), could be a list (ex: ['MAIL','DNS']). Required when I(state=present).}
	service_negate=${11:no}
	schedule=${12:always}
	nat=${13:no}
	fixedport=${14:no}
	poolname=${15:# Specifies NAT pool name.}
	av_profile=${16:# Specifies Antivirus profile name.}
	webfilter_profile=${17:# Specifies Webfilter profile name.}
	ips_sensor=${18:# Specifies IPS Sensor profile name.}
	application_list=${19:# Specifies Application Control name.}
	logtraffic=${20:disable|#utm|all}
	logtraffic_start=${21:no}
	comment=${22:# free text to describe policy.}
	file_mode=${23:no}
	config_file=${24:# Path to configuration file. Required when I(file_mode) is True.}
	host=${25:# Specifies the DNS hostname or IP address for connecting to the remote fortios device. Required when I(file_mode) is False.}
	username=${26:# Configures the username used to authenticate to the remote device. Required when I(file_mode) is True.}
	password=${27:# Specifies the password used to authenticate to the remote device. Required when I(file_mode) is True.}
	timeout=${28:60}
	vdom=${29:# Specifies on which vdom to apply configuration}
	backup=${30:no}
	backup_path=${31:# Specifies where to store backup files. Required if I(backup=yes).}
	backup_filename=${32:# Specifies the backup filename. If omitted filename will be formatted like HOST_config.YYYY-MM-DD@HH:MM:SS}

endsnippet

snippet fortios_user_device "Configure devices in Fortinet's FortiOS and FortiGate." b
fortios_user_device: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_device=${8:# Configure devices.}

endsnippet

snippet fortios_system_custom_language "Configure custom languages in Fortinet's FortiOS and FortiGate." b
fortios_system_custom_language: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_custom_language=${8:# Configure custom languages.}

endsnippet

snippet fortios_system_dns_server "Configure DNS servers in Fortinet's FortiOS and FortiGate." b
fortios_system_dns_server: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_dns_server=${8:# Configure DNS servers.}

endsnippet

snippet fortios_antivirus_quarantine "Configure quarantine options in Fortinet's FortiOS and FortiGate." b
fortios_antivirus_quarantine: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	antivirus_quarantine=${7:# Configure quarantine options.}

endsnippet

snippet fortios_webfilter "Configure webfilter capabilities of FortiGate and FortiOS." b
fortios_webfilter: >
	host=${1:# FortiOS or FortiGate ip address.}
	username=${2:# FortiOS or FortiGate username.}

	password=${3:}
	vdom=${4:root}
	webfilter_url=${5:# Container for a group of url entries that the FortiGate must act upon}
	webfilter_content=${6:# Container for a group of content-filtering entries that the FortiGate must act upon}

endsnippet

snippet fortios_system_replacemsg_nntp "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_nntp: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_nntp=${8:# Replacement messages.}

endsnippet

snippet fortios_wireless_controller_hotspot20_h2qp_operator_name "Configure operator friendly name in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_h2qp_operator_name: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_h2qp_operator_name=${8:# Configure operator friendly name.}

endsnippet

snippet fortios_system_management_tunnel "Management tunnel configuration in Fortinet's FortiOS and FortiGate." b
fortios_system_management_tunnel: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_management_tunnel=${7:# Management tunnel configuration.}

endsnippet

snippet fortios_firewall_profile_protocol_options "Configure protocol options in Fortinet's FortiOS and FortiGate." b
fortios_firewall_profile_protocol_options: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_profile_protocol_options=${8:# Configure protocol options.}

endsnippet

snippet fortios_firewall_shaping_profile "Configure shaping profiles in Fortinet's FortiOS and FortiGate." b
fortios_firewall_shaping_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_shaping_profile=${8:# Configure shaping profiles.}

endsnippet

snippet fortios_system_ipv6_tunnel "Configure IPv6/IPv4 in IPv6 tunnel in Fortinet's FortiOS and FortiGate." b
fortios_system_ipv6_tunnel: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_ipv6_tunnel=${8:# Configure IPv6/IPv4 in IPv6 tunnel.}

endsnippet

snippet fortios_system_ha_monitor "Configure HA monitor in Fortinet's FortiOS and FortiGate." b
fortios_system_ha_monitor: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_ha_monitor=${7:# Configure HA monitor.}

endsnippet

snippet fortios_system_fips_cc "Configure FIPS-CC mode in Fortinet's FortiOS and FortiGate." b
fortios_system_fips_cc: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_fips_cc=${7:# Configure FIPS-CC mode.}

endsnippet

snippet fortios_system_session_ttl "Configure global session TTL timers for this FortiGate in Fortinet's FortiOS and FortiGate." b
fortios_system_session_ttl: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_session_ttl=${7:# Configure global session TTL timers for this FortiGate.}

endsnippet

snippet fortios_wireless_controller_hotspot20_anqp_3gpp_cellular "Configure 3GPP public land mobile network (PLMN) in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_anqp_3gpp_cellular: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_anqp_3gpp_cellular=${8:# Configure 3GPP public land mobile network (PLMN).}

endsnippet

snippet fortios_router_auth_path "Configure authentication based routing in Fortinet's FortiOS and FortiGate." b
fortios_router_auth_path: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	router_auth_path=${8:# Configure authentication based routing.}

endsnippet

snippet fortios_system_resource_limits "Configure resource limits in Fortinet's FortiOS and FortiGate." b
fortios_system_resource_limits: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_resource_limits=${7:# Configure resource limits.}

endsnippet

snippet fortios_switch_controller_custom_command "Configure the FortiGate switch controller to send custom commands to managed FortiSwitch devices in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_custom_command: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_custom_command=${8:# Configure the FortiGate switch controller to send custom commands to managed FortiSwitch devices.}

endsnippet

snippet fortios_waf_main_class "Hidden table for datasource in Fortinet's FortiOS and FortiGate." b
fortios_waf_main_class: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	waf_main_class=${8:# Hidden table for datasource.}

endsnippet

snippet fortios_log_null_device_setting "Settings for null device logging in Fortinet's FortiOS and FortiGate." b
fortios_log_null_device_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_null_device_setting=${7:# Settings for null device logging.}

endsnippet

snippet fortios_router_ospf "Configure OSPF in Fortinet's FortiOS and FortiGate." b
fortios_router_ospf: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_ospf=${7:# Configure OSPF.}

endsnippet

snippet fortios_wireless_controller_ap_status "Configure access point status (rogue | accepted | suppressed) in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_ap_status: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_ap_status=${8:# Configure access point status (rogue | accepted | suppressed).}

endsnippet

snippet fortios_system_netflow "Configure NetFlow in Fortinet's FortiOS and FortiGate." b
fortios_system_netflow: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_netflow=${7:# Configure NetFlow.}

endsnippet

snippet fortios_ftp_proxy_explicit "Configure explicit FTP proxy settings in Fortinet's FortiOS and FortiGate." b
fortios_ftp_proxy_explicit: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	ftp_proxy_explicit=${7:# Configure explicit FTP proxy settings.}

endsnippet

snippet fortios_wireless_controller_setting "VDOM wireless controller configuration in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	wireless_controller_setting=${7:# VDOM wireless controller configuration.}

endsnippet

snippet fortios_user_local "Configure local users in Fortinet's FortiOS and FortiGate." b
fortios_user_local: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	user_local=${8:# Configure local users.}

endsnippet

snippet fortios_wanopt_auth_group "Configure WAN optimization authentication groups in Fortinet's FortiOS and FortiGate." b
fortios_wanopt_auth_group: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wanopt_auth_group=${8:# Configure WAN optimization authentication groups.}

endsnippet

snippet fortios_switch_controller_virtual_port_pool "Configure virtual pool in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_virtual_port_pool: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	switch_controller_virtual_port_pool=${8:# Configure virtual pool.}

endsnippet

snippet fortios_report_theme "Report themes configuration in Fortinet's FortiOS and FortiGate." b
fortios_report_theme: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	report_theme=${8:# Report themes configuration}

endsnippet

snippet fortios_user_tacacsplus "Configure TACACS+ server entries in Fortinet's FortiOS and FortiGate." b
fortios_user_tacacsplus: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	user_tacacsplus=${8:# Configure TACACS+ server entries.}

endsnippet

snippet fortios_system_admin "Configure admin users in Fortinet's FortiOS and FortiGate." b
fortios_system_admin: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	system_admin=${8:# Configure admin users.}

endsnippet

snippet fortios_router_static "Configure IPv4 static routing tables in Fortinet's FortiOS and FortiGate." b
fortios_router_static: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	router_static=${8:# Configure IPv4 static routing tables.}

endsnippet

snippet fortios_wireless_controller_wtp_profile "Configure WTP profiles or FortiAP profiles that define radio settings for manageable FortiAP platforms in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_wtp_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	wireless_controller_wtp_profile=${8:# Configure WTP profiles or FortiAP profiles that define radio settings for manageable FortiAP platforms.}

endsnippet

snippet fortios_report_style "Report style configuration in Fortinet's FortiOS and FortiGate." b
fortios_report_style: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	report_style=${8:# Report style configuration.}

endsnippet

snippet fortios_firewall_interface_policy6 "Configure IPv6 interface policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_interface_policy6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_interface_policy6=${8:# Configure IPv6 interface policies.}

endsnippet

snippet fortios_firewall_ssh_setting "SSH proxy settings in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ssh_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	firewall_ssh_setting=${7:# SSH proxy settings.}

endsnippet

snippet fortios_webfilter_ips_urlfilter_setting "Configure IPS URL filter settings in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_ips_urlfilter_setting: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	webfilter_ips_urlfilter_setting=${7:# Configure IPS URL filter settings.}

endsnippet

snippet fortios_wireless_controller_utm_profile "Configure UTM (Unified Threat Management) profile in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_utm_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	wireless_controller_utm_profile=${8:# Configure UTM (Unified Threat Management) profile.}

endsnippet

snippet fortios_router_multicast6 "Configure IPv6 multicast in Fortinet's FortiOS and FortiGate." b
fortios_router_multicast6: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	router_multicast6=${7:# Configure IPv6 multicast.}

endsnippet

snippet fortios_antivirus_heuristic "Configure global heuristic options in Fortinet's FortiOS and FortiGate." b
fortios_antivirus_heuristic: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	antivirus_heuristic=${7:# Configure global heuristic options.}

endsnippet

snippet fortios_log_syslogd4_filter "Filters for remote system server in Fortinet's FortiOS and FortiGate." b
fortios_log_syslogd4_filter: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	log_syslogd4_filter=${7:# Filters for remote system server.}

endsnippet

snippet fortios_webfilter_profile "Configure Web filter profiles in Fortinet's FortiOS and FortiGate." b
fortios_webfilter_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	webfilter_profile=${8:# Configure Web filter profiles.}

endsnippet

snippet fortios_firewall_ssl_ssh_profile "Configure SSL/SSH protocol options in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ssl_ssh_profile: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ssl_ssh_profile=${8:# Configure SSL/SSH protocol options.}

endsnippet

snippet fortios_switch_controller_storm_control "Configure FortiSwitch storm control in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_storm_control: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_storm_control=${7:# Configure FortiSwitch storm control.}

endsnippet

snippet fortios_web_proxy_wisp "Configure Wireless Internet service provider (WISP) servers in Fortinet's FortiOS and FortiGate." b
fortios_web_proxy_wisp: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	web_proxy_wisp=${8:# Configure Wireless Internet service provider (WISP) servers.}

endsnippet

snippet fortios_system_replacemsg_admin "Replacement messages in Fortinet's FortiOS and FortiGate." b
fortios_system_replacemsg_admin: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_replacemsg_admin=${8:# Replacement messages.}

endsnippet

snippet fortios_firewall_shaping_policy "Configure shaping policies in Fortinet's FortiOS and FortiGate." b
fortios_firewall_shaping_policy: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_shaping_policy=${8:# Configure shaping policies.}

endsnippet

snippet fortios_system_central_management "Configure central management in Fortinet's FortiOS and FortiGate." b
fortios_system_central_management: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	system_central_management=${7:# Configure central management.}

endsnippet

snippet fortios_system_arp_table "Configure ARP table in Fortinet's FortiOS and FortiGate." b
fortios_system_arp_table: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	system_arp_table=${8:# Configure ARP table.}

endsnippet

snippet fortios_firewall_ssl_server "Configure SSL servers in Fortinet's FortiOS and FortiGate." b
fortios_firewall_ssl_server: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	state=${7:present|absent}
	firewall_ssl_server=${8:# Configure SSL servers.}

endsnippet

snippet fortios_wireless_controller_hotspot20_icon "Configure OSU provider icon in Fortinet's FortiOS and FortiGate." b
fortios_wireless_controller_hotspot20_icon: >
	state=${1:present|absent}

	host=${2:# FortiOS or FortiGate IP address.}
	username=${3:# FortiOS or FortiGate username.}
	password=${4:}
	vdom=${5:root}
	https=${6:yes}
	ssl_verify=${7:yes}
	wireless_controller_hotspot20_icon=${8:# Configure OSU provider icon.}

endsnippet

snippet fortios_switch_controller_system "Configure system-wide switch controller settings in Fortinet's FortiOS and FortiGate." b
fortios_switch_controller_system: >
	host=${1:# FortiOS or FortiGate IP address.}
	username=${2:# FortiOS or FortiGate username.}
	password=${3:}
	vdom=${4:root}
	https=${5:yes}
	ssl_verify=${6:yes}
	switch_controller_system=${7:# Configure system-wide switch controller settings.}

endsnippet

snippet skydive_node "Module which add nodes to Skydive topology" b
skydive_node: >
	name=${1:# To define name for the node.}
	node_type=${2:# To define type for the node.}

	host=${3:# To define host for the node.}
	seed=${4:}
	metadata=${5:# To define metadata for the node.}
	state=${6:#present|update|absent}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet skydive_capture "Module which manages flow capture on interfaces" b
skydive_capture: >
	query=${1:# It's the complete gremlin query which the users can input, I(G.V().Has('Name', 'eth0', 'Type', 'device')), to create the capture. And, if the user directly inputs the gremlin query then user is not required to input any other module parameter as gremlin query takes care of creating the flow capture.}
	interface_name=${2:# To define flow capture interface name.}
	type=${3:# To define flow capture interface type.}
	capture_name=${4:}
	description=${5:}
	extra_tcp_metric=${6:no}
	ip_defrag=${7:no}
	reassemble_tcp=${8:no}
	layer_key_mode=${9:L2}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet skydive_edge "Module to add edges to Skydive topology" b
skydive_edge: >
	parent_node=${1:# To defined the first node of the link, it can be either an ID or a gremlin expression}
	child_node=${2:# To defined the second node of the link, it can be either an ID or a gremlin expression}
	relation_type=${3:# To define relation type of the node I(ownership, layer2, layer3).}

	host=${4:}
	metadata=${5:# To define metadata for the edge.}
	state=${6:#present|absent}
	provider=${7:# A dict object containing connection details.}

endsnippet

snippet nclu "Configure network interfaces using NCLU" b
nclu: >
	commands=${1:# A list of strings containing the net commands to run. Mutually exclusive with I(template).}
	template=${2:# A single, multi-line string with jinja2 formatting. This string will be broken by lines, and each line will be run through net. Mutually exclusive with I(commands).}
	commit=${3:no}
	abort=${4:no}
	atomic=${5:no}
	description=${6:Ansible-originated commit}

endsnippet

snippet edgeos_facts "Collect facts from remote devices running EdgeOS" b
edgeos_facts: >
	gather_subset=${1:!config}

endsnippet

snippet edgeos_command "Run one or more commands on EdgeOS devices" b
edgeos_command: >
	commands=${1:# The commands or ordered set of commands that should be run against the remote device. The output of the command is returned to the playbook. If the C(wait_for) argument is provided, the module is not returned until the condition is met or the number of retries is exceeded.}

	wait_for=${2:# Causes the task to wait for a specific condition to be met before moving forward. If the condition is not met before the specified number of retries is exceeded, the task will fail.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet edgeos_config "Manage EdgeOS configuration on remote device" b
edgeos_config: >
	lines=${1:# The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.}
	src=${2:# The C(src) argument specifies the path to the source config file to load. The source config file can either be in bracket format or set format. The source file can include Jinja2 template variables.}
	match=${3:#line|none}
	backup=${4:no}
	comment=${5:configured by edgeos_config}
	config=${6:# The C(config) argument specifies the base configuration to use to compare against the desired configuration. If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.}
	save=${7:no}
	backup_options=${8:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet junos_l2_interfaces "Manage Layer-2 interface on Juniper JUNOS devices" b
junos_l2_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet junos_lacp_interfaces "Manage Link Aggregation Control Protocol (LACP) attributes of interfaces on Juniper JUNOS devices." b
junos_lacp_interfaces: >
	config=${1:# T}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet junos_user "Manage local user accounts on Juniper JUNOS devices" b
junos_user: >
	aggregate=${1:# The C(aggregate) argument defines a list of users to be configured on the remote device.  The list of users will be compared against the current users and only changes will be added or removed from the device configuration.  This argument is mutually exclusive with the name argument.}
	name=${2:# The C(name) argument defines the username of the user to be created on the system.  This argument must follow appropriate usernaming conventions for the target device running JUNOS.  This argument is mutually exclusive with the C(aggregate) argument.}
	full_name=${3:# The C(full_name) argument provides the full name of the user account to be created on the remote device.  This argument accepts any text string value.}
	role=${4:operator|read-only|super-user|unauthorized}
	sshkey=${5:# The C(sshkey) argument defines the public SSH key to be configured for the user account on the remote system.  This argument must be a valid SSH key}
	encrypted_password=${6:# The C(encrypted_password) argument set already hashed password for the user account on the remote system.}
	purge=${7:no}
	state=${8:#present|absent}
	active=${9:yes}
	provider=${10:# B(Deprecated)}

endsnippet

snippet junos_banner "Manage multiline banners on Juniper JUNOS devices" b
junos_banner: >
	banner=${1:login|motd}

	text=${2:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
	state=${3:#present|absent}
	active=${4:yes}
	provider=${5:# B(Deprecated)}

endsnippet

snippet junos_vrf "Manage the VRF definitions on Juniper JUNOS devices" b
junos_vrf: >
	name=${1:# The name of the VRF definition to be managed on the remote IOS device.  The VRF definition name is an ASCII string name used to uniquely identify the VRF.  This argument is mutually exclusive with the C(aggregate) argument}
	description=${2:# Provides a short description of the VRF definition in the current active configuration.  The VRF definition value accepts alphanumeric characters used to provide additional information about the VRF.}
	rd=${3:# The router-distinguisher value uniquely identifies the VRF to routing processes on the remote IOS system.  The RD value takes the form of C(A:B) where C(A) and C(B) are both numeric values.}
	interfaces=${4:# Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF.}
	target=${5:# It configures VRF target community configuration. The target value takes the form of C(target:A:B) where C(A) and C(B) are both numeric values.}
	table_label=${6:# Causes JUNOS to allocate a VPN label per VRF rather than per VPN FEC. This allows for forwarding of traffic to directly connected subnets, COS Egress filtering etc.}
	aggregate=${7:# The set of VRF definition objects to be configured on the remote JUNOS device.  Ths list entries can either be the VRF name or a hash of VRF definitions and attributes.  This argument is mutually exclusive with the C(name) argument.}
	state=${8:#present|absent}
	active=${9:yes}
	provider=${10:# B(Deprecated)}

endsnippet

snippet junos_vlans "Create and manage VLAN configurations on Junos OS" b
junos_vlans: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet junos_config "Manage configuration on devices running Juniper JUNOS" b
junos_config: >
	lines=${1:# This argument takes a list of C(set) or C(delete) configuration lines to push into the remote device.  Each line must start with either C(set) or C(delete).  This argument is mutually exclusive with the I(src) argument.}
	src=${2:# The I(src) argument provides a path to the configuration file to load into the remote system. The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) argument.}
	src_format=${3:xml|set|text|json}
	rollback=${4:# The C(rollback) argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the C(rollback) argument to 0.}
	zeroize=${5:# The C(zeroize) argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.}
	confirm=${6:0}
	comment=${7:configured by junos_config}
	replace=${8:no}
	backup=${9:no}
	update=${10:#merge|override|replace|update}
	confirm_commit=${11:no}
	check_commit=${12:no}
	backup_options=${13:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${14:# B(Deprecated)}

endsnippet

snippet junos_scp "Transfer files from or to remote devices running Junos" b
junos_scp: >
	src=${1:# The C(src) argument takes a single path, or a list of paths to be transferred. The argument C(recursive) must be C(true) to transfer directories.}

	dest=${2:.}
	recursive=${3:no}
	remote_src=${4:no}
	provider=${5:# B(Deprecated)}

endsnippet

snippet junos_interfaces "Manages interface attributes of Juniper Junos OS network devices." b
junos_interfaces: >
	config=${1:# T}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet junos_command "Run arbitrary commands on an Juniper JUNOS device" b
junos_command: >
	commands=${1:# The commands to send to the remote junos device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}
	rpcs=${2:# The C(rpcs) argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.}
	wait_for=${3:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails.  See examples.}
	match=${4:any|#all}
	retries=${5:10}
	interval=${6:1}
	display=${7:text|json|xml|set}
	provider=${8:# B(Deprecated)}

endsnippet

snippet junos_facts "Collect facts from remote devices running Juniper Junos" b
junos_facts: >
	gather_subset=${1:['!config']}
	config_format=${2:xml|#text|set|json}
	gather_network_resources=${3:# When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all and the resources like interfaces, vlans etc. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Valid subsets are 'all', 'interfaces', 'lacp', 'lacp_interfaces', 'lag_interfaces', 'l2_interfaces', 'l3_interfaces', 'lldp_global', 'lldp_interfaces', 'vlans'.}
	provider=${4:# B(Deprecated)}

endsnippet

snippet junos_lldp_global "Manage link layer discovery protocol (LLDP) attributes on Juniper JUNOS devices." b
junos_lldp_global: >
	config=${1:# T}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet junos_package "Installs packages on remote devices running Junos" b
junos_package: >
	src=${1:# The I(src) argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The I(src) argument can be either a localized path or a full path to the package file to install.}

	version=${2:# The I(version) argument can be used to explicitly specify the version of the package that should be installed on the remote device.  If the I(version) argument is not specified, then the version is extracts from the I(src) filename.}
	reboot=${3:yes}
	no_copy=${4:no}
	validate=${5:yes}
	force=${6:no}
	force_host=${7:no}
	issu=${8:no}
	provider=${9:# B(Deprecated)}

endsnippet

snippet junos_lacp "Manage Global Link Aggregation Control Protocol (LACP) on Juniper Junos devices" b
junos_lacp: >
	config=${1:# A}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet junos_system "Manage the system attributes on Juniper JUNOS devices" b
junos_system: >
	hostname=${1:# Configure the device hostname parameter. This option takes an ASCII string value.}
	domain_name=${2:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
	domain_search=${3:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
	name_servers=${4:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers See examples.}
	state=${5:#present|absent}
	active=${6:yes}
	provider=${7:# B(Deprecated)}

endsnippet

snippet junos_logging "Manage logging on network devices" b
junos_logging: >
	dest=${1:console|host|file|user}
	name=${2:# If value of C(dest) is I(file) it indicates file-name, for I(user) it indicates username and for I(host) indicates the host name to be notified.}
	facility=${3:# Set logging facility.}
	level=${4:# Set logging severity levels.}
	aggregate=${5:# L}
	state=${6:#present|absent}
	active=${7:yes}
	rotate_frequency=${8:# Rotate log frequency in minutes, this is applicable if value of I(dest) is C(file). The acceptable value is in range of 1 to 59. This controls the frequency after which log file is rotated.}
	size=${9:# Size of the file in archive, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 65536 to 1073741824 bytes.}
	files=${10:# Number of files to be archived, this is applicable if value of I(dest) is C(file). The acceptable value is in range from 1 to 1000.}
	provider=${11:# B(Deprecated)}

endsnippet

snippet junos_lldp_interfaces "Manage link layer discovery protocol (LLDP) attributes of interfaces on Juniper JUNOS devices" b
junos_lldp_interfaces: >
	config=${1:# T}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet junos_ping "Tests reachability using ping from devices running Juniper JUNOS" b
junos_ping: >
	dest=${1:# The IP Address or hostname (resolvable by the device) of the remote node.}

	count=${2:5}
	source=${3:# The IP Address to use while sending the ping packet(s).}
	interface=${4:# The source interface to use while sending the ping packet(s).}
	ttl=${5:# The time-to-live value for the ICMP packet(s).}
	size=${6:# Determines the size (in bytes) of the ping packet(s).}
	interval=${7:# Determines the interval (in seconds) between consecutive pings.}
	state=${8:absent|#present}
	provider=${9:# B(Deprecated)}

endsnippet

snippet junos_netconf "Configures the Junos Netconf system service" b
junos_netconf: >
	netconf_port=${1:830}
	state=${2:#present|absent}
	provider=${3:# B(Deprecated)}

endsnippet

snippet junos_lag_interfaces "Manage Link Aggregation on Juniper JUNOS devices." b
junos_lag_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet junos_static_route "Manage static IP routes on Juniper JUNOS network devices" b
junos_static_route: >
	address=${1:# Network address with prefix of the static route.}
	next_hop=${2:# Next hop IP of the static route.}

	qualified_next_hop=${3:# Qualified next hop IP of the static route. Qualified next hops allow to associate preference with a particular next-hop address.}
	preference=${4:# Global admin preference of the static route.}
	qualified_preference=${5:# Assign preference for qualified next hop.}
	aggregate=${6:# L}
	state=${7:#present|absent}
	active=${8:yes}
	provider=${9:# B(Deprecated)}

endsnippet

snippet junos_rpc "Runs an arbitrary RPC over NetConf on an Juniper JUNOS device" b
junos_rpc: >
	rpc=${1:# The C(rpc) argument specifies the RPC call to send to the remote devices to be executed.  The RPC Reply message is parsed and the contents are returned to the playbook.}

	args=${2:# The C(args) argument provides a set of arguments for the RPC call and are encoded in the request message.  This argument accepts a set of key=value arguments.}
	attrs=${3:# The C(attrs) arguments defines a list of attributes and their values to set for the RPC call. This accepts a dictionary of key-values.}
	output=${4:xml}
	provider=${5:# B(Deprecated)}

endsnippet

snippet junos_l3_interfaces "Manage Layer 3 interface on Juniper JUNOS devices" b
junos_l3_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet cnos_vlag "Manage VLAG resources and attributes on devices running Lenovo CNOS" b
cnos_vlag: >
	vlagArg1=${1:enable|auto-recovery|config-consistency|isl|mac-address-table|peer-gateway|priority|startup-delay|tier-id|vrrp|instance|hlthchk}
	outputfile=${2:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${4:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${6:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	vlagArg2=${7:Interval in seconds|disable or strict|Port Aggregation Number|VLAG priority|Delay time in seconds|VLAG tier-id value|VLAG instance number|keepalive-attempts|keepalive-interval|retry-interval|peer-ip}
	vlagArg3=${8:enable or port-aggregation|Number of keepalive attempts|Interval in seconds|Interval in seconds|VLAG health check peer IP4 address}
	vlagArg4=${9:Port Aggregation Number|default or management}
	enablePassword=${10:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_lldp "Manage LLDP configuration on Lenovo CNOS network devices." b
cnos_lldp: >
	state=${1:#present|absent}

endsnippet

snippet cnos_banner "Manage multiline banners on Lenovo CNOS devices" b
cnos_banner: >
	banner=${1:login|motd}

	text=${2:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string, with no empty lines. Requires I(state=present).}
	state=${3:#present|absent}
	provider=${4:# B(Deprecated)}

endsnippet

snippet cnos_rollback "Roll back the running or startup configuration from a remote server on devices running Lenovo CNOS" b
cnos_rollback: >
	configType=${1:running-config|startup-config}
	protocol=${2:SFTP|SCP|FTP|TFTP}
	rcserverip=${3:# This specifies the IP Address of the remote server from where the backup configuration will be downloaded.}
	rcpath=${4:# This specifies the full file path of the configuration file located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
	serverusername=${5:# Specify username for the server relating to the protocol used.}
	serverpassword=${6:# Specify password for the server relating to the protocol used.}
	outputfile=${7:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${8:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${9:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${10:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${11:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${12:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_facts "Collect facts from remote devices running Lenovo CNOS" b
cnos_facts: >
	authorize=${1:no}
	auth_pass=${2:# Specifies the password to use if required to enter privileged mode on the remote device.  If I(authorize) is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.}
	gather_subset=${3:!config}

endsnippet

snippet cnos_vrf "Manage VRFs on Lenovo CNOS network devices" b
cnos_vrf: >
	name=${1:# Name of the VRF.}

	rd=${2:# Route distinguisher of the VRF}
	interfaces=${3:# Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF. The name of interface should be in expanded format and not abbreviated.}
	associated_interfaces=${4:# This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.}
	aggregate=${5:# L}
	purge=${6:no}
	delay=${7:10}
	state=${8:#present|absent}

endsnippet

snippet cnos_interface "Manage Interface on Lenovo CNOS network devices" b
cnos_interface: >
	name=${1:# Name of the Interface.}

	description=${2:# Description of Interface.}
	enabled=${3:yes}
	speed=${4:# Interface link speed.}
	mtu=${5:# Maximum size of transmit packet.}
	duplex=${6:full|half|#auto}
	tx_rate=${7:# Transmit rate in bits per second (bps).}
	rx_rate=${8:# Receiver rate in bits per second (bps).}
	neighbors=${9:# Check operational state of given interface C(name) for LLDP neighbor.}
	aggregate=${10:# L}
	delay=${11:20}
	state=${12:#present|absent|up|down}
	provider=${13:# B(Deprecated)}

endsnippet

snippet cnos_bgp "Manage BGP resources and attributes on devices running CNOS" b
cnos_bgp: >
	asNum=${1:# AS number}
	bgpArg1=${2:address-family|bestpath|bgp|cluster-id|confederation|enforce-first-as|fast-external-failover|graceful-restart|graceful-restart-helper|log-neighbor-changes|maxas-limit|neighbor|router-id|shutdown|synchronization|timers|vrf}
	outputfile=${3:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${4:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${5:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${6:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${7:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	bgpArg2=${8:ipv4 or ipv6|always-compare-med|compare-confed-aspath|compare-routerid|dont-compare-originator-id|tie-break-on-age|as-path|med|identifier|peers}
	bgpArg3=${9:aggregate-address|client-to-client|dampening|distance|maximum-paths|network|nexthop|redistribute|save|synchronization|ignore or multipath-relax|confed or missing-as-worst or non-deterministic or remove-recv-med or remove-send-med}
	bgpArg4=${10:Aggregate prefix|Reachability Half-life time|route-map|Distance for routes ext|ebgp or ibgp|IP prefix <network>|IP prefix <network>/<length>|synchronization|Delay value|direct|ospf|static|memory}
	bgpArg5=${11:as-set|summary-only|Value to start reusing a route|Distance for routes internal|Supported multipath numbers|backdoor|map|route-map}
	bgpArg6=${12:summary-only|as-set|route-map name|Value to start suppressing a route|Distance local routes|Network mask|Pointer to route-map entries}
	bgpArg7=${13:Maximum duration to suppress a stable route(minutes)|backdoor|route-map|Name of the route map}
	bgpArg8=${14:Un-reachability Half-life time for the penalty(minutes)|backdoor}
	enablePassword=${15:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_linkagg "Manage link aggregation groups on Lenovo CNOS devices" b
cnos_linkagg: >
	group=${1:# Channel-group number for the port-channel Link aggregation group. Range 1-255.}
	mode=${2:active|on|passive}
	members=${3:# List of members of the link aggregation group.}
	aggregate=${4:# L}
	state=${5:#present|absent}
	purge=${6:no}
	provider=${7:# B(Deprecated)}

endsnippet

snippet cnos_showrun "Collect the current running configuration on devices running on CNOS" b
cnos_showrun: >
	outputfile=${1:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${2:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${3:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${4:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${5:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${6:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_user "Manage the collection of local users on Lenovo CNOS devices" b
cnos_user: >
	aggregate=${1:# The set of username objects to be configured on the remote Lenovo CNOS device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(name) argument.}
	name=${2:# The username to be configured on the remote Lenovo CNOS device.  This argument accepts a string value and is mutually exclusive with the C(aggregate) argument.}
	configured_password=${3:# The password to be configured on the network device. The password needs to be provided in cleartext and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
	update_password=${4:on_create|#always}
	role=${5:# The C(role) argument configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.}
	sshkey=${6:# The C(sshkey) argument defines the SSH public key to configure for the username.  This argument accepts a valid SSH key value.}
	purge=${7:no}
	state=${8:#present|absent}

endsnippet

snippet cnos_conditional_command "Execute a single command based on condition on devices running Lenovo CNOS" b
cnos_conditional_command: >
	clicommand=${1:# This specifies the CLI command as an attribute to this method. The command is passed using double quotes. The variables can be placed directly on to the CLI commands or can be invoked from the vars directory.}
	condition=${2:# If you specify condition=false in the inventory file against any device, the command execution is skipped for that device.}
	flag=${3:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
	outputfile=${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${6:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${8:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${9:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_save "Save the running configuration as the startup configuration on devices running Lenovo CNOS" b
cnos_save: >
	outputfile=${1:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${2:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${3:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${4:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${5:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${6:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_command "Run arbitrary commands on Lenovo CNOS devices" b
cnos_command: >
	commands=${1:# List of commands to send to the remote device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retires is expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet cnos_vlan "Manage VLANs on CNOS network devices" b
cnos_vlan: >
	vlan_id=${1:# ID of the VLAN. Range 1-4094.}
	interfaces=${2:# List of interfaces that should be associated to the VLAN.}

	name=${3:# Name of the VLAN.}
	associated_interfaces=${4:# This is a intent option and checks the operational state of the for given vlan C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vlan interfaces on device it will result in failure.}
	delay=${5:10}
	aggregate=${6:# L}
	purge=${7:no}
	state=${8:#present|absent|active|suspend}
	provider=${9:# B(Deprecated)}

endsnippet

snippet cnos_conditional_template "Manage switch configuration using templates based on condition on devices running Lenovo CNOS" b
cnos_conditional_template: >
	commandfile=${1:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. The command file must contain the Ansible keyword {{ inventory_hostname }} and the condition flag in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_ {{ inventory_hostname }}_LP21_commands.txt}
	condition=${2:# If you specify condition=<flag string> in the inventory file against any device, the template execution is done for that device in case it matches the flag setting for that task.}
	flag=${3:# If a task needs to be executed, you have to set the flag the same as it is specified in the inventory for that device.}
	outputfile=${4:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${5:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${6:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${7:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${8:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${9:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_static_route "Manage static IP routes on Lenovo CNOS network devices" b
cnos_static_route: >
	prefix=${1:# Network prefix of the static route.}
	mask=${2:# Network prefix mask of the static route.}
	next_hop=${3:# Next hop IP of the static route.}
	interface=${4:# Interface of the static route.}
	description=${5:# Name of the static route}
	admin_distance=${6:1}
	tag=${7:# Set tag of the static route.}
	aggregate=${8:# L}
	state=${9:#present|absent}

endsnippet

snippet cnos_logging "Manage logging on network devices" b
cnos_logging: >
	dest=${1:server|console|monitor|logfile}
	name=${2:# If value of C(dest) is I(file) it indicates file-name and for I(server) indicates the server name to be notified.}
	size=${3:10485760}
	facility=${4:# Set logging facility. This is applicable only for server logging}
	level=${5:5}
	aggregate=${6:# L}
	state=${7:#present|absent}

endsnippet

snippet cnos_factory "Reset the switch startup configuration to default (factory) on devices running Lenovo CNOS." b
cnos_factory: >
	outputfile=${1:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${2:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${3:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${4:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${5:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${6:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_reload "Perform switch restart on devices running Lenovo CNOS" b
cnos_reload: >
	outputfile=${1:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${2:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${3:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${4:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${5:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${6:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_image "Perform firmware upgrade/download from a remote server on devices running Lenovo CNOS" b
cnos_image: >
	protocol=${1:SFTP|SCP|FTP|TFTP}
	serverip=${2:# This specifies the IP Address of the remote server from where the software image will be downloaded.}
	imgpath=${3:# This specifies the full file path of the image located on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
	imgtype=${4:all|boot|os|onie}
	serverusername=${5:# Specify the username for the server relating to the protocol used}
	outputfile=${6:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${7:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${8:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${9:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${10:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	serverpassword=${11:# Specify the password for the server relating to the protocol used}
	enablePassword=${12:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_config "Manage Lenovo CNOS configuration sections" b
cnos_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block|config}
	config=${8:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	backup=${9:no}
	comment=${10:configured by cnos_config}
	admin=${11:no}
	backup_options=${12:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet cnos_l3_interface "Manage Layer-3 interfaces on Lenovo CNOS network devices." b
cnos_l3_interface: >
	name=${1:# Name of the Layer-3 interface to be configured eg. Ethernet1/2}
	ipv4=${2:# IPv4 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv4 address>/<mask>, the mask is number in range 0-32 eg. 10.241.107.1/24}
	ipv6=${3:# IPv6 address to be set for the Layer-3 interface mentioned in I(name) option. The address format is <ipv6 address>/<mask>, the mask is number in range 0-128 eg. fd5d:12c9:2201:1::1/64}
	aggregate=${4:# List of Layer-3 interfaces definitions. Each of the entry in aggregate list should define name of interface C(name) and a optional C(ipv4) or C(ipv6) address.}
	state=${5:#present|absent}
	provider=${6:# B(Deprecated)}

endsnippet

snippet cnos_system "Manage the system attributes on Lenovo CNOS devices" b
cnos_system: >
	hostname=${1:# Configure the device hostname parameter. This option takes an ASCII string value or keyword 'default'}
	domain_name=${2:# Configures the default domain name suffix to be used when referencing this node by its FQDN.  This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.}
	lookup_enabled=${3:# Administrative control for enabling or disabling DNS lookups. When this argument is set to True, lookups are performed and when it is set to False, lookups are not performed.}
	domain_search=${4:# Configures a list of domain name suffixes to search when performing DNS name resolution. This argument accepts either a list of domain names or a list of dicts that configure the domain name and VRF name or keyword 'default'. See examples.}
	name_servers=${5:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name or keyword 'default'. See examples.}
	lookup_source=${6:# Provides one or more source interfaces to use for performing DNS lookups. The interface must be a valid interface configured. on the device.}
	state=${7:#present|absent}

endsnippet

snippet cnos_backup "Backup the current running or startup configuration to a remote server on devices running Lenovo CNOS" b
cnos_backup: >
	configType=${1:running-config|startup-config}
	protocol=${2:SFTP|SCP|FTP|TFTP}
	rcserverip=${3:# -}
	rcpath=${4:# This specifies the full file path where the configuration file will be copied on the remote server. In case the relative path is used as the variable value, the root folder for the user of the server needs to be specified.}
	serverusername=${5:# Specify the username for the server relating to the protocol used.}
	serverpassword=${6:# Specify the password for the server relating to the protocol used.}
	outputfile=${7:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${8:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${9:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${10:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${11:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${12:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cnos_l2_interface "Manage Layer-2 interface on Lenovo CNOS devices." b
cnos_l2_interface: >
	name=${1:# Full name of the interface excluding any logical unit number, i.e. Ethernet1/3.}

	mode=${2:#access|trunk}
	access_vlan=${3:# Configure given VLAN in access port. If C(mode=access), used as the access VLAN ID.}
	trunk_vlans=${4:# List of VLANs to be configured in trunk port. If C(mode=trunk), used as the VLAN range to ADD or REMOVE from the trunk.}
	native_vlan=${5:# Native VLAN to be configured in trunk port. If C(mode=trunk), used as the trunk native VLAN ID.}
	trunk_allowed_vlans=${6:# List of allowed VLANs in a given trunk port. If C(mode=trunk), these are the only VLANs that will be configured on the trunk, i.e. "2-10,15".}
	aggregate=${7:# List of Layer-2 interface definitions.}
	state=${8:#present|absent|unconfigured}
	provider=${9:# B(Deprecated)}

endsnippet

snippet cnos_template "Manage switch configuration using templates on devices running Lenovo CNOS" b
cnos_template: >
	commandfile=${1:# This specifies the path to the CNOS command file which needs to be applied. This usually comes from the commands folder. Generally this file is the output of the variables applied on a template file. So this command is preceded by a template module. Note The command file must contain the Ansible keyword {{ inventory_hostname }} in its filename to ensure that the command file is unique for each switch and condition. If this is omitted, the command file will be overwritten during iteration. For example, commandfile=./commands/clos_leaf_bgp_{{ inventory_hostname }}_commands.txt}
	outputfile=${2:# This specifies the file path where the output of each command execution is saved. Each command that is specified in the merged template file and each response from the device are saved here. Usually the location is the results folder, but you can choose another location based on your write permission.}
	host=${3:# This is the variable used to search the hosts file at /etc/ansible/hosts and identify the IP address of the device on which the template is going to be applied. Usually the Ansible keyword {{ inventory_hostname }} is specified in the playbook as an abstraction of the group of network elements that need to be configured.}
	username=${4:# Configures the username used to authenticate the connection to the remote device. The value of the username parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	password=${5:# Configures the password used to authenticate the connection to the remote device. The value of the password parameter is used to authenticate the SSH session. While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}
	deviceType=${6:g8272_cnos|g8296_cnos|g8332_cnos|NE0152T|NE1072T|NE1032|NE1032T|NE10032|NE2572}

	enablePassword=${7:# Configures the password used to enter Global Configuration command mode on the switch. If the switch does not request this password, the parameter is ignored.While generally the value should come from the inventory file, you can also specify it as a variable. This parameter is optional. If it is not specified, no default value will be used.}

endsnippet

snippet cp_mgmt_access_role "Manages access-role objects on Check Point over Web Services API" b
cp_mgmt_access_role: >
	name=${1:# Object name.}

	machines=${2:# Machines that can access the system.}
	networks=${3:# Collection of Network objects identified by the name or UID that can access the system.}
	remote_access_clients=${4:# Remote access clients identified by name or UID.}
	tags=${5:# Collection of tag identifiers.}
	users=${6:# Users that can access the system.}
	color=${7:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${8:# Comments string.}
	details_level=${9:uid|standard|full}
	ignore_warnings=${10:# Apply changes ignoring warnings.}
	ignore_errors=${11:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${12:#present|absent}
	auto_publish_session=${13:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${14:yes}
	version=${15:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_exception_group_facts "Get exception-group objects facts on Check Point over Web Services API" b
cp_mgmt_exception_group_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_package_facts "Get package objects facts on Check Point over Web Services API" b
cp_mgmt_package_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_group "Manages group objects on Check Point over Web Services API" b
cp_mgmt_group: >
	name=${1:# Object name.}

	members=${2:# Collection of Network objects identified by the name or UID.}
	tags=${3:# Collection of tag identifiers.}
	color=${4:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${5:# Comments string.}
	details_level=${6:uid|standard|full}
	groups=${7:# Collection of group identifiers.}
	ignore_warnings=${8:# Apply changes ignoring warnings.}
	ignore_errors=${9:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${10:#present|absent}
	auto_publish_session=${11:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${12:yes}
	version=${13:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_layer "Manages threat-layer objects on Check Point over Web Services API" b
cp_mgmt_threat_layer: >
	name=${1:# Object name.}

	add_default_rule=${2:# Indicates whether to include a default rule in the new layer.}
	tags=${3:# Collection of tag identifiers.}
	color=${4:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${5:# Comments string.}
	details_level=${6:uid|standard|full}
	ignore_warnings=${7:# Apply changes ignoring warnings.}
	ignore_errors=${8:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${9:#present|absent}
	auto_publish_session=${10:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${11:yes}
	version=${12:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_host "Manages host objects on Check Point over Web Services API" b
cp_mgmt_host: >
	name=${1:# Object name.}

	ip_address=${2:# IPv4 or IPv6 address. If both addresses are required use ipv4-address and ipv6-address fields explicitly.}
	ipv4_address=${3:# IPv4 address.}
	ipv6_address=${4:# IPv6 address.}
	interfaces=${5:# Host interfaces.}
	nat_settings=${6:# NAT settings.}
	tags=${7:# Collection of tag identifiers.}
	host_servers=${8:# Servers Configuration.}
	color=${9:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${10:# Comments string.}
	details_level=${11:uid|standard|full}
	groups=${12:# Collection of group identifiers.}
	ignore_warnings=${13:# Apply changes ignoring warnings.}
	ignore_errors=${14:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${15:#present|absent}
	auto_publish_session=${16:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${17:yes}
	version=${18:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_group "Manages service-group objects on Check Point over Web Services API" b
cp_mgmt_service_group: >
	name=${1:# Object name.}

	members=${2:# Collection of Network objects identified by the name or UID.}
	tags=${3:# Collection of tag identifiers.}
	color=${4:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${5:# Comments string.}
	details_level=${6:uid|standard|full}
	groups=${7:# Collection of group identifiers.}
	ignore_warnings=${8:# Apply changes ignoring warnings.}
	ignore_errors=${9:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${10:#present|absent}
	auto_publish_session=${11:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${12:yes}
	version=${13:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_access_layer_facts "Get access-layer objects facts on Check Point over Web Services API" b
cp_mgmt_access_layer_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_wildcard "Manages wildcard objects on Check Point over Web Services API" b
cp_mgmt_wildcard: >
	name=${1:# Object name.}

	ipv4_address=${2:# IPv4 address.}
	ipv4_mask_wildcard=${3:# IPv4 mask wildcard.}
	ipv6_address=${4:# IPv6 address.}
	ipv6_mask_wildcard=${5:# IPv6 mask wildcard.}
	tags=${6:# Collection of tag identifiers.}
	color=${7:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${8:# Comments string.}
	details_level=${9:uid|standard|full}
	groups=${10:# Collection of group identifiers.}
	ignore_warnings=${11:# Apply changes ignoring warnings.}
	ignore_errors=${12:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${13:#present|absent}
	auto_publish_session=${14:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${15:yes}
	version=${16:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_publish "All the changes done by this user will be seen by all users only after publish is called." b
cp_mgmt_publish: >
	uid=${1:# Session unique identifier. Specify it to publish a different session than the one you currently use.}
	wait_for_task=${2:yes}
	version=${3:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_access_rule_facts "Get access-rule objects facts on Check Point over Web Services API" b
cp_mgmt_access_rule_facts: >
	name=${1:# Object name. Should be unique in the domain.}
	layer=${2:# Layer that the rule belongs to identified by the name or UID.}
	show_as_ranges=${3:# When true, the source, destination and services & applications parameters are displayed as ranges of IP addresses and port numbers rather than network objects.<br /> Objects that are not represented using IP addresses or port numbers are presented as objects.<br /> In addition, the response of each rule does not contain the parameters, source, source-negate, destination, destination-negate, service and service-negate, but instead it contains the parameters, source-ranges, destination-ranges and service-ranges.<br /><br /> Note, Requesting to show rules as ranges is limited up to 20 rules per request, otherwise an error is returned. If you wish to request more rules, use the offset and limit parameters to limit your request.}
	show_hits=${4:# N/A}
	hits_settings=${5:# N/A}
	details_level=${6:uid|standard|full}
	filter=${7:# Search expression to filter the rulebase. The provided text should be exactly the same as it would be given in Smart Console. The logical operators in the expression ('AND', 'OR') should be provided in capital letters. If an operator is not used, the default OR operator applies.}
	filter_settings=${8:# Sets filter preferences.}
	limit=${9:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${10:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${11:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	package=${12:# Name of the package.}
	use_object_dictionary=${13:# N/A}
	dereference_group_members=${14:# Indicates whether to dereference "members" field by details level for every object in reply.}
	show_membership=${15:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${16:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_vpn_community_star_facts "Get vpn-community-star objects facts on Check Point over Web Services API" b
cp_mgmt_vpn_community_star_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_sctp_facts "Get service-sctp objects facts on Check Point over Web Services API" b
cp_mgmt_service_sctp_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_udp "Manages service-udp objects on Check Point over Web Services API" b
cp_mgmt_service_udp: >
	name=${1:# Object name.}

	accept_replies=${2:# N/A}
	aggressive_aging=${3:# Sets short (aggressive) timeouts for idle connections.}
	keep_connections_open_after_policy_installation=${4:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	match_by_protocol_signature=${5:# A value of true enables matching by the selected protocol's signature - the signature identifies the protocol as genuine. Select this option to limit the port to the specified protocol. If the selected protocol does not support matching by signature, this field cannot be set to true.}
	match_for_any=${6:# Indicates whether this service is used when 'Any' is set as the rule's service and there are several service objects with the same source port and protocol.}
	override_default_settings=${7:# Indicates whether this service is a Data Domain service which has been overridden.}
	port=${8:# The number of the port used to provide this service. To specify a port range, place a hyphen between the lowest and highest port numbers, for example 44-55.}
	protocol=${9:# Select the protocol type associated with the service, and by implication, the management server (if any) that enforces Content Security and Authentication for the service. Selecting a Protocol Type invokes the specific protocol handlers for each protocol type, thus enabling higher level of security by parsing the protocol, and higher level of connectivity by tracking dynamic actions (such as opening of ports).}
	session_timeout=${10:# Time (in seconds) before the session times out.}
	source_port=${11:# Port number for the client side service. If specified, only those Source port Numbers will be Accepted, Dropped, or Rejected during packet inspection. Otherwise, the source port is not inspected.}
	sync_connections_on_cluster=${12:# Enables state-synchronized High Availability or Load Sharing on a ClusterXL or OPSEC-certified cluster.}
	tags=${13:# Collection of tag identifiers.}
	use_default_session_timeout=${14:# Use default virtual session timeout.}
	color=${15:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${16:# Comments string.}
	details_level=${17:uid|standard|full}
	groups=${18:# Collection of group identifiers.}
	ignore_warnings=${19:# Apply changes ignoring warnings.}
	ignore_errors=${20:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${21:#present|absent}
	auto_publish_session=${22:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${23:yes}
	version=${24:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet checkpoint_access_rule_facts "Get access rules objects facts on Check Point over Web Services API" b
checkpoint_access_rule_facts: >
	layer=${1:# Layer the access rule is attached to.}

	name=${2:# Name of the access rule. If not provided, UID is required.}
	uid=${3:# UID of the access rule. If not provided, name is required.}

endsnippet

snippet cp_mgmt_service_rpc "Manages service-rpc objects on Check Point over Web Services API" b
cp_mgmt_service_rpc: >
	name=${1:# Object name.}

	keep_connections_open_after_policy_installation=${2:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	program_number=${3:# N/A}
	tags=${4:# Collection of tag identifiers.}
	color=${5:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${6:# Comments string.}
	details_level=${7:uid|standard|full}
	groups=${8:# Collection of group identifiers.}
	ignore_warnings=${9:# Apply changes ignoring warnings.}
	ignore_errors=${10:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${11:#present|absent}
	auto_publish_session=${12:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${13:yes}
	version=${14:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_application_site_facts "Get application-site objects facts on Check Point over Web Services API" b
cp_mgmt_application_site_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	application_id=${2:# Object application identifier.}
	details_level=${3:uid|standard|full}
	limit=${4:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${5:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${6:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${7:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${8:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_address_range "Manages address-range objects on Check Point over Web Services API" b
cp_mgmt_address_range: >
	name=${1:# Object name.}

	ip_address_first=${2:# First IP address in the range. If both IPv4 and IPv6 address ranges are required, use the ipv4-address-first and the ipv6-address-first fields instead.}
	ipv4_address_first=${3:# First IPv4 address in the range.}
	ipv6_address_first=${4:# First IPv6 address in the range.}
	ip_address_last=${5:# Last IP address in the range. If both IPv4 and IPv6 address ranges are required, use the ipv4-address-first and the ipv6-address-first fields instead.}
	ipv4_address_last=${6:# Last IPv4 address in the range.}
	ipv6_address_last=${7:# Last IPv6 address in the range.}
	nat_settings=${8:# NAT settings.}
	tags=${9:# Collection of tag identifiers.}
	color=${10:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${11:# Comments string.}
	details_level=${12:uid|standard|full}
	groups=${13:# Collection of group identifiers.}
	ignore_warnings=${14:# Apply changes ignoring warnings.}
	ignore_errors=${15:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${16:#present|absent}
	auto_publish_session=${17:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${18:yes}
	version=${19:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_application_site_category "Manages application-site-category objects on Check Point over Web Services API" b
cp_mgmt_application_site_category: >
	name=${1:# Object name.}

	description=${2:# N/A}
	tags=${3:# Collection of tag identifiers.}
	color=${4:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${5:# Comments string.}
	details_level=${6:uid|standard|full}
	groups=${7:# Collection of group identifiers.}
	ignore_warnings=${8:# Apply changes ignoring warnings.}
	ignore_errors=${9:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${10:#present|absent}
	auto_publish_session=${11:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${12:yes}
	version=${13:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_profile "Manages threat-profile objects on Check Point over Web Services API" b
cp_mgmt_threat_profile: >
	name=${1:# Object name.}

	active_protections_performance_impact=${2:high|medium|low|very_low}
	active_protections_severity=${3:Critical|High|Medium or above|Low or above}
	confidence_level_high=${4:Inactive|Ask|Prevent|Detect}
	confidence_level_low=${5:Inactive|Ask|Prevent|Detect}
	confidence_level_medium=${6:Inactive|Ask|Prevent|Detect}
	indicator_overrides=${7:# Indicators whose action will be overridden in this profile.}
	ips_settings=${8:# IPS blade settings.}
	malicious_mail_policy_settings=${9:# Malicious Mail Policy for MTA Gateways.}
	overrides=${10:# Overrides per profile for this protection.}
	tags=${11:# Collection of tag identifiers.}
	use_indicators=${12:# Indicates whether the profile should make use of indicators.}
	anti_bot=${13:# Is Anti-Bot blade activated.}
	anti_virus=${14:# Is Anti-Virus blade activated.}
	ips=${15:# Is IPS blade activated.}
	threat_emulation=${16:# Is Threat Emulation blade activated.}
	activate_protections_by_extended_attributes=${17:# Activate protections by these extended attributes.}
	deactivate_protections_by_extended_attributes=${18:# Deactivate protections by these extended attributes.}
	use_extended_attributes=${19:# Whether to activate/deactivate IPS protections according to the extended attributes.}
	color=${20:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${21:# Comments string.}
	details_level=${22:uid|standard|full}
	ignore_warnings=${23:# Apply changes ignoring warnings.}
	ignore_errors=${24:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${25:#present|absent}
	auto_publish_session=${26:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${27:yes}
	version=${28:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_time_facts "Get time objects facts on Check Point over Web Services API" b
cp_mgmt_time_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_tcp "Manages service-tcp objects on Check Point over Web Services API" b
cp_mgmt_service_tcp: >
	name=${1:# Object name.}

	aggressive_aging=${2:# Sets short (aggressive) timeouts for idle connections.}
	keep_connections_open_after_policy_installation=${3:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	match_by_protocol_signature=${4:# A value of true enables matching by the selected protocol's signature - the signature identifies the protocol as genuine. Select this option to limit the port to the specified protocol. If the selected protocol does not support matching by signature, this field cannot be set to true.}
	match_for_any=${5:# Indicates whether this service is used when 'Any' is set as the rule's service and there are several service objects with the same source port and protocol.}
	override_default_settings=${6:# Indicates whether this service is a Data Domain service which has been overridden.}
	port=${7:# The number of the port used to provide this service. To specify a port range, place a hyphen between the lowest and highest port numbers, for example 44-55.}
	protocol=${8:# Select the protocol type associated with the service, and by implication, the management server (if any) that enforces Content Security and Authentication for the service. Selecting a Protocol Type invokes the specific protocol handlers for each protocol type, thus enabling higher level of security by parsing the protocol, and higher level of connectivity by tracking dynamic actions (such as opening of ports).}
	session_timeout=${9:# Time (in seconds) before the session times out.}
	source_port=${10:# Port number for the client side service. If specified, only those Source port Numbers will be Accepted, Dropped, or Rejected during packet inspection. Otherwise, the source port is not inspected.}
	sync_connections_on_cluster=${11:# Enables state-synchronized High Availability or Load Sharing on a ClusterXL or OPSEC-certified cluster.}
	tags=${12:# Collection of tag identifiers.}
	use_default_session_timeout=${13:# Use default virtual session timeout.}
	color=${14:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${15:# Comments string.}
	details_level=${16:uid|standard|full}
	groups=${17:# Collection of group identifiers.}
	ignore_warnings=${18:# Apply changes ignoring warnings.}
	ignore_errors=${19:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${20:#present|absent}
	auto_publish_session=${21:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${22:yes}
	version=${23:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_vpn_community_meshed "Manages vpn-community-meshed objects on Check Point over Web Services API" b
cp_mgmt_vpn_community_meshed: >
	name=${1:# Object name.}

	encryption_method=${2:prefer ikev2 but support ikev1|ikev2 only|ikev1 for ipv4 and ikev2 for ipv6 only}
	encryption_suite=${3:suite-b-gcm-256|custom|vpn b|vpn a|suite-b-gcm-128}
	gateways=${4:# Collection of Gateway objects identified by the name or UID.}
	ike_phase_1=${5:# Ike Phase 1 settings. Only applicable when the encryption-suite is set to [custom].}
	ike_phase_2=${6:# Ike Phase 2 settings. Only applicable when the encryption-suite is set to [custom].}
	shared_secrets=${7:# Shared secrets for external gateways.}
	tags=${8:# Collection of tag identifiers.}
	use_shared_secret=${9:# Indicates whether the shared secret should be used for all external gateways.}
	color=${10:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${11:# Comments string.}
	details_level=${12:uid|standard|full}
	ignore_warnings=${13:# Apply changes ignoring warnings.}
	ignore_errors=${14:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${15:#present|absent}
	auto_publish_session=${16:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${17:yes}
	version=${18:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_indicator_facts "Get threat-indicator objects facts on Check Point over Web Services API" b
cp_mgmt_threat_indicator_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_dce_rpc_facts "Get service-dce-rpc objects facts on Check Point over Web Services API" b
cp_mgmt_service_dce_rpc_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_icmp_facts "Get service-icmp objects facts on Check Point over Web Services API" b
cp_mgmt_service_icmp_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet checkpoint_host "Manages host objects on Check Point over Web Services API" b
checkpoint_host: >
	name=${1:# Name of the access rule.}

	ip_address=${2:# IP address of the host object.}
	state=${3:present}
	auto_publish_session=${4:yes}
	auto_install_policy=${5:yes}
	policy_package=${6:standard}
	targets=${7:# Targets to install the package policy on.}

endsnippet

snippet checkpoint_task_facts "Get task objects facts on Check Point over Web Services API" b
checkpoint_task_facts: >
	task_id=${1:# ID of the task object.}

endsnippet

snippet cp_mgmt_service_sctp "Manages service-sctp objects on Check Point over Web Services API" b
cp_mgmt_service_sctp: >
	name=${1:# Object name.}

	port=${2:# Port number. To specify a port range add a hyphen between the lowest and the highest port numbers, for example 44-45.}
	aggressive_aging=${3:# Sets short (aggressive) timeouts for idle connections.}
	keep_connections_open_after_policy_installation=${4:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	match_for_any=${5:# Indicates whether this service is used when 'Any' is set as the rule's service and there are several service objects with the same source port and protocol.}
	session_timeout=${6:# Time (in seconds) before the session times out.}
	source_port=${7:# Source port number. To specify a port range add a hyphen between the lowest and the highest port numbers, for example 44-45.}
	sync_connections_on_cluster=${8:# Enables state-synchronized High Availability or Load Sharing on a ClusterXL or OPSEC-certified cluster.}
	tags=${9:# Collection of tag identifiers.}
	use_default_session_timeout=${10:# Use default virtual session timeout.}
	color=${11:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${12:# Comments string.}
	details_level=${13:uid|standard|full}
	groups=${14:# Collection of group identifiers.}
	ignore_warnings=${15:# Apply changes ignoring warnings.}
	ignore_errors=${16:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${17:#present|absent}
	auto_publish_session=${18:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${19:yes}
	version=${20:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_group_facts "Get service-group objects facts on Check Point over Web Services API" b
cp_mgmt_service_group_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	show_as_ranges=${2:# When true, the service group's matched content is displayed as ranges of port numbers rather than service objects.<br />Objects that are not represented using port numbers are presented as objects.<br />The 'members' parameter is omitted from the response and instead the 'ranges' parameter is displayed.}
	details_level=${3:uid|standard|full}
	limit=${4:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${5:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${6:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	dereference_group_members=${7:# Indicates whether to dereference "members" field by details level for every object in reply.}
	show_membership=${8:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${9:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_network_facts "Get network objects facts on Check Point over Web Services API" b
cp_mgmt_network_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_time "Manages time objects on Check Point over Web Services API" b
cp_mgmt_time: >
	name=${1:# Object name.}

	end=${2:# End time. Note, Each gateway may interpret this time differently according to its time zone.}
	end_never=${3:# End never.}
	hours_ranges=${4:# Hours recurrence. Note, Each gateway may interpret this time differently according to its time zone.}
	start=${5:# Starting time. Note, Each gateway may interpret this time differently according to its time zone.}
	start_now=${6:# Start immediately.}
	tags=${7:# Collection of tag identifiers.}
	recurrence=${8:# Days recurrence.}
	color=${9:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${10:# Comments string.}
	details_level=${11:uid|standard|full}
	groups=${12:# Collection of group identifiers.}
	ignore_warnings=${13:# Apply changes ignoring warnings.}
	ignore_errors=${14:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${15:#present|absent}
	auto_publish_session=${16:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${17:yes}
	version=${18:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_administrator_facts "Get administrator objects facts on Check Point over Web Services API" b
cp_mgmt_administrator_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_dns_domain_facts "Get dns-domain objects facts on Check Point over Web Services API" b
cp_mgmt_dns_domain_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_application_site_category_facts "Get application-site-category objects facts on Check Point over Web Services API" b
cp_mgmt_application_site_category_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_discard "All changes done by user are discarded and removed from database." b
cp_mgmt_discard: >
	uid=${1:# Session unique identifier. Specify it to discard a different session than the one you currently use.}
	wait_for_task=${2:yes}
	version=${3:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_assign_global_assignment "assign global assignment on Check Point over Web Services API" b
cp_mgmt_assign_global_assignment: >
	dependent_domains=${1:# N/A}
	global_domains=${2:# N/A}
	details_level=${3:uid|standard|full}
	wait_for_task=${4:yes}
	version=${5:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet checkpoint_run_script "Run scripts on Check Point devices over Web Services API" b
checkpoint_run_script: >
	script_name=${1:# Name of the script.}
	script=${2:# Script body contents.}
	targets=${3:# Targets the script should be run against. Can reference either name or UID.}

endsnippet

snippet checkpoint_access_layer_facts "Get access layer facts on Check Point over Web Services API" b
checkpoint_access_layer_facts: >
	uid=${1:# UID of access layer object.}
	name=${2:# Name of the access layer object.}

endsnippet

snippet cp_mgmt_host_facts "Get host objects facts on Check Point over Web Services API" b
cp_mgmt_host_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_publish "All the changes done by this user will be seen by all users only after publish is called." b
cp_publish: >
	uid=${1:# Session unique identifier. Specify it to publish a different session than the one you currently use.}
	wait_for_task=${2:yes}
	version=${3:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_mds_facts "Get Multi-Domain Server (mds) objects facts on Check Point over Web Services API" b
cp_mgmt_mds_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_network "Manages network objects on Check Point over Web Services API" b
cp_mgmt_network: >
	name=${1:# Object name.}

	subnet=${2:# IPv4 or IPv6 network address. If both addresses are required use subnet4 and subnet6 fields explicitly.}
	subnet4=${3:# IPv4 network address.}
	subnet6=${4:# IPv6 network address.}
	mask_length=${5:# IPv4 or IPv6 network mask length. If both masks are required use mask-length4 and mask-length6 fields explicitly. Instead of IPv4 mask length it is possible to specify IPv4 mask itself in subnet-mask field.}
	mask_length4=${6:# IPv4 network mask length.}
	mask_length6=${7:# IPv6 network mask length.}
	subnet_mask=${8:# IPv4 network mask.}
	nat_settings=${9:# NAT settings.}
	tags=${10:# Collection of tag identifiers.}
	broadcast=${11:disallow|allow}
	color=${12:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${13:# Comments string.}
	details_level=${14:uid|standard|full}
	groups=${15:# Collection of group identifiers.}
	ignore_warnings=${16:# Apply changes ignoring warnings.}
	ignore_errors=${17:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${18:#present|absent}
	auto_publish_session=${19:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${20:yes}
	version=${21:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet checkpoint_session "Manages session objects on Check Point over Web Services API" b
checkpoint_session: >
	uid=${1:# UID of the session.}

	state=${2:#published|discarded}

endsnippet

snippet cp_mgmt_service_tcp_facts "Get service-tcp objects facts on Check Point over Web Services API" b
cp_mgmt_service_tcp_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_multicast_address_range "Manages multicast-address-range objects on Check Point over Web Services API" b
cp_mgmt_multicast_address_range: >
	name=${1:# Object name.}

	ip_address=${2:# IPv4 or IPv6 address. If both addresses are required use ipv4-address and ipv6-address fields explicitly.}
	ipv4_address=${3:# IPv4 address.}
	ipv6_address=${4:# IPv6 address.}
	ip_address_first=${5:# First IP address in the range. If both IPv4 and IPv6 address ranges are required, use the ipv4-address-first and the ipv6-address-first fields instead.}
	ipv4_address_first=${6:# First IPv4 address in the range.}
	ipv6_address_first=${7:# First IPv6 address in the range.}
	ip_address_last=${8:# Last IP address in the range. If both IPv4 and IPv6 address ranges are required, use the ipv4-address-first and the ipv6-address-first fields instead.}
	ipv4_address_last=${9:# Last IPv4 address in the range.}
	ipv6_address_last=${10:# Last IPv6 address in the range.}
	tags=${11:# Collection of tag identifiers.}
	color=${12:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${13:# Comments string.}
	details_level=${14:uid|standard|full}
	groups=${15:# Collection of group identifiers.}
	ignore_warnings=${16:# Apply changes ignoring warnings.}
	ignore_errors=${17:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${18:#present|absent}
	auto_publish_session=${19:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${20:yes}
	version=${21:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_address_range_facts "Get address-range objects facts on Check Point over Web Services API" b
cp_mgmt_address_range_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_simple_gateway_facts "Get simple-gateway objects facts on Check Point over Web Services API" b
cp_mgmt_simple_gateway_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_vpn_community_meshed_facts "Get vpn-community-meshed objects facts on Check Point over Web Services API" b
cp_mgmt_vpn_community_meshed_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_application_site_group_facts "Get application-site-group objects facts on Check Point over Web Services API" b
cp_mgmt_application_site_group_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	dereference_group_members=${6:# Indicates whether to dereference "members" field by details level for every object in reply.}
	show_membership=${7:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${8:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet checkpoint_object_facts "Get object facts on Check Point over Web Services API" b
checkpoint_object_facts: >
	uid=${1:# UID of the object. If UID is not provided, it will do a full search which can be filtered with the filter argument.}
	object_filter=${2:# Filter expression for search. It accepts AND/OR logical operators and performs a textual and IP address search. To search only by IP address, set ip_only argument to True. which can be filtered with the filter argument.}
	ip_only=${3:no}
	object_type=${4:# Type of the object to search. Must be a valid API resource name}

endsnippet

snippet cp_mgmt_application_site_group "Manages application-site-group objects on Check Point over Web Services API" b
cp_mgmt_application_site_group: >
	name=${1:# Object name.}

	members=${2:# Collection of application and URL filtering objects identified by the name or UID.}
	tags=${3:# Collection of tag identifiers.}
	color=${4:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${5:# Comments string.}
	details_level=${6:uid|standard|full}
	groups=${7:# Collection of group identifiers.}
	ignore_warnings=${8:# Apply changes ignoring warnings.}
	ignore_errors=${9:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${10:#present|absent}
	auto_publish_session=${11:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${12:yes}
	version=${13:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_exception_facts "Get threat-exception objects facts on Check Point over Web Services API" b
cp_mgmt_threat_exception_facts: >
	name=${1:# The name of the layer containing the parent threat rule. This parameter is relevant only for getting few objects.}
	exception_group_uid=${2:# The UID of the exception-group.}
	exception_group_name=${3:# The name of the exception-group.}
	layer=${4:# Layer that the rule belongs to identified by the name or UID.}
	rule_name=${5:# The name of the parent rule.}
	details_level=${6:uid|standard|full}
	filter=${7:# Search expression to filter the rulebase. The provided text should be exactly the same as it would be given in Smart Console. The logical operators in the expression ('AND', 'OR') should be provided in capital letters. If an operator is not used, the default OR operator applies.}
	filter_settings=${8:# Sets filter preferences.}
	limit=${9:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${10:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${11:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	package=${12:# Name of the package.}
	use_object_dictionary=${13:# N/A}
	dereference_group_members=${14:# Indicates whether to dereference "members" field by details level for every object in reply.}
	show_membership=${15:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${16:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_install_policy "install policy on Check Point over Web Services API" b
cp_mgmt_install_policy: >
	policy_package=${1:# The name of the Policy Package to be installed.}
	targets=${2:# On what targets to execute this command. Targets may be identified by their name, or object unique identifier.}
	access=${3:# Set to be true in order to install the Access Control policy. By default, the value is true if Access Control policy is enabled on the input policy package, otherwise false.}
	desktop_security=${4:# Set to be true in order to install the Desktop Security policy. By default, the value is true if desktop security policy is enabled on the input policy package, otherwise false.}
	qos=${5:# Set to be true in order to install the QoS policy. By default, the value is true if Quality-of-Service policy is enabled on the input policy package, otherwise false.}
	threat_prevention=${6:# Set to be true in order to install the Threat Prevention policy. By default, the value is true if Threat Prevention policy is enabled on the input policy package, otherwise false.}
	install_on_all_cluster_members_or_fail=${7:# Relevant for the gateway clusters. If true, the policy is installed on all the cluster members. If the installation on a cluster member fails, don't install on that cluster.}
	prepare_only=${8:# If true, prepares the policy for the installation, but doesn't install it on an installation target.}
	revision=${9:# The UID of the revision of the policy to install.}
	wait_for_task=${10:yes}
	version=${11:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_administrator "Manages administrator objects on Check Point over Web Services API" b
cp_mgmt_administrator: >
	name=${1:# Object name.}

	authentication_method=${2:undefined|check point password|os password|securid|radius|tacacs|ad authentication}
	email=${3:# Administrator email.}
	expiration_date=${4:# Format, YYYY-MM-DD, YYYY-mm-ddThh,mm,ss.}
	multi_domain_profile=${5:# Administrator multi-domain profile.}
	must_change_password=${6:# True if administrator must change password on the next login.}
	password=${7:# Administrator password.}
	password_hash=${8:# Administrator password hash.}
	permissions_profile=${9:# Administrator permissions profile. Permissions profile should not be provided when multi-domain-profile is set to "Multi-Domain Super User" or "Domain Super User".}
	phone_number=${10:# Administrator phone number.}
	radius_server=${11:# RADIUS server object identified by the name or UID. Must be set when "authentication-method" was selected to be "RADIUS".}
	tacacs_server=${12:# TACACS server object identified by the name or UID. Must be set when "authentication-method" was selected to be "TACACS".}
	tags=${13:# Collection of tag identifiers.}
	color=${14:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${15:# Comments string.}
	details_level=${16:uid|standard|full}
	ignore_warnings=${17:# Apply changes ignoring warnings.}
	ignore_errors=${18:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${19:#present|absent}
	auto_publish_session=${20:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${21:yes}
	version=${22:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet checkpoint_access_rule "Manages access rules on Check Point over Web Services API" b
checkpoint_access_rule: >
	layer=${1:# Layer to attach the access rule to.}

	name=${2:# Name of the access rule.}
	position=${3:# Position of the access rule.}
	source=${4:# Source object of the access rule.}
	destination=${5:# Destination object of the access rule.}
	action=${6:drop}
	enabled=${7:yes}
	state=${8:present}
	auto_publish_session=${9:yes}
	auto_install_policy=${10:yes}
	policy_package=${11:standard}
	targets=${12:# Targets to install the package policy on.}

endsnippet

snippet cp_mgmt_threat_profile_facts "Get threat-profile objects facts on Check Point over Web Services API" b
cp_mgmt_threat_profile_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_udp_facts "Get service-udp objects facts on Check Point over Web Services API" b
cp_mgmt_service_udp_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_tag "Manages tag objects on Check Point over Web Services API" b
cp_mgmt_tag: >
	name=${1:# Object name.}

	tags=${2:# Collection of tag identifiers.}
	color=${3:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${4:# Comments string.}
	details_level=${5:uid|standard|full}
	ignore_warnings=${6:# Apply changes ignoring warnings.}
	ignore_errors=${7:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${8:#present|absent}
	auto_publish_session=${9:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${10:yes}
	version=${11:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_indicator "Manages threat-indicator objects on Check Point over Web Services API" b
cp_mgmt_threat_indicator: >
	name=${1:# Object name.}

	observables=${2:# The indicator's observables.}
	observables_raw_data=${3:# The contents of a file containing the indicator's observables.}
	action=${4:Inactive|Ask|Prevent|Detect}
	profile_overrides=${5:# Profiles in which to override the indicator's default action.}
	tags=${6:# Collection of tag identifiers.}
	color=${7:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${8:# Comments string.}
	details_level=${9:uid|standard|full}
	ignore_warnings=${10:# Apply changes ignoring warnings.}
	ignore_errors=${11:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${12:#present|absent}
	auto_publish_session=${13:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${14:yes}
	version=${15:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_access_layer "Manages access-layer objects on Check Point over Web Services API" b
cp_mgmt_access_layer: >
	name=${1:# Object name.}

	add_default_rule=${2:# Indicates whether to include a cleanup rule in the new layer.}
	applications_and_url_filtering=${3:# Whether to enable Applications & URL Filtering blade on the layer.}
	content_awareness=${4:# Whether to enable Content Awareness blade on the layer.}
	detect_using_x_forward_for=${5:# Whether to use X-Forward-For HTTP header, which is added by the  proxy server to keep track of the original source IP.}
	firewall=${6:# Whether to enable Firewall blade on the layer.}
	implicit_cleanup_action=${7:drop|accept}
	mobile_access=${8:# Whether to enable Mobile Access blade on the layer.}
	shared=${9:# Whether this layer is shared.}
	tags=${10:# Collection of tag identifiers.}
	color=${11:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${12:# Comments string.}
	details_level=${13:uid|standard|full}
	ignore_warnings=${14:# Apply changes ignoring warnings.}
	ignore_errors=${15:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${16:#present|absent}
	auto_publish_session=${17:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${18:yes}
	version=${19:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_global_assignment_facts "Get global-assignment objects facts on Check Point over Web Services API" b
cp_mgmt_global_assignment_facts: >
	dependent_domain=${1:# N/A}
	global_domain=${2:# N/A}
	details_level=${3:uid|standard|full}
	limit=${4:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${5:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${6:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_group_with_exclusion "Manages group-with-exclusion objects on Check Point over Web Services API" b
cp_mgmt_group_with_exclusion: >
	name=${1:# Object name.}

	except=${2:# Name or UID of an object which the group excludes.}
	include=${3:# Name or UID of an object which the group includes.}
	tags=${4:# Collection of tag identifiers.}
	color=${5:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${6:# Comments string.}
	details_level=${7:uid|standard|full}
	groups=${8:# Collection of group identifiers.}
	ignore_warnings=${9:# Apply changes ignoring warnings.}
	ignore_errors=${10:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${11:#present|absent}
	auto_publish_session=${12:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${13:yes}
	version=${14:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_protection_override "Edit existing object using object name or uid." b
cp_mgmt_threat_protection_override: >
	name=${1:# Object name.}
	comments=${2:# Protection comments.}
	follow_up=${3:# Tag the protection with pre-defined follow-up flag.}
	overrides=${4:# Overrides per profile for this protection<br> Note, Remove override for Core protections removes only the action's override. Remove override for Threat Cloud protections removes the action, track and packet captures.}
	details_level=${5:uid|standard|full}
	wait_for_task=${6:yes}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_run_ips_update "Runs IPS database update. If package-path is not provided server will try to get the latest package from the User Center." b
cp_mgmt_run_ips_update: >
	package_path=${1:# Offline update package path.}
	wait_for_task=${2:yes}
	version=${3:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_verify_policy "Verifies the policy of the selected package." b
cp_mgmt_verify_policy: >
	policy_package=${1:# Policy package identified by the name or UID.}
	wait_for_task=${2:yes}
	version=${3:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_application_site "Manages application-site objects on Check Point over Web Services API" b
cp_mgmt_application_site: >
	name=${1:# Object name.}

	primary_category=${2:# Each application is assigned to one primary category based on its most defining aspect.}
	url_list=${3:# URLs that determine this particular application.}
	application_signature=${4:# Application signature generated by <a href="https,//supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&solutionid=sk103051">Signature Tool</a>.}
	additional_categories=${5:# Used to configure or edit the additional categories of a custom application / site used in the Application and URL Filtering or Threat Prevention.}
	description=${6:# A description for the application.}
	tags=${7:# Collection of tag identifiers.}
	urls_defined_as_regular_expression=${8:# States whether the URL is defined as a Regular Expression or not.}
	color=${9:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${10:# Comments string.}
	details_level=${11:uid|standard|full}
	groups=${12:# Collection of group identifiers.}
	ignore_warnings=${13:# Apply changes ignoring warnings.}
	ignore_errors=${14:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${15:#present|absent}
	auto_publish_session=${16:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${17:yes}
	version=${18:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_dce_rpc "Manages service-dce-rpc objects on Check Point over Web Services API" b
cp_mgmt_service_dce_rpc: >
	name=${1:# Object name.}

	interface_uuid=${2:# Network interface UUID.}
	keep_connections_open_after_policy_installation=${3:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	tags=${4:# Collection of tag identifiers.}
	color=${5:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${6:# Comments string.}
	details_level=${7:uid|standard|full}
	groups=${8:# Collection of group identifiers.}
	ignore_warnings=${9:# Apply changes ignoring warnings.}
	ignore_errors=${10:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${11:#present|absent}
	auto_publish_session=${12:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${13:yes}
	version=${14:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_global_assignment "Manages global-assignment objects on Check Point over Web Services API" b
cp_mgmt_global_assignment: >
	dependent_domain=${1:# N/A}
	global_access_policy=${2:# Global domain access policy that is assigned to a dependent domain.}
	global_domain=${3:# N/A}
	global_threat_prevention_policy=${4:# Global domain threat prevention policy that is assigned to a dependent domain.}
	manage_protection_actions=${5:# N/A}
	details_level=${6:uid|standard|full}
	ignore_warnings=${7:# Apply changes ignoring warnings.}
	ignore_errors=${8:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${9:#present|absent}
	auto_publish_session=${10:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${11:yes}
	version=${12:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_icmp6 "Manages service-icmp6 objects on Check Point over Web Services API" b
cp_mgmt_service_icmp6: >
	name=${1:# Object name.}

	icmp_code=${2:# As listed in, <a href="http,//www.iana.org/assignments/icmp-parameters" target="_blank">RFC 792</a>.}
	icmp_type=${3:# As listed in, <a href="http,//www.iana.org/assignments/icmp-parameters" target="_blank">RFC 792</a>.}
	keep_connections_open_after_policy_installation=${4:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	tags=${5:# Collection of tag identifiers.}
	color=${6:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${7:# Comments string.}
	details_level=${8:uid|standard|full}
	groups=${9:# Collection of group identifiers.}
	ignore_warnings=${10:# Apply changes ignoring warnings.}
	ignore_errors=${11:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${12:#present|absent}
	auto_publish_session=${13:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${14:yes}
	version=${15:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_vpn_community_star "Manages vpn-community-star objects on Check Point over Web Services API" b
cp_mgmt_vpn_community_star: >
	name=${1:# Object name.}

	center_gateways=${2:# Collection of Gateway objects representing center gateways identified by the name or UID.}
	encryption_method=${3:prefer ikev2 but support ikev1|ikev2 only|ikev1 for ipv4 and ikev2 for ipv6 only}
	encryption_suite=${4:suite-b-gcm-256|custom|vpn b|vpn a|suite-b-gcm-128}
	ike_phase_1=${5:# Ike Phase 1 settings. Only applicable when the encryption-suite is set to [custom].}
	ike_phase_2=${6:# Ike Phase 2 settings. Only applicable when the encryption-suite is set to [custom].}
	mesh_center_gateways=${7:# Indicates whether the meshed community is in center.}
	satellite_gateways=${8:# Collection of Gateway objects representing satellite gateways identified by the name or UID.}
	shared_secrets=${9:# Shared secrets for external gateways.}
	tags=${10:# Collection of tag identifiers.}
	use_shared_secret=${11:# Indicates whether the shared secret should be used for all external gateways.}
	color=${12:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${13:# Comments string.}
	details_level=${14:uid|standard|full}
	ignore_warnings=${15:# Apply changes ignoring warnings.}
	ignore_errors=${16:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${17:#present|absent}
	auto_publish_session=${18:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${19:yes}
	version=${20:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_wildcard_facts "Get wildcard objects facts on Check Point over Web Services API" b
cp_mgmt_wildcard_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_other_facts "Get service-other objects facts on Check Point over Web Services API" b
cp_mgmt_service_other_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_simple_gateway "Manages simple-gateway objects on Check Point over Web Services API" b
cp_mgmt_simple_gateway: >
	name=${1:# Object name.}

	ip_address=${2:# IPv4 or IPv6 address. If both addresses are required use ipv4-address and ipv6-address fields explicitly.}
	ipv4_address=${3:# IPv4 address.}
	ipv6_address=${4:# IPv6 address.}
	anti_bot=${5:# Anti-Bot blade enabled.}
	anti_virus=${6:# Anti-Virus blade enabled.}
	application_control=${7:# Application Control blade enabled.}
	content_awareness=${8:# Content Awareness blade enabled.}
	firewall=${9:# Firewall blade enabled.}
	firewall_settings=${10:# N/A}
	interfaces=${11:# Network interfaces. When a gateway is updated with a new interfaces, the existing interfaces are removed.}
	ips=${12:# Intrusion Prevention System blade enabled.}
	logs_settings=${13:# N/A}
	one_time_password=${14:# N/A}
	os_name=${15:# Gateway platform operating system.}
	save_logs_locally=${16:# Save logs locally on the gateway.}
	send_alerts_to_server=${17:# Server(s) to send alerts to.}
	send_logs_to_backup_server=${18:# Backup server(s) to send logs to.}
	send_logs_to_server=${19:# Server(s) to send logs to.}
	tags=${20:# Collection of tag identifiers.}
	threat_emulation=${21:# Threat Emulation blade enabled.}
	threat_extraction=${22:# Threat Extraction blade enabled.}
	url_filtering=${23:# URL Filtering blade enabled.}
	version=${24:# Gateway platform version.}
	vpn=${25:# VPN blade enabled.}
	vpn_settings=${26:# Gateway VPN settings.}
	color=${27:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${28:# Comments string.}
	details_level=${29:uid|standard|full}
	groups=${30:# Collection of group identifiers.}
	ignore_warnings=${31:# Apply changes ignoring warnings.}
	ignore_errors=${32:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${33:#present|absent}
	auto_publish_session=${34:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${35:yes}

endsnippet

snippet cp_mgmt_access_role_facts "Get access-role objects facts on Check Point over Web Services API" b
cp_mgmt_access_role_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_group_facts "Get group objects facts on Check Point over Web Services API" b
cp_mgmt_group_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	show_as_ranges=${2:# When true, the group's matched content is displayed as ranges of IP addresses rather than network objects.<br />Objects that are not represented using IP addresses are presented as objects.<br />The 'members' parameter is omitted from the response and instead the 'ranges' parameter is displayed.}
	details_level=${3:uid|standard|full}
	limit=${4:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${5:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${6:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	dereference_group_members=${7:# Indicates whether to dereference "members" field by details level for every object in reply.}
	show_membership=${8:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${9:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_security_zone "Manages security-zone objects on Check Point over Web Services API" b
cp_mgmt_security_zone: >
	name=${1:# Object name.}

	tags=${2:# Collection of tag identifiers.}
	color=${3:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${4:# Comments string.}
	details_level=${5:uid|standard|full}
	ignore_warnings=${6:# Apply changes ignoring warnings.}
	ignore_errors=${7:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${8:#present|absent}
	auto_publish_session=${9:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${10:yes}
	version=${11:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_security_zone_facts "Get security-zone objects facts on Check Point over Web Services API" b
cp_mgmt_security_zone_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_dns_domain "Manages dns-domain objects on Check Point over Web Services API" b
cp_mgmt_dns_domain: >
	name=${1:# Object name.}

	is_sub_domain=${2:# Whether to match sub-domains in addition to the domain itself.}
	tags=${3:# Collection of tag identifiers.}
	color=${4:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${5:# Comments string.}
	details_level=${6:uid|standard|full}
	ignore_warnings=${7:# Apply changes ignoring warnings.}
	ignore_errors=${8:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${9:#present|absent}
	auto_publish_session=${10:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${11:yes}
	version=${12:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_multicast_address_range_facts "Get multicast-address-range objects facts on Check Point over Web Services API" b
cp_mgmt_multicast_address_range_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_rule_facts "Get threat-rule objects facts on Check Point over Web Services API" b
cp_mgmt_threat_rule_facts: >
	name=${1:# Object name. Should be unique in the domain.}
	layer=${2:# Layer that the rule belongs to identified by the name or UID.}
	details_level=${3:uid|standard|full}
	filter=${4:# Search expression to filter the rulebase. The provided text should be exactly the same as it would be given in Smart Console. The logical operators in the expression ('AND', 'OR') should be provided in capital letters. If an operator is not used, the default OR operator applies.}
	filter_settings=${5:# Sets filter preferences.}
	limit=${6:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${7:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${8:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	package=${9:# Name of the package.}
	use_object_dictionary=${10:# N/A}
	dereference_group_members=${11:# Indicates whether to dereference "members" field by details level for every object in reply.}
	show_membership=${12:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${13:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_other "Manages service-other objects on Check Point over Web Services API" b
cp_mgmt_service_other: >
	name=${1:# Object name.}

	accept_replies=${2:# Specifies whether Other Service replies are to be accepted.}
	action=${3:# Contains an INSPECT expression that defines the action to take if a rule containing this service is matched. Example, set r_mhandler &open_ssl_handler sets a handler on the connection.}
	aggressive_aging=${4:# Sets short (aggressive) timeouts for idle connections.}
	ip_protocol=${5:# IP protocol number.}
	keep_connections_open_after_policy_installation=${6:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	match=${7:# Contains an INSPECT expression that defines the matching criteria. The connection is examined against the expression during the first packet. Example, tcp, dport = 21, direction = 0 matches incoming FTP control connections.}
	match_for_any=${8:# Indicates whether this service is used when 'Any' is set as the rule's service and there are several service objects with the same source port and protocol.}
	override_default_settings=${9:# Indicates whether this service is a Data Domain service which has been overridden.}
	session_timeout=${10:# Time (in seconds) before the session times out.}
	sync_connections_on_cluster=${11:# Enables state-synchronized High Availability or Load Sharing on a ClusterXL or OPSEC-certified cluster.}
	tags=${12:# Collection of tag identifiers.}
	use_default_session_timeout=${13:# Use default virtual session timeout.}
	color=${14:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${15:# Comments string.}
	details_level=${16:uid|standard|full}
	groups=${17:# Collection of group identifiers.}
	ignore_warnings=${18:# Apply changes ignoring warnings.}
	ignore_errors=${19:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${20:#present|absent}
	auto_publish_session=${21:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${22:yes}
	version=${23:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_package "Manages package objects on Check Point over Web Services API" b
cp_mgmt_package: >
	name=${1:# Object name.}

	access=${2:# True - enables, False - disables access & NAT policies, empty - nothing is changed.}
	desktop_security=${3:# True - enables, False - disables Desktop security policy, empty - nothing is changed.}
	installation_targets=${4:# Which Gateways identified by the name or UID to install the policy on.}
	qos=${5:# True - enables, False - disables QoS policy, empty - nothing is changed.}
	qos_policy_type=${6:recommended|express}
	tags=${7:# Collection of tag identifiers.}
	threat_prevention=${8:# True - enables, False - disables Threat policy, empty - nothing is changed.}
	vpn_traditional_mode=${9:# True - enables, False - disables VPN traditional mode, empty - nothing is changed.}
	color=${10:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${11:# Comments string.}
	details_level=${12:uid|standard|full}
	ignore_warnings=${13:# Apply changes ignoring warnings.}
	ignore_errors=${14:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	access_layers=${15:# Access policy layers.}
	threat_layers=${16:# Threat policy layers.}
	state=${17:#present|absent}
	auto_publish_session=${18:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${19:yes}
	version=${20:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_rule "Manages threat-rule objects on Check Point over Web Services API" b
cp_mgmt_threat_rule: >
	name=${1:# Object name.}

	position=${2:# Position in the rulebase.}
	layer=${3:# Layer that the rule belongs to identified by the name or UID.}
	action=${4:# Action-the enforced profile.}
	destination=${5:# Collection of Network objects identified by the name or UID.}
	destination_negate=${6:# True if negate is set for destination.}
	enabled=${7:# Enable/Disable the rule.}
	install_on=${8:# Which Gateways identified by the name or UID to install the policy on.}
	protected_scope=${9:# Collection of objects defining Protected Scope identified by the name or UID.}
	protected_scope_negate=${10:# True if negate is set for Protected Scope.}
	service=${11:# Collection of Network objects identified by the name or UID.}
	service_negate=${12:# True if negate is set for Service.}
	source=${13:# Collection of Network objects identified by the name or UID.}
	source_negate=${14:# True if negate is set for source.}
	track=${15:# Packet tracking.}
	track_settings=${16:# Threat rule track settings.}
	comments=${17:# Comments string.}
	details_level=${18:uid|standard|full}
	ignore_warnings=${19:# Apply changes ignoring warnings.}
	ignore_errors=${20:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${21:#present|absent}
	auto_publish_session=${22:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${23:yes}
	version=${24:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_tag_facts "Get tag objects facts on Check Point over Web Services API" b
cp_mgmt_tag_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_rpc_facts "Get service-rpc objects facts on Check Point over Web Services API" b
cp_mgmt_service_rpc_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_group_with_exclusion_facts "Get group-with-exclusion objects facts on Check Point over Web Services API" b
cp_mgmt_group_with_exclusion_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	show_as_ranges=${2:# When true, the group with exclusion's matched content is displayed as ranges of IP addresses rather than network objects.<br />Objects that are not represented using IP addresses are presented as objects.<br />The 'include' and 'except' parameters are omitted from the response and instead the 'ranges' parameter is displayed.}
	details_level=${3:uid|standard|full}
	limit=${4:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${5:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${6:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_dynamic_object_facts "Get dynamic-object objects facts on Check Point over Web Services API" b
cp_mgmt_dynamic_object_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_layer_facts "Get threat-layer objects facts on Check Point over Web Services API" b
cp_mgmt_threat_layer_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_threat_exception "Manages threat-exception objects on Check Point over Web Services API" b
cp_mgmt_threat_exception: >
	name=${1:# The name of the exception.}

	position=${2:# Position in the rulebase.}
	exception_group_uid=${3:# The UID of the exception-group.}
	exception_group_name=${4:# The name of the exception-group.}
	layer=${5:# Layer that the rule belongs to identified by the name or UID.}
	rule_name=${6:# The name of the parent rule.}
	action=${7:# Action-the enforced profile.}
	destination=${8:# Collection of Network objects identified by the name or UID.}
	destination_negate=${9:# True if negate is set for destination.}
	enabled=${10:# Enable/Disable the rule.}
	install_on=${11:# Which Gateways identified by the name or UID to install the policy on.}
	protected_scope=${12:# Collection of objects defining Protected Scope identified by the name or UID.}
	protected_scope_negate=${13:# True if negate is set for Protected Scope.}
	protection_or_site=${14:# Name of the protection or site.}
	service=${15:# Collection of Network objects identified by the name or UID.}
	service_negate=${16:# True if negate is set for Service.}
	source=${17:# Collection of Network objects identified by the name or UID.}
	source_negate=${18:# True if negate is set for source.}
	track=${19:# Packet tracking.}
	comments=${20:# Comments string.}
	details_level=${21:uid|standard|full}
	ignore_warnings=${22:# Apply changes ignoring warnings.}
	ignore_errors=${23:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${24:#present|absent}
	auto_publish_session=${25:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${26:yes}
	version=${27:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_access_rule "Manages access-rule objects on Check Point over Web Services API" b
cp_mgmt_access_rule: >
	name=${1:# Object name.}

	layer=${2:# Layer that the rule belongs to identified by the name or UID.}
	position=${3:# Position in the rulebase.}
	action=${4:# a "Accept", "Drop", "Ask", "Inform", "Reject", "User Auth", "Client Auth", "Apply Layer".}
	action_settings=${5:# Action settings.}
	content=${6:# List of processed file types that this rule applies on.}
	content_direction=${7:any|up|down}
	content_negate=${8:# True if negate is set for data.}
	custom_fields=${9:# Custom fields.}
	destination=${10:# Collection of Network objects identified by the name or UID.}
	destination_negate=${11:# True if negate is set for destination.}
	enabled=${12:# Enable/Disable the rule.}
	inline_layer=${13:# Inline Layer identified by the name or UID. Relevant only if "Action" was set to "Apply Layer".}
	install_on=${14:# Which Gateways identified by the name or UID to install the policy on.}
	service=${15:# Collection of Network objects identified by the name or UID.}
	service_negate=${16:# True if negate is set for service.}
	source=${17:# Collection of Network objects identified by the name or UID.}
	source_negate=${18:# True if negate is set for source.}
	time=${19:# List of time objects. For example, "Weekend", "Off-Work", "Every-Day".}
	track=${20:# Track Settings.}
	user_check=${21:# User check settings.}
	vpn=${22:# Communities or Directional.}
	comments=${23:# Comments string.}
	details_level=${24:uid|standard|full}
	ignore_warnings=${25:# Apply changes ignoring warnings.}
	ignore_errors=${26:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${27:#present|absent}
	auto_publish_session=${28:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${29:yes}
	version=${30:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_put_file "put file on Check Point over Web Services API" b
cp_mgmt_put_file: >
	targets=${1:# On what targets to execute this command. Targets may be identified by their name, or object unique identifier.}
	file_content=${2:# N/A}
	file_name=${3:# N/A}
	file_path=${4:# N/A}
	comments=${5:# Comments string.}
	wait_for_task=${6:yes}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_service_icmp "Manages service-icmp objects on Check Point over Web Services API" b
cp_mgmt_service_icmp: >
	name=${1:# Object name.}

	icmp_code=${2:# As listed in, <a href="http,//www.iana.org/assignments/icmp-parameters" target="_blank">RFC 792</a>.}
	icmp_type=${3:# As listed in, <a href="http,//www.iana.org/assignments/icmp-parameters" target="_blank">RFC 792</a>.}
	keep_connections_open_after_policy_installation=${4:# Keep connections open after policy has been installed even if they are not allowed under the new policy. This overrides the settings in the Connection Persistence page. If you change this property, the change will not affect open connections, but only future connections.}
	tags=${5:# Collection of tag identifiers.}
	color=${6:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${7:# Comments string.}
	details_level=${8:uid|standard|full}
	groups=${9:# Collection of group identifiers.}
	ignore_warnings=${10:# Apply changes ignoring warnings.}
	ignore_errors=${11:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${12:#present|absent}
	auto_publish_session=${13:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${14:yes}
	version=${15:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_session_facts "Get session objects facts on Check Point over Web Services API" b
cp_mgmt_session_facts: >
	limit=${1:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${2:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${3:# Sorts results by the given field. By default the results are sorted in the descending order by the session publish time. This parameter is relevant only for getting few objects.}
	view_published_sessions=${4:# Show a list of published sessions.}
	details_level=${5:uid|standard|full}
	version=${6:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_exception_group "Manages exception-group objects on Check Point over Web Services API" b
cp_mgmt_exception_group: >
	name=${1:# Object name.}

	applied_profile=${2:# The threat profile to apply this group to in the case of apply-on threat-rules-with-specific-profile.}
	applied_threat_rules=${3:# The threat rules to apply this group on in the case of apply-on manually-select-threat-rules.}
	apply_on=${4:all-threat-rules|all-threat-rules-with-specific-profile|manually-select-threat-rules}
	tags=${5:# Collection of tag identifiers.}
	color=${6:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${7:# Comments string.}
	details_level=${8:uid|standard|full}
	ignore_warnings=${9:# Apply changes ignoring warnings.}
	ignore_errors=${10:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${11:#present|absent}
	auto_publish_session=${12:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${13:yes}
	version=${14:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_dynamic_object "Manages dynamic-object objects on Check Point over Web Services API" b
cp_mgmt_dynamic_object: >
	name=${1:# Object name.}

	tags=${2:# Collection of tag identifiers.}
	color=${3:aquamarine|black|blue|crete blue|burlywood|cyan|dark green|khaki|orchid|dark orange|dark sea green|pink|turquoise|dark blue|firebrick|brown|forest green|gold|dark gold|gray|dark gray|light green|lemon chiffon|coral|sea green|sky blue|magenta|purple|slate blue|violet red|navy blue|olive|orange|red|sienna|yellow}
	comments=${4:# Comments string.}
	details_level=${5:uid|standard|full}
	ignore_warnings=${6:# Apply changes ignoring warnings.}
	ignore_errors=${7:# Apply changes ignoring errors. You won't be able to publish such a changes. If ignore-warnings flag was omitted - warnings will also be ignored.}
	state=${8:#present|absent}
	auto_publish_session=${9:# Publish the current session if changes have been performed after task completes.}
	wait_for_task=${10:yes}
	version=${11:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet checkpoint_host_facts "Get host objects facts on Check Point over Web Services API" b
checkpoint_host_facts: >
	name=${1:# Name of the host object. If name is not provided, UID is required.}
	uid=${2:# UID of the host object. If UID is not provided, name is required.}

endsnippet

snippet cp_mgmt_service_icmp6_facts "Get service-icmp6 objects facts on Check Point over Web Services API" b
cp_mgmt_service_icmp6_facts: >
	name=${1:# Object name. This parameter is relevant only for getting a specific object.}
	details_level=${2:uid|standard|full}
	limit=${3:# No more than that many results will be returned. This parameter is relevant only for getting few objects.}
	offset=${4:# Skip that many results before beginning to return them. This parameter is relevant only for getting few objects.}
	order=${5:# Sorts results by the given field. By default the results are sorted in the ascending order by name. This parameter is relevant only for getting few objects.}
	show_membership=${6:# Indicates whether to calculate and show "groups" field for every object in reply.}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet cp_mgmt_run_script "Executes the script on a given list of targets." b
cp_mgmt_run_script: >
	script_name=${1:# Script name.}
	script=${2:# Script body.}
	targets=${3:# On what targets to execute this command. Targets may be identified by their name, or object unique identifier.}
	args=${4:# Script arguments.}
	comments=${5:# Comments string.}
	wait_for_task=${6:yes}
	version=${7:# Version of checkpoint. If not given one, the latest version taken.}

endsnippet

snippet edgeswitch_facts "Collect facts from remote devices running Edgeswitch" b
edgeswitch_facts: >
	gather_subset=${1:!config}

endsnippet

snippet edgeswitch_vlan "Manage VLANs on Ubiquiti Edgeswitch network devices" b
edgeswitch_vlan: >
	name=${1:# Name of the VLAN.}
	vlan_id=${2:# ID of the VLAN. Range 1-4093.}
	tagged_interfaces=${3:# List of interfaces that should accept and transmit tagged frames for the VLAN. Accept range of interfaces.}
	untagged_interfaces=${4:# List of interfaces that should accept untagged frames and transmit them tagged for the VLAN. Accept range of interfaces.}
	excluded_interfaces=${5:# List of interfaces that should be excluded of the VLAN. Accept range of interfaces.}
	auto_tag=${6:# Each of the switch interfaces will be set to accept and transmit untagged frames for I(vlan_id) unless defined in I(*_interfaces). This is a default setting for all switch interfaces.}
	auto_untag=${7:# Each of the switch interfaces will be set to accept untagged frames and transmit them tagged for I(vlan_id) unless defined in I(*_interfaces). This is a default setting for all switch interfaces.}
	auto_exclude=${8:# Each of the switch interfaces will be excluded from I(vlan_id) unless defined in I(*_interfaces). This is a default setting for all switch interfaces.}
	aggregate=${9:# L}
	purge=${10:no}
	state=${11:#present|absent}

endsnippet

snippet voss_config "Manage Extreme VOSS configuration sections" b
voss_config: >
	lines=${1:# The ordered set of commands that should be configured in the section. The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The parent line that uniquely identifies the section the commands should be checked against. If this argument is omitted, the commands are checked against the set of top level or global commands. Note that VOSS configurations only support one level of nested commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made. This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	backup=${8:no}
	running_config=${9:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source. There are times when it is not desirable to have the task get the current running-config for every task in a playbook. The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	defaults=${10:no}
	save_when=${11:always|#never|modified|changed}
	diff_against=${12:running|startup|intended}
	diff_ignore_lines=${13:# Use this argument to specify one or more lines that should be ignored during the diff. This is used for lines in the configuration that are automatically updated by the system. This argument takes a list of regular expressions or exact line matches.}
	intended_config=${14:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against. This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against. When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${15:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}

endsnippet

snippet voss_facts "Collect facts from remote devices running Extreme VOSS" b
voss_facts: >
	gather_subset=${1:!config}

endsnippet

snippet voss_command "Run commands on remote devices running Extreme VOSS" b
voss_command: >
	commands=${1:# List of commands to send to the remote VOSS device. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired. If a command sent to the device requires answering a prompt, it is possible to pass a dict containing I(command), I(answer) and I(prompt). Common answers are 'y' or "\r" (carriage return, must be double quotes). See examples.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}

endsnippet

snippet pn_dscp_map_pri_map "CLI command to modify dscp-map-pri-map" b
pn_dscp_map_pri_map: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_pri=${3:# CoS priority.}
	pn_name=${4:# Name for the DSCP map.}
	pn_dsmap=${5:# DSCP value(s).}

endsnippet

snippet pn_ipv6security_raguard_port "CLI command to add/remove ipv6security-raguard-port" b
pn_ipv6security_raguard_port: >
	pn_name=${1:# RA Guard Policy Name.}
	pn_ports=${2:# Ports attached to RA Guard Policy.}

	pn_cliswitch=${3:# Target switch to run the CLI on.}
	state=${4:#present|absent}

endsnippet

snippet pn_admin_session_timeout "CLI command to modify admin-session-timeout" b
pn_admin_session_timeout: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_timeout=${3:# Maximum time to wait for user activity before terminating login session. Minimum should be 60s.}

endsnippet

snippet pn_admin_syslog "CLI command to create/modify/delete admin-syslog" b
pn_admin_syslog: >
	state=${1:present|absent|update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_scope=${3:local|fabric}
	pn_host=${4:# Hostname to log system events.}
	pn_port=${5:# Host port.}
	pn_transport=${6:tcp-tls|#udp}
	pn_message_format=${7:structured|legacy}
	pn_name=${8:# name of the system log.}

endsnippet

snippet pn_vrouter_ospf "CLI command to add/remove vrouter-ospf" b
pn_vrouter_ospf: >
	pn_network=${1:# OSPF network IP address.}
	pn_vrouter_name=${2:# name of service config.}

	pn_cliswitch=${3:# Target switch to run the CLI on.}
	state=${4:#present|absent}
	pn_netmask=${5:# OSPF network IP address netmask.}
	pn_ospf_area=${6:# stub area number for the configuration.}

endsnippet

snippet pn_log_audit_exception "CLI command to create/delete an audit exception" b
pn_log_audit_exception: >
	pn_access=${1:any|read-only|read-write}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_audit_type=${3:cli|shell|vtysh}
	state=${4:#present|absent}
	pn_pattern=${5:# Specify a regular expression to match exceptions.}
	pn_scope=${6:local|fabric}

endsnippet

snippet pn_snmp_vacm "CLI command to create/modify/delete snmp-vacm" b
pn_snmp_vacm: >
	state=${1:present|absent|update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_oid_restrict=${3:# restrict OID.}
	pn_priv=${4:# privileges.}
	pn_auth=${5:# authentication required.}
	pn_user_type=${6:rouser|rwuser}
	pn_user_name=${7:# SNMP administrator name.}

endsnippet

snippet pn_vrouter_interface_ip "CLI command to add/remove vrouter-interface-ip" b
pn_vrouter_interface_ip: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_bd=${3:# interface Bridge Domain.}
	pn_netmask=${4:# netmask.}
	pn_vnet=${5:# interface VLAN VNET.}
	pn_ip=${6:# IP address.}
	pn_nic=${7:# virtual NIC assigned to interface.}
	pn_vrouter_name=${8:# name of service config.}

endsnippet

snippet pn_vtep "CLI command to create/delete vtep" b
pn_vtep: >
	pn_cliswitch=${1:# Target switch to run the CLI on.}
	state=${2:#present|absent}
	pn_name=${3:# vtep name.}
	pn_ip=${4:# Primary IP address.}
	pn_vrouter_name=${5:# name of the vrouter service.}
	pn_virtual_ip=${6:# Virtual/Secondary IP address.}
	pn_location=${7:# switch name.}
	pn_switch_in_cluster=${8:yes}

endsnippet

snippet pn_connection_stats_settings "CLI command to modify connection-stats-settings" b
pn_connection_stats_settings: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_enable=${3:# Enable or disable collecting connections statistics.}
	pn_connection_backup_enable=${4:# Enable backup for connection statistics collection.}
	pn_client_server_stats_max_memory=${5:# maximum memory for client server statistics.}
	pn_connection_stats_log_disk_space=${6:# disk-space allocated for statistics (including rotated log files).}
	pn_client_server_stats_log_enable=${7:# Enable or disable statistics.}
	pn_service_stat_max_memory=${8:# maximum memory allowed for service statistics.}
	pn_connection_stats_log_interval=${9:# interval to collect statistics.}
	pn_fabric_connection_backup_interval=${10:# backup interval for fabric connection statistics collection.}
	pn_connection_backup_interval=${11:# backup interval for connection statistics collection.}
	pn_connection_stats_log_enable=${12:# enable or disable statistics.}
	pn_fabric_connection_max_memory=${13:# maximum memory allowed for fabric connection statistics.}
	pn_fabric_connection_backup_enable=${14:# enable backup for fabric connection statistics collection.}
	pn_client_server_stats_log_disk_space=${15:# disk-space allocated for statistics (including rotated log files).}
	pn_connection_max_memory=${16:# maximum memory allowed for connection statistics.}
	pn_connection_stats_max_memory=${17:# maximum memory allowed for connection statistics.}
	pn_client_server_stats_log_interval=${18:# interval to collect statistics.}

endsnippet

snippet pn_ipv6security_raguard_vlan "CLI command to add/remove ipv6security-raguard-vlan" b
pn_ipv6security_raguard_vlan: >
	pn_vlans=${1:# Vlans attached to RA Guard Policy.}
	pn_name=${2:# RA Guard Policy Name.}

	pn_cliswitch=${3:# Target switch to run the CLI on.}
	state=${4:#present|absent}

endsnippet

snippet pn_vrouter_loopback_interface "CLI command to add/remove vrouter-loopback-interface" b
pn_vrouter_loopback_interface: >
	pn_ip=${1:# loopback IP address.}
	pn_vrouter_name=${2:# name of service config.}

	pn_cliswitch=${3:# Target switch to run the CLI on.}
	state=${4:#present|absent}
	pn_index=${5:# loopback index from 1 to 255.}

endsnippet

snippet pn_vrouter_packet_relay "CLI command to add/remove vrouter-packet-relay" b
pn_vrouter_packet_relay: >
	pn_forward_ip=${1:# forwarding IP address.}
	pn_nic=${2:# NIC.}
	pn_vrouter_name=${3:# name of service config.}

	pn_cliswitch=${4:# Target switch to run the CLI on.}
	state=${5:#present|absent}
	pn_forward_proto=${6:#dhcp}

endsnippet

snippet pn_port_cos_rate_setting "CLI command to modify port-cos-rate-setting" b
pn_port_cos_rate_setting: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_cos0_rate=${3:# cos0 rate limit (pps) unlimited or 0 to 10000000.}
	pn_cos1_rate=${4:# cos1 rate limit (pps) unlimited or 0 to 10000000.}
	pn_cos2_rate=${5:# cos2 rate limit (pps) unlimited or 0 to 10000000.}
	pn_cos3_rate=${6:# cos3 rate limit (pps) unlimited or 0 to 10000000.}
	pn_cos4_rate=${7:# cos4 rate limit (pps) unlimited or 0 to 10000000.}
	pn_cos5_rate=${8:# cos5 rate limit (pps) unlimited or 0 to 10000000.}
	pn_cos6_rate=${9:# cos6 rate limit (pps) unlimited or 0 to 10000000.}
	pn_cos7_rate=${10:# cos7 rate limit (pps) unlimited or 0 to 10000000.}
	pn_port=${11:control-port|data-port|span-ports}

endsnippet

snippet pn_prefix_list "CLI command to create/delete prefix-list" b
pn_prefix_list: >
	pn_name=${1:# Prefix List Name.}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	state=${3:#present|absent}
	pn_scope=${4:local|fabric}

endsnippet

snippet pn_cpu_class "CLI command to create/modify/delete cpu-class" b
pn_cpu_class: >
	state=${1:present|absent|update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_scope=${3:local|fabric}
	pn_hog_protect=${4:disable|enable|enable-and-drop}
	pn_rate_limit=${5:# rate-limit for CPU class.}
	pn_name=${6:# name for the CPU class.}

endsnippet

snippet pn_snmp_community "CLI command to create/modify/delete snmp-community" b
pn_snmp_community: >
	state=${1:present|absent|update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_community_type=${3:read-only|read-write}
	pn_community_string=${4:# community name.}

endsnippet

snippet pn_dscp_map "CLI command to create/delete dscp-map" b
pn_dscp_map: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_name=${3:# Name for the DSCP map.}
	pn_scope=${4:local|fabric}

endsnippet

snippet pn_vrouter_pim_config "CLI command to modify vrouter-pim-config" b
pn_vrouter_pim_config: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_query_interval=${3:# igmp query interval in seconds.}
	pn_querier_timeout=${4:# igmp querier timeout in seconds.}
	pn_hello_interval=${5:# hello interval in seconds.}
	pn_vrouter_name=${6:# name of service config.}

endsnippet

snippet pn_port_config "CLI command to modify port-config" b
pn_port_config: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_intf=${3:# physical interface.}
	pn_crc_check_enable=${4:# CRC check on ingress and rewrite on egress.}
	pn_dscp_map=${5:# DSCP map name to enable on port.}
	pn_autoneg=${6:# physical port autonegotiation.}
	pn_speed=${7:disable|10m|100m|1g|2.5g|10g|25g|40g|50g|100g}
	pn_port=${8:# physical port.}
	pn_vxlan_termination=${9:# physical port vxlan termination setting.}
	pn_pause=${10:# physical port pause.}
	pn_loopback=${11:# physical port loopback.}
	pn_loop_vlans=${12:# looping vlans.}
	pn_routing=${13:# routing.}
	pn_edge_switch=${14:# physical port edge switch.}
	pn_enable=${15:# physical port enable.}
	pn_description=${16:# physical port description.}
	pn_host_enable=${17:# Host facing port control setting.}
	pn_allowed_tpid=${18:vlan|q-in-q|q-in-q-old}
	pn_mirror_only=${19:# physical port mirror only.}
	pn_reflect=${20:# physical port reflection.}
	pn_jumbo=${21:# jumbo frames on physical port.}
	pn_egress_rate_limit=${22:# max egress port data rate limit.}
	pn_eth_mode=${23:1000base-x|sgmii|disabled|GMII}
	pn_fabric_guard=${24:# Fabric guard configuration.}
	pn_local_switching=${25:# no-local-switching port cannot bridge traffic to another no-local-switching port.}
	pn_lacp_priority=${26:# LACP priority from 1 to 65535.}
	pn_send_port=${27:# send port.}
	pn_port_mac_address=${28:# physical port MAC Address.}
	pn_defer_bringup=${29:# defer port bringup.}

endsnippet

snippet pn_stp "CLI command to modify stp" b
pn_stp: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_hello_time=${3:2}
	pn_enable=${4:# enable or disable STP}
	pn_root_guard_wait_time=${5:20}
	pn_bpdus_bridge_ports=${6:# BPDU packets to bridge specific port.}
	pn_mst_max_hops=${7:20}
	pn_bridge_id=${8:# STP bridge id.}
	pn_max_age=${9:20}
	pn_stp_mode=${10:rstp|mstp}
	pn_mst_config_name=${11:# Name for MST Configuration Instance.}
	pn_forwarding_delay=${12:15}
	pn_bridge_priority=${13:32768}

endsnippet

snippet pn_igmp_snooping "CLI command to modify igmp-snooping" b
pn_igmp_snooping: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_enable=${3:# enable or disable IGMP snooping.}
	pn_query_interval=${4:# IGMP query interval in seconds.}
	pn_igmpv2_vlans=${5:# VLANs on which to use IGMPv2 protocol.}
	pn_igmpv3_vlans=${6:# VLANs on which to use IGMPv3 protocol.}
	pn_enable_vlans=${7:# enable per VLAN IGMP snooping.}
	pn_vxlan=${8:# enable or disable IGMP snooping on vxlans.}
	pn_query_max_response_time=${9:# maximum response time, in seconds, advertised in IGMP queries.}
	pn_scope=${10:local|fabric}
	pn_no_snoop_linklocal_vlans=${11:# Remove snooping of link-local groups(224.0.0.0/24) on these vlans.}
	pn_snoop_linklocal_vlans=${12:# Allow snooping of link-local groups(224.0.0.0/24) on these vlans.}

endsnippet

snippet pn_switch_setup "CLI command to modify switch-setup" b
pn_switch_setup: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_force=${3:# Force analytics-store change even if it involves removing data.}
	pn_dns_ip=${4:# DNS IP address.}
	pn_mgmt_netmask=${5:# Netmask.}
	pn_gateway_ip6=${6:# Gateway IPv6 address.}
	pn_in_band_ip6_assign=${7:none|autoconf}
	pn_domain_name=${8:# Domain name.}
	pn_timezone=${9:# Timezone to be configured.}
	pn_in_band_netmask=${10:# Data in-band netmask.}
	pn_in_band_ip6=${11:# Data in-band IPv6 address.}
	pn_in_band_netmask_ip6=${12:# Data in-band IPv6 netmask.}
	pn_motd=${13:# Message of the Day.}
	pn_loopback_ip6=${14:# loopback IPv6 address.}
	pn_mgmt_ip6_assignment=${15:none|autoconf}
	pn_ntp_secondary_server=${16:# Secondary NTP server.}
	pn_in_band_ip=${17:# data in-band IP address.}
	pn_eula_accepted=${18:true|false}
	pn_mgmt_ip=${19:# Management IP address.}
	pn_ntp_server=${20:# NTP server.}
	pn_mgmt_ip_assignment=${21:none|dhcp}
	pn_date=${22:# Date.}
	pn_password=${23:# plain text password.}
	pn_banner=${24:# Banner to display on server-switch.}
	pn_loopback_ip=${25:# loopback IPv4 address.}
	pn_dns_secondary_ip=${26:# secondary DNS IP address.}
	pn_switch_name=${27:# switch name.}
	pn_eula_timestamp=${28:# EULA timestamp.}
	pn_mgmt_netmask_ip6=${29:# IPv6 netmask.}
	pn_enable_host_ports=${30:# Enable host ports by default.}
	pn_mgmt_ip6=${31:# IPv6 address.}
	pn_analytics_store=${32:default|optimized}
	pn_gateway_ip=${33:# gateway IPv4 address.}

endsnippet

snippet pn_fabric_local "CLI command to modify fabric-local" b
pn_fabric_local: >
	pn_cliswitch=${1:# Target switch to run the CLI on.}

	state=${2:#update}
	pn_fabric_network=${3:in-band|#mgmt|vmgmt}
	pn_vlan=${4:# VLAN assigned to fabric.}
	pn_control_network=${5:in-band|mgmt|vmgmt}
	pn_fabric_advertisement_network=${6:inband-mgmt|inband-only|inband-vmgmt|mgmt-only}

endsnippet

snippet pn_access_list "CLI command to create/delete access-list" b
pn_access_list: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_name=${3:# Access List Name.}
	pn_scope=${4:local|fabric}

endsnippet

snippet pn_dhcp_filter "CLI command to create/modify/delete dhcp-filter" b
pn_dhcp_filter: >
	state=${1:present|absent|update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_trusted_ports=${3:# trusted ports of dhcp config.}
	pn_name=${4:# name of the DHCP filter.}

endsnippet

snippet pn_vrouter_ospf6 "CLI command to add/remove vrouter-ospf6" b
pn_vrouter_ospf6: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_ospf6_area=${3:# area id for this interface in IPv4 address format.}
	pn_nic=${4:# OSPF6 control for this interface.}
	pn_vrouter_name=${5:# name of service config.}

endsnippet

snippet pn_stp_port "CLI command to modify stp-port." b
pn_stp_port: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_priority=${3:128}
	pn_cost=${4:2000}
	pn_root_guard=${5:# STP port Root guard.}
	pn_filter=${6:# STP port filters BPDUs.}
	pn_edge=${7:# STP port is an edge port.}
	pn_bpdu_guard=${8:# STP port BPDU guard.}
	pn_port=${9:# STP port.}
	pn_block=${10:# Specify if a STP port blocks BPDUs.}

endsnippet

snippet pn_cpu_mgmt_class "CLI command to modify cpu-mgmt-class" b
pn_cpu_mgmt_class: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_burst_size=${3:# ingress traffic burst size (bytes) or default.}
	pn_name=${4:arp|icmp|ssh|snmp|fabric|bcast|nfs|web|web-ssl|net-api}
	pn_rate_limit=${5:# ingress rate limit on mgmt port(bps) or unlimited.}

endsnippet

snippet pn_ipv6security_raguard "CLI command to create/modify/delete ipv6security-raguard" b
pn_ipv6security_raguard: >
	pn_name=${1:# RA Guard Policy Name.}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	state=${3:#present|update|absent}
	pn_device=${4:host|router}
	pn_access_list=${5:# RA Guard Access List of Source IPs.}
	pn_prefix_list=${6:# RA Guard Prefix List.}
	pn_router_priority=${7:low|medium|high}

endsnippet

snippet pn_vflow_table_profile "CLI command to modify vflow-table-profile" b
pn_vflow_table_profile: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_profile=${3:application|ipv6|qos}
	pn_hw_tbl=${4:switch-main|switch-hash|npu-main|npu-hash}
	pn_enable=${5:# enable or disable vflow profile table.}

endsnippet

snippet pn_vrouter_bgp_network "CLI command to add/remove vrouter-bgp-network" b
pn_vrouter_bgp_network: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_netmask=${3:# BGP network mask.}
	pn_network=${4:# IP address for BGP network.}
	pn_vrouter_name=${5:# name of service config.}

endsnippet

snippet pn_admin_service "CLI command to modify admin-service" b
pn_admin_service: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_web=${3:# Web (HTTP) to enable or disable.}
	pn_web_ssl=${4:# Web SSL (HTTPS) to enable or disable.}
	pn_snmp=${5:# Simple Network Monitoring Protocol (SNMP) to enable or disable.}
	pn_web_port=${6:# Web (HTTP) port to enable or disable.}
	pn_web_ssl_port=${7:# Web SSL (HTTPS) port to enable or disable.}
	pn_nfs=${8:# Network File System (NFS) to enable or disable.}
	pn_ssh=${9:# Secure Shell to enable or disable.}
	pn_web_log=${10:# Web logging to enable or disable.}
	pn__if=${11:mgmt|data}
	pn_icmp=${12:# Internet Message Control Protocol (ICMP) to enable or disable.}
	pn_net_api=${13:# Netvisor API to enable or disable APIs.}

endsnippet

snippet pn_role "CLI command to create/delete/modify role" b
pn_role: >
	state=${1:present|absent|update}
	pn_name=${2:# role name.}

	pn_cliswitch=${3:# Target switch to run the CLI on.}
	pn_scope=${4:local|fabric}
	pn_access=${5:read-only|read-write}
	pn_shell=${6:# allow shell command.}
	pn_sudo=${7:# allow sudo from shell.}
	pn_running_config=${8:# display running configuration of switch.}
	pn_delete_from_users=${9:# delete from users.}

endsnippet

snippet pn_prefix_list_network "CLI command to add/remove prefix-list-network" b
pn_prefix_list_network: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_netmask=${3:# netmask of the network associated the prefix list.}
	pn_name=${4:# Prefix List Name.}
	pn_network=${5:# network associated with the prefix list.}

endsnippet

snippet pn_snmp_trap_sink "CLI command to create/delete snmp-trap-sink" b
pn_snmp_trap_sink: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_dest_host=${3:# destination host.}
	pn_community=${4:# community type.}
	pn_dest_port=${5:162}
	pn_type=${6:TRAP_TYPE_V1_TRAP|#TRAP_TYPE_V2C_TRAP|TRAP_TYPE_V2_INFORM}

endsnippet

snippet pn_port_cos_bw "CLI command to modify port-cos-bw" b
pn_port_cos_bw: >
	state=${1:update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_max_bw_limit=${3:# Maximum b/w in percentage.}
	pn_cos=${4:# CoS priority.}
	pn_port=${5:# physical port number.}
	pn_weight=${6:priority|no-priority}
	pn_min_bw_guarantee=${7:# Minimum b/w in percentage.}

endsnippet

snippet pn_vrouter_bgp "CLI command to add/modify/remove vrouter-bgp" b
pn_vrouter_bgp: >
	pn_neighbor=${1:# IP address for BGP neighbor.}
	pn_vrouter_name=${2:# name of service config.}

	pn_cliswitch=${3:# Target switch to run the CLI on.}
	state=${4:#present|absent|update}
	pn_send_community=${5:# send any community attribute to neighbor.}
	pn_weight=${6:# default weight value between 0 and 65535 for the neighbor's routes.}
	pn_multi_protocol=${7:ipv4-unicast|ipv6-unicast}
	pn_prefix_list_in=${8:# prefixes used for filtering.}
	pn_route_reflector_client=${9:# set as route reflector client.}
	pn_default_originate=${10:# announce default routes to the neighbor or not.}
	pn_neighbor_holdtime=${11:# BGP Holdtime (seconds).}
	pn_connect_retry_interval=${12:# BGP Connect retry interval (seconds).}
	pn_advertisement_interval=${13:# Minimum interval between sending BGP routing updates.}
	pn_route_map_out=${14:# route map out for nbr.}
	pn_update_source=${15:# IP address of BGP packets required for peering over loopback interface.}
	pn_bfd=${16:no}
	pn_next_hop_self=${17:# BGP next hop is self or not.}
	pn_allowas_in=${18:# Allow/reject routes with local AS in AS_PATH.}
	pn_neighbor_keepalive_interval=${19:# BGP Keepalive interval (seconds).}
	pn_max_prefix=${20:# maximum number of prefixes.}
	pn_bfd_multihop=${21:# always use BFD multi-hop port for fault detection.}
	pn_interface=${22:# Interface to reach the neighbor.}
	pn_password=${23:# password for MD5 BGP.}
	pn_route_map_in=${24:# route map in for nbr.}
	pn_soft_reconfig_inbound=${25:# soft reset to reconfigure inbound traffic.}
	pn_override_capability=${26:# override capability.}
	pn_max_prefix_warn_only=${27:# warn if the maximum number of prefixes is exceeded.}
	pn_ebgp_multihop=${28:# value for external BGP from 1 to 255.}
	pn_remote_as=${29:# BGP remote AS from 1 to 4294967295.}
	pn_prefix_list_out=${30:# prefixes used for filtering outgoing packets.}
	pn_no_route_map_out=${31:# Remove egress route-map from BGP neighbor.}
	pn_no_route_map_in=${32:# Remove ingress route-map from BGP neighbor.}

endsnippet

snippet pn_user "CLI command to create/modify/delete user" b
pn_user: >
	state=${1:present|absent|update}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_scope=${3:local|fabric}
	pn_initial_role=${4:# initial role for user.}
	pn_password=${5:# plain text password.}
	pn_name=${6:# username.}

endsnippet

snippet pn_access_list_ip "CLI command to add/remove access-list-ip" b
pn_access_list_ip: >
	state=${1:present|absent}

	pn_cliswitch=${2:# Target switch to run the CLI on.}
	pn_ip=${3:::}
	pn_name=${4:# Access List Name.}

endsnippet

snippet dellos9_command "Run commands on remote devices running Dell OS9" b
dellos9_command: >
	commands=${1:# List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
	match=${3:#all|any}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet dellos9_config "Manage Dell EMC Networking OS9 configuration sections" b
dellos9_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	update=${8:#merge|check}
	save=${9:no}
	config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	backup=${11:no}
	backup_options=${12:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet dellos9_facts "Collect facts from remote devices running Dell EMC Networking OS9" b
dellos9_facts: >
	gather_subset=${1:['!config']}
	provider=${2:# A dict object containing connection details.}

endsnippet

snippet eos_lldp_interfaces "Manage Link Layer Discovery Protocol (LLDP) attributes of interfaces on Arista EOS devices." b
eos_lldp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet eos_lacp "Manage Global Link Aggregation Control Protocol (LACP) on Arista EOS devices." b
eos_lacp: >
	config=${1:# L}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet eos_lldp "Manage LLDP configuration on Arista EOS network devices" b
eos_lldp: >
	state=${1:#present|absent}
	authorize=${2:no}
	auth_pass=${3:# B(Deprecated)}
	provider=${4:# B(Deprecated)}

endsnippet

snippet eos_config "Manage Arista EOS configuration sections" b
eos_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# The I(src) argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the I(lines) and I(parents) arguments. It can be a Jinja2 template as well. src file must have same indentation as a live switch config. Arista EOS device config has 3 spaces indentation.}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block|config}
	backup=${8:no}
	running_config=${9:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for this module.}
	defaults=${10:no}
	save_when=${11:always|#never|modified|changed}
	diff_against=${12:startup|running|intended|#session}
	diff_ignore_lines=${13:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${14:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	backup_options=${15:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	authorize=${16:no}
	auth_pass=${17:# B(Deprecated)}
	provider=${18:# B(Deprecated)}

endsnippet

snippet eos_bgp "Configure global BGP protocol settings on Arista EOS." b
eos_bgp: >
	config=${1:# Specifies the BGP related configuration.}
	operation=${2:#merge|replace|override|delete}

endsnippet

snippet eos_l3_interfaces "Manages L3 interface attributes of Arista EOS devices." b
eos_l3_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet eos_system "Manage the system attributes on Arista EOS devices" b
eos_system: >
	hostname=${1:# Configure the device hostname parameter. This option takes an ASCII string value.}
	domain_name=${2:# Configure the IP domain name on the remote device to the provided value. Value should be in the dotted name form and will be appended to the C(hostname) to create a fully-qualified domain name.}
	domain_search=${3:# Provides the list of domain suffixes to append to the hostname for the purpose of doing name resolution. This argument accepts a list of names and will be reconciled with the current active configuration on the running node.}
	lookup_source=${4:# Provides one or more source interfaces to use for performing DNS lookups.  The interface provided in C(lookup_source) can only exist in a single VRF.  This argument accepts either a list of interface names or a list of hashes that configure the interface name and VRF name.  See examples.}
	name_servers=${5:# List of DNS name servers by IP address to use to perform name resolution lookups.  This argument accepts either a list of DNS servers or a list of hashes that configure the name server and VRF name.  See examples.}
	state=${6:#present|absent}
	authorize=${7:no}
	auth_pass=${8:# B(Deprecated)}
	provider=${9:# B(Deprecated)}

endsnippet

snippet eos_vrf "Manage VRFs on Arista EOS network devices" b
eos_vrf: >
	name=${1:# Name of the VRF.}

	rd=${2:# Route distinguisher of the VRF}
	interfaces=${3:# Identifies the set of interfaces that should be configured in the VRF. Interfaces must be routed interfaces in order to be placed into a VRF. The name of interface should be in expanded format and not abbreviated.}
	associated_interfaces=${4:# This is a intent option and checks the operational state of the for given vrf C(name) for associated interfaces. If the value in the C(associated_interfaces) does not match with the operational state of vrf interfaces on device it will result in failure.}
	aggregate=${5:# L}
	purge=${6:no}
	delay=${7:10}
	state=${8:#present|absent}
	authorize=${9:no}
	auth_pass=${10:# B(Deprecated)}
	provider=${11:# B(Deprecated)}

endsnippet

snippet eos_logging "Manage logging on network devices" b
eos_logging: >
	dest=${1:on|host|console|monitor|buffered}
	name=${2:# The hostname or IP address of the destination.}
	size=${3:# Size of buffer. The acceptable value is in range from 10 to 2147483647 bytes.}
	facility=${4:# Set logging facility.}
	level=${5:emergencies|alerts|critical|errors|warnings|notifications|informational|debugging}
	aggregate=${6:# L}
	state=${7:#present|absent}
	authorize=${8:no}
	auth_pass=${9:# B(Deprecated)}
	provider=${10:# B(Deprecated)}

endsnippet

snippet eos_facts "Collect facts from remote devices running Arista EOS" b
eos_facts: >
	gather_subset=${1:!config}
	gather_network_resources=${2:# When supplied, this argument will restrict the facts collected to a given subset. Possible values for this argument include all and the resources like interfaces, vlans etc. Can specify a list of values to include a larger subset. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected. Valid subsets are 'all', 'interfaces', 'l2_interfaces', 'l3_interfaces', 'lacp', 'lacp_interfaces', 'lag_interfaces', 'lldp_global', 'lldp_interfaces', 'vlans'.}
	authorize=${3:no}
	auth_pass=${4:# B(Deprecated)}
	provider=${5:# B(Deprecated)}

endsnippet

snippet eos_command "Run arbitrary commands on an Arista EOS device" b
eos_command: >
	commands=${1:# The commands to send to the remote EOS device over the configured provider.  The resulting output from the command is returned.  If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of I(retries) has been exceeded.}

	wait_for=${2:# Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward.   If the conditional is not true by the configured retries, the task fails. Note - With I(wait_for) the value in C(result['stdout']) can be accessed using C(result), that is to access C(result['stdout'][0]) use C(result[0]) See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	authorize=${6:no}
	auth_pass=${7:# B(Deprecated)}
	provider=${8:# B(Deprecated)}

endsnippet

snippet eos_eapi "Manage and configure Arista EOS eAPI." b
eos_eapi: >
	http=${1:no}
	http_port=${2:80}
	https=${3:yes}
	https_port=${4:443}
	local_http=${5:no}
	local_http_port=${6:8080}
	socket=${7:no}
	vrf=${8:default}
	config=${9:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	state=${10:#started|stopped}
	authorize=${11:no}
	auth_pass=${12:# B(Deprecated)}
	provider=${13:# B(Deprecated)}

endsnippet

snippet eos_user "Manage the collection of local users on EOS devices" b
eos_user: >
	aggregate=${1:# The set of username objects to be configured on the remote Arista EOS device.  The list entries can either be the username or a hash of username and properties.  This argument is mutually exclusive with the C(username) argument.}
	name=${2:# The username to be configured on the remote Arista EOS device.  This argument accepts a stringv value and is mutually exclusive with the C(aggregate) argument. Please note that this option is not same as C(provider username).}
	configured_password=${3:# The password to be configured on the remote Arista EOS device. The password needs to be provided in clear and it will be encrypted on the device. Please note that this option is not same as C(provider password).}
	update_password=${4:on_create|#always}
	privilege=${5:# The C(privilege) argument configures the privilege level of the user when logged into the system.  This argument accepts integer values in the range of 1 to 15.}
	role=${6:# Configures the role for the username in the device running configuration.  The argument accepts a string value defining the role name.  This argument does not check if the role has been configured on the device.}
	sshkey=${7:# Specifies the SSH public key to configure for the given username.  This argument accepts a valid SSH key value.}
	nopassword=${8:# Defines the username without assigning a password.  This will allow the user to login to the system without being authenticated by a password.}
	purge=${9:no}
	state=${10:#present|absent}
	authorize=${11:no}
	auth_pass=${12:# B(Deprecated)}
	provider=${13:# B(Deprecated)}

endsnippet

snippet eos_vlans "Manage VLANs on Arista EOS devices." b
eos_vlans: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet eos_static_route "Manage static IP routes on Arista EOS network devices" b
eos_static_route: >
	address=${1:# Network address with prefix of the static route.}
	next_hop=${2:# Next hop IP of the static route.}

	vrf=${3:default}
	admin_distance=${4:1}
	aggregate=${5:# L}
	state=${6:#present|absent}
	authorize=${7:no}
	auth_pass=${8:# B(Deprecated)}
	provider=${9:# B(Deprecated)}

endsnippet

snippet eos_lacp_interfaces "Manage Link Aggregation Control Protocol (LACP) attributes of interfaces on Arista EOS devices." b
eos_lacp_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet eos_l2_interfaces "Manages Layer-2 interface attributes of Arista EOS devices" b
eos_l2_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet eos_banner "Manage multiline banners on Arista EOS devices" b
eos_banner: >
	banner=${1:login|motd}

	text=${2:# The banner text that should be present in the remote device running configuration.  This argument accepts a multiline string. Requires I(state=present).}
	state=${3:#present|absent}
	authorize=${4:no}
	auth_pass=${5:# B(Deprecated)}
	provider=${6:# B(Deprecated)}

endsnippet

snippet eos_lag_interfaces "Manages link aggregation groups on Arista EOS devices" b
eos_lag_interfaces: >
	config=${1:# A}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet eos_lldp_global "Manage Global Link Layer Discovery Protocol (LLDP) settings on Arista EOS devices." b
eos_lldp_global: >
	config=${1:# T}
	state=${2:#merged|replaced|deleted}

endsnippet

snippet eos_interfaces "Manages interface attributes of Arista EOS interfaces" b
eos_interfaces: >
	config=${1:# T}
	state=${2:#merged|replaced|overridden|deleted}

endsnippet

snippet iap_start_workflow "Start a workflow in the Itential Automation Platform" b
iap_start_workflow: >
	iap_port=${1:# Provide the port number for the Itential Automation Platform}
	iap_fqdn=${2:# Provide the fqdn for the Itential Automation Platform}
	token_key=${3:# Token key generated by iap_token module for the Itential Automation Platform}
	workflow_name=${4:# Provide the workflow name}
	description=${5:# Provide the description for the workflow}
	variables=${6:# Provide the values to the job variables}

	https=${7:no}
	validate_certs=${8:no}

endsnippet

snippet iap_token "Get token for the Itential Automation Platform" b
iap_token: >
	iap_port=${1:# Provide the port number for the Itential Automation Platform}
	iap_fqdn=${2:# Provide the fqdn or ip-address for the Itential Automation Platform}
	username=${3:# Provide the username for the Itential Automation Platform}
	password=${4:# Provide the password for the Itential Automation Platform}

	https=${5:no}
	validate_certs=${6:no}

endsnippet

snippet dellos6_config "Manage Dell EMC Networking OS6 configuration sections" b
dellos6_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with I(src).}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory. This argument is mutually exclusive with I(lines).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	update=${8:#merge|check}
	save=${9:no}
	config=${10:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	backup=${11:no}
	backup_options=${12:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet dellos6_command "Run commands on remote devices running Dell OS6" b
dellos6_command: >
	commands=${1:# List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of I(retries), the task fails. See examples.}
	match=${3:#all|any}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet dellos6_facts "Collect facts from remote devices running Dell EMC Networking OS6" b
dellos6_facts: >
	gather_subset=${1:['!config']}
	provider=${2:# A dict object containing connection details.}

endsnippet

snippet aruba_command "Run commands on remote devices running Aruba Mobility Controller" b
aruba_command: >
	commands=${1:# List of commands to send to the remote aruba device over the configured provider. The resulting output from the command is returned. If the I(wait_for) argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.}

	wait_for=${2:# List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.}
	match=${3:any|#all}
	retries=${4:10}
	interval=${5:1}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet aruba_config "Manage Aruba configuration sections" b
aruba_config: >
	lines=${1:# The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config.  Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.}
	parents=${2:# The ordered set of parents that uniquely identify the section or hierarchy the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.}
	src=${3:# Specifies the source path to the file that contains the configuration or configuration template to load.  The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with I(lines), I(parents).}
	before=${4:# The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.}
	after=${5:# The ordered set of commands to append to the end of the command stack if a change needs to be made.  Just like with I(before) this allows the playbook designer to append a set of commands to be executed after the command set.}
	match=${6:#line|strict|exact|none}
	replace=${7:#line|block}
	backup=${8:no}
	running_config=${9:# The module, by default, will connect to the remote device and retrieve the current running-config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The I(running_config) argument allows the implementer to pass in the configuration to use as the base config for comparison.}
	save_when=${10:always|#never|modified|changed}
	diff_against=${11:startup|intended|running}
	diff_ignore_lines=${12:# Use this argument to specify one or more lines that should be ignored during the diff.  This is used for lines in the configuration that are automatically updated by the system.  This argument takes a list of regular expressions or exact line matches.}
	intended_config=${13:# The C(intended_config) provides the master configuration that the node should conform to and is used to check the final running-config against.   This argument will not modify any settings on the remote device and is strictly used to check the compliance of the current device's configuration against.  When specifying this argument, the task should also modify the C(diff_against) value and set it to I(intended).}
	encrypt=${14:yes}
	backup_options=${15:# This is a dict object containing configurable options related to backup file path. The value of this option is read only when C(backup) is set to I(yes), if C(backup) is set to I(no) this option will be silently ignored.}
	provider=${16:# A dict object containing connection details.}

endsnippet

snippet etcd3 "Set or delete key value pairs from an etcd3 cluster" b
etcd3: >
	key=${1:# the key where the information is stored in the cluster}
	value=${2:# the information stored}
	state=${3:# the state of the value for the key.}

	host=${4:localhost}
	port=${5:2379}
	user=${6:# The etcd user to authenticate with.}
	password=${7:# The password to use for authentication.}
	ca_cert=${8:# The Certificate Authority to use to verify the etcd host.}
	client_cert=${9:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${10:# PEM formatted file that contains your private key to be used for SSL client authentication.}
	timeout=${11:# The socket level timeout in seconds.}

endsnippet

snippet consul_acl "Manipulate Consul ACL keys and rules" b
consul_acl: >
	mgmt_token=${1:# a management token is required to manipulate the acl lists}
	state=${2:#present|absent}
	token_type=${3:#client|management}
	name=${4:# the name that should be associated with the acl key, this is opaque to Consul}
	token=${5:# the token key identifying an ACL rule set. If generated by consul this will be a UUID}
	rules=${6:# rules that should be associated with a given token}
	host=${7:localhost}
	port=${8:8500}
	scheme=${9:http}
	validate_certs=${10:yes}

endsnippet

snippet consul_session "Manipulate consul sessions" b
consul_session: >
	id=${1:# ID of the session, required when I(state) is either C(info) or C(remove).}
	state=${2:absent|info|list|node|#present}
	name=${3:# The name that should be associated with the session. Required when I(state=node) is used.}
	delay=${4:15}
	node=${5:# The name of the node that with which the session will be associated. by default this is the name of the agent.}
	datacenter=${6:# The name of the datacenter in which the session exists or should be created.}
	checks=${7:# Checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.}
	host=${8:localhost}
	port=${9:8500}
	scheme=${10:http}
	validate_certs=${11:yes}
	behavior=${12:delete|#release}

endsnippet

snippet consul "Add, modify & delete services within a consul cluster." b
consul: >
	state=${1:#present|absent}
	service_name=${2:# Unique name for the service on a node, must be unique per node, required if registering a service. May be omitted if registering a node level check}
	service_id=${3:# the ID for the service, must be unique per node. If I(state=absent), defaults to the service name if supplied.}
	host=${4:localhost}
	port=${5:8500}
	scheme=${6:http}
	validate_certs=${7:yes}
	notes=${8:# Notes to attach to check when registering it.}
	service_port=${9:# the port on which the service is listening. Can optionally be supplied for registration of a service, i.e. if I(service_name) or I(service_id) is set}
	service_address=${10:# the address to advertise that the service will be listening on. This value will be passed as the I(address) parameter to Consul's U(/v1/agent/service/register) API method, so refer to the Consul API documentation for further details.}
	tags=${11:# tags that will be attached to the service registration.}
	script=${12:# the script/command that will be run periodically to check the health of the service. Scripts require I(interval) and vice versa.}
	interval=${13:# the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g C(15s) or C(1m). If no suffix is supplied, m will be used by default e.g. C(1) will be C(1m). Required if the I(script) parameter is specified.}
	check_id=${14:# an ID for the service check. If I(state=absent), defaults to I(check_name). Ignored if part of a service definition.}
	check_name=${15:# a name for the service check. Required if standalone, ignored if part of service definition.}
	ttl=${16:# checks can be registered with a ttl instead of a I(script) and I(interval) this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g C(15s) or C(1m). If no suffix is supplied, C(m) will be used by default e.g. C(1) will be C(1m)}
	http=${17:# checks can be registered with an HTTP endpoint. This means that consul will check that the http endpoint returns a successful HTTP status. I(interval) must also be provided with this option.}
	timeout=${18:# A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a C(s) or C(m) suffix to signify the units of seconds or minutes, e.g. C(15s) or C(1m).}
	token=${19:# the token key identifying an ACL rule set. May be required to register services.}

endsnippet

snippet znode "Create, delete, retrieve, and update znodes using ZooKeeper" b
znode: >
	hosts=${1:# A list of ZooKeeper servers (format '[server]:[port]').}
	name=${2:# The path of the znode.}

	value=${3:# The value assigned to the znode.}
	op=${4:# An operation to perform. Mutually exclusive with state.}
	state=${5:# The state to enforce. Mutually exclusive with op.}
	timeout=${6:300}
	recursive=${7:no}

endsnippet

snippet pacemaker_cluster "Manage pacemaker clusters" b
pacemaker_cluster: >
	state=${1:cleanup|offline|online|restart}

	node=${2:# Specify which node of the cluster you want to manage. None == the cluster status itself, 'all' == check the status of all nodes.}
	timeout=${3:300}
	force=${4:yes}

endsnippet

snippet consul_kv "Manipulate entries in the key/value store of a consul cluster" b
consul_kv: >
	key=${1:# The key at which the value should be stored.}
	value=${2:# The value should be associated with the given key, required if C(state) is C(present).}

	state=${3:absent|acquire|#present|release}
	recurse=${4:no}
	retrieve=${5:yes}
	session=${6:# The session that should be used to acquire or release a lock associated with a key/value pair.}
	token=${7:# The token key identifying an ACL rule set that controls access to the key value pair}
	cas=${8:# Used when acquiring a lock with a session. If the C(cas) is C(0), then Consul will only put the key if it does not already exist. If the C(cas) value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.}
	flags=${9:# Opaque positive integer value that can be passed when setting a value.}
	host=${10:localhost}
	port=${11:8500}
	scheme=${12:http}
	validate_certs=${13:yes}

endsnippet

snippet k8s "Manage Kubernetes (K8s) objects" b
k8s: >
	merge_type=${1:json|merge|strategic-merge}
	wait=${2:no}
	wait_sleep=${3:5}
	wait_timeout=${4:120}
	wait_condition=${5:# Specifies a custom condition on the status to wait for. Ignored if C(wait) is not set or is set to False.}
	validate=${6:# how (if at all) to validate the resource definition against the kubernetes schema. Requires the kubernetes-validate python module}
	append_hash=${7:# Whether to append a hash to a resource name for immutability purposes}
	apply=${8:# C(apply) compares the desired resource definition with the previously supplied resource definition, ignoring properties that are automatically generated}
	state=${9:absent|#present}
	force=${10:no}
	api_version=${11:v1}
	kind=${12:# Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.}
	name=${13:# Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.}
	namespace=${14:# Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.}
	resource_definition=${15:# Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).}
	src=${16:# Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.}
	host=${17:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${18:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${19:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${20:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${21:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${22:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${23:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${24:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${25:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${26:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${27:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet k8s_info "Describe Kubernetes (K8s) objects" b
k8s_info: >
	kind=${1:# Use to specify an object model. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object.}

	api_version=${2:v1}
	name=${3:# Use to specify an object name.  Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object.}
	namespace=${4:# Use to specify an object namespace. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specific object.}
	label_selectors=${5:# L}
	field_selectors=${6:# L}
	host=${7:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${8:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${9:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${10:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${11:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${12:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${13:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${14:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${15:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${16:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${17:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet k8s_scale "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job." b
k8s_scale: >
	api_version=${1:v1}
	kind=${2:# Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.}
	name=${3:# Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.}
	namespace=${4:# Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.}
	host=${5:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${6:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${7:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${8:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${9:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${10:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${11:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${12:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${13:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${14:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${15:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}
	resource_definition=${16:# Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).}
	src=${17:# Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.}
	replicas=${18:# The desired number of replicas.}
	current_replicas=${19:# For Deployment, ReplicaSet, Replication Controller, only scale, if the number of existing replicas matches. In the case of a Job, update parallelism only if the current parallelism value matches.}
	resource_version=${20:# Only attempt to scale, if the current object version matches.}
	wait=${21:yes}
	wait_timeout=${22:20}

endsnippet

snippet k8s_service "Manage Services on Kubernetes" b
k8s_service: >
	name=${1:# Use to specify a Service object name.}
	namespace=${2:# Use to specify a Service object namespace.}

	resource_definition=${3:# A partial YAML definition of the Service object being created/updated. Here you can define Kubernetes Service Resource parameters not covered by this module's parameters.}
	state=${4:#present|absent}
	force=${5:no}
	merge_type=${6:json|merge|strategic-merge}
	type=${7:NodePort|ClusterIP|LoadBalancer|ExternalName}
	ports=${8:# A list of ports to expose.}
	selector=${9:# Label selectors identify objects this Service should apply to.}
	host=${10:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${11:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${12:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${13:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${14:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${15:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${16:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${17:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${18:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${19:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${20:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet k8s "Manage Kubernetes (K8s) objects" b
k8s: >
	merge_type=${1:json|merge|strategic-merge}
	wait=${2:no}
	wait_sleep=${3:5}
	wait_timeout=${4:120}
	wait_condition=${5:# Specifies a custom condition on the status to wait for. Ignored if C(wait) is not set or is set to False.}
	validate=${6:# how (if at all) to validate the resource definition against the kubernetes schema. Requires the kubernetes-validate python module}
	append_hash=${7:# Whether to append a hash to a resource name for immutability purposes}
	apply=${8:# C(apply) compares the desired resource definition with the previously supplied resource definition, ignoring properties that are automatically generated}
	state=${9:absent|#present}
	force=${10:no}
	api_version=${11:v1}
	kind=${12:# Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.}
	name=${13:# Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.}
	namespace=${14:# Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.}
	resource_definition=${15:# Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).}
	src=${16:# Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.}
	host=${17:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${18:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${19:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${20:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${21:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${22:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${23:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${24:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${25:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${26:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${27:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet k8s_auth "Authenticate to Kubernetes clusters which require an explicit login step" b
k8s_auth: >
	host=${1:# Provide a URL for accessing the API server.}

	state=${2:#present|absent}
	username=${3:# Provide a username for authenticating with the API server.}
	password=${4:# Provide a password for authenticating with the API server.}
	ca_cert=${5:# Path to a CA certificate file used to verify connection to the API server. The full certificate chain must be provided to avoid certificate validation errors.}
	validate_certs=${6:yes}
	api_key=${7:# When C(state) is set to I(absent), this specifies the token to revoke.}

endsnippet

snippet k8s_info "Describe Kubernetes (K8s) objects" b
k8s_info: >
	kind=${1:# Use to specify an object model. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object.}

	api_version=${2:v1}
	name=${3:# Use to specify an object name.  Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object.}
	namespace=${4:# Use to specify an object namespace. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specific object.}
	label_selectors=${5:# L}
	field_selectors=${6:# L}
	host=${7:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${8:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${9:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${10:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${11:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${12:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${13:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${14:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${15:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${16:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${17:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet k8s_scale "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job." b
k8s_scale: >
	api_version=${1:v1}
	kind=${2:# Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.}
	name=${3:# Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.}
	namespace=${4:# Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.}
	host=${5:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${6:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${7:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${8:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${9:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${10:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${11:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${12:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${13:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${14:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${15:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}
	resource_definition=${16:# Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).}
	src=${17:# Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.}
	replicas=${18:# The desired number of replicas.}
	current_replicas=${19:# For Deployment, ReplicaSet, Replication Controller, only scale, if the number of existing replicas matches. In the case of a Job, update parallelism only if the current parallelism value matches.}
	resource_version=${20:# Only attempt to scale, if the current object version matches.}
	wait=${21:yes}
	wait_timeout=${22:20}

endsnippet

snippet k8s "Manage Kubernetes (K8s) objects" b
k8s: >
	merge_type=${1:json|merge|strategic-merge}
	wait=${2:no}
	wait_sleep=${3:5}
	wait_timeout=${4:120}
	wait_condition=${5:# Specifies a custom condition on the status to wait for. Ignored if C(wait) is not set or is set to False.}
	validate=${6:# how (if at all) to validate the resource definition against the kubernetes schema. Requires the kubernetes-validate python module}
	append_hash=${7:# Whether to append a hash to a resource name for immutability purposes}
	apply=${8:# C(apply) compares the desired resource definition with the previously supplied resource definition, ignoring properties that are automatically generated}
	state=${9:absent|#present}
	force=${10:no}
	api_version=${11:v1}
	kind=${12:# Use to specify an object model. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(name), and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(kind) from the I(resource_definition) will override this option.}
	name=${13:# Use to specify an object name. Use to create, delete, or discover an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind) and I(namespace) to identify a specific object. If I(resource definition) is provided, the I(metadata.name) value from the I(resource_definition) will override this option.}
	namespace=${14:# Use to specify an object namespace. Useful when creating, deleting, or discovering an object without providing a full resource definition. Use in conjunction with I(api_version), I(kind), and I(name) to identify a specfic object. If I(resource definition) is provided, the I(metadata.namespace) value from the I(resource_definition) will override this option.}
	resource_definition=${15:# Provide a valid YAML definition (either as a string, list, or dict) for an object when creating or updating. NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the provided I(resource_definition).}
	src=${16:# Provide a path to a file containing a valid YAML definition of an object or objects to be created or updated. Mutually exclusive with I(resource_definition). NOTE: I(kind), I(api_version), I(name), and I(namespace) will be overwritten by corresponding values found in the configuration read in from the I(src) file.}
	host=${17:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${18:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${19:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${20:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${21:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${22:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${23:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${24:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${25:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${26:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${27:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet ss_3par_cpg "Manage HPE StoreServ 3PAR CPG" b
ss_3par_cpg: >
	cpg_name=${1:# Name of the CPG.}
	state=${2:present|absent}
	storage_system_ip=${3:# The storage system IP address.}
	storage_system_password=${4:# The storage system password.}
	storage_system_username=${5:# The storage system user name.}

	disk_type=${6:FC|NL|SSD}
	domain=${7:# Specifies the name of the domain in which the object will reside.}
	growth_increment=${8:# Specifies the growth increment(in MiB, GiB or TiB) the amount of logical disk storage created on each auto-grow operation.}
	growth_limit=${9:# Specifies that the autogrow operation is limited to the specified storage amount that sets the growth limit(in MiB, GiB or TiB).}
	growth_warning=${10:# Specifies that the threshold(in MiB, GiB or TiB) of used logical disk space when exceeded results in a warning alert.}
	high_availability=${11:PORT|CAGE|MAG}
	raid_type=${12:R0|R1|R5|R6}
	set_size=${13:# Specifies the set size in the number of chunklets.}
	secure=${14:no}

endsnippet

snippet netapp_e_facts "NetApp E-Series retrieve facts about NetApp E-Series storage arrays" b
netapp_e_facts: >
	api_username=${1:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${2:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${3:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	validate_certs=${4:yes}
	ssid=${5:1}

endsnippet

snippet na_elementsw_initiators "Manage Element SW initiators" b
na_elementsw_initiators: >
	hostname=${1:# The hostname or IP address of the SolidFire cluster.}
	username=${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${3:# Password for the specified user.}

	initiators=${4:# A}
	state=${5:#present|absent}

endsnippet

snippet netapp_e_syslog "NetApp E-Series manage syslog settings" b
netapp_e_syslog: >
	api_username=${1:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${2:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${3:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	state=${4:#present|absent}
	address=${5:# The syslog server's IPv4 address or a fully qualified hostname.}
	port=${6:514}
	protocol=${7:#udp|tcp|tls}
	components=${8:['auditLog']}
	test=${9:no}
	log_path=${10:# This argument specifies a local path for logging purposes.}
	validate_certs=${11:yes}
	ssid=${12:1}

endsnippet

snippet na_ontap_job_schedule "NetApp ONTAP Job Schedule" b
na_ontap_job_schedule: >
	name=${1:# The name of the job-schedule to manage.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	job_minutes=${6:# The minute(s) of each hour when the job should be run. Job Manager cron scheduling minute. -1 represents all minutes and is only supported for cron schedule create and modify. Range is [-1..59]}
	job_hours=${7:# The hour(s) of the day when the job should be run. Job Manager cron scheduling hour. -1 represents all hours and is only supported for cron schedule create and modify. Range is [-1..23]}
	job_months=${8:# The month(s) when the job should be run. Job Manager cron scheduling month. -1 represents all months and is only supported for cron schedule create and modify. Range is [-1..11]}
	job_days_of_month=${9:# The day(s) of the month when the job should be run. Job Manager cron scheduling day of month. -1 represents all days of a month from 1 to 31, and is only supported for cron schedule create and modify. Range is [-1..31]}
	job_days_of_week=${10:# The day(s) in the week when the job should be run. Job Manager cron scheduling day of week. Zero represents Sunday. -1 represents all days of a week and is only supported for cron schedule create and modify. Range is [-1..6]}
	https=${11:no}
	validate_certs=${12:yes}
	http_port=${13:# Override the default port (80 or 443) with this port}
	ontapi=${14:# The ontap api version to use}
	use_rest=${15:Never|Always|#Auto}

endsnippet

snippet netapp_e_auditlog "NetApp E-Series manage audit-log configuration" b
netapp_e_auditlog: >
	api_username=${1:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${2:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${3:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	max_records=${4:50000}
	log_level=${5:all|#writeOnly}
	full_policy=${6:#overWrite|preventSystemAccess}
	threshold=${7:90}
	force=${8:no}
	log_path=${9:# A}
	validate_certs=${10:yes}
	ssid=${11:1}

endsnippet

snippet na_ontap_flexcache "NetApp ONTAP FlexCache - create/delete relationship" b
na_ontap_flexcache: >
	volume=${1:# Name of the target volume for the FlexCache.}
	vserver=${2:# Name of the target vserver for the FlexCache.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	origin_volume=${7:# Name of the origin volume for the FlexCache.}
	origin_vserver=${8:# Name of the origin vserver for the FlexCache.}
	origin_cluster=${9:# Name of the origin cluster for the FlexCache.}
	junction_path=${10:# Junction path of the cache volume.}
	auto_provision_as=${11:# Use this parameter to automatically select existing aggregates for volume provisioning.Eg flexgroup}
	size=${12:# Size of cache volume.}
	size_unit=${13:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	aggr_list=${14:# List of aggregates to host target FlexCache volume.}
	aggr_list_multiplier=${15:# Aggregate list repeat count.}
	force_unmount=${16:no}
	force_offline=${17:no}
	time_out=${18:180}
	https=${19:no}
	validate_certs=${20:yes}
	http_port=${21:# Override the default port (80 or 443) with this port}
	ontapi=${22:# The ontap api version to use}
	use_rest=${23:Never|Always|#Auto}

endsnippet

snippet na_ontap_service_processor_network "NetApp ONTAP service processor network" b
na_ontap_service_processor_network: >
	address_type=${1:ipv4|ipv6}
	is_enabled=${2:# Specify whether to enable or disable the service processor network.}
	node=${3:# The node where the service processor network should be enabled}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present}
	dhcp=${8:v4|none}
	gateway_ip_address=${9:# Specify the gateway ip.}
	ip_address=${10:# Specify the service processor ip address.}
	netmask=${11:# Specify the service processor netmask.}
	prefix_length=${12:# Specify the service processor prefix_length.}
	wait_for_completion=${13:no}
	https=${14:no}
	validate_certs=${15:yes}
	http_port=${16:# Override the default port (80 or 443) with this port}
	ontapi=${17:# The ontap api version to use}
	use_rest=${18:Never|Always|#Auto}

endsnippet

snippet na_ontap_vscan_on_demand_task "NetApp ONTAP Vscan on demand task configuration." b
na_ontap_vscan_on_demand_task: >
	vserver=${1:# the name of the data vserver to use.}
	task_name=${2:# Name of the task.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	cross_junction=${7:no}
	directory_recursion=${8:no}
	file_ext_to_exclude=${9:# File-Extensions for which scanning must not be performed.}
	file_ext_to_include=${10:# File extensions for which scanning is considered.}
	max_file_size=${11:# Max file-size (in bytes) allowed for scanning. The default value of 10737418240 (10GB) is taken if not provided at the time of creating a task.}
	paths_to_exclude=${12:# File-paths for which scanning must not be performed.}
	report_directory=${13:# Path from the vserver root where task report is created. The path must be a directory and provided in unix-format from the root of the Vserver.}
	report_log_level=${14:verbose|info|#error}
	request_timeout=${15:# Total request-service time-limit in seconds. If the virus-scanner does not respond within the provided time, scan will be timed out.}
	scan_files_with_no_ext=${16:yes}
	scan_paths=${17:# List of paths that need to be scanned. The path must be provided in unix-format and from the root of the Vserver.}
	scan_priority=${18:#low|normal}
	schedule=${19:# Schedule of the task. The task will be run as per the schedule.}
	https=${20:no}
	validate_certs=${21:yes}
	http_port=${22:# Override the default port (80 or 443) with this port}
	ontapi=${23:# The ontap api version to use}
	use_rest=${24:Never|Always|#Auto}

endsnippet

snippet na_ontap_dns "NetApp ONTAP Create, delete, modify DNS servers." b
na_ontap_dns: >
	vserver=${1:# The name of the vserver to use.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	domains=${6:# List of DNS domains such as 'sales.bar.com'. The first domain is the one that the Vserver belongs to.}
	nameservers=${7:# List of IPv4 addresses of name servers such as '123.123.123.123'.}
	skip_validation=${8:# By default, all nameservers are checked to validate they are available to resolve.}
	https=${9:no}
	validate_certs=${10:yes}
	http_port=${11:# Override the default port (80 or 443) with this port}
	ontapi=${12:# The ontap api version to use}
	use_rest=${13:Never|Always|#Auto}

endsnippet

snippet na_ontap_cifs "NetApp ONTAP Manage cifs-share" b
na_ontap_cifs: >
	vserver=${1:# Vserver containing the CIFS share.}
	share_name=${2:# T}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	path=${6:# T}
	share_properties=${7:# The list of properties for the CIFS share}
	symlink_properties=${8:# The list of symlink properties for this CIFS share}
	state=${9:#present|absent}
	vscan_fileop_profile=${10:no_scan|standard|strict|writes_only}
	https=${11:no}
	validate_certs=${12:yes}
	http_port=${13:# Override the default port (80 or 443) with this port}
	ontapi=${14:# The ontap api version to use}
	use_rest=${15:Never|Always|#Auto}

endsnippet

snippet na_ontap_volume "NetApp ONTAP manage volumes." b
na_ontap_volume: >
	name=${1:# The name of the volume to manage.}
	vserver=${2:# Name of the vserver to use.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	from_name=${7:# Name of the existing volume to be renamed to name.}
	is_infinite=${8:# S}
	is_online=${9:yes}
	aggregate_name=${10:# The name of the aggregate the flexvol should exist on.}
	size=${11:# The size of the volume in (size_unit). Required when C(state=present).}
	size_unit=${12:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	type=${13:# The volume type, either read-write (RW) or data-protection (DP).}
	policy=${14:# Name of the export policy.}
	junction_path=${15:# Junction path of the volume.}
	space_guarantee=${16:none|file|volume}
	percent_snapshot_space=${17:# Amount of space reserved for snapshot copies of the volume.}
	volume_security_style=${18:#mixed|ntfs|unified|unix}
	encrypt=${19:no}
	efficiency_policy=${20:# Allows a storage efficiency policy to be set on volume creation.}
	unix_permissions=${21:# Unix permission bits in octal or symbolic format.}
	snapshot_policy=${22:# The name of the snapshot policy.}
	aggr_list=${23:# an array of names of aggregates to be used for FlexGroup constituents.}
	aggr_list_multiplier=${24:# The number of times to iterate over the aggregates listed with the aggr_list parameter when creating a FlexGroup.}
	auto_provision_as=${25:flexgroup}
	snapdir_access=${26:# This is an advanced option, the default is False.}
	atime_update=${27:# This is an advanced option, the default is True.}
	wait_for_completion=${28:no}
	time_out=${29:180}
	language=${30:# Language to use for Volume}
	qos_policy_group=${31:# Specifies a QoS policy group to be set on volume.}
	qos_adaptive_policy_group=${32:# Specifies a QoS adaptive policy group to be set on volume.}
	tiering_policy=${33:snapshot-only|auto|backup|none}
	space_slo=${34:none|thick|semi-thick}
	nvfail_enabled=${35:# If true, the controller performs additional work at boot and takeover times if it finds that there has been any potential data loss in the volume's constituents due to an NVRAM failure.}
	vserver_dr_protection=${36:protected|unprotected}
	comment=${37:# Sets a comment associated with the volume.}
	https=${38:no}
	validate_certs=${39:yes}
	http_port=${40:# Override the default port (80 or 443) with this port}
	ontapi=${41:# The ontap api version to use}
	use_rest=${42:Never|Always|#Auto}

endsnippet

snippet na_ontap_export_policy "NetApp ONTAP manage export-policy" b
na_ontap_export_policy: >
	name=${1:# The name of the export-policy to manage.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	from_name=${6:# The name of the export-policy to be renamed.}
	vserver=${7:# Name of the vserver to use.}
	https=${8:no}
	validate_certs=${9:yes}
	http_port=${10:# Override the default port (80 or 443) with this port}
	ontapi=${11:# The ontap api version to use}
	use_rest=${12:Never|Always|#Auto}

endsnippet

snippet na_ontap_ports "NetApp ONTAP add/remove ports" b
na_ontap_ports: >
	names=${1:# List of ports.}
	resource_name=${2:# name of the portset or broadcast domain.}
	resource_type=${3:broadcast_domain|portset}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	vserver=${8:# Name of the SVM.}
	ipspace=${9:# Specify the required ipspace for the broadcast domain.}
	portset_type=${10:fcp|iscsi|mixed}
	https=${11:no}
	validate_certs=${12:yes}
	http_port=${13:# Override the default port (80 or 443) with this port}
	ontapi=${14:# The ontap api version to use}
	use_rest=${15:Never|Always|#Auto}

endsnippet

snippet netapp_e_amg_sync "NetApp E-Series conduct synchronization actions on asynchronous mirror groups." b
netapp_e_amg_sync: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
	name=${4:# The name of the async mirror group you wish to target}
	state=${5:running|suspended}

	validate_certs=${6:yes}
	ssid=${7:# The ID of the storage array containing the AMG you wish to target}
	delete_recovery_point=${8:no}

endsnippet

snippet na_ontap_volume_clone "NetApp ONTAP manage volume clones." b
na_ontap_volume_clone: >
	parent_volume=${1:# The parent volume of the volume clone being created.}
	name=${2:# The name of the volume clone being created.}
	vserver=${3:# Vserver in which the volume clone should be created.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present}
	parent_snapshot=${8:# Parent snapshot in which volume clone is created off.}
	parent_vserver=${9:# Vserver of parent volume in which clone is created off.}
	qos_policy_group_name=${10:# The qos-policy-group-name which should be set for volume clone.}
	space_reserve=${11:volume|none}
	volume_type=${12:rw|dp}
	junction_path=${13:# Junction path of the volume.}
	uid=${14:# The UNIX user ID for the clone volume.}
	gid=${15:# The UNIX group ID for the clone volume.}
	https=${16:no}
	validate_certs=${17:yes}
	http_port=${18:# Override the default port (80 or 443) with this port}
	ontapi=${19:# The ontap api version to use}
	use_rest=${20:Never|Always|#Auto}

endsnippet

snippet na_elementsw_cluster_snmp "Configure Element SW Cluster SNMP" b
na_elementsw_cluster_snmp: >
	hostname=${1:# The hostname or IP address of the SolidFire cluster.}
	username=${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${3:# Password for the specified user.}

	state=${4:#present|absent}
	snmp_v3_enabled=${5:# Which version of SNMP has to be enabled.}
	networks=${6:# List of networks and what type of access they have to the SNMP servers running on the cluster nodes.}
	usm_users=${7:# List of users and the type of access they have to the SNMP servers running on the cluster nodes.}

endsnippet

snippet netapp_e_flashcache "NetApp E-Series manage SSD caches" b
netapp_e_flashcache: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
	ssid=${4:# The ID of the array to manage (as configured on the web services proxy).}
	state=${5:#present|absent}
	name=${6:# The name of the SSD cache to manage}

	validate_certs=${7:yes}
	io_type=${8:#filesystem|database|media}
	disk_count=${9:# The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place}
	size_unit=${10:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	cache_size_min=${11:# The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.}

endsnippet

snippet na_elementsw_snapshot "NetApp Element Software Manage Snapshots" b
na_elementsw_snapshot: >
	src_volume_id=${1:# ID or Name of active volume.}
	account_id=${2:# Account ID or Name of Parent/Source Volume.}
	password=${3:# Element OS access account password}
	username=${4:# Element OS access account user-name}
	hostname=${5:# The hostname or IP address of the SolidFire cluster.}

	name=${6:# Name of new snapshot create.}
	state=${7:#present|absent}
	retention=${8:# Retention period for the snapshot.}
	src_snapshot_id=${9:# ID or Name of an existing snapshot.}
	enable_remote_replication=${10:# Flag, whether to replicate the snapshot created to a remote replication cluster.}
	snap_mirror_label=${11:# Label used by SnapMirror software to specify snapshot retention policy on SnapMirror endpoint.}
	expiration_time=${12:# The date and time (format ISO 8601 date string) at which this snapshot will expire.}

endsnippet

snippet na_ontap_net_routes "NetApp ONTAP network routes" b
na_ontap_net_routes: >
	vserver=${1:# The name of the vserver.}
	destination=${2:# Specify the route destination.}
	gateway=${3:# Specify the route gateway.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	metric=${8:# Specify the route metric.}
	from_destination=${9:# Specify the route destination that should be changed.}
	from_gateway=${10:# Specify the route gateway that should be changed.}
	from_metric=${11:# Specify the route metric that should be changed.}
	https=${12:no}
	validate_certs=${13:yes}
	http_port=${14:# Override the default port (80 or 443) with this port}
	ontapi=${15:# The ontap api version to use}
	use_rest=${16:Never|Always|#Auto}

endsnippet

snippet netapp_e_volume "NetApp E-Series manage storage volumes (standard and thin)" b
netapp_e_volume: >
	state=${1:present|absent}
	name=${2:# The name of the volume to manage.}
	size=${3:# Required only when I(state=='present').}
	api_username=${4:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${5:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${6:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	storage_pool_name=${7:# Required only when requested I(state=='present').}
	size_unit=${8:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	segment_size_kb=${9:128}
	thin_provision=${10:no}
	thin_volume_repo_size=${11:# This value (in size_unit) sets the allocated space for the thin provisioned repository.}
	thin_volume_max_repo_size=${12:same as size (in size_unit)}
	thin_volume_expansion_policy=${13:#automatic|manual}
	thin_volume_growth_alert_threshold=${14:95}
	owning_controller=${15:A|B}
	ssd_cache_enabled=${16:no}
	data_assurance_enabled=${17:no}
	read_cache_enable=${18:yes}
	read_ahead_enable=${19:yes}
	write_cache_enable=${20:yes}
	cache_without_batteries=${21:no}
	workload_name=${22:# Label for the workload defined by the metadata.}
	metadata=${23:# Dictionary containing meta data for the use, user, location, etc of the volume (dictionary is arbitrarily defined for whatever the user deems useful)}
	wait_for_initialization=${24:no}
	initialization_timeout=${25:# Duration in seconds before the wait_for_initialization operation will terminate.}
	validate_certs=${26:yes}
	ssid=${27:1}

endsnippet

snippet na_elementsw_volume "NetApp Element Software Manage Volumes" b
na_elementsw_volume: >
	state=${1:present|absent}
	name=${2:# The name of the volume to manage.}
	account_id=${3:# Account ID for the owner of this volume.}
	password=${4:# ElementSW access account password}
	username=${5:# ElementSW access account user-name}
	hostname=${6:# The hostname or IP address of the SolidFire cluster.}

	enable512e=${7:# Required when C(state=present)}
	qos=${8:# I}
	attributes=${9:# A}
	size=${10:# The size of the volume in (size_unit).}
	size_unit=${11:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	access=${12:readOnly|readWrite|locked|replicationTarget}

endsnippet

snippet netapp_e_amg_role "NetApp E-Series update the role of a storage array within an Asynchronous Mirror Group (AMG)." b
netapp_e_amg_role: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
	ssid=${4:# The ID of the primary storage array for the async mirror action}
	role=${5:primary|secondary}

	validate_certs=${6:yes}
	noSync=${7:no}
	force=${8:no}

endsnippet

snippet na_ontap_nvme "NetApp ONTAP Manage NVMe Service" b
na_ontap_nvme: >
	vserver=${1:# Name of the vserver to use.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	status_admin=${6:# Whether the status of NVMe should be up or down}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet na_ontap_net_port "NetApp ONTAP network ports." b
na_ontap_net_port: >
	node=${1:# Specifies the name of node.}
	ports=${2:# Specifies the name of port(s).}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present}
	mtu=${7:# Specifies the maximum transmission unit (MTU) reported by the port.}
	autonegotiate_admin=${8:# Enables or disables Ethernet auto-negotiation of speed, duplex and flow control.}
	duplex_admin=${9:# Specifies the user preferred duplex setting of the port.}
	speed_admin=${10:# Specifies the user preferred speed setting of the port.}
	flowcontrol_admin=${11:# Specifies the user preferred flow control setting of the port.}
	ipspace=${12:# Specifies the port's associated IPspace name.}
	https=${13:no}
	validate_certs=${14:yes}
	http_port=${15:# Override the default port (80 or 443) with this port}
	ontapi=${16:# The ontap api version to use}
	use_rest=${17:Never|Always|#Auto}

endsnippet

snippet na_ontap_lun_map "NetApp ONTAP LUN maps" b
na_ontap_lun_map: >
	initiator_group_name=${1:# Initiator group to map to the given LUN.}
	path=${2:# Path of the LUN..}
	vserver=${3:# The name of the vserver to use.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	lun_id=${8:# LUN ID assigned for the map.}
	https=${9:no}
	validate_certs=${10:yes}
	http_port=${11:# Override the default port (80 or 443) with this port}
	ontapi=${12:# The ontap api version to use}
	use_rest=${13:Never|Always|#Auto}

endsnippet

snippet na_ontap_user "NetApp ONTAP user configuration and management" b
na_ontap_user: >
	name=${1:# The name of the user to manage.}
	applications=${2:console|http|ontapi|rsh|snmp|service-processor|sp|ssh|telnet}
	authentication_method=${3:community|password|publickey|domain|nsswitch|usm|cert}
	vserver=${4:# The name of the vserver to use.}
	hostname=${5:# The hostname or IP address of the ONTAP instance.}
	username=${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${7:# Password for the specified user.}

	state=${8:#present|absent}
	set_password=${9:# Password for the user account.}
	role_name=${10:# The name of the role. Required when C(state=present)}
	lock_user=${11:# Whether the specified user account is locked.}
	https=${12:no}
	validate_certs=${13:yes}
	http_port=${14:# Override the default port (80 or 443) with this port}
	ontapi=${15:# The ontap api version to use}
	use_rest=${16:Never|Always|#Auto}

endsnippet

snippet na_ontap_qos_adaptive_policy_group "NetApp ONTAP Adaptive Quality of Service policy group." b
na_ontap_qos_adaptive_policy_group: >
	name=${1:# The name of the policy group to manage.}
	vserver=${2:# Name of the vserver to use.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	from_name=${7:# Name of the existing policy group to be renamed to name.}
	absolute_min_iops=${8:# Absolute minimum IOPS defined by this policy.}
	expected_iops=${9:# Minimum expected IOPS defined by this policy.}
	peak_iops=${10:# Maximum possible IOPS per allocated or used TB|GB.}
	peak_iops_allocation=${11:allocated_space|#used_space}
	force=${12:no}
	https=${13:no}
	validate_certs=${14:yes}
	http_port=${15:# Override the default port (80 or 443) with this port}
	ontapi=${16:# The ontap api version to use}
	use_rest=${17:Never|Always|#Auto}

endsnippet

snippet na_ontap_quotas "NetApp ONTAP Quotas" b
na_ontap_quotas: >
	vserver=${1:# Name of the vserver to use.}
	volume=${2:# The name of the volume that the quota resides on.}
	quota_target=${3:# The quota target of the type specified.}
	type=${4:user|group|tree}
	hostname=${5:# The hostname or IP address of the ONTAP instance.}
	username=${6:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${7:# Password for the specified user.}

	state=${8:#present|absent}
	qtree=${9:}
	policy=${10:# Name of the quota policy from which the quota rule should be obtained.}
	set_quota_status=${11:# Whether the specified volume should have quota status on or off.}
	file_limit=${12:-}
	disk_limit=${13:-}
	threshold=${14:-}
	https=${15:no}
	validate_certs=${16:yes}
	http_port=${17:# Override the default port (80 or 443) with this port}
	ontapi=${18:# The ontap api version to use}
	use_rest=${19:Never|Always|#Auto}

endsnippet

snippet na_ontap_unix_user "NetApp ONTAP UNIX users" b
na_ontap_unix_user: >
	name=${1:# Specifies user's UNIX account name.}
	vserver=${2:# Specifies the Vserver for the UNIX user.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	group_id=${7:# Specifies the primary group identification number for the UNIX user}
	id=${8:# Specifies an identification number for the UNIX user.}
	full_name=${9:# Specifies the full name of the UNIX user}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet netapp_e_lun_mapping "NetApp E-Series create, delete, or modify lun mappings" b
netapp_e_lun_mapping: >
	state=${1:present|absent}
	volume_name=${2:# The name of the volume you wish to include in the mapping.}
	api_username=${3:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${4:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${5:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	target=${6:# The name of host or hostgroup you wish to assign to the mapping}
	lun=${7:# The LUN value you wish to give the mapping.}
	target_type=${8:host|group}
	validate_certs=${9:yes}
	ssid=${10:1}

endsnippet

snippet na_ontap_snapmirror "NetApp ONTAP or ElementSW Manage SnapMirror" b
na_ontap_snapmirror: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#present|absent}
	source_volume=${5:# Specifies the name of the source volume for the SnapMirror.}
	destination_volume=${6:# Specifies the name of the destination volume for the SnapMirror.}
	source_vserver=${7:# Name of the source vserver for the SnapMirror.}
	destination_vserver=${8:# Name of the destination vserver for the SnapMirror.}
	source_path=${9:# Specifies the source endpoint of the SnapMirror relationship.}
	destination_path=${10:# Specifies the destination endpoint of the SnapMirror relationship.}
	relationship_type=${11:data_protection|load_sharing|vault|restore|transition_data_protection|extended_data_protection}
	schedule=${12:# Specify the name of the current schedule, which is used to update the SnapMirror relationship.}
	policy=${13:# Specify the name of the SnapMirror policy that applies to this relationship.}
	source_hostname=${14:# Source hostname or management IP address for ONTAP or ElementSW cluster.}
	source_username=${15:# Source username for ONTAP or ElementSW cluster.}
	source_password=${16:# Source password for ONTAP or ElementSW cluster.}
	connection_type=${17:#ontap_ontap|elementsw_ontap|ontap_elementsw}
	max_transfer_rate=${18:# Specifies the upper bound, in kilobytes per second, at which data is transferred.}
	identity_preserve=${19:# Specifies whether or not the identity of the source Vserver is replicated to the destination Vserver.}
	https=${20:no}
	validate_certs=${21:yes}
	http_port=${22:# Override the default port (80 or 443) with this port}
	ontapi=${23:# The ontap api version to use}
	use_rest=${24:Never|Always|#Auto}

endsnippet

snippet na_elementsw_snapshot_schedule "NetApp Element Software Snapshot Schedules" b
na_elementsw_snapshot_schedule: >
	state=${1:present|absent}
	password=${2:# Element SW access account password}
	username=${3:# Element SW access account user-name}
	hostname=${4:# The hostname or IP address of the SolidFire cluster.}

	paused=${5:# Pause / Resume a schedule.}
	recurring=${6:# Should the schedule recur?}
	schedule_type=${7:DaysOfWeekFrequency|DaysOfMonthFrequency|TimeIntervalFrequency}
	time_interval_days=${8:1}
	time_interval_hours=${9:0}
	time_interval_minutes=${10:0}
	days_of_week_weekdays=${11:# L}
	days_of_week_hours=${12:0}
	days_of_week_minutes=${13:0}
	days_of_month_monthdays=${14:# L}
	days_of_month_hours=${15:0}
	days_of_month_minutes=${16:0}
	name=${17:# Name for the snapshot schedule.}
	snapshot_name=${18:# Name for the created snapshots.}
	volumes=${19:# Volume IDs that you want to set the snapshot schedule for.}
	account_id=${20:# Account ID for the owner of this volume.}
	retention=${21:# Retention period for the snapshot.}
	starting_date=${22:# Starting date for the schedule.}

endsnippet

snippet na_elementsw_node "NetApp Element Software Node Operation" b
na_elementsw_node: >
	node_id=${1:# List of IDs or Names or IP Address of nodes from cluster used for operation.}
	hostname=${2:# The hostname or IP address of the SolidFire cluster.}
	username=${3:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}

endsnippet

snippet na_ontap_command "NetApp ONTAP Run any cli command, the username provided needs to have console login permission." b
na_ontap_command: >
	command=${1:# a comma separated list containing the command and arguments.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	privilege=${5:#admin|advanced}
	return_dict=${6:no}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet na_elementsw_access_group "NetApp Element Software Manage Access Groups" b
na_elementsw_access_group: >
	state=${1:present|absent}
	name=${2:# Name for the access group for create, modify and delete operations.}
	hostname=${3:# The hostname or IP address of the SolidFire cluster.}
	username=${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${5:# Password for the specified user.}

	from_name=${6:# ID or Name of the access group to rename.}
	initiators=${7:# List of initiators to include in the access group. If unspecified, the access group will start out without configured initiators.}
	volumes=${8:# List of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes.}
	account_id=${9:# Account ID for the owner of this volume.}
	virtual_network_id=${10:# The ID of the Element SW Software Cluster Virtual Network ID to associate the access group with.}
	virtual_network_tags=${11:# The ID of the VLAN Virtual Network Tag to associate the access group with.}
	attributes=${12:# L}

endsnippet

snippet na_ontap_snapshot_policy "NetApp ONTAP manage Snapshot Policy" b
na_ontap_snapshot_policy: >
	name=${1:# N}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	enabled=${6:# Status of the snapshot policy indicating whether the policy will be enabled or disabled.}
	comment=${7:# A}
	count=${8:# R}
	schedule=${9:# Schedule to be added inside the policy.}
	snapmirror_label=${10:# SnapMirror label assigned to each schedule inside the policy. Use an empty string ('') for no label.}
	vserver=${11:# The name of the vserver to use. In a multi-tenanted environment, assigning a Snapshot Policy to a vserver will restrict its use to that vserver.}
	https=${12:no}
	validate_certs=${13:yes}
	http_port=${14:# Override the default port (80 or 443) with this port}
	ontapi=${15:# The ontap api version to use}
	use_rest=${16:Never|Always|#Auto}

endsnippet

snippet na_elementsw_cluster_pair "NetApp Element Software Manage Cluster Pair" b
na_elementsw_cluster_pair: >
	dest_mvip=${1:# Destination IP address of the cluster to be paired.}
	hostname=${2:# The hostname or IP address of the SolidFire cluster.}
	username=${3:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	dest_username=${6:# Destination username for the cluster to be paired.}
	dest_password=${7:# Destination password for the cluster to be paired.}

endsnippet

snippet netapp_e_mgmt_interface "NetApp E-Series management interface configuration" b
netapp_e_mgmt_interface: >
	controller=${1:A|B}
	api_username=${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	state=${5:enable|disable}
	name=${6:# The port to modify the configuration for.}
	channel=${7:# The port to modify the configuration for.}
	address=${8:# The IPv4 address to assign to the interface.}
	subnet_mask=${9:# The subnet mask to utilize for the interface.}
	gateway=${10:# The IPv4 gateway address to utilize for the interface.}
	config_method=${11:dhcp|static}
	dns_config_method=${12:dhcp|static}
	dns_address=${13:# Primary IPv4 DNS server address}
	dns_address_backup=${14:# Backup IPv4 DNS server address}
	ntp_config_method=${15:disable|dhcp|static}
	ntp_address=${16:# Primary IPv4 NTP server address}
	ntp_address_backup=${17:# Backup IPv4 NTP server address}
	ssh=${18:# Enable ssh access to the controller for debug purposes.}
	log_path=${19:# A local path to a file to be used for debug logging}
	validate_certs=${20:yes}
	ssid=${21:1}

endsnippet

snippet na_ontap_nvme_subsystem "NetApp ONTAP Manage NVME Subsystem" b
na_ontap_nvme_subsystem: >
	vserver=${1:# Name of the vserver to use.}
	subsystem=${2:# Specifies the subsystem}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	ostype=${7:windows|linux|vmware|xen|hyper_v}
	skip_host_check=${8:no}
	skip_mapped_check=${9:no}
	hosts=${10:# List of host NQNs (NVMe Qualification Name) associated to the controller.}
	paths=${11:# List of Namespace paths to be associated with the subsystem.}
	https=${12:no}
	validate_certs=${13:yes}
	http_port=${14:# Override the default port (80 or 443) with this port}
	ontapi=${15:# The ontap api version to use}
	use_rest=${16:Never|Always|#Auto}

endsnippet

snippet na_elementsw_volume_pair "NetApp Element Software Volume Pair" b
na_elementsw_volume_pair: >
	src_volume=${1:# Source volume name or volume ID}
	src_account=${2:# Source account name or ID}
	dest_volume=${3:# Destination volume name or volume ID}
	dest_account=${4:# Destination account name or ID}
	dest_mvip=${5:# Destination IP address of the paired cluster.}
	hostname=${6:# The hostname or IP address of the SolidFire cluster.}
	username=${7:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${8:# Password for the specified user.}

	state=${9:#present|absent}
	mode=${10:#async|sync|snapshotsonly}
	dest_username=${11:# Destination username for the paired cluster}
	dest_password=${12:# Destination password for the paired cluster}

endsnippet

snippet netapp_e_iscsi_interface "NetApp E-Series manage iSCSI interface configuration" b
netapp_e_iscsi_interface: >
	controller=${1:A|B}
	name=${2:# The channel of the port to modify the configuration of.}
	api_username=${3:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${4:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${5:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	state=${6:#enabled|disabled}
	address=${7:# The IPv4 address to assign to the interface.}
	subnet_mask=${8:# The subnet mask to utilize for the interface.}
	gateway=${9:# The IPv4 gateway address to utilize for the interface.}
	config_method=${10:#dhcp|static}
	mtu=${11:1500}
	log_path=${12:# A local path to a file to be used for debug logging}
	validate_certs=${13:yes}
	ssid=${14:1}

endsnippet

snippet na_ontap_ntp "NetApp ONTAP NTP server" b
na_ontap_ntp: >
	server_name=${1:# The name of the NTP server to manage.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	version=${6:#auto|3|4}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet na_ontap_lun "NetApp ONTAP manage LUNs" b
na_ontap_lun: >
	name=${1:# The name of the LUN to manage.}
	flexvol_name=${2:# The name of the FlexVol the LUN should exist on.}
	vserver=${3:# The name of the vserver to use.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	size=${8:# The size of the LUN in C(size_unit).}
	size_unit=${9:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	force_resize=${10:no}
	force_remove=${11:no}
	force_remove_fenced=${12:no}
	ostype=${13:image}
	space_reserve=${14:yes}
	space_allocation=${15:no}
	https=${16:no}
	validate_certs=${17:yes}
	http_port=${18:# Override the default port (80 or 443) with this port}
	ontapi=${19:# The ontap api version to use}
	use_rest=${20:Never|Always|#Auto}

endsnippet

snippet na_elementsw_cluster_config "Configure Element SW Cluster" b
na_elementsw_cluster_config: >
	hostname=${1:# The hostname or IP address of the SolidFire cluster.}
	username=${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${3:# Password for the specified user.}

	modify_cluster_full_threshold=${4:# The capacity level at which the cluster generates an event}
	encryption_at_rest=${5:present|absent}
	set_ntp_info=${6:# configure NTP on cluster node}
	enable_virtual_volumes=${7:yes}

endsnippet

snippet na_ontap_ldap "NetApp ONTAP LDAP" b
na_ontap_ldap: >
	vserver=${1:# vserver/svm configured to use LDAP}
	name=${2:# The name of LDAP client configuration}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	skip_config_validation=${7:true|false}
	https=${8:no}
	validate_certs=${9:yes}
	http_port=${10:# Override the default port (80 or 443) with this port}
	ontapi=${11:# The ontap api version to use}
	use_rest=${12:Never|Always|#Auto}

endsnippet

snippet na_ontap_ldap_client "NetApp ONTAP LDAP client" b
na_ontap_ldap_client: >
	vserver=${1:# vserver/svm that holds LDAP client configuration}
	name=${2:# The name of LDAP client configuration}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	ldap_servers=${7:# Comma separated list of LDAP servers. FQDN's or IP addresses}
	schema=${8:AD-IDMU|AD-SFU|MS-AD-BIS|RFC-2307}
	base_dn=${9:# LDAP base DN}
	base_scope=${10:subtree|onelevel|base}
	port=${11:# LDAP server port}
	query_timeout=${12:# LDAP server query timeout}
	min_bind_level=${13:anonymous|simple|sasl}
	bind_dn=${14:# LDAP bind user DN}
	bind_password=${15:# LDAP bind user password}
	use_start_tls=${16:true|false}
	referral_enabled=${17:true|false}
	session_security=${18:true|false}
	https=${19:no}
	validate_certs=${20:yes}
	http_port=${21:# Override the default port (80 or 443) with this port}
	ontapi=${22:# The ontap api version to use}
	use_rest=${23:Never|Always|#Auto}

endsnippet

snippet na_ontap_net_vlan "NetApp ONTAP network VLAN" b
na_ontap_net_vlan: >
	parent_interface=${1:# The interface that hosts the VLAN interface.}
	vlanid=${2:# The VLAN id. Ranges from 1 to 4094.}
	node=${3:# Node name of VLAN interface.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	https=${8:no}
	validate_certs=${9:yes}
	http_port=${10:# Override the default port (80 or 443) with this port}
	ontapi=${11:# The ontap api version to use}
	use_rest=${12:Never|Always|#Auto}

endsnippet

snippet na_ontap_cifs_server "NetApp ONTAP CIFS server configuration" b
na_ontap_cifs_server: >
	name=${1:# Specifies the cifs_server name.}
	vserver=${2:# The name of the vserver to use.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	service_state=${7:stopped|started}
	admin_user_name=${8:# Specifies the cifs server admin username.}
	admin_password=${9:# Specifies the cifs server admin password.}
	domain=${10:# The Fully Qualified Domain Name of the Windows Active Directory this CIFS server belongs to.}
	workgroup=${11:# The NetBIOS name of the domain or workgroup this CIFS server belongs to.}
	ou=${12:# The Organizational Unit (OU) within the Windows Active Directory this CIFS server belongs to.}
	force=${13:# If this is set and a machine account with the same name as specified in 'name' exists in the Active Directory, it will be overwritten and reused.}
	https=${14:no}
	validate_certs=${15:yes}
	http_port=${16:# Override the default port (80 or 443) with this port}
	ontapi=${17:# The ontap api version to use}
	use_rest=${18:Never|Always|#Auto}

endsnippet

snippet na_ontap_ipspace "NetApp ONTAP Manage an ipspace" b
na_ontap_ipspace: >
	name=${1:# The name of the ipspace to manage}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	from_name=${6:# Name of the existing ipspace to be renamed to name}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet netapp_e_global "NetApp E-Series manage global settings configuration" b
netapp_e_global: >
	api_username=${1:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${2:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${3:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	name=${4:# Set the name of the E-Series storage-system}
	log_path=${5:# A local path to a file to be used for debug logging}
	validate_certs=${6:yes}
	ssid=${7:1}

endsnippet

snippet na_elementsw_ldap "NetApp Element Software Manage ldap admin users" b
na_elementsw_ldap: >
	state=${1:present|absent}
	hostname=${2:# The hostname or IP address of the SolidFire cluster.}
	username=${3:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${4:# Password for the specified user.}

	authType=${5:DirectBind|SearchAndBind}
	groupSearchBaseDn=${6:# The base DN of the tree to start the group search (will do a subtree search from here)}
	groupSearchType=${7:NoGroup|ActiveDirectory|MemberDN}
	serverURIs=${8:# A comma-separated list of LDAP server URIs}
	userSearchBaseDN=${9:# The base DN of the tree to start the search (will do a subtree search from here)}
	searchBindDN=${10:# A dully qualified DN to log in with to perform an LDAp search for the user (needs read access to the LDAP directory).}
	searchBindPassword=${11:# The password for the searchBindDN account used for searching}
	userSearchFilter=${12:# the LDAP Filter to use}
	userDNTemplate=${13:# A string that is used form a fully qualified user DN.}
	groupSearchCustomFilter=${14:# For use with the CustomFilter Search type}

endsnippet

snippet na_ontap_info "NetApp information gatherer" b
na_ontap_info: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#info}
	gather_subset=${5:all}
	https=${6:no}
	validate_certs=${7:yes}
	http_port=${8:# Override the default port (80 or 443) with this port}
	ontapi=${9:# The ontap api version to use}
	use_rest=${10:Never|Always|#Auto}

endsnippet

snippet na_ontap_unix_group "NetApp ONTAP UNIX Group" b
na_ontap_unix_group: >
	name=${1:# Specifies UNIX group's name, unique for each group.}
	vserver=${2:# Specifies the Vserver for the UNIX group.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	id=${7:# Specifies an identification number for the UNIX group.}
	skip_name_validation=${8:# Specifies if group name validation is skipped.}
	users=${9:# Specifies the users associated with this group. Should be comma separated.}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet na_ontap_snapshot "NetApp ONTAP manage Snapshots" b
na_ontap_snapshot: >
	snapshot=${1:# N}
	volume=${2:# Name of the volume on which the snapshot is to be created.}
	vserver=${3:# The Vserver name}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	from_name=${8:# Name of the existing snapshot to be renamed to.}
	async_bool=${9:# If true, the snapshot is to be created asynchronously.}
	comment=${10:# A}
	snapmirror_label=${11:# A}
	ignore_owners=${12:# if this field is true, snapshot will be deleted even if some other processes are accessing it.}
	snapshot_instance_uuid=${13:# The 128 bit unique snapshot identifier expressed in the form of UUID.}
	https=${14:no}
	validate_certs=${15:yes}
	http_port=${16:# Override the default port (80 or 443) with this port}
	ontapi=${17:# The ontap api version to use}
	use_rest=${18:Never|Always|#Auto}

endsnippet

snippet na_ontap_vserver_cifs_security "NetApp ONTAP vserver CIFS security modification" b
na_ontap_vserver_cifs_security: >
	vserver=${1:# name of the vserver.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	kerberos_clock_skew=${5:# The clock skew in minutes is the tolerance for accepting tickets with time stamps that do not exactly match the host's system clock.}
	kerberos_ticket_age=${6:# Determine the maximum amount of time in hours that a user's ticket may be used for the purpose of Kerberos authentication.}
	kerberos_renew_age=${7:# Determine the maximum amount of time in days for which a ticket can be renewed.}
	kerberos_kdc_timeout=${8:# Determine the timeout value in seconds for KDC connections.}
	is_signing_required=${9:# Determine whether signing is required for incoming CIFS traffic.}
	is_password_complexity_required=${10:# Determine whether password complexity is required for local users.}
	is_aes_encryption_enabled=${11:# Determine whether AES-128 and AES-256 encryption mechanisms are enabled for Kerberos-related CIFS communication.}
	is_smb_encryption_required=${12:# Determine whether SMB encryption is required for incoming CIFS traffic.}
	lm_compatibility_level=${13:lm_ntlm_ntlmv2_krb|ntlm_ntlmv2_krb|ntlmv2_krb|krb}
	referral_enabled_for_ad_ldap=${14:# Determine whether LDAP referral chasing is enabled or not for AD LDAP connections.}
	session_security_for_ad_ldap=${15:none|sign|seal}
	smb1_enabled_for_dc_connections=${16:false|true|system_default}
	smb2_enabled_for_dc_connections=${17:false|true|system_default}
	use_start_tls_for_ad_ldap=${18:# Determine whether to use start_tls for AD LDAP connections.}
	https=${19:no}
	validate_certs=${20:yes}
	http_port=${21:# Override the default port (80 or 443) with this port}
	ontapi=${22:# The ontap api version to use}
	use_rest=${23:Never|Always|#Auto}

endsnippet

snippet na_ontap_ndmp "NetApp ONTAP NDMP services configuration" b
na_ontap_ndmp: >
	vserver=${1:# Name of the vserver.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	abort_on_disk_error=${5:# Enable abort on disk error.}
	authtype=${6:# Authentication type.}
	backup_log_enable=${7:# Enable backup log.}
	data_port_range=${8:# Data port range.}
	debug_enable=${9:# Enable debug.}
	debug_filter=${10:# Debug filter.}
	dump_detailed_stats=${11:# Enable logging of VM stats for dump.}
	dump_logical_find=${12:# Enable logical find for dump.}
	enable=${13:# Enable NDMP on vserver.}
	fh_dir_retry_interval=${14:# FH throttle value for dir.}
	fh_node_retry_interval=${15:# FH throttle value for node.}
	ignore_ctime_enabled=${16:# Ignore ctime.}
	is_secure_control_connection_enabled=${17:# Is secure control connection enabled.}
	offset_map_enable=${18:# Enable offset map.}
	per_qtree_exclude_enable=${19:# Enable per qtree exclusion.}
	preferred_interface_role=${20:# Preferred interface role.}
	restore_vm_cache_size=${21:# Restore VM file cache size.}
	secondary_debug_filter=${22:# Secondary debug filter.}
	tcpnodelay=${23:# Enable TCP nodelay.}
	tcpwinsize=${24:# TCP window size.}
	https=${25:no}
	validate_certs=${26:yes}
	http_port=${27:# Override the default port (80 or 443) with this port}
	ontapi=${28:# The ontap api version to use}
	use_rest=${29:Never|Always|#Auto}

endsnippet

snippet na_ontap_object_store "NetApp ONTAP manage object store config." b
na_ontap_object_store: >
	name=${1:# The name of the object store config to manage.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	provider_type=${6:# The name of the object store config provider.}
	server=${7:# Fully qualified domain name of the object store config.}
	container=${8:# Data bucket/container name used in S3 requests.}
	access_key=${9:# Access key ID for AWS_S3 and SGWS provider types.}
	secret_password=${10:# Secret access key for AWS_S3 and SGWS provider types.}
	https=${11:no}
	validate_certs=${12:yes}
	http_port=${13:# Override the default port (80 or 443) with this port}
	ontapi=${14:# The ontap api version to use}
	use_rest=${15:Never|Always|#Auto}

endsnippet

snippet na_ontap_qos_policy_group "NetApp ONTAP manage policy group in Quality of Service." b
na_ontap_qos_policy_group: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#present|absent}
	name=${5:# The name of the policy group to manage.}
	vserver=${6:# Name of the vserver to use.}
	from_name=${7:# Name of the existing policy group to be renamed to name.}
	max_throughput=${8:# Maximum throughput defined by this policy.}
	min_throughput=${9:# Minimum throughput defined by this policy.}
	force=${10:no}
	https=${11:no}
	validate_certs=${12:yes}
	http_port=${13:# Override the default port (80 or 443) with this port}
	ontapi=${14:# The ontap api version to use}
	use_rest=${15:Never|Always|#Auto}

endsnippet

snippet netapp_e_auth "NetApp E-Series set or update the password for a storage array." b
netapp_e_auth: >
	new_password=${1:# The password you would like to set. Cannot be more than 30 characters.}

	validate_certs=${2:yes}
	name=${3:# The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.}
	ssid=${4:# the identifier of the storage array in the Web Services Proxy.}
	set_admin=${5:no}
	current_password=${6:# The current admin password. This is not required if the password hasn't been set before.}
	api_url=${7:# The full API url.}
	api_username=${8:# The username used to authenticate against the API}
	api_password=${9:# The password used to authenticate against the API}

endsnippet

snippet na_ontap_node "NetApp ONTAP Rename a node." b
na_ontap_node: >
	name=${1:# The new name for the node}
	from_name=${2:# The name of the node to be renamed.  If I(name) already exists, no action will be performed.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	https=${6:no}
	validate_certs=${7:yes}
	http_port=${8:# Override the default port (80 or 443) with this port}
	ontapi=${9:# The ontap api version to use}
	use_rest=${10:Never|Always|#Auto}

endsnippet

snippet na_elementsw_vlan "NetApp Element Software Manage VLAN" b
na_elementsw_vlan: >
	vlan_tag=${1:# Virtual Network Tag}
	hostname=${2:# The hostname or IP address of the SolidFire cluster.}
	username=${3:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	name=${6:# User defined name for the new VLAN}
	svip=${7:# Storage virtual IP which is unique}
	address_blocks=${8:# List of address blocks for the VLAN}
	netmask=${9:# Netmask for the VLAN}
	gateway=${10:# Gateway for the VLAN}
	namespace=${11:# Enable or disable namespaces}
	attributes=${12:# Dictionary of attributes with name and value for each attribute}

endsnippet

snippet na_ontap_cifs_acl "NetApp ONTAP manage cifs-share-access-control" b
na_ontap_cifs_acl: >
	share_name=${1:# The name of the cifs-share-access-control to manage.}
	vserver=${2:# Name of the vserver to use.}
	user_or_group=${3:# The user or group name for which the permissions are listed.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	permission=${7:no_access|read|change|full_control}
	state=${8:#present|absent}
	https=${9:no}
	validate_certs=${10:yes}
	http_port=${11:# Override the default port (80 or 443) with this port}
	ontapi=${12:# The ontap api version to use}
	use_rest=${13:Never|Always|#Auto}

endsnippet

snippet na_ontap_cluster_peer "NetApp ONTAP Manage Cluster peering" b
na_ontap_cluster_peer: >
	dest_hostname=${1:# Destination cluster IP or hostname which needs to be peered}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	source_intercluster_lifs=${6:# List of intercluster addresses of the source cluster.}
	dest_intercluster_lifs=${7:# List of intercluster addresses of the destination cluster.}
	passphrase=${8:# The arbitrary passphrase that matches the one given to the peer cluster.}
	source_cluster_name=${9:# The name of the source cluster name in the peer relation to be deleted.}
	dest_cluster_name=${10:# The name of the destination cluster name in the peer relation to be deleted.}
	dest_username=${11:# Destination username.}
	dest_password=${12:# Destination password.}
	https=${13:no}
	validate_certs=${14:yes}
	http_port=${15:# Override the default port (80 or 443) with this port}
	ontapi=${16:# The ontap api version to use}
	use_rest=${17:Never|Always|#Auto}

endsnippet

snippet netapp_e_firmware "NetApp E-Series manage firmware." b
netapp_e_firmware: >
	nvsram=${1:# Path to the NVSRAM file.}
	firmware=${2:# Path to the firmware file.}
	api_username=${3:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${4:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${5:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	wait_for_completion=${6:no}
	ignore_health_check=${7:no}
	validate_certs=${8:yes}
	ssid=${9:1}

endsnippet

snippet na_ontap_vscan "NetApp ONTAP Vscan enable/disable." b
na_ontap_vscan: >
	vserver=${1:# the name of the data vserver to use.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	enable=${5:yes}
	https=${6:no}
	validate_certs=${7:yes}
	http_port=${8:# Override the default port (80 or 443) with this port}
	ontapi=${9:# The ontap api version to use}
	use_rest=${10:Never|Always|#Auto}

endsnippet

snippet netapp_e_storage_system "NetApp E-Series Web Services Proxy manage storage arrays" b
netapp_e_storage_system: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
	ssid=${4:# The ID of the array to manage. This value must be unique for each array.}
	state=${5:present|absent}
	controller_addresses=${6:# The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.}

	validate_certs=${7:yes}
	array_wwn=${8:# The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter.}
	array_password=${9:# The management password of the array to manage, if set.}
	enable_trace=${10:no}
	meta_tags=${11:# Optional meta tags to associate to this storage system}

endsnippet

snippet na_ontap_nfs "NetApp ONTAP NFS status" b
na_ontap_nfs: >
	vserver=${1:# Name of the vserver to use.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	service_state=${6:started|stopped}
	nfsv3=${7:enabled|disabled}
	nfsv3_fsid_change=${8:enabled|disabled}
	nfsv4_fsid_change=${9:enabled|disabled}
	nfsv4=${10:enabled|disabled}
	nfsv41=${11:enabled|disabled}
	nfsv41_pnfs=${12:enabled|disabled}
	nfsv4_numeric_ids=${13:enabled|disabled}
	vstorage_state=${14:enabled|disabled}
	nfsv4_id_domain=${15:# Name of the nfsv4_id_domain to use.}
	nfsv40_acl=${16:enabled|disabled}
	nfsv40_read_delegation=${17:enabled|disabled}
	nfsv40_write_delegation=${18:enabled|disabled}
	nfsv41_acl=${19:enabled|disabled}
	nfsv41_read_delegation=${20:enabled|disabled}
	nfsv41_write_delegation=${21:enabled|disabled}
	nfsv40_referrals=${22:enabled|disabled}
	nfsv41_referrals=${23:enabled|disabled}
	tcp=${24:enabled|disabled}
	udp=${25:enabled|disabled}
	showmount=${26:enabled|disabled}
	tcp_max_xfer_size=${27:# TCP Maximum Transfer Size (bytes). The default value is 65536.}
	https=${28:no}
	validate_certs=${29:yes}
	http_port=${30:# Override the default port (80 or 443) with this port}
	ontapi=${31:# The ontap api version to use}
	use_rest=${32:Never|Always|#Auto}

endsnippet

snippet na_ontap_igroup_initiator "NetApp ONTAP igroup initiator configuration" b
na_ontap_igroup_initiator: >
	names=${1:# List of initiators to manage.}
	initiator_group=${2:# Name of the initiator group to which the initiator belongs.}
	vserver=${3:# The name of the vserver to use.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	https=${8:no}
	validate_certs=${9:yes}
	http_port=${10:# Override the default port (80 or 443) with this port}
	ontapi=${11:# The ontap api version to use}
	use_rest=${12:Never|Always|#Auto}

endsnippet

snippet na_elementsw_cluster "NetApp Element Software Create Cluster" b
na_elementsw_cluster: >
	management_virtual_ip=${1:# Floating (virtual) IP address for the cluster on the management network.}
	storage_virtual_ip=${2:# Floating (virtual) IP address for the cluster on the storage (iSCSI) network.}
	nodes=${3:# Storage IP (SIP) addresses of the initial set of nodes making up the cluster.}
	hostname=${4:# The hostname or IP address of the SolidFire cluster.}
	username=${5:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${6:# Password for the specified user.}

	replica_count=${7:2}
	cluster_admin_username=${8:# Username for the cluster admin.}
	cluster_admin_password=${9:# Initial password for the cluster admin account.}
	accept_eula=${10:# Required to indicate your acceptance of the End User License Agreement when creating this cluster.}
	attributes=${11:# List of name-value pairs in JSON object format.}

endsnippet

snippet na_ontap_svm_options "NetApp ONTAP Modify SVM Options" b
na_ontap_svm_options: >
	vserver=${1:# The name of the vserver to which this option belongs to.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	name=${5:# Name of the option.}
	value=${6:# Value of the option.}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet na_ontap_broadcast_domain "NetApp ONTAP manage broadcast domains." b
na_ontap_broadcast_domain: >
	name=${1:# Specify the broadcast domain name.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	from_name=${6:# Specify the  broadcast domain name to be split into new broadcast domain.}
	mtu=${7:# Specify the required mtu for the broadcast domain.}
	ipspace=${8:# Specify the required ipspace for the broadcast domain.}
	ports=${9:# Specify the ports associated with this broadcast domain. Should be comma separated.}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet na_ontap_volume_autosize "NetApp ONTAP manage volume autosize" b
na_ontap_volume_autosize: >
	volume=${1:# The name of the flexible volume for which we want to set autosize.}
	vserver=${2:# Name of the vserver to use.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	mode=${6:grow|grow_shrink|off}
	grow_threshold_percent=${7:# Specifies the percentage of the flexible volume's capacity at which autogrow is initiated.}
	increment_size=${8:# Specify the flexible volume's increment size using the following format < number > [k|m|g|t]}
	maximum_size=${9:# Specify the flexible volume's maximum allowed size using the following format < number > [k|m|g|t]}
	minimum_size=${10:# Specify the flexible volume's minimum allowed size using the following format < number > [k|m|g|t] The amount is the absolute size to set.}
	reset=${11:# Sets the values of maximum_size, increment_size, minimum_size, grow_threshold_percent, shrink_threshold_percent and mode to their defaults}
	shrink_threshold_percent=${12:# Specifies the percentage of the flexible volume's capacity at which autoshrink is initiated.}
	https=${13:no}
	validate_certs=${14:yes}
	http_port=${15:# Override the default port (80 or 443) with this port}
	ontapi=${16:# The ontap api version to use}
	use_rest=${17:Never|Always|#Auto}

endsnippet

snippet netapp_e_amg "NetApp E-Series create, remove, and update asynchronous mirror groups" b
netapp_e_amg: >
	name=${1:# The name of the async array you wish to target, or create.}
	secondaryArrayId=${2:# The ID of the secondary array to be used in mirroring process}
	state=${3:absent|present}
	api_username=${4:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${5:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${6:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	syncIntervalMinutes=${7:10}
	manualSync=${8:no}
	recoveryWarnThresholdMinutes=${9:20}
	repoUtilizationWarnThreshold=${10:80}
	interfaceType=${11:iscsi|fibre}
	syncWarnThresholdMinutes=${12:10}
	validate_certs=${13:yes}
	ssid=${14:1}

endsnippet

snippet na_ontap_iscsi "NetApp ONTAP manage iSCSI service" b
na_ontap_iscsi: >
	vserver=${1:# The name of the vserver to use.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	service_state=${6:started|stopped}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet na_elementsw_volume_clone "NetApp Element Software Create Volume Clone" b
na_elementsw_volume_clone: >
	name=${1:# The name of the clone.}
	src_volume_id=${2:# The id of the src volume to clone. id may be a numeric identifier or a volume name.}
	account_id=${3:# Account ID for the owner of this cloned volume. id may be a numeric identifier or an account name.}
	hostname=${4:# The hostname or IP address of the SolidFire cluster.}
	username=${5:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${6:# Password for the specified user.}

	src_snapshot_id=${7:# The id of the snapshot to clone. id may be a numeric identifier or a snapshot name.}
	attributes=${8:# A}
	size=${9:# The size of the cloned volume in (size_unit).}
	size_unit=${10:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	access=${11:readOnly|readWrite|locked|replicationTarget}

endsnippet

snippet na_ontap_interface "NetApp ONTAP LIF configuration" b
na_ontap_interface: >
	interface_name=${1:# Specifies the logical interface (LIF) name.}
	vserver=${2:# The name of the vserver to use.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	home_node=${7:# Specifies the LIF's home node.}
	home_port=${8:# Specifies the LIF's home port.}
	role=${9:# Specifies the role of the LIF.}
	address=${10:# Specifies the LIF's IP address.}
	netmask=${11:# Specifies the LIF's netmask.}
	firewall_policy=${12:# Specifies the firewall policy for the LIF.}
	failover_policy=${13:disabled|system-defined|local-only|sfo-partner-only|broadcast-domain-wide}
	subnet_name=${14:# Subnet where the interface address is allocated from. If the option is not used, the IP address will need to be provided by the administrator during configuration.}
	admin_status=${15:up|down}
	is_auto_revert=${16:# I}
	force_subnet_association=${17:# S}
	protocols=${18:# Specifies the list of data protocols configured on the LIF. By default, the values in this element are nfs, cifs and fcache.}
	dns_domain_name=${19:# Specifies the unique, fully qualified domain name of the DNS zone of this LIF.}
	listen_for_dns_query=${20:# If True, this IP address will listen for DNS queries for the dnszone specified.}
	is_dns_update_enabled=${21:# Specifies if DNS update is enabled for this LIF. Dynamic updates will be sent for this LIF if updates are enabled at Vserver level.}
	https=${22:no}
	validate_certs=${23:yes}
	http_port=${24:# Override the default port (80 or 443) with this port}
	ontapi=${25:# The ontap api version to use}
	use_rest=${26:Never|Always|#Auto}

endsnippet

snippet na_ontap_firmware_upgrade "NetApp ONTAP firmware upgrade for SP, shelf, ACP, and disk." b
na_ontap_firmware_upgrade: >
	node=${1:# Node on which the device is located.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:present}
	clear_logs=${6:yes}
	package=${7:# Name of the package file containing the firmware to be installed. Not required when -baseline is true.}
	shelf_module_fw=${8:# Shelf module firmware to be updated to.}
	disk_fw=${9:# disk firmware to be updated to.}
	update_type=${10:# Type of firmware update to be performed. Options include serial_full, serial_differential, network_full.}
	install_baseline_image=${11:no}
	firmware_type=${12:service-processor|shelf|acp|disk}
	https=${13:no}
	validate_certs=${14:yes}
	http_port=${15:# Override the default port (80 or 443) with this port}
	ontapi=${16:# The ontap api version to use}
	use_rest=${17:Never|Always|#Auto}

endsnippet

snippet netapp_e_alerts "NetApp E-Series manage email notification settings" b
netapp_e_alerts: >
	api_username=${1:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${2:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${3:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	state=${4:#enabled|disabled}
	server=${5:# A fully qualified domain name, IPv4 address, or IPv6 address of a mail server.}
	sender=${6:# This is the sender that the recipient will see. It doesn't necessarily need to be a valid email account.}
	contact=${7:# Allows the owner to specify some free-form contact information to be included in the emails.}
	recipients=${8:# The email addresses that will receive the email notifications.}
	test=${9:no}
	log_path=${10:# Path to a file on the Ansible control node to be used for debug logging}
	validate_certs=${11:yes}
	ssid=${12:1}

endsnippet

snippet netapp_e_iscsi_target "NetApp E-Series manage iSCSI target configuration" b
netapp_e_iscsi_target: >
	api_username=${1:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${2:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${3:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	name=${4:# The name/alias to assign to the iSCSI target.}
	ping=${5:yes}
	chap_secret=${6:# Enable Challenge-Handshake Authentication Protocol (CHAP), utilizing this value as the password.}
	unnamed_discovery=${7:yes}
	log_path=${8:# A local path (on the Ansible controller), to a file to be used for debug logging.}
	validate_certs=${9:yes}
	ssid=${10:1}

endsnippet

snippet na_elementsw_check_connections "NetApp Element Software Check connectivity to MVIP and SVIP." b
na_elementsw_check_connections: >
	hostname=${1:# The hostname or IP address of the SolidFire cluster.}
	username=${2:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${3:# Password for the specified user.}

	skip=${4:svip|mvip}
	mvip=${5:# Optionally, use to test connection of a different MVIP.}
	svip=${6:# Optionally, use to test connection of a different SVIP.}

endsnippet

snippet netapp_e_ldap "NetApp E-Series manage LDAP integration to use for authentication" b
netapp_e_ldap: >
	username=${1:# This is the user account that will be used for querying the LDAP server.}
	password=${2:# This is the password for the bind user account.}
	server=${3:# This is the LDAP server url.}
	search_base=${4:# The search base is used to find group memberships of the user.}
	role_mappings=${5:# This is where you specify which groups should have access to what permissions for the storage-system.}
	api_username=${6:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${7:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${8:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	state=${9:#present|absent}
	identifier=${10:# This is a unique identifier for the configuration (for cases where there are multiple domains configured).}
	attributes=${11:memberOf}
	name=${12:# The domain name[s] that will be utilized when authenticating to identify which domain to utilize.}
	user_attribute=${13:sAMAccountName}
	log_path=${14:# A local path to a file to be used for debug logging}
	validate_certs=${15:yes}
	ssid=${16:1}

endsnippet

snippet na_ontap_motd "Setup motd" b
na_ontap_motd: >
	vserver=${1:# The name of the SVM motd should be set for.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	message=${6:# MOTD Text message, required when C(state=present).}
	show_cluster_motd=${7:yes}
	https=${8:no}
	validate_certs=${9:yes}
	http_port=${10:# Override the default port (80 or 443) with this port}
	ontapi=${11:# The ontap api version to use}
	use_rest=${12:Never|Always|#Auto}

endsnippet

snippet na_ontap_svm "NetApp ONTAP SVM" b
na_ontap_svm: >
	name=${1:# The name of the SVM to manage.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	from_name=${6:# Name of the SVM to be renamed}
	root_volume=${7:# Root volume of the SVM.}
	root_volume_aggregate=${8:# The aggregate on which the root volume will be created.}
	root_volume_security_style=${9:unix|ntfs|mixed|unified}
	allowed_protocols=${10:# Allowed Protocols.}
	aggr_list=${11:# List of aggregates assigned for volume operations.}
	ipspace=${12:# IPSpace name}
	snapshot_policy=${13:# Default snapshot policy setting for all volumes of the Vserver. This policy will be assigned to all volumes created in this Vserver unless the volume create request explicitly provides a snapshot policy or volume is modified later with a specific snapshot policy. A volume-level snapshot policy always overrides the default Vserver-wide snapshot policy.}
	language=${14:# Language to use for the SVM}
	subtype=${15:default|dp_destination|sync_source|sync_destination}
	comment=${16:# When specified as part of a vserver-create, this field represents the comment associated with the Vserver.}
	https=${17:no}
	validate_certs=${18:yes}
	http_port=${19:# Override the default port (80 or 443) with this port}
	ontapi=${20:# The ontap api version to use}
	use_rest=${21:Never|Always|#Auto}

endsnippet

snippet netapp_e_asup "NetApp E-Series manage auto-support settings" b
netapp_e_asup: >
	api_username=${1:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${2:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${3:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	state=${4:#enabled|disabled}
	active=${5:yes}
	start=${6:0}
	end=${7:24}
	days=${8:monday|tuesday|wednesday|thursday|friday|saturday|sunday}
	verbose=${9:no}
	log_path=${10:# A local path to a file to be used for debug logging}
	validate_certs=${11:yes}
	ssid=${12:1}

endsnippet

snippet na_ontap_cg_snapshot "NetApp ONTAP manage consistency group snapshot" b
na_ontap_cg_snapshot: >
	vserver=${1:# Name of the vserver.}
	volumes=${2:# A list of volumes in this filer that is part of this CG operation.}
	snapshot=${3:# The provided name of the snapshot that is created in each volume.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:present}
	timeout=${8:urgent|#medium|relaxed}
	snapmirror_label=${9:# A human readable SnapMirror label to be attached with the consistency group snapshot copies.}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet na_ontap_qtree "NetApp ONTAP manage qtrees" b
na_ontap_qtree: >
	name=${1:# The name of the qtree to manage.}
	flexvol_name=${2:# The name of the FlexVol the qtree should exist on. Required when C(state=present).}
	vserver=${3:# The name of the vserver to use.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	from_name=${8:# Name of the qtree to be renamed.}
	export_policy=${9:# The name of the export policy to apply.}
	security_style=${10:unix|ntfs|mixed}
	oplocks=${11:enabled|disabled}
	unix_permissions=${12:# File permissions bits of the qtree.}
	https=${13:no}
	validate_certs=${14:yes}
	http_port=${15:# Override the default port (80 or 443) with this port}
	ontapi=${16:# The ontap api version to use}
	use_rest=${17:Never|Always|#Auto}

endsnippet

snippet na_ontap_vscan_scanner_pool "NetApp ONTAP Vscan Scanner Pools Configuration." b
na_ontap_vscan_scanner_pool: >
	vserver=${1:# the name of the data vserver to use.}
	scanner_pool=${2:# the name of the virus scanner pool}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	hostnames=${7:# List of hostnames of Vscan servers which are allowed to connect to Data ONTAP}
	privileged_users=${8:# List of privileged usernames. Username must be in the form "domain-name\user-name"}
	scanner_policy=${9:primary|secondary|idle}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet na_ontap_firewall_policy "NetApp ONTAP Manage a firewall policy" b
na_ontap_firewall_policy: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#present|absent}
	allow_list=${5:# A list of IPs and masks to use.}
	policy=${6:# A policy name for the firewall policy}
	service=${7:dns|http|https|ndmp|ndmps|ntp|rsh|snmp|ssh|telnet}
	vserver=${8:# The Vserver to apply the policy to.}
	enable=${9:enable|disable}
	logging=${10:enable|disable}
	node=${11:# The node to run the firewall configuration on}
	https=${12:no}
	validate_certs=${13:yes}
	http_port=${14:# Override the default port (80 or 443) with this port}
	ontapi=${15:# The ontap api version to use}
	use_rest=${16:Never|Always|#Auto}

endsnippet

snippet na_elementsw_drive "NetApp Element Software Manage Node Drives" b
na_elementsw_drive: >
	node_id=${1:# ID or Name of cluster node.}
	hostname=${2:# The hostname or IP address of the SolidFire cluster.}
	username=${3:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${4:# Password for the specified user.}

	drive_id=${5:# Drive ID or Serial Name of Node drive.}
	state=${6:#present|absent|clean}
	force_during_upgrade=${7:# Flag to force drive operation during upgrade.}
	force_during_bin_sync=${8:# Flag to force during a bin sync operation.}

endsnippet

snippet netapp_e_snapshot_volume "NetApp E-Series manage snapshot volumes." b
netapp_e_snapshot_volume: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
	ssid=${4:# storage array ID}
	snapshot_image_id=${5:# The identifier of the snapshot image used to create the new snapshot volume.}
	name=${6:# The name you wish to give the snapshot volume}
	view_mode=${7:modeUnknown|readWrite|readOnly|__UNDEFINED}
	storage_pool_name=${8:# Name of the storage pool on which to allocate the repository volume.}
	state=${9:absent|present}

	validate_certs=${10:yes}
	full_threshold=${11:85}
	repo_percentage=${12:20}

endsnippet

snippet na_elementsw_account "NetApp Element Software Manage Accounts" b
na_elementsw_account: >
	state=${1:present|absent}
	element_username=${2:# Unique username for this account. (May be 1 to 64 characters in length).}
	hostname=${3:# The hostname or IP address of the SolidFire cluster.}
	username=${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${5:# Password for the specified user.}

	from_name=${6:# ID or Name of the account to rename.}
	initiator_secret=${7:# CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.}
	target_secret=${8:# CHAP secret to use for the target (mutual CHAP authentication).}
	attributes=${9:# L}
	status=${10:# Status of the account.}

endsnippet

snippet netapp_e_snapshot_group "NetApp E-Series manage snapshot groups" b
netapp_e_snapshot_group: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
	state=${4:present|absent}
	name=${5:# The name to give the snapshot group}
	base_volume_name=${6:# The name of the base volume or thin volume to use as the base for the new snapshot group.}
	storage_pool_name=${7:# The name of the storage pool on which to allocate the repository volume.}

	validate_certs=${8:yes}
	repo_pct=${9:20}
	warning_threshold=${10:80}
	delete_limit=${11:30}
	full_policy=${12:#purgepit|unknown|failbasewrites|__UNDEFINED}
	rollback_priority=${13:highest|high|#medium|low|lowest|__UNDEFINED}

endsnippet

snippet na_ontap_cluster "NetApp ONTAP cluster - create, join, add license" b
na_ontap_cluster: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#present}
	cluster_name=${5:# The name of the cluster to manage.}
	cluster_ip_address=${6:# IP address of cluster to be joined}
	license_code=${7:# License code to be applied to the cluster}
	license_package=${8:# License package name of the license to be removed}
	node_serial_number=${9:# Serial number of the cluster node}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet na_ontap_security_key_manager "NetApp ONTAP security key manager." b
na_ontap_security_key_manager: >
	ip_address=${1:# The IP address of the key management server.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	tcp_port=${6:5696}
	node=${7:# The node which key management server runs on.}
	https=${8:no}
	validate_certs=${9:yes}
	http_port=${10:# Override the default port (80 or 443) with this port}
	ontapi=${11:# The ontap api version to use}
	use_rest=${12:Never|Always|#Auto}

endsnippet

snippet netapp_e_drive_firmware "NetApp E-Series manage drive firmware" b
netapp_e_drive_firmware: >
	firmware=${1:# list of drive firmware file paths.}
	api_username=${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	wait_for_completion=${5:no}
	ignore_inaccessible_drives=${6:no}
	upgrade_drives_online=${7:yes}
	validate_certs=${8:yes}
	ssid=${9:1}

endsnippet

snippet na_ontap_net_subnet "NetApp ONTAP Create, delete, modify network subnets." b
na_ontap_net_subnet: >
	broadcast_domain=${1:# Specify the required broadcast_domain name for the subnet.}
	name=${2:# Specify the subnet name.}
	subnet=${3:# Specify the subnet (ip and mask).}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	from_name=${8:# Name of the subnet to be renamed}
	gateway=${9:# Specify the gateway for the default route of the subnet.}
	ipspace=${10:# Specify the ipspace for the subnet.}
	ip_ranges=${11:# Specify the list of IP address ranges associated with the subnet.}
	https=${12:no}
	validate_certs=${13:yes}
	http_port=${14:# Override the default port (80 or 443) with this port}
	ontapi=${15:# The ontap api version to use}
	use_rest=${16:Never|Always|#Auto}

endsnippet

snippet na_ontap_autosupport "NetApp ONTAP Autosupport" b
na_ontap_autosupport: >
	node_name=${1:# The name of the filer that owns the AutoSupport Configuration.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	transport=${6:http|https|smtp}
	noteto=${7:# Specifies up to five recipients of short AutoSupport e-mail messages.}
	post_url=${8:# The URL used to deliver AutoSupport messages via HTTP POST}
	mail_hosts=${9:# List of mail server(s) used to deliver AutoSupport messages via SMTP.}
	support=${10:# Specifies whether AutoSupport notification to technical support is enabled.}
	from_address=${11:# specify the e-mail address from which the node sends AutoSupport messages}
	partner_addresses=${12:# Specifies up to five partner vendor recipients of full AutoSupport e-mail messages.}
	to_addresses=${13:# Specifies up to five recipients of full AutoSupport e-mail messages.}
	proxy_url=${14:# specify an HTTP or HTTPS proxy if the 'transport' parameter is set to HTTP or HTTPS and your organization uses a proxy.}
	hostname_in_subject=${15:# Specify whether the hostname of the node is included in the subject line of the AutoSupport message.}
	https=${16:no}
	validate_certs=${17:yes}
	http_port=${18:# Override the default port (80 or 443) with this port}
	ontapi=${19:# The ontap api version to use}
	use_rest=${20:Never|Always|#Auto}

endsnippet

snippet na_ontap_portset "NetApp ONTAP Create/Delete portset" b
na_ontap_portset: >
	vserver=${1:# Name of the SVM.}
	name=${2:# Name of the port set to create.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:present}
	type=${7:fcp|iscsi|mixed}
	force=${8:no}
	ports=${9:# Specify the ports associated with this portset. Should be comma separated.}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet netapp_e_host "NetApp E-Series manage eseries hosts" b
netapp_e_host: >
	name=${1:# If the host doesn't yet exist, the label/name to assign at creation time.}
	api_username=${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	state=${5:absent|#present}
	host_type=${6:# This is the type of host to be mapped}
	ports=${7:# A list of host ports you wish to associate with the host.}
	force_port=${8:# Allow ports that are already assigned to be re-assigned to your current host}
	group=${9:# The unique identifier of the host-group you want the host to be a member of; this is used for clustering.}
	log_path=${10:# A local path to a file to be used for debug logging}
	validate_certs=${11:yes}
	ssid=${12:1}

endsnippet

snippet na_ontap_ucadapter "NetApp ONTAP UC adapter configuration" b
na_ontap_ucadapter: >
	adapter_name=${1:# Specifies the adapter name.}
	node_name=${2:# Specifies the adapter home node.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present}
	mode=${7:# Specifies the mode of the adapter.}
	type=${8:# Specifies the fc4 type of the adapter.}
	https=${9:no}
	validate_certs=${10:yes}
	http_port=${11:# Override the default port (80 or 443) with this port}
	ontapi=${12:# The ontap api version to use}
	use_rest=${13:Never|Always|#Auto}

endsnippet

snippet na_elementsw_snapshot_restore "NetApp Element Software Restore Snapshot" b
na_elementsw_snapshot_restore: >
	src_volume_id=${1:# ID or Name of source active volume.}
	src_snapshot_id=${2:# ID or Name of an existing snapshot.}
	dest_volume_name=${3:# New Name of destination for restoring the snapshot}
	account_id=${4:# Account ID or Name of Parent/Source Volume.}
	hostname=${5:# The hostname or IP address of the SolidFire cluster.}
	username=${6:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${7:# Password for the specified user.}

endsnippet

snippet na_elementsw_backup "NetApp Element Software Create Backups" b
na_elementsw_backup: >
	src_volume_id=${1:# ID of the backup source volume.}
	dest_volume_id=${2:# ID of the backup destination volume}
	hostname=${3:# The hostname or IP address of the SolidFire cluster.}
	username=${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${5:# Password for the specified user.}

	dest_hostname=${6:# hostname for the backup source cluster}
	dest_username=${7:# username for the backup destination cluster}
	dest_password=${8:# password for the backup destination cluster}
	format=${9:#native|uncompressed}
	script=${10:# the backup script to be executed}
	script_parameters=${11:# the backup script parameters}

endsnippet

snippet na_ontap_broadcast_domain_ports "NetApp ONTAP manage broadcast domain ports" b
na_ontap_broadcast_domain_ports: >
	broadcast_domain=${1:# Specify the broadcast_domain name}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	ipspace=${6:# Specify the ipspace for the broadcast domain}
	ports=${7:# Specify the list of ports to add to or remove from this broadcast domain.}
	https=${8:no}
	validate_certs=${9:yes}
	http_port=${10:# Override the default port (80 or 443) with this port}
	ontapi=${11:# The ontap api version to use}
	use_rest=${12:Never|Always|#Auto}

endsnippet

snippet na_ontap_export_policy_rule "NetApp ONTAP manage export policy rules" b
na_ontap_export_policy_rule: >
	name=${1:# The name of the export rule to manage.}
	vserver=${2:# Name of the vserver to use.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	client_match=${7:# List of Client Match host names, IP Addresses, Netgroups, or Domains}
	ro_rule=${8:any|none|never|krb5|krb5i|krb5p|ntlm|sys}
	rw_rule=${9:any|none|never|krb5|krb5i|krb5p|ntlm|sys}
	super_user_security=${10:any|none|never|krb5|krb5i|krb5p|ntlm|sys}
	allow_suid=${11:# If 'true', NFS server will honor SetUID bits in SETATTR operation. Default value on creation is 'true'}
	protocol=${12:any|nfs|nfs3|nfs4|cifs|flexcache}
	rule_index=${13:# rule index of the export policy}
	https=${14:no}
	validate_certs=${15:yes}
	http_port=${16:# Override the default port (80 or 443) with this port}
	ontapi=${17:# The ontap api version to use}
	use_rest=${18:Never|Always|#Auto}

endsnippet

snippet na_ontap_igroup "NetApp ONTAP iSCSI or FC igroup configuration" b
na_ontap_igroup: >
	name=${1:# The name of the igroup to manage.}
	vserver=${2:# The name of the vserver to use.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	initiator_group_type=${7:fcp|iscsi|mixed}
	from_name=${8:# Name of igroup to rename to name.}
	ostype=${9:# OS type of the initiators within the group.}
	initiators=${10:# List of initiators to be mapped to the igroup.}
	bind_portset=${11:# Name of a current portset to bind to the newly created igroup.}
	force_remove_initiator=${12:# Forcibly remove the initiator even if there are existing LUNs mapped to this initiator group.}
	https=${13:no}
	validate_certs=${14:yes}
	http_port=${15:# Override the default port (80 or 443) with this port}
	ontapi=${16:# The ontap api version to use}
	use_rest=${17:Never|Always|#Auto}

endsnippet

snippet na_ontap_net_ifgrp "NetApp Ontap modify network interface group" b
na_ontap_net_ifgrp: >
	name=${1:# Specifies the interface group name.}
	node=${2:# Specifies the name of node.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	distribution_function=${7:mac|ip|sequential|port}
	mode=${8:# Specifies the link policy for the ifgrp.}
	ports=${9:# List of expected ports to be present in the interface group.}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet netapp_e_snapshot_images "NetApp E-Series create and delete snapshot images" b
netapp_e_snapshot_images: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API.}
	snapshot_group=${4:# The name of the snapshot group in which you want to create a snapshot image.}
	state=${5:create|remove}

	validate_certs=${6:yes}

endsnippet

snippet netapp_e_hostgroup "NetApp E-Series manage array host groups" b
netapp_e_hostgroup: >
	state=${1:present|absent}
	api_username=${2:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${3:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${4:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	name=${5:# Name of the host group to manage}
	new_name=${6:# Specify this when you need to update the name of a host group}
	id=${7:# Host reference identifier for the host group to manage.}
	hosts=${8:# List of host names/labels to add to the group}
	validate_certs=${9:yes}
	ssid=${10:1}

endsnippet

snippet na_ontap_software_update "NetApp ONTAP Update Software" b
na_ontap_software_update: >
	package_version=${1:# Specifies the package version to update software.}
	package_url=${2:# Specifies the package URL to download the package.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	nodes=${7:# List of nodes to be updated, the nodes have to be a part of a HA Pair.}
	ignore_validation_warning=${8:no}
	https=${9:no}
	validate_certs=${10:yes}
	http_port=${11:# Override the default port (80 or 443) with this port}
	ontapi=${12:# The ontap api version to use}
	use_rest=${13:Never|Always|#Auto}

endsnippet

snippet na_ontap_kerberos_realm "NetApp ONTAP vserver nfs kerberos realm" b
na_ontap_kerberos_realm: >
	vserver=${1:# vserver/svm with kerberos realm configured}
	realm=${2:# Kerberos realm name}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	kdc_vendor=${7:Other|Microsoft}
	kdc_ip=${8:# IP address of the Key Distribution Centre (KDC) server}
	kdc_port=${9:# TCP port on the KDC to be used for Kerberos communication.}
	clock_skew=${10:# The clock skew in minutes is the tolerance for accepting tickets with time stamps that do not exactly match the host's system clock.}
	comment=${11:# Optional comment}
	admin_server_ip=${12:# IP address of the host where the Kerberos administration daemon is running. This is usually the master KDC.}
	admin_server_port=${13:# The TCP port on the Kerberos administration server where the Kerberos administration service is running.}
	pw_server_ip=${14:# IP address of the host where the Kerberos password-changing server is running.}
	pw_server_port=${15:# The TCP port on the Kerberos password-changing server where the Kerberos password-changing service is running.}
	https=${16:no}
	validate_certs=${17:yes}
	http_port=${18:# Override the default port (80 or 443) with this port}
	ontapi=${19:# The ontap api version to use}
	use_rest=${20:Never|Always|#Auto}

endsnippet

snippet na_ontap_nvme_namespace "NetApp ONTAP Manage NVME Namespace" b
na_ontap_nvme_namespace: >
	vserver=${1:# Name of the vserver to use.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	ostype=${6:windows|linux|vmware|xen|hyper_v}
	size=${7:# Size in bytes. Range is [0..2^63-1].}
	path=${8:# Namespace path.}
	https=${9:no}
	validate_certs=${10:yes}
	http_port=${11:# Override the default port (80 or 443) with this port}
	ontapi=${12:# The ontap api version to use}
	use_rest=${13:Never|Always|#Auto}

endsnippet

snippet na_ontap_vscan_on_access_policy "NetApp ONTAP Vscan on access policy configuration." b
na_ontap_vscan_on_access_policy: >
	vserver=${1:# the name of the data vserver to use.}
	policy_name=${2:# The name of the policy}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	file_ext_to_exclude=${7:# File extensions for which On-Access scanning must not be performed.}
	file_ext_to_include=${8:# File extensions for which On-Access scanning is considered. The default value is '*', which means that all files are considered for scanning except}
	filters=${9:# A list of filters which can be used to define the scope of the On-Access policy more precisely. The filters can be added in any order. Possible values}
	is_scan_mandatory=${10:# Specifies whether access to a file is allowed if there are no external virus-scanning servers available for virus scanning. It is true if not provided at the time of creating a policy.}
	max_file_size=${11:# Max file-size (in bytes) allowed for scanning. The default value of 2147483648 (2GB) is taken if not provided at the time of creating a policy.}
	paths_to_exclude=${12:# File paths for which On-Access scanning must not be performed.}
	scan_files_with_no_ext=${13:yes}
	https=${14:no}
	validate_certs=${15:yes}
	http_port=${16:# Override the default port (80 or 443) with this port}
	ontapi=${17:# The ontap api version to use}
	use_rest=${18:Never|Always|#Auto}

endsnippet

snippet na_ontap_vserver_peer "NetApp ONTAP Vserver peering" b
na_ontap_vserver_peer: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#present|absent}
	vserver=${5:# Specifies name of the source Vserver in the relationship.}
	applications=${6:snapmirror|file_copy|lun_copy|flexcache}
	peer_vserver=${7:# Specifies name of the peer Vserver in the relationship.}
	peer_cluster=${8:# Specifies name of the peer Cluster.}
	dest_hostname=${9:# Destination hostname or IP address.}
	dest_username=${10:# Destination username.}
	dest_password=${11:# Destination password.}
	https=${12:no}
	validate_certs=${13:yes}
	http_port=${14:# Override the default port (80 or 443) with this port}
	ontapi=${15:# The ontap api version to use}
	use_rest=${16:Never|Always|#Auto}

endsnippet

snippet na_ontap_lun_copy "NetApp ONTAP copy LUNs" b
na_ontap_lun_copy: >
	destination_vserver=${1:# the name of the Vserver that will host the new LUN.}
	destination_path=${2:# Specifies the full path to the new LUN.}
	source_path=${3:# Specifies the full path to the source LUN.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present}
	source_vserver=${8:# Specifies the name of the vserver hosting the LUN to be copied.}
	https=${9:no}
	validate_certs=${10:yes}
	http_port=${11:# Override the default port (80 or 443) with this port}
	ontapi=${12:# The ontap api version to use}
	use_rest=${13:Never|Always|#Auto}

endsnippet

snippet na_ontap_license "NetApp ONTAP protocol and feature licenses" b
na_ontap_license: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#present|absent}
	remove_unused=${5:# Remove licenses that have no controller affiliation in the cluster.}
	remove_expired=${6:# Remove licenses that have expired in the cluster.}
	serial_number=${7:# S}
	license_names=${8:# List of license-names to delete.}
	license_codes=${9:# List of license codes to be added.}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet na_elementsw_network_interfaces "NetApp Element Software Configure Node Network Interfaces" b
na_elementsw_network_interfaces: >
	method=${1:loopback|manual|dhcp|static}
	ip_address_1g=${2:# IP address for the 1G network.}
	ip_address_10g=${3:# IP address for the 10G network.}
	subnet_1g=${4:# 1GbE Subnet Mask.}
	subnet_10g=${5:# 10GbE Subnet Mask.}
	gateway_address_1g=${6:# Router network address to send packets out of the local network.}
	gateway_address_10g=${7:# Router network address to send packets out of the local network.}
	hostname=${8:# The hostname or IP address of the SolidFire cluster.}
	username=${9:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${10:# Password for the specified user.}

	mtu_1g=${11:1500}
	mtu_10g=${12:1500}
	dns_nameservers=${13:# List of addresses for domain name servers.}
	dns_search_domains=${14:# List of DNS search domains.}
	bond_mode_1g=${15:#ActivePassive|ALB|LACP}
	bond_mode_10g=${16:#ActivePassive|ALB|LACP}
	lacp_1g=${17:Fast|#Slow}
	lacp_10g=${18:Fast|#Slow}
	virtual_network_tag=${19:# This is the primary network tag. All nodes in a cluster have the same VLAN tag.}

endsnippet

snippet na_elementsw_admin_users "NetApp Element Software Manage Admin Users" b
na_elementsw_admin_users: >
	state=${1:present|absent}
	element_username=${2:# Unique username for this account. (May be 1 to 64 characters in length).}
	hostname=${3:# The hostname or IP address of the SolidFire cluster.}
	username=${4:# Please ensure that the user has the adequate permissions. For more information, please read the official documentation U(https://mysupport.netapp.com/documentation/docweb/index.html?productID=62636&language=en-US).}
	password=${5:# Password for the specified user.}

	element_password=${6:# The password for the new admin account. Setting the password attribute will always reset your password, even if the password is the same}
	acceptEula=${7:# Boolean, true for accepting Eula, False Eula}
	access=${8:# A list of type the admin has access to}

endsnippet

snippet na_ontap_snmp "NetApp ONTAP SNMP community" b
na_ontap_snmp: >
	access_control=${1:# Access control for the community. The only supported value is 'ro' (read-only)}
	community_name=${2:# The name of the SNMP community to manage.}
	hostname=${3:# The hostname or IP address of the ONTAP instance.}
	username=${4:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${5:# Password for the specified user.}

	state=${6:#present|absent}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet na_ontap_disks "NetApp ONTAP Assign disks to nodes" b
na_ontap_disks: >
	node=${1:# It specifies the node to assign all visible unowned disks.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	disk_count=${5:# Total number of disks a node should own}
	https=${6:no}
	validate_certs=${7:yes}
	http_port=${8:# Override the default port (80 or 443) with this port}
	ontapi=${9:# The ontap api version to use}
	use_rest=${10:Never|Always|#Auto}

endsnippet

snippet na_ontap_aggregate "NetApp ONTAP manage aggregates." b
na_ontap_aggregate: >
	name=${1:# The name of the aggregate to manage.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	service_state=${6:online|offline}
	from_name=${7:# Name of the aggregate to be renamed.}
	nodes=${8:# Node(s) for the aggregate to be created on.  If no node specified, mgmt lif home will be used.}
	disk_type=${9:ATA|BSAS|FCAL|FSAS|LUN|MSATA|SAS|SSD|VMDISK}
	disk_count=${10:# Number of disks to place into the aggregate, including parity disks.}
	disk_size=${11:# Disk size to use in 4K block size.  Disks within 10% of specified size will be used.}
	raid_size=${12:# Sets the maximum number of drives per raid group.}
	raid_type=${13:raid4|raid_dp|raid_tec}
	unmount_volumes=${14:# If set to "TRUE", this option specifies that all of the volumes hosted by the given aggregate are to be unmounted}
	disks=${15:# Specific list of disks to use for the new aggregate.}
	is_mirrored=${16:# Specifies that the new aggregate be mirrored (have two plexes).}
	mirror_disks=${17:# List of mirror disks to use. It must contain the same number of disks specified in 'disks'.}
	spare_pool=${18:Pool0|Pool1}
	wait_for_online=${19:no}
	time_out=${20:100}
	https=${21:no}
	validate_certs=${22:yes}
	http_port=${23:# Override the default port (80 or 443) with this port}
	ontapi=${24:# The ontap api version to use}
	use_rest=${25:Never|Always|#Auto}

endsnippet

snippet netapp_e_storagepool "NetApp E-Series manage volume groups and disk pools" b
netapp_e_storagepool: >
	state=${1:present|absent}
	name=${2:# The name of the storage pool to manage}
	api_username=${3:# The username to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_password=${4:# The password to authenticate with the SANtricity Web Services Proxy or Embedded Web Services API.}
	api_url=${5:# The url to the SANtricity Web Services Proxy or Embedded Web Services API. Example https://prod-1.wahoo.acme.com/devmgr/v2}

	criteria_drive_count=${6:# The number of disks to use for building the storage pool.}
	criteria_min_usable_capacity=${7:# The minimum size of the storage pool (in size_unit).}
	criteria_drive_type=${8:hdd|ssd}
	criteria_size_unit=${9:bytes|b|kb|mb|#gb|tb|pb|eb|zb|yb}
	criteria_drive_min_size=${10:# The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.}
	criteria_drive_interface_type=${11:sas|sas4k|fibre|fibre520b|scsi|sata|pata}
	criteria_drive_require_da=${12:no}
	criteria_drive_require_fde=${13:no}
	raid_level=${14:raidAll|raid0|raid1|raid3|raid5|raid6|#raidDiskPool}
	secure_pool=${15:# Enables security at rest feature on the storage pool.}
	reserve_drive_count=${16:# Set the number of drives reserved by the storage pool for reconstruction operations.}
	remove_volumes=${17:yes}
	erase_secured_drives=${18:yes}
	validate_certs=${19:yes}
	ssid=${20:1}

endsnippet

snippet na_ontap_fcp "NetApp ONTAP Start, Stop and Enable FCP services." b
na_ontap_fcp: >
	vserver=${1:# The name of the vserver to use.}
	hostname=${2:# The hostname or IP address of the ONTAP instance.}
	username=${3:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${4:# Password for the specified user.}

	state=${5:#present|absent}
	status=${6:#up|down}
	https=${7:no}
	validate_certs=${8:yes}
	http_port=${9:# Override the default port (80 or 443) with this port}
	ontapi=${10:# The ontap api version to use}
	use_rest=${11:Never|Always|#Auto}

endsnippet

snippet na_ontap_user_role "NetApp ONTAP user role configuration and management" b
na_ontap_user_role: >
	name=${1:# The name of the role to manage.}
	command_directory_name=${2:# The command or command directory to which the role has an access.}
	vserver=${3:# The name of the vserver to use.}
	hostname=${4:# The hostname or IP address of the ONTAP instance.}
	username=${5:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${6:# Password for the specified user.}

	state=${7:#present|absent}
	access_level=${8:none|readonly|#all}
	query=${9:# A query for the role. The query must apply to the specified command or directory name.}
	https=${10:no}
	validate_certs=${11:yes}
	http_port=${12:# Override the default port (80 or 443) with this port}
	ontapi=${13:# The ontap api version to use}
	use_rest=${14:Never|Always|#Auto}

endsnippet

snippet netapp_e_volume_copy "NetApp E-Series create volume copy pairs" b
netapp_e_volume_copy: >
	api_username=${1:# The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_password=${2:# The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.}
	api_url=${3:# The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2).}
	state=${4:present|absent}

	validate_certs=${5:yes}
	source_volume_id=${6:# The id of the volume copy source.}
	destination_volume_id=${7:# The id of the volume copy destination.}
	volume_copy_pair_id=${8:# The id of a given volume copy pair}
	create_copy_pair_if_does_not_exist=${9:yes}
	start_stop_copy=${10:# starts a re-copy or stops a copy in progress}
	search_volume_id=${11:# Searches for all valid potential target and source volumes that could be used in a copy_pair}
	ssid=${12:1}

endsnippet

snippet na_ontap_cluster_ha "NetApp ONTAP Manage HA status for cluster" b
na_ontap_cluster_ha: >
	hostname=${1:# The hostname or IP address of the ONTAP instance.}
	username=${2:# This can be a Cluster-scoped or SVM-scoped account, depending on whether a Cluster-level or SVM-level API is required. For more information, please read the documentation U(https://mysupport.netapp.com/NOW/download/software/nmsdk/9.4/).}
	password=${3:# Password for the specified user.}

	state=${4:#present|absent}
	https=${5:no}
	validate_certs=${6:yes}
	http_port=${7:# Override the default port (80 or 443) with this port}
	ontapi=${8:# The ontap api version to use}
	use_rest=${9:Never|Always|#Auto}

endsnippet

snippet gluster_heal_info "Gather information on self-heal or rebalance status" b
gluster_heal_info: >
	name=${1:# The volume name.}

	status_filter=${2:#self-heal|rebalance}

endsnippet

snippet gluster_volume "Manage GlusterFS volumes" b
gluster_volume: >
	name=${1:# The volume name.}
	state=${2:absent|present|started|stopped}

	cluster=${3:# List of hosts to use for probing and brick setup.}
	host=${4:# Override local hostname (for peer probing purposes).}
	replicas=${5:# Replica count for volume.}
	arbiters=${6:# Arbiter count for volume.}
	stripes=${7:# Stripe count for volume.}
	disperses=${8:# Disperse count for volume.}
	redundancies=${9:# Redundancy count for volume.}
	transport=${10:#tcp|rdma|tcp,rdma}
	bricks=${11:# Brick paths on servers. Multiple brick paths can be separated by commas.}
	start_on_create=${12:yes}
	rebalance=${13:no}
	directory=${14:# Directory for limit-usage.}
	options=${15:# A dictionary/hash with options/settings for the volume.}
	quota=${16:# Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list).}
	force=${17:# If brick is being created in the root partition, module will fail. Set force to true to override this behaviour.}

endsnippet

snippet gluster_heal_info "Gather information on self-heal or rebalance status" b
gluster_heal_info: >
	name=${1:# The volume name.}

	status_filter=${2:#self-heal|rebalance}

endsnippet

snippet gluster_peer "Attach/Detach peers to/from the cluster" b
gluster_peer: >
	state=${1:#present|absent}
	nodes=${2:# List of nodes that have to be probed into the pool.}

	force=${3:false}

endsnippet

snippet vexata_volume "Manage volumes on Vexata VX100 storage arrays" b
vexata_volume: >
	name=${1:# Volume name.}
	array=${2:# Vexata VX100 array hostname or IPv4 Address.}

	state=${3:#present|absent}
	size=${4:# Volume size in M, G, T units. M=2^20, G=2^30, T=2^40 bytes.}
	user=${5:# Vexata API user with administrative privileges.}
	password=${6:# Vexata API user password.}
	validate_certs=${7:no}

endsnippet

snippet vexata_eg "Manage export groups on Vexata VX100 storage arrays" b
vexata_eg: >
	name=${1:# Export group name.}
	array=${2:# Vexata VX100 array hostname or IPv4 Address.}

	state=${3:#present|absent}
	vg=${4:# Volume group name.}
	ig=${5:# Initiator group name.}
	pg=${6:# Port group name.}
	user=${7:# Vexata API user with administrative privileges.}
	password=${8:# Vexata API user password.}
	validate_certs=${9:no}

endsnippet

snippet purefb_ra "Enable or Disable Pure Storage FlashBlade Remote Assist" b
purefb_ra: >
	state=${1:#present|absent}
	fb_url=${2:# FlashBlade management IP address or Hostname.}
	api_token=${3:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefb_network "Manage network interfaces in a Pure Storage FlashBlade" b
purefb_network: >
	name=${1:# Interface Name.}

	state=${2:#present|absent}
	address=${3:# IP address of interface.}
	services=${4:#data}
	itype=${5:#vip}
	fb_url=${6:# FlashBlade management IP address or Hostname.}
	api_token=${7:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefb_snap "Manage filesystem snapshots on Pure Storage FlashBlades" b
purefb_snap: >
	name=${1:# The name of the source filesystem.}

	suffix=${2:# Suffix of snapshot name.}
	state=${3:absent|#present}
	eradicate=${4:no}
	fb_url=${5:# FlashBlade management IP address or Hostname.}
	api_token=${6:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefa_ds "Configure FlashArray Directory Service" b
purefa_ds: >
	base_dn=${1:# Sets the base of the Distinguished Name (DN) of the directory service groups. The base should consist of only Domain Components (DCs). The base_dn will populate with a default value when a URI is entered by parsing domain components from the URI. The base DN should specify DC= for each domain component and multiple DCs should be separated by commas.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	enable=${5:no}
	uri=${6:# A list of up to 30 URIs of the directory servers. Each URI must include the scheme ldap:// or ldaps:// (for LDAP over SSL), a hostname, and a domain name or IP address. For example, ldap://ad.company.com configures the directory service with the hostname "ad" in the domain "company.com" while specifying the unencrypted LDAP protocol.}
	bind_password=${7:# Sets the password of the bind_user user name account.}
	bind_user=${8:# Sets the user name that can be used to bind to and query the directory.}
	group_base=${9:# Specifies where the configured groups are located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right. Each OU should not exceed 64 characters in length.}
	ro_group=${10:# Sets the common Name (CN) of the configured directory service group containing users with read-only privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.}
	sa_group=${11:# Sets the common Name (CN) of the configured directory service group containing administrators with storage-related privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.}
	aa_group=${12:# Sets the common Name (CN) of the directory service group containing administrators with full privileges when managing the FlashArray. The name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.}

endsnippet

snippet purefa_user "Create, modify or delete FlashArray local user account" b
purefa_user: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:absent|#present}
	name=${4:# The name of the local user account}
	role=${5:readonly|storage_admin|array_admin}
	password=${6:# Password for the local user.}
	old_password=${7:# If changing an existing password, you must provide the old password for security}
	api=${8:no}

endsnippet

snippet purefa_ntp "Configure Pure Storage FlashArray NTP settings" b
purefa_ntp: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:absent|#present}
	ntp_servers=${4:# A list of up to 4 alternate NTP servers. These may include IPv4, IPv6 or FQDNs. Invalid IP addresses will cause the module to fail. No validation is performed for FQDNs.}

endsnippet

snippet purefb_dsrole "Configure FlashBlade  Management Directory Service Roles" b
purefb_dsrole: >
	state=${1:absent|#present}
	role=${2:array_admin|ops_admin|readonly|storage_admin}
	group_base=${3:# Specifies where the configured group is located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right.}
	group=${4:# Sets the common Name (CN) of the configured directory service group containing users for the FlashBlade. This name should be just the Common Name of the group without the CN= specifier.}
	fb_url=${5:# FlashBlade management IP address or Hostname.}
	api_token=${6:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefa_host "Manage hosts on Pure Storage FlashArrays" b
purefa_host: >
	host=${1:# The name of the host.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	protocol=${5:fc|#iscsi|nvme|mixed}
	wwns=${6:# List of wwns of the host if protocol is fc or mixed.}
	iqn=${7:# List of IQNs of the host if protocol is iscsi or mixed.}
	nqn=${8:# List of NQNs of the host if protocol is nvme or mixed.}
	volume=${9:# Volume name to map to the host.}
	lun=${10:# LUN ID to assign to volume for host. Must be unique.}
	personality=${11:hpux|vms|aix|esxi|solaris|hitachi-vsp|oracle-vm-server|delete|#}
	preferred_array=${12:# List of preferred arrays in an ActiveCluster environment.}

endsnippet

snippet purefb_ds "Configure FlashBlade Directory Service" b
purefb_ds: >
	base_dn=${1:# Sets the base of the Distinguished Name (DN) of the directory service groups. The base should consist of only Domain Components (DCs). The base_dn will populate with a default value when a URI is entered by parsing domain components from the URI. The base DN should specify DC= for each domain component and multiple DCs should be separated by commas.}

	state=${2:absent|#present}
	dstype=${3:management|nfs|smb}
	enable=${4:no}
	uri=${5:# A list of up to 30 URIs of the directory servers. Each URI must include the scheme ldap:// or ldaps:// (for LDAP over SSL), a hostname, and a domain name or IP address. For example, ldap://ad.company.com configures the directory service with the hostname "ad" in the domain "company.com" while specifying the unencrypted LDAP protocol.}
	bind_password=${6:# Sets the password of the bind_user user name account.}
	bind_user=${7:# Sets the user name that can be used to bind to and query the directory.}
	nis_servers=${8:# A list of up to 30 IP addresses or FQDNs for NIS servers.}
	nis_domain=${9:# The NIS domain to search}
	join_ou=${10:# The optional organizational unit (OU) where the machine account for the directory service will be created.}
	fb_url=${11:# FlashBlade management IP address or Hostname.}
	api_token=${12:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefa_ra "Enable or Disable Pure Storage FlashArray Remote Assist" b
purefa_ra: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:#enable|disable}

endsnippet

snippet purefb_fs "Manage filesystemon Pure Storage FlashBlade`" b
purefb_fs: >
	name=${1:# Filesystem Name.}

	state=${2:#present|absent}
	eradicate=${3:no}
	size=${4:32G}
	nfsv3=${5:yes}
	nfsv4=${6:yes}
	nfs=${7:yes}
	nfs_rules=${8:*(rw,no_root_squash)}
	smb=${9:no}
	http=${10:no}
	snapshot=${11:no}
	fastremove=${12:no}
	hard_limit=${13:no}
	user_quota=${14:# Default quota in M, G, T or P units for a user under this file system.}
	group_quota=${15:# Default quota in M, G, T or P units for a group under this file system.}
	fb_url=${16:# FlashBlade management IP address or Hostname.}
	api_token=${17:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefa_snap "Manage volume snapshots on Pure Storage FlashArrays" b
purefa_snap: >
	name=${1:# The name of the source volume.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	suffix=${4:# Suffix of snapshot name.}
	target=${5:# Name of target volume if creating from snapshot.}
	overwrite=${6:no}
	state=${7:absent|copy|#present}
	eradicate=${8:no}

endsnippet

snippet purefa_connect "Manage replication connections between two FlashArrays" b
purefa_connect: >
	target_url=${1:# Management IP address of remote array.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	target_api=${5:# API token for target array}
	connection=${6:sync|#async}

endsnippet

snippet purefa_dns "Configure FlashArray DNS settings" b
purefa_dns: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:absent|#present}
	domain=${4:# Domain suffix to be appended when performing DNS lookups.}
	nameservers=${5:# List of up to 3 unique DNS server IP addresses. These can be IPv4 or IPv6 - No validation is done of the addresses is performed.}

endsnippet

snippet purefb_s3user "Create or delete FlashBlade Object Store account users" b
purefb_s3user: >
	state=${1:absent|#present}
	name=${2:# The name of object store user}
	account=${3:# The name of object store account associated with user}
	access_key=${4:yes}
	fb_url=${5:# FlashBlade management IP address or Hostname.}
	api_token=${6:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefa_hg "Manage hostgroups on Pure Storage FlashArrays" b
purefa_hg: >
	hostgroup=${1:# The name of the hostgroup.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	host=${5:# List of existing hosts to add to hostgroup.}
	volume=${6:# List of existing volumes to add to hostgroup.}

endsnippet

snippet purefa_volume "Manage volumes on Pure Storage FlashArrays" b
purefa_volume: >
	name=${1:# The name of the volume.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	target=${4:# The name of the target volume, if copying.}
	state=${5:absent|#present}
	eradicate=${6:no}
	overwrite=${7:no}
	size=${8:# Volume size in M, G, T or P units.}
	qos=${9:# Bandwidth limit for volume in M or G units. M will set MB/s G will set GB/s To clear an existing Qos setting using 0 (zero)}

endsnippet

snippet purefb_info "Collect information from Pure Storage FlashBlade" b
purefb_info: >
	gather_subset=${1:minimum}
	fb_url=${2:# FlashBlade management IP address or Hostname.}
	api_token=${3:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefa_pg "Manage protection groups on Pure Storage FlashArrays" b
purefa_pg: >
	pgroup=${1:# The name of the protection group.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	volume=${5:# List of existing volumes to add to protection group.}
	host=${6:# List of existing hosts to add to protection group.}
	hostgroup=${7:# List of existing hostgroups to add to protection group.}
	eradicate=${8:no}
	enabled=${9:yes}
	target=${10:# List of remote arrays or offload target for replication protection group to connect to.}

endsnippet

snippet purefa_snmp "Configure FlashArray SNMP Managers" b
purefa_snmp: >
	name=${1:# Name of SNMP Manager}
	host=${2:# IPv4 or IPv6 address or FQDN to send trap messages to.}
	fa_url=${3:# FlashArray management IPv4 address or Hostname.}
	api_token=${4:# FlashArray API token for admin privileged user.}

	state=${5:absent|#present}
	auth_passphrase=${6:# SNMPv3 only. Passphrase of 8 - 32 characters.}
	auth_protocol=${7:MD5|SHA}
	community=${8:# SNMP v2c only. Manager community ID. Between 1 and 32 characters long.}
	user=${9:# SNMP v3 only. User ID recognized by the specified SNMP manager. Must be between 1 and 32 characters.}
	version=${10:#v2c|v3}
	notification=${11:inform|#trap}
	privacy_passphrase=${12:# SNMPv3 only. Passphrase to encrypt SNMP messages. Must be between 8 and 63 non-space ASCII characters.}
	privacy_protocol=${13:AES|DES}

endsnippet

snippet purefa_syslog "Configure Pure Storage FlashArray syslog settings" b
purefa_syslog: >
	protocol=${1:tcp|tls|udp}
	address=${2:# Syslog server address. This field supports IPv4, IPv6 or FQDN. An invalid IP addresses will cause the module to fail. No validation is performed for FQDNs.}
	fa_url=${3:# FlashArray management IPv4 address or Hostname.}
	api_token=${4:# FlashArray API token for admin privileged user.}

	state=${5:absent|#present}
	port=${6:# Port at which the server is listening. If no port is specified the system will use 514}

endsnippet

snippet purefa_phonehome "Enable or Disable Pure Storage FlashArray Phonehome" b
purefa_phonehome: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:#present|absent}

endsnippet

snippet purefa_smtp "Configure FlashArray SMTP settings" b
purefa_smtp: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:absent|#present}
	password=${4:# The SMTP password.}
	user=${5:# The SMTP username.}
	relay_host=${6:# IPv4 or IPv6 address or FQDN. A port number may be appended.}
	sender_domain=${7:# Domain name.}

endsnippet

snippet purefa_offload "Create, modify and delete NFS or S3 offload targets" b
purefa_offload: >
	name=${1:# The name of the offload target}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	protocol=${5:#nfs|s3}
	address=${6:# The IP or FQDN address of the NFS server}
	share=${7:# NFS export on the NFS server}
	options=${8:}
	access_key=${9:# Access Key ID of the S3 target}
	bucket=${10:# Name of the bucket for the S3 target}
	secret=${11:# Secret Access Key for the S3 target}
	initialize=${12:yes}

endsnippet

snippet purefa_vg "Manage volume groups on Pure Storage FlashArrays" b
purefa_vg: >
	vgroup=${1:# The name of the volume group.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	eradicate=${5:no}

endsnippet

snippet purefa_alert "Configure Pure Storage FlashArray alert email settings" b
purefa_alert: >
	address=${1:# Email address (valid format required)}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:absent|#present}
	enabled=${5:yes}

endsnippet

snippet purefa_info "Collect information from Pure Storage FlashArray" b
purefa_info: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	gather_subset=${3:minimum}

endsnippet

snippet purefa_arrayname "Configure Pure Storage FlashArray array name" b
purefa_arrayname: >
	name=${1:# Name of the array. Must conform to correct naming schema.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	state=${4:#present}

endsnippet

snippet purefb_subnet "Manage network subnets in a Pure Storage FlashBlade" b
purefb_subnet: >
	name=${1:# Subnet Name.}

	state=${2:#present|absent}
	gateway=${3:# IPv4 or IPv6 address of subnet gateway.}
	mtu=${4:1500}
	prefix=${5:# IPv4 or IPv6 address associated with the subnet.}
	vlan=${6:0}
	fb_url=${7:# FlashBlade management IP address or Hostname.}
	api_token=${8:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefb_bucket "Manage Object Store Buckets on a  Pure Storage FlashBlade." b
purefb_bucket: >
	name=${1:# Bucket Name.}
	account=${2:# Object Store Account for Bucket.}

	state=${3:#present|absent}
	eradicate=${4:no}
	fb_url=${5:# FlashBlade management IP address or Hostname.}
	api_token=${6:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefb_s3acc "Create or delete FlashBlade Object Store accounts" b
purefb_s3acc: >
	state=${1:absent|#present}
	name=${2:# The name of object store account}
	fb_url=${3:# FlashBlade management IP address or Hostname.}
	api_token=${4:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefb_smtp "Configure SMTP for Pure Storage FlashBlade" b
purefb_smtp: >
	domain=${1:# D}

	host=${2:# R}
	fb_url=${3:# FlashBlade management IP address or Hostname.}
	api_token=${4:# FlashBlade API token for admin privileged user.}

endsnippet

snippet purefa_pgsnap "Manage protection group snapshots on Pure Storage FlashArrays" b
purefa_pgsnap: >
	name=${1:# The name of the source protection group.}
	fa_url=${2:# FlashArray management IPv4 address or Hostname.}
	api_token=${3:# FlashArray API token for admin privileged user.}

	suffix=${4:# Suffix of snapshot name.}
	state=${5:absent|#present|copy}
	eradicate=${6:no}
	restore=${7:# Restore a specific volume from a protection group snapshot.}
	overwrite=${8:no}
	target=${9:# Volume to restore a specified volume to.}
	now=${10:no}
	apply_retention=${11:no}
	remote=${12:no}

endsnippet

snippet purefa_banner "Configure Pure Storage FlashArray GUI and SSH MOTD message" b
purefa_banner: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:#present|absent}
	banner=${4:Welcome to the machine...}

endsnippet

snippet purefa_dsrole "Configure FlashArray Directory Service Roles" b
purefa_dsrole: >
	fa_url=${1:# FlashArray management IPv4 address or Hostname.}
	api_token=${2:# FlashArray API token for admin privileged user.}

	state=${3:absent|#present}
	role=${4:array_admin|ops_admin|readonly|storage_admin}
	group_base=${5:# Specifies where the configured group is located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right.}
	group=${6:# Sets the common Name (CN) of the configured directory service group containing users for the FlashBlade. This name should be just the Common Name of the group without the CN= specifier.}

endsnippet

snippet ibm_sa_host "Adds hosts to or removes them from IBM Spectrum Accelerate Family storage systems." b
ibm_sa_host: >
	host=${1:# Host name.}
	state=${2:#present|absent}
	username=${3:# Management user on the spectrum accelerate storage system.}
	password=${4:# Password for username on the spectrum accelerate storage system.}
	endpoints=${5:# The hostname or management IP of Spectrum Accelerate storage system.}

	cluster=${6:# The name of the cluster to include the host.}
	domain=${7:# The domains the cluster will be attached to. To include more than one domain, separate domain names with commas. To include all existing domains, use an asterisk ("*").}
	iscsi_chap_name=${8:# The host's CHAP name identifier}
	iscsi_chap_secret=${9:# The password of the initiator used to authenticate to the system when CHAP is enable}

endsnippet

snippet ibm_sa_domain "Manages domains on IBM Spectrum Accelerate Family storage systems" b
ibm_sa_domain: >
	domain=${1:# Name of the domain to be managed.}
	state=${2:#present|absent}
	username=${3:# Management user on the spectrum accelerate storage system.}
	password=${4:# Password for username on the spectrum accelerate storage system.}
	endpoints=${5:# The hostname or management IP of Spectrum Accelerate storage system.}

	ldap_id=${6:# ldap id to add to the domain.}
	size=${7:# Size of the domain.}
	hard_capacity=${8:# Hard capacity of the domain.}
	soft_capacity=${9:# Soft capacity of the domain.}
	max_cgs=${10:# Number of max cgs.}
	max_dms=${11:# Number of max dms.}
	max_mirrors=${12:# Number of max_mirrors.}
	max_pools=${13:# Number of max_pools.}
	max_volumes=${14:# Number of max_volumes.}
	perf_class=${15:# Add the domain to a performance class.}

endsnippet

snippet ibm_sa_host_ports "Add host ports on IBM Spectrum Accelerate Family storage systems." b
ibm_sa_host_ports: >
	host=${1:# Host name.}
	state=${2:#present|absent}
	username=${3:# Management user on the spectrum accelerate storage system.}
	password=${4:# Password for username on the spectrum accelerate storage system.}
	endpoints=${5:# The hostname or management IP of Spectrum Accelerate storage system.}

	iscsi_name=${6:# iSCSI initiator name.}
	fcaddress=${7:# Fiber channel address.}
	num_of_visible_targets=${8:# Number of visible targets.}

endsnippet

snippet ibm_sa_vol_map "Handles volume mapping on IBM Spectrum Accelerate Family storage systems." b
ibm_sa_vol_map: >
	vol=${1:# Volume name.}
	state=${2:#present|absent}
	username=${3:# Management user on the spectrum accelerate storage system.}
	password=${4:# Password for username on the spectrum accelerate storage system.}
	endpoints=${5:# The hostname or management IP of Spectrum Accelerate storage system.}

	cluster=${6:# Maps the volume to a cluster.}
	host=${7:# Maps the volume to a host.}
	lun=${8:# The LUN identifier.}
	override=${9:# Overrides the existing volume mapping.}

endsnippet

snippet ibm_sa_pool "Handles pools on IBM Spectrum Accelerate Family storage systems." b
ibm_sa_pool: >
	pool=${1:# Pool name.}
	state=${2:#present|absent}
	username=${3:# Management user on the spectrum accelerate storage system.}
	password=${4:# Password for username on the spectrum accelerate storage system.}
	endpoints=${5:# The hostname or management IP of Spectrum Accelerate storage system.}

	size=${6:# Pool size in GB}
	snapshot_size=${7:# Pool snapshot size in GB}
	domain=${8:# Adds the pool to the specified domain.}
	perf_class=${9:# Assigns a perf_class to the pool.}

endsnippet

snippet ibm_sa_vol "Handle volumes on IBM Spectrum Accelerate Family storage systems." b
ibm_sa_vol: >
	vol=${1:# Volume name.}
	state=${2:#present|absent}
	username=${3:# Management user on the spectrum accelerate storage system.}
	password=${4:# Password for username on the spectrum accelerate storage system.}
	endpoints=${5:# The hostname or management IP of Spectrum Accelerate storage system.}

	pool=${6:# Volume pool.}
	size=${7:# Volume size.}

endsnippet

snippet zfs_facts "Gather facts about ZFS datasets." b
zfs_facts: >
	name=${1:# ZFS dataset name.}

	recurse=${2:no}
	parsable=${3:no}
	properties=${4:all}
	type=${5:#all|filesystem|volume|snapshot|bookmark}
	depth=${6:# Specifies recursion depth.}

endsnippet

snippet zfs "Manage zfs" b
zfs: >
	name=${1:# File system, snapshot or volume name e.g. C(rpool/myfs).}
	state=${2:absent|present}

	origin=${3:# Snapshot from which to create a clone.}
	extra_zfs_properties=${4:# A dictionary of zfs properties to be set.}

endsnippet

snippet zfs_delegate_admin "Manage ZFS delegated administration (user admin privileges)" b
zfs_delegate_admin: >
	name=${1:# File system or volume name e.g. C(rpool/myfs).}
	state=${2:absent|#present}

	users=${3:# List of users to whom permission(s) should be granted.}
	groups=${4:# List of groups to whom permission(s) should be granted.}
	everyone=${5:no}
	permissions=${6:allow|clone|create|destroy|mount|promote|readonly|receive|rename|rollback|send|share|snapshot|unallow}
	local=${7:# Apply permissions to C(name) locally (C(zfs allow -l)).}
	descendents=${8:# Apply permissions to C(name)'s descendents (C(zfs allow -d)).}
	recursive=${9:no}

endsnippet

snippet zpool_facts "Gather facts about ZFS pools." b
zpool_facts: >
	name=${1:# ZFS pool name.}
	parsable=${2:no}
	properties=${3:all}

endsnippet

snippet infini_export "Create, Delete or Modify NFS Exports on Infinibox" b
infini_export: >
	name=${1:# Export name. Should always start with C(/). (ex. name=/data)}
	filesystem=${2:# Name of exported file system.}
	system=${3:# Infinibox Hostname or IPv4 Address.}

	state=${4:#present|absent}
	inner_path=${5:/}
	client_list=${6:All Hosts(*), RW, no_root_squash: True}
	user=${7:# Infinibox User username with sufficient priveledges ( see notes ).}
	password=${8:# Infinibox User password.}

endsnippet

snippet infini_host "Create, Delete and Modify Hosts on Infinibox" b
infini_host: >
	name=${1:# Host Name}
	system=${2:# Infinibox Hostname or IPv4 Address.}

	state=${3:#present|absent}
	wwns=${4:# List of wwns of the host}
	volume=${5:# Volume name to map to the host}
	user=${6:# Infinibox User username with sufficient priveledges ( see notes ).}
	password=${7:# Infinibox User password.}

endsnippet

snippet infini_pool "Create, Delete and Modify Pools on Infinibox" b
infini_pool: >
	name=${1:# Pool Name}
	system=${2:# Infinibox Hostname or IPv4 Address.}

	state=${3:#present|absent}
	size=${4:# Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples.}
	vsize=${5:# Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples.}
	ssd_cache=${6:yes}
	user=${7:# Infinibox User username with sufficient priveledges ( see notes ).}
	password=${8:# Infinibox User password.}

endsnippet

snippet infini_fs "Create, Delete or Modify filesystems on Infinibox" b
infini_fs: >
	name=${1:# File system name.}
	pool=${2:# Pool that will host file system.}
	system=${3:# Infinibox Hostname or IPv4 Address.}

	state=${4:#present|absent}
	size=${5:# File system size in MB, GB or TB units. See examples.}
	user=${6:# Infinibox User username with sufficient priveledges ( see notes ).}
	password=${7:# Infinibox User password.}

endsnippet

snippet infini_export_client "Create, Delete or Modify NFS Client(s) for existing exports on Infinibox" b
infini_export_client: >
	client=${1:# Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254.}
	export=${2:# Name of the export.}
	system=${3:# Infinibox Hostname or IPv4 Address.}

	state=${4:#present|absent}
	access_mode=${5:#RW|RO}
	no_root_squash=${6:no}
	user=${7:# Infinibox User username with sufficient priveledges ( see notes ).}
	password=${8:# Infinibox User password.}

endsnippet

snippet infini_vol "Create, Delete or Modify volumes on Infinibox" b
infini_vol: >
	name=${1:# Volume Name}
	pool=${2:# Pool that volume will reside on}
	system=${3:# Infinibox Hostname or IPv4 Address.}

	state=${4:#present|absent}
	size=${5:# Volume size in MB, GB or TB units. See examples.}
	user=${6:# Infinibox User username with sufficient priveledges ( see notes ).}
	password=${7:# Infinibox User password.}

endsnippet

snippet emc_vnx_sg_member "Manage storage group member on EMC VNX" b
emc_vnx_sg_member: >
	name=${1:# Name of the Storage group to manage.}
	lunid=${2:# Lun id to be added.}
	sp_address=${3:# Address of the SP of target/secondary storage.}

	state=${4:#present|absent}
	sp_user=${5:sysadmin}
	sp_password=${6:sysadmin}

endsnippet

snippet async_status "Obtain status of asynchronous task" b
async_status: >
	jid=${1:# Job or task identifier}

	mode=${2:cleanup|#status}

endsnippet

snippet include_role "Load and execute a role" b
include_role: >
	name=${1:# The name of the role to be executed.}

	apply=${2:# Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to all tasks within the included role.}
	tasks_from=${3:main}
	vars_from=${4:main}
	defaults_from=${5:main}
	allow_duplicates=${6:yes}
	public=${7:no}
	handlers_from=${8:main}

endsnippet

snippet wait_for "Waits for a condition before continuing" b
wait_for: >
	host=${1:127.0.0.1}
	timeout=${2:300}
	connect_timeout=${3:5}
	delay=${4:0}
	port=${5:# Port number to poll.}
	active_connection_states=${6:['ESTABLISHED', 'FIN_WAIT1', 'FIN_WAIT2', 'SYN_RECV', 'SYN_SENT', 'TIME_WAIT']}
	state=${7:absent|drained|present|#started|stopped}
	path=${8:# Path to a file on the filesystem that must exist before continuing.}
	search_regex=${9:# Can be used to match a string in either a file or a socket connection.}
	exclude_hosts=${10:# List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state.}
	sleep=${11:1}
	msg=${12:# This overrides the normal error message from a failure to meet the required conditions.}

endsnippet

snippet wait_for_connection "Waits until remote system is reachable/usable" b
wait_for_connection: >
	connect_timeout=${1:5}
	delay=${2:0}
	sleep=${3:1}
	timeout=${4:600}

endsnippet

snippet include_tasks "Dynamically include a task list" b
include_tasks: >
	file=${1:# The name of the imported file is specified directly without any other option.}
	apply=${2:# Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to the tasks within the include.}
	free-form=${3:# Supplying a file name via free-form C(- include_tasks: file.yml) of a file to be included is the equivalent
of specifying an argument of I(file).
}

endsnippet

snippet import_tasks "Import a task list" b
import_tasks: >
	free-form=${1:# The name of the imported file is specified directly without any other option.}

endsnippet

snippet assert "Asserts given expressions are true" b
assert: >
	that=${1:# A list of string expressions of the same form that can be passed to the 'when' statement.}

	fail_msg=${2:# The customized message used for a failing assertion.}
	success_msg=${3:# The customized message used for a successful assertion.}
	quiet=${4:no}

endsnippet

snippet include_vars "Load variables from files, dynamically within a task" b
include_vars: >
	file=${1:# The file name from which variables should be loaded.}
	dir=${2:# The directory name from which the variables should be loaded.}
	name=${3:# The name of a variable into which assign the included vars.}
	depth=${4:0}
	files_matching=${5:# Limit the files that are loaded within any directory to this regular expression.}
	ignore_files=${6:# List of file names to ignore.}
	extensions=${7:['json', 'yaml', 'yml']}
	ignore_unknown_extensions=${8:no}
	free-form=${9:# This module allows you to specify the 'file' option directly without any other options.}

endsnippet

snippet fail "Fail with custom message" b
fail: >
	msg=${1:Failed as requested from task}

endsnippet

snippet set_fact "Set host facts from a task" b
set_fact: >
	key_value=${1:# The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement.}

	cacheable=${2:no}

endsnippet

snippet pause "Pause playbook execution" b
pause: >
	minutes=${1:# A positive number of minutes to pause for.}
	seconds=${2:# A positive number of seconds to pause for.}
	prompt=${3:# Optional text to use for the prompt message.}
	echo=${4:yes}

endsnippet

snippet import_playbook "Import a playbook" b
import_playbook: >
	free-form=${1:# The name of the imported playbook is specified directly without any other option.}

endsnippet

snippet debug "Print statements during execution" b
debug: >
	msg=${1:Hello world!}
	var=${2:# A variable name to debug.}
	verbosity=${3:0}

endsnippet

snippet import_role "Import a role into a play" b
import_role: >
	name=${1:# The name of the role to be executed.}

	tasks_from=${2:main}
	vars_from=${3:main}
	defaults_from=${4:main}
	allow_duplicates=${5:yes}
	handlers_from=${6:main}

endsnippet

snippet include "Include a play or task list" b
include: >
	free-form=${1:# This module allows you to specify the name of the file directly without any other options.}

endsnippet

snippet set_stats "Set stats for the current ansible run" b
set_stats: >
	data=${1:# A dictionary of which each key represents a stat (or variable) you want to keep track of.}

	per_host=${2:no}
	aggregate=${3:yes}

endsnippet

snippet meta "Execute Ansible 'actions'" b
meta: >
	${1:free_form=clear_facts|clear_host_errors|end_host|end_play|flush_handlers|noop|refresh_inventory|reset_connection}

endsnippet

snippet cronvar "Manage variables in crontabs" b
cronvar: >
	name=${1:# Name of the crontab variable.}

	value=${2:# The value to set this variable to.}
	insertafter=${3:# If specified, the variable will be inserted after the variable specified.}
	insertbefore=${4:# Used with C(state=present). If specified, the variable will be inserted just before the variable specified.}
	state=${5:absent|#present}
	user=${6:# The specific user whose crontab should be modified.}
	cron_file=${7:# If specified, uses this file instead of an individual user's crontab.}
	backup=${8:no}

endsnippet

snippet osx_defaults "Manage macOS user defaults" b
osx_defaults: >
	key=${1:# The key of the user preference.}

	domain=${2:NSGlobalDomain}
	host=${3:# The host on which the preference should apply.}
	type=${4:array|bool|boolean|date|float|int|integer|#string}
	array_add=${5:no}
	value=${6:# The value to write.}
	state=${7:absent|list|#present}
	path=${8:/usr/bin:/usr/local/bin}

endsnippet

snippet aix_lvg "Manage LVM volume groups on AIX" b
aix_lvg: >
	vg=${1:# The name of the volume group.}

	force=${2:no}
	pp_size=${3:# The size of the physical partition in megabytes.}
	pvs=${4:# List of comma-separated devices to use as physical devices in this volume group.}
	state=${5:absent|#present|varyoff|varyon}
	vg_type=${6:big|#normal|scalable}

endsnippet

snippet service "Manage services" b
service: >
	name=${1:# Name of the service.}

	state=${2:reloaded|restarted|started|stopped}
	sleep=${3:# If the service is being C(restarted) then sleep this many seconds between the stop and start command.}
	pattern=${4:# If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.}
	enabled=${5:# Whether the service should start on boot.}
	runlevel=${6:default}
	arguments=${7:# Additional arguments provided on the command line.}
	use=${8:auto}

endsnippet

snippet user "Manage user accounts" b
user: >
	name=${1:# Name of the user to create, remove or modify.}

	uid=${2:# Optionally sets the I(UID) of the user.}
	comment=${3:# Optionally sets the description (aka I(GECOS)) of user account.}
	hidden=${4:# macOS only, optionally hide the user from the login window and system preferences.}
	non_unique=${5:no}
	seuser=${6:# Optionally sets the seuser type (user_u) on selinux enabled systems.}
	group=${7:# Optionally sets the user's primary group (takes a group name).}
	groups=${8:# List of groups user will be added to. When set to an empty string C(''), the user is removed from all groups except the primary group.}
	append=${9:no}
	shell=${10:# Optionally set the user's shell.}
	home=${11:# Optionally set the user's home directory.}
	skeleton=${12:# Optionally set a home skeleton directory.}
	password=${13:# Optionally set the user's password to this crypted value.}
	state=${14:absent|#present}
	create_home=${15:yes}
	move_home=${16:no}
	system=${17:no}
	force=${18:no}
	remove=${19:no}
	login_class=${20:# Optionally sets the user's login class, a feature of most BSD OSs.}
	generate_ssh_key=${21:no}
	ssh_key_bits=${22:default set by ssh-keygen}
	ssh_key_type=${23:rsa}
	ssh_key_file=${24:# Optionally specify the SSH key filename.}
	ssh_key_comment=${25:ansible-generated on $HOSTNAME}
	ssh_key_passphrase=${26:# Set a passphrase for the SSH key.}
	update_password=${27:#always|on_create}
	expires=${28:# An expiry time for the user in epoch, it will be ignored on platforms that do not support this.}
	password_lock=${29:# Lock the password (usermod -L, pw lock, usermod -C).}
	local=${30:no}
	profile=${31:# Sets the profile of the user.}
	authorization=${32:# Sets the authorization of the user.}
	role=${33:# Sets the role of the user.}

endsnippet

snippet selogin "Manages linux user to SELinux user mapping" b
selogin: >
	login=${1:# a Linux user}
	seuser=${2:# SELinux user name}
	state=${3:#present|absent}

	selevel=${4:s0}
	reload=${5:yes}
	ignore_selinux_state=${6:no}

endsnippet

snippet sefcontext "Manages SELinux file context mapping definitions" b
sefcontext: >
	target=${1:# Target path (expression).}
	setype=${2:# SELinux type for the specified target.}

	ftype=${3:#a|b|c|d|f|l|p|s}
	seuser=${4:# SELinux user for the specified target.}
	selevel=${5:# SELinux range for the specified target.}
	state=${6:absent|#present}
	reload=${7:yes}
	ignore_selinux_state=${8:no}

endsnippet

snippet selinux "Change policy and state of SELinux" b
selinux: >
	state=${1:disabled|enforcing|permissive}

	policy=${2:# The name of the SELinux policy to use (e.g. C(targeted)) will be required if state is not C(disabled).}
	configfile=${3:/etc/selinux/config}

endsnippet

snippet syspatch "Manage OpenBSD system patches" b
syspatch: >
	apply=${1:no}
	revert=${2:all|one}

endsnippet

snippet crypttab "Encrypted Linux block devices" b
crypttab: >
	name=${1:# Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionally prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name).}
	state=${2:absent|opts_absent|opts_present|present}

	backing_device=${3:# Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=).}
	password=${4:# Encryption password, the path to a file containing the password, or C(-) or unset if the password should be entered at boot.}
	opts=${5:# A comma-delimited list of options. See C(crypttab(5) ) for details.}
	path=${6:/etc/crypttab}

endsnippet

snippet gconftool2 "Edit GNOME Configurations" b
gconftool2: >
	key=${1:# A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)}
	state=${2:absent|get|present}

	value=${3:# Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is "get". See man gconftool-2(1)}
	value_type=${4:bool|float|int|string}
	config_source=${5:# Specify a configuration source to use rather than the default path. See man gconftool-2(1)}
	direct=${6:no}

endsnippet

snippet open_iscsi "Manage iSCSI targets with Open-iSCSI" b
open_iscsi: >
	portal=${1:# The IP address of the iSCSI target.}
	port=${2:3260}
	target=${3:# The iSCSI target name.}
	login=${4:# Whether the target node should be connected.}
	node_auth=${5:CHAP}
	node_user=${6:# The value for C(discovery.sendtargets.auth.username).}
	node_pass=${7:# The value for C(discovery.sendtargets.auth.password).}
	auto_node_startup=${8:# Whether the target node should be automatically connected at startup.}
	discover=${9:# Whether the list of target nodes on the portal should be (re)discovered and added to the persistent iSCSI database.}
	show_nodes=${10:# Whether the list of nodes in the persistent iSCSI database should be returned by the module.}

endsnippet

snippet aix_inittab "Manages the inittab on AIX" b
aix_inittab: >
	name=${1:# Name of the inittab entry.}
	runlevel=${2:# Runlevel of the entry.}
	action=${3:boot|bootwait|hold|initdefault|off|once|ondemand|powerfail|powerwait|respawn|sysinit|wait}
	command=${4:# What command has to run.}

	insertafter=${5:# After which inittabline should the new entry inserted.}
	state=${6:absent|#present}

endsnippet

snippet ohai "Returns inventory data from I(Ohai)" b
ohai:

endsnippet

snippet debconf "Configure a .deb package" b
debconf: >
	name=${1:# Name of package to configure.}

	question=${2:# A debconf configuration setting.}
	vtype=${3:boolean|error|multiselect|note|password|seen|select|string|text|title}
	value=${4:# Value to set the configuration to.}
	unseen=${5:no}

endsnippet

snippet systemd "Manage services" b
systemd: >
	name=${1:# Name of the service. This parameter takes the name of exactly one service to work with.}
	state=${2:reloaded|restarted|started|stopped}
	enabled=${3:# Whether the service should start on boot. B(At least one of state and enabled are required.)}
	force=${4:# Whether to override existing symlinks.}
	masked=${5:# Whether the unit should be masked or not, a masked unit is impossible to start.}
	daemon_reload=${6:no}
	daemon_reexec=${7:no}
	user=${8:no}
	scope=${9:system|user|global}
	no_block=${10:no}

endsnippet

snippet cron "Manage cron.d and crontab entries" b
cron: >
	name=${1:# Description of a crontab entry or, if env is set, the name of environment variable.}
	user=${2:# The specific user whose crontab should be modified.}
	job=${3:# The command to execute or, if env is set, the value of environment variable.}
	state=${4:absent|#present}
	cron_file=${5:# If specified, uses this file instead of an individual user's crontab.}
	backup=${6:no}
	minute=${7:*}
	hour=${8:*}
	day=${9:*}
	month=${10:*}
	weekday=${11:*}
	reboot=${12:no}
	special_time=${13:annually|daily|hourly|monthly|reboot|weekly|yearly}
	disabled=${14:no}
	env=${15:no}
	insertafter=${16:# Used with C(state=present) and C(env).}
	insertbefore=${17:# Used with C(state=present) and C(env).}

endsnippet

snippet getent "A wrapper to the unix getent utility" b
getent: >
	database=${1:# The name of a getent database supported by the target system (passwd, group, hosts, etc).}

	key=${2:}
	service=${3:# Override all databases with the specified service}
	split=${4:# Character used to split the database values into lists/arrays such as ':' or '	', otherwise  it will try to pick one depending on the database.}
	fail_key=${5:yes}

endsnippet

snippet xfconf "Edit XFCE4 Configurations" b
xfconf: >
	channel=${1:# A Xfconf preference channel is a top-level tree key, inside of the Xfconf repository that corresponds to the location for which all application properties/keys are stored. See man xfconf-query(1)}
	property=${2:# A Xfce preference key is an element in the Xfconf repository that corresponds to an application preference. See man xfconf-query(1)}

	value=${3:# Preference properties typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is "get". See man xfconf-query(1)}
	value_type=${4:int|bool|float|string}
	state=${5:get|#present|absent}

endsnippet

snippet modprobe "Load or unload kernel modules" b
modprobe: >
	name=${1:# Name of kernel module to manage.}

	state=${2:absent|#present}
	params=${3:}

endsnippet

snippet filesystem "Makes a filesystem" b
filesystem: >
	fstype=${1:btrfs|ext2|ext3|ext4|ext4dev|f2fs|lvm|ocfs2|reiserfs|xfs|vfat|swap}
	dev=${2:# Target path to device or image file.}

	force=${3:no}
	resizefs=${4:no}
	opts=${5:# List of options to be passed to mkfs command.}

endsnippet

snippet gather_facts "Gathers facts about remote hosts" b
gather_facts: >
	parallel=${1:# A toggle that controls if the fact modules are executed in parallel or serially and in order. This can guarantee the merge order of module facts at the expense of performance.}

endsnippet

snippet facter "Runs the discovery program I(facter) on the remote system" b
facter:

endsnippet

snippet dconf "Modify and read dconf database" b
dconf: >
	key=${1:# A dconf key to modify or read from the dconf database.}

	value=${2:# Value to set for the specified dconf key. Value should be specified in GVariant format. Due to complexity of this format, it is best to have a look at existing values in the dconf database. Required for C(state=present).}
	state=${3:read|#present|absent}

endsnippet

snippet beadm "Manage ZFS boot environments on FreeBSD/Solaris/illumos systems." b
beadm: >
	name=${1:# ZFS boot environment name.}

	snapshot=${2:# If specified, the new boot environment will be cloned from the given snapshot or inactive boot environment.}
	description=${3:# Associate a description with a new boot environment. This option is available only on Solarish platforms.}
	options=${4:# Create the datasets for new BE with specific ZFS properties.}
	mountpoint=${5:# Path where to mount the ZFS boot environment.}
	state=${6:absent|activated|mounted|#present|unmounted}
	force=${7:no}

endsnippet

snippet python_requirements_info "Show python path and assert dependency versions" b
python_requirements_info: >
	dependencies=${1:# A}

endsnippet

snippet firewalld "Manage arbitrary ports/services with firewalld" b
firewalld: >
	state=${1:absent|disabled|enabled|present}

	service=${2:# Name of a service to add/remove to/from firewalld.}
	port=${3:# Name of a port or port range to add/remove to/from firewalld.}
	rich_rule=${4:# Rich rule to add/remove to/from firewalld.}
	source=${5:# The source/network you would like to add/remove to/from firewalld.}
	interface=${6:# The interface you would like to add/remove to/from a zone in firewalld.}
	icmp_block=${7:# The ICMP block you would like to add/remove to/from a zone in firewalld.}
	icmp_block_inversion=${8:# Enable/Disable inversion of ICMP blocks for a zone in firewalld.}
	zone=${9:# The firewalld zone to add/remove to/from.}
	permanent=${10:# Should this configuration be in the running firewalld configuration or persist across reboots.}
	immediate=${11:no}
	timeout=${12:0}
	masquerade=${13:# The masquerade setting you would like to enable/disable to/from zones within firewalld.}
	offline=${14:# Whether to run this module even when firewalld is offline.}

endsnippet

snippet at "Schedule the execution of a command or script file via the at command" b
at: >
	count=${1:# The count of units in the future to execute the command or script file.}
	units=${2:minutes|hours|days|weeks}

	command=${3:# A command to be executed in the future.}
	script_file=${4:# An existing script file to be executed in the future.}
	state=${5:absent|#present}
	unique=${6:no}

endsnippet

snippet mksysb "Generates AIX mksysb rootvg backups." b
mksysb: >
	name=${1:# Backup name}
	storage_path=${2:# Storage path where the mksysb will stored.}

	backup_crypt_files=${3:yes}
	backup_dmapi_fs=${4:yes}
	create_map_files=${5:no}
	exclude_files=${6:no}
	exclude_wpar_files=${7:no}
	extended_attrs=${8:yes}
	new_image_data=${9:yes}
	software_packing=${10:no}
	use_snapshot=${11:no}

endsnippet

snippet xfs_quota "Manage quotas on XFS filesystems" b
xfs_quota: >
	type=${1:user|group|project}
	mountpoint=${2:# The mount point on which to apply the quotas.}

	name=${3:# The name of the user, group or project to apply the quota to, if other than default.}
	bhard=${4:# Hard blocks quota limit.}
	bsoft=${5:# Soft blocks quota limit.}
	ihard=${6:# Hard inodes quota limit.}
	isoft=${7:# Soft inodes quota limit.}
	rtbhard=${8:# Hard realtime blocks quota limit.}
	rtbsoft=${9:# Soft realtime blocks quota limit.}
	state=${10:#present|absent}

endsnippet

snippet ufw "Manage firewall with UFW" b
ufw: >
	state=${1:disabled|enabled|reloaded|reset}
	default=${2:allow|deny|reject}
	direction=${3:in|incoming|out|outgoing|routed}
	logging=${4:on|off|low|medium|high|full}
	insert=${5:# Insert the corresponding rule as rule number NUM.}
	insert_relative_to=${6:first-ipv4|first-ipv6|last-ipv4|last-ipv6|#zero}
	rule=${7:allow|deny|limit|reject}
	log=${8:# Log new connections matched to this rule}
	from_ip=${9:any}
	from_port=${10:# Source port.}
	to_ip=${11:any}
	to_port=${12:# Destination port.}
	proto=${13:any|tcp|udp|ipv6|esp|ah|gre|igmp}
	name=${14:# Use profile located in C(/etc/ufw/applications.d).}
	delete=${15:# Delete rule.}
	interface=${16:# Specify interface for rule.}
	route=${17:# Apply the rule to routed/forwarded packets.}
	comment=${18:# Add a comment to the rule. Requires UFW version >=0.35.}

endsnippet

snippet known_hosts "Add or remove a host from the C(known_hosts) file" b
known_hosts: >
	name=${1:# The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.}

	key=${2:# The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(8), section "SSH_KNOWN_HOSTS FILE FORMAT").
Specifically, the key should not match the format that is found in an SSH pubkey file, but should rather have the hostname prepended to a line that includes the pubkey, the same way that it would appear in the known_hosts file. The value prepended to the line must also match the value of the name parameter.
Should be of format `<hostname[,IP]> ssh-rsa <pubkey>`}
	path=${3:(homedir)+/.ssh/known_hosts}
	hash_host=${4:no}
	state=${5:#present|absent}

endsnippet

snippet solaris_zone "Manage Solaris zones" b
solaris_zone: >
	state=${1:absent|attached|configured|detached|installed|#present|running|started|stopped}
	name=${2:# Zone name.}

	path=${3:# The path where the zone will be created. This is required when the zone is created, but not used otherwise.}
	sparse=${4:no}
	root_password=${5:# The password hash for the root account. If not specified, the zone's root account will not have a password.}
	config=${6:}
	create_options=${7:}
	install_options=${8:}
	attach_options=${9:}
	timeout=${10:600}

endsnippet

snippet listen_ports_facts "Gather facts on processes listening on TCP and UDP ports." b
listen_ports_facts:

endsnippet

snippet nosh "Manage services with nosh" b
nosh: >
	name=${1:# Name of the service to manage.}

	state=${2:started|stopped|reset|restarted|reloaded}
	enabled=${3:# Enable or disable the service, independently of C(*.preset) file preference or running state. Mutually exclusive with I(preset). Will take effect prior to I(state=reset).}
	preset=${4:# Enable or disable the service according to local preferences in *.preset files. Mutually exclusive with I(enabled). Only has an effect if set to true. Will take effect prior to I(state=reset).}
	user=${5:no}

endsnippet

snippet authorized_key "Adds or removes an SSH authorized key" b
authorized_key: >
	user=${1:# The username on the remote host whose authorized_keys file will be modified.}
	key=${2:# The SSH public key(s), as a string or (since Ansible 1.9) url (https://github.com/username.keys).}

	path=${3:# Alternate path to the authorized_keys file.}
	manage_dir=${4:yes}
	state=${5:absent|#present}
	key_options=${6:# A string of ssh key options to be prepended to the key in the authorized_keys file.}
	exclusive=${7:no}
	validate_certs=${8:yes}
	comment=${9:# Change the comment on the public key.}
	follow=${10:no}

endsnippet

snippet aix_filesystem "Configure LVM and NFS file systems for AIX" b
aix_filesystem: >
	filesystem=${1:# Specifies the mount point, which is the directory where the file system will be mounted.}
	state=${2:absent|mounted|#present|unmounted}

	account_subsystem=${3:no}
	attributes=${4:agblksize='4096',isnapshot='no'}
	auto_mount=${5:yes}
	device=${6:# Logical volume (LV) device name or remote export device to create a NFS file system.}
	fs_type=${7:jfs2}
	permissions=${8:ro|#rw}
	mount_group=${9:# Specifies the mount group.}
	nfs_server=${10:# Specifies a Network File System (NFS) server.}
	rm_mount_point=${11:no}
	size=${12:# Specifies the file system size.}
	vg=${13:# Specifies an existing volume group (VG).}

endsnippet

snippet pamd "Manage PAM Modules" b
pamd: >
	name=${1:# The name generally refers to the PAM service file to change, for example system-auth.}
	type=${2:account|-account|auth|-auth|password|-password|session|-session}
	control=${3:# The control of the PAM rule being modified.}
	module_path=${4:# The module path of the PAM rule being modified.}

	new_type=${5:account|-account|auth|-auth|password|-password|session|-session}
	new_control=${6:# The new control to assign to the new rule.}
	new_module_path=${7:# The new module path to be assigned to the new rule.}
	module_arguments=${8:# When state is C(updated), the module_arguments will replace existing module_arguments.}
	state=${9:absent|before|after|args_absent|args_present|#updated}
	path=${10:/etc/pam.d}
	backup=${11:no}

endsnippet

snippet sysvinit "Manage SysV services." b
sysvinit: >
	name=${1:# Name of the service.}

	state=${2:started|stopped|restarted|reloaded}
	enabled=${3:# Whether the service should start on boot. B(At least one of state and enabled are required.)}
	sleep=${4:1}
	pattern=${5:# A substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.}
	runlevels=${6:# The runlevels this script should be enabled/disabled from.}
	arguments=${7:# Additional arguments provided on the command line that some init scripts accept.}
	daemonize=${8:no}

endsnippet

snippet aix_lvol "Configure AIX LVM logical volumes" b
aix_lvol: >
	vg=${1:# The volume group this logical volume is part of.}
	lv=${2:# The name of the logical volume.}

	lv_type=${3:jfs2}
	size=${4:# The size of the logical volume with one of the [MGT] units.}
	copies=${5:1}
	policy=${6:#maximum|minimum}
	state=${7:absent|#present}
	opts=${8:# Free-form options to be passed to the mklv command.}
	pvs=${9:# A list of physical volumes e.g. C(hdisk1,hdisk2).}

endsnippet

snippet svc "Manage daemontools services" b
svc: >
	name=${1:# Name of the service to manage.}

	state=${2:killed|once|reloaded|restarted|started|stopped}
	downed=${3:no}
	enabled=${4:# Whether the service is enabled or not, if disabled it also implies stopped. Take note that a service can be enabled and downed (no auto restart).}
	service_dir=${5:/service}
	service_src=${6:/etc/service}

endsnippet

snippet setup "Gathers facts about remote hosts" b
setup: >
	gather_subset=${1:all}
	gather_timeout=${2:10}
	filter=${3:*}
	fact_path=${4:/etc/ansible/facts.d}

endsnippet

snippet service_facts "Return service state information as fact data" b
service_facts:

endsnippet

snippet vdo "Module to control VDO" b
vdo: >
	name=${1:# The name of the VDO volume.}
	state=${2:absent|#present}

	activated=${3:# The "activate" status for a VDO volume.  If this is set to "no", the VDO volume cannot be started, and it will not start on system startup.  However, on initial creation, a VDO volume with "activated" set to "off" will be running, until stopped.  This is the default behavior of the "vdo create" command; it provides the user an opportunity to write a base amount of metadata (filesystem, LVM headers, etc.) to the VDO volume prior to stopping the volume, and leaving it deactivated until ready to use.}
	running=${4:# Whether this VDO volume is running.}
	device=${5:# The full path of the device to use for VDO storage.}
	logicalsize=${6:# The logical size of the VDO volume (in megabytes, or LVM suffix format).  If not specified for a new volume, this defaults to the same size as the underlying storage device, which is specified in the 'device' parameter. Existing volumes will maintain their size if the logicalsize parameter is not specified, or is smaller than or identical to the current size.  If the specified size is larger than the current size, a growlogical operation will be performed.}
	deduplication=${7:disabled|enabled}
	compression=${8:disabled|enabled}
	blockmapcachesize=${9:# The amount of memory allocated for caching block map pages, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  The default (and minimum) value is 128M.  The value specifies the size of the cache; there is a 15% memory usage overhead. Each 1.25G of block map covers 1T of logical blocks, therefore a small amount of block map cache memory can cache a significantly large amount of block map data.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.}
	readcache=${10:disabled|enabled}
	readcachesize=${11:# Specifies the extra VDO device read cache size in megabytes.  This is in addition to a system-defined minimum.  Using a value with a suffix of K, M, G, or T is optional.  The default value is 0.  1.125 MB of memory per bio thread will be used per 1 MB of read cache specified (for example, a VDO volume configured with 4 bio threads will have a read cache memory usage overhead of 4.5 MB per 1 MB of read cache specified). Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.}
	emulate512=${12:# Enables 512-byte emulation mode, allowing drivers or filesystems to access the VDO volume at 512-byte granularity, instead of the default 4096-byte granularity. Default is 'disabled'; only recommended when a driver or filesystem requires 512-byte sector level access to a device.  This option is only available when creating a new volume, and cannot be changed for an existing volume.}
	growphysical=${13:no}
	slabsize=${14:# The size of the increment by which the physical size of a VDO volume is grown, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  Must be a power of two between 128M and 32G.  The default is 2G, which supports volumes having a physical size up to 16T. The maximum, 32G, supports a physical size of up to 256T. This option is only available when creating a new volume, and cannot be changed for an existing volume.}
	writepolicy=${15:async|auto|sync}
	indexmem=${16:# Specifies the amount of index memory in gigabytes.  The default is 0.25.  The special decimal values 0.25, 0.5, and 0.75 can be used, as can any positive integer. This option is only available when creating a new volume, and cannot be changed for an existing volume.}
	indexmode=${17:dense|sparse}
	ackthreads=${18:# Specifies the number of threads to use for acknowledging completion of requested VDO I/O operations. Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.}
	biothreads=${19:# Specifies the number of threads to use for submitting I/O operations to the storage device.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 4. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.}
	cputhreads=${20:# Specifies the number of threads to use for CPU-intensive work such as hashing or compression.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 2. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.}
	logicalthreads=${21:# Specifies the number of threads across which to subdivide parts of the VDO processing based on logical block addresses.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead). The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.}
	physicalthreads=${22:# Specifies the number of threads across which to subdivide parts of the VDO processing based on physical block addresses.  Valid values are integer values from 1 to 16 (lower numbers are preferable due to overhead). The physical space used by the VDO volume must be larger than (slabsize * physicalthreads).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.}

endsnippet

snippet openwrt_init "Manage services on OpenWrt." b
openwrt_init: >
	name=${1:# Name of the service.}

	state=${2:started|stopped|restarted|reloaded}
	enabled=${3:# Whether the service should start on boot. B(At least one of state and enabled are required.)}
	pattern=${4:# If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running.}

endsnippet

snippet capabilities "Manage Linux capabilities" b
capabilities: >
	path=${1:# Specifies the path to the file to be managed.}
	capability=${2:# Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))}

	state=${3:absent|#present}

endsnippet

snippet java_keystore "Create or delete a Java keystore in JKS format." b
java_keystore: >
	name=${1:# Name of the certificate.}
	certificate=${2:# Certificate that should be used to create the key store.}
	private_key=${3:# Private key that should be used to create the key store.}
	password=${4:# Password that should be used to secure the key store.}
	dest=${5:# Absolute path where the jks should be generated.}

	owner=${6:# Name of the user that should own jks file.}
	group=${7:# Name of the group that should own jks file.}
	mode=${8:# Mode the file should be.}
	force=${9:no}

endsnippet

snippet puppet "Runs puppet" b
puppet: >
	timeout=${1:30m}
	puppetmaster=${2:# The hostname of the puppetmaster to contact.}
	modulepath=${3:# Path to an alternate location for puppet modules.}
	manifest=${4:# Path to the manifest file to run puppet apply on.}
	noop=${5:# Override puppet.conf noop mode.}
	facts=${6:# A dict of values to pass in as persistent external facter facts.}
	facter_basename=${7:ansible}
	environment=${8:# Puppet environment to be used.}
	logdest=${9:all|#stdout|syslog}
	certname=${10:# The name to use when handling certificates.}
	tags=${11:# A list of puppet tags to be used.}
	execute=${12:# Execute a specific piece of Puppet code.}
	use_srv_records=${13:# Toggles use_srv_records flag}
	summarize=${14:# Whether to print a transaction summary.}
	verbose=${15:# Print extra information.}
	debug=${16:# Enable full debugging.}

endsnippet

snippet runit "Manage runit services" b
runit: >
	name=${1:# Name of the service to manage.}

	state=${2:killed|once|reloaded|restarted|started|stopped}
	enabled=${3:# Whether the service is enabled or not, if disabled it also implies stopped.}
	service_dir=${4:/var/service}
	service_src=${5:/etc/sv}

endsnippet

snippet pam_limits "Modify Linux PAM limits" b
pam_limits: >
	domain=${1:# A username, @groupname, wildcard, uid/gid range.}
	limit_type=${2:hard|soft|-}
	limit_item=${3:core|data|fsize|memlock|nofile|rss|stack|cpu|nproc|as|maxlogins|maxsyslogins|priority|locks|sigpending|msgqueue|nice|rtprio|chroot}
	value=${4:# The value of the limit.}

	backup=${5:no}
	use_min=${6:no}
	use_max=${7:no}
	dest=${8:/etc/security/limits.conf}
	comment=${9:}

endsnippet

snippet pids "Retrieves process IDs list if the process is running otherwise return empty list" b
pids: >
	name=${1:# t}

endsnippet

snippet awall "Manage awall policies" b
awall: >
	name=${1:# One or more policy names.}
	state=${2:disabled|#enabled}
	activate=${3:no}

endsnippet

snippet kernel_blacklist "Blacklist kernel modules" b
kernel_blacklist: >
	name=${1:# Name of kernel module to black- or whitelist.}

	state=${2:absent|#present}
	blacklist_file=${3:# If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).}

endsnippet

snippet reboot "Reboot a machine" b
reboot: >
	pre_reboot_delay=${1:0}
	post_reboot_delay=${2:0}
	reboot_timeout=${3:600}
	connect_timeout=${4:# Maximum seconds to wait for a successful connection to the managed hosts before trying again.}
	test_command=${5:whoami}
	msg=${6:Reboot initiated by Ansible}
	search_paths=${7:['/sbin', '/usr/sbin', '/usr/local/sbin']}

endsnippet

snippet parted "Configure block device partitions" b
parted: >
	device=${1:# T}

	align=${2:cylinder|minimal|none|#optimal}
	number=${3:# The number of the partition to work with or the number of the partition that will be created.}
	unit=${4:s|B|KB|#KiB|MB|MiB|GB|GiB|TB|TiB|%|cyl|chs|compact}
	label=${5:aix|amiga|bsd|dvh|gpt|loop|mac|#msdos|pc98|sun}
	part_type=${6:extended|logical|#primary}
	part_start=${7:0%}
	part_end=${8:100%}
	name=${9:# Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).}
	flags=${10:# A}
	state=${11:absent|present|#info}

endsnippet

snippet lvol "Configure LVM logical volumes" b
lvol: >
	vg=${1:# The volume group this logical volume is part of.}
	lv=${2:# The name of the logical volume.}
	size=${3:# The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.}
	state=${4:absent|#present}
	active=${5:yes}
	force=${6:no}
	opts=${7:# Free-form options to be passed to the lvcreate command.}
	snapshot=${8:# The name of the snapshot volume}
	pvs=${9:# Comma separated list of physical volumes (e.g. /dev/sda,/dev/sdb).}
	thinpool=${10:# The thin pool volume name. When you want to create a thin provisioned volume, specify a thin pool volume name.}
	shrink=${11:yes}
	resizefs=${12:no}

endsnippet

snippet group "Add or remove groups" b
group: >
	name=${1:# Name of the group to manage.}

	gid=${2:# Optional I(GID) to set for the group.}
	state=${3:absent|#present}
	system=${4:no}
	local=${5:no}
	non_unique=${6:no}

endsnippet

snippet make "Run targets in a Makefile" b
make: >
	chdir=${1:# Change to this directory before running make.}

	target=${2:# The target to run.}
	params=${3:# Any extra parameters to pass to make.}
	file=${4:# Use a custom Makefile.}

endsnippet

snippet mount "Control active and configured mount points" b
mount: >
	path=${1:# Path to the mount point (e.g. C(/mnt/files)).}
	state=${2:absent|mounted|present|unmounted|remounted}

	src=${3:# Device to be mounted on I(path).}
	fstype=${4:# Filesystem type.}
	opts=${5:# Mount options (see fstab(5), or vfstab(4) on Solaris).}
	dump=${6:0}
	passno=${7:0}
	fstab=${8:# File to use instead of C(/etc/fstab).}
	boot=${9:yes}
	backup=${10:no}

endsnippet

snippet iptables "Modify iptables rules" b
iptables: >
	table=${1:#filter|nat|mangle|raw|security}
	state=${2:absent|#present}
	action=${3:#append|insert}
	rule_num=${4:# Insert the rule as the given rule number.}
	ip_version=${5:#ipv4|ipv6}
	chain=${6:# Specify the iptables chain to modify.}
	protocol=${7:# The protocol of the rule or of the packet to check.}
	source=${8:# Source specification.}
	destination=${9:# Destination specification.}
	tcp_flags=${10:{}}
	match=${11:[]}
	jump=${12:# This specifies the target of the rule; i.e., what to do if the packet matches it.}
	gateway=${13:# This specifies the IP address of host to send the cloned packets.}
	log_prefix=${14:# Specifies a log text for the rule. Only make sense with a LOG jump.}
	log_level=${15:0|1|2|3|4|5|6|7|emerg|alert|crit|error|warning|notice|info|debug}
	goto=${16:# This specifies that the processing should continue in a user specified chain.}
	in_interface=${17:# Name of an interface via which a packet was received (only for packets entering the C(INPUT), C(FORWARD) and C(PREROUTING) chains).}
	out_interface=${18:# Name of an interface via which a packet is going to be sent (for packets entering the C(FORWARD), C(OUTPUT) and C(POSTROUTING) chains).}
	fragment=${19:# This means that the rule only refers to second and further fragments of fragmented packets.}
	set_counters=${20:# This enables the administrator to initialize the packet and byte counters of a rule (during C(INSERT), C(APPEND), C(REPLACE) operations).}
	source_port=${21:# Source port or port range specification.}
	destination_port=${22:# Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.}
	to_ports=${23:# This specifies a destination port or range of ports to use, without this, the destination port is never altered.}
	to_destination=${24:# This specifies a destination address to use with C(DNAT).}
	to_source=${25:# This specifies a source address to use with C(SNAT).}
	syn=${26:#ignore|match|negate}
	set_dscp_mark=${27:# This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.}
	set_dscp_mark_class=${28:# This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.}
	comment=${29:# This specifies a comment that will be added to the rule.}
	ctstate=${30:[]}
	src_range=${31:# Specifies the source IP range to match in the iprange module.}
	dst_range=${32:# Specifies the destination IP range to match in the iprange module.}
	limit=${33:# Specifies the maximum average number of matches to allow per second.}
	limit_burst=${34:# Specifies the maximum burst before the above limit kicks in.}
	uid_owner=${35:# Specifies the UID or username to use in match by owner rule.}
	gid_owner=${36:# Specifies the GID or group to use in match by owner rule.}
	reject_with=${37:# Specifies the error packet type to return while rejecting. It implies "jump: REJECT"}
	icmp_type=${38:# This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'}
	flush=${39:# Flushes the specified table and chain of all rules.}
	policy=${40:ACCEPT|DROP|QUEUE|RETURN}

endsnippet

snippet java_cert "Uses keytool to import/remove key from java keystore (cacerts)" b
java_cert: >
	keystore_pass=${1:# Keystore password.}

	cert_url=${2:# Basic URL to fetch SSL certificate from.}
	cert_port=${3:443}
	cert_path=${4:# Local path to load certificate from.}
	cert_alias=${5:# Imported certificate alias.}
	pkcs12_path=${6:# Local path to load PKCS12 keystore from.}
	pkcs12_password=${7:}
	pkcs12_alias=${8:# Alias in the PKCS12 keystore.}
	keystore_path=${9:# Path to keystore.}
	keystore_create=${10:# Create keystore if it does not exist.}
	keystore_type=${11:# Keystore type (JCEKS, JKS).}
	executable=${12:keytool}
	state=${13:absent|#present}

endsnippet

snippet sysctl "Manage entries in sysctl.conf." b
sysctl: >
	name=${1:# The dot-separated path (aka I(key)) specifying the sysctl variable.}

	value=${2:# Desired value of the sysctl key.}
	state=${3:#present|absent}
	ignoreerrors=${4:no}
	reload=${5:yes}
	sysctl_file=${6:/etc/sysctl.conf}
	sysctl_set=${7:no}

endsnippet

snippet lvg "Configure LVM volume groups" b
lvg: >
	vg=${1:# The name of the volume group.}

	pvs=${2:# List of comma-separated devices to use as physical devices in this volume group.}
	pesize=${3:4}
	pv_options=${4:# Additional options to pass to C(pvcreate) when creating the volume group.}
	vg_options=${5:# Additional options to pass to C(vgcreate) when creating the volume group.}
	state=${6:absent|#present}
	force=${7:no}

endsnippet

snippet locale_gen "Creates or removes locales" b
locale_gen: >
	name=${1:# Name and encoding of the locale, such as "en_GB.UTF-8".}

	state=${2:absent|#present}

endsnippet

snippet timezone "Configure timezone setting" b
timezone: >
	name=${1:# Name of the timezone for the system clock.}
	hwclock=${2:local|UTC}

endsnippet

snippet seport "Manages SELinux network port type definitions" b
seport: >
	ports=${1:# Ports or port ranges.}
	proto=${2:tcp|udp}
	setype=${3:# SELinux type for the specified port.}

	state=${4:absent|#present}
	reload=${5:yes}
	ignore_selinux_state=${6:no}

endsnippet

snippet python_requirements_info "Show python path and assert dependency versions" b
python_requirements_info: >
	dependencies=${1:# A}

endsnippet

snippet alternatives "Manages alternative programs for common commands" b
alternatives: >
	name=${1:# The generic name of the link.}
	path=${2:# The path to the real executable that the link should point to.}

	link=${3:# The path to the symbolic link that should point to the real executable.}
	priority=${4:50}

endsnippet

snippet hostname "Manage hostname" b
hostname: >
	name=${1:# Name of the host}

	use=${2:generic|debian|sles|redhat|alpine|systemd|openrc|openbsd|solaris|freebsd}

endsnippet

snippet seboolean "Toggles SELinux booleans" b
seboolean: >
	name=${1:# Name of the boolean to configure.}
	state=${2:# Desired boolean value}

	persistent=${3:no}
	ignore_selinux_state=${4:no}

endsnippet

snippet ping "Try to connect to host, verify a usable python and return C(pong) on success" b
ping: >
	data=${1:pong}

endsnippet

snippet interfaces_file "Tweak settings in /etc/network/interfaces files" b
interfaces_file: >
	dest=${1:/etc/network/interfaces}
	iface=${2:# Name of the interface, required for value changes or option remove}
	address_family=${3:# Address family of the interface, useful if same interface name is used for both inet and inet6}
	option=${4:# Name of the option, required for value changes or option remove}
	value=${5:# If I(option) is not presented for the I(interface) and I(state) is C(present) option will be added. If I(option) already exists and is not C(pre-up), C(up), C(post-up) or C(down), it's value will be updated. C(pre-up), C(up), C(post-up) and C(down) options can't be updated, only adding new options, removing existing ones or cleaning the whole option set are supported}
	backup=${6:no}
	state=${7:#present|absent}
	mode=${8:# The permissions the resulting file or directory should have.}
	owner=${9:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${10:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${11:# The user part of the SELinux file context.}
	serole=${12:# The role part of the SELinux file context.}
	setype=${13:# The type part of the SELinux file context.}
	selevel=${14:s0}
	unsafe_writes=${15:no}
	attributes=${16:# The attributes the resulting file or directory should have.}

endsnippet

snippet aix_devices "Manages AIX devices" b
aix_devices: >
	device=${1:# The name of the device.}

	attributes=${2:# A list of device attributes.}
	force=${3:no}
	recursive=${4:no}
	state=${5:#available|defined|removed}

endsnippet

snippet selinux_permissive "Change permissive domain in SELinux policy" b
selinux_permissive: >
	domain=${1:}
	permissive=${2:# Indicate if the domain should or should not be set as permissive.}

	no_reload=${3:no}
	store=${4:# Name of the SELinux policy store to use.}

endsnippet

snippet add_host "Add a host (and alternatively a group) to the ansible-playbook in-memory inventory" b
add_host: >
	name=${1:# The hostname/ip of the host to add to the inventory, can include a colon and a port number.}

	groups=${2:# The groups to add the hostname to.}

endsnippet

snippet group_by "Create Ansible groups based on facts" b
group_by: >
	key=${1:# The variables whose values will be used as groups.}

	parents=${2:all}

endsnippet

snippet ali_instance "Create, Start, Stop, Restart or Terminate an Instance in ECS. Add or Remove Instance to/from a Security Group." b
ali_instance: >
	state=${1:#present|running|stopped|restarted|absent}
	availability_zone=${2:# Aliyun availability zone ID in which to launch the instance. If it is not specified, it will be allocated by system automatically.}
	image_id=${3:# Image ID used to launch instances. Required when C(state=present) and creating new ECS instances.}
	instance_type=${4:# Instance type used to launch instances. Required when C(state=present) and creating new ECS instances.}
	security_groups=${5:# A list of security group IDs.}
	vswitch_id=${6:# The subnet ID in which to launch the instances (VPC).}
	instance_name=${7:# The name of ECS instance, which is a string of 2 to 128 Chinese or English characters. It must begin with an uppercase/lowercase letter or a Chinese character and can contain numerals, ".", "_" or "-". It cannot begin with http:// or https://.}
	description=${8:# The description of ECS instance, which is a string of 2 to 256 characters. It cannot begin with http:// or https://.}
	internet_charge_type=${9:#PayByBandwidth|PayByTraffic}
	max_bandwidth_in=${10:200}
	max_bandwidth_out=${11:0}
	host_name=${12:# Instance host name.}
	password=${13:# The password to login instance. After rebooting instances, modified password will take effect.}
	system_disk_category=${14:#cloud_efficiency|cloud_ssd}
	system_disk_size=${15:40}
	system_disk_name=${16:# Name of the system disk.}
	system_disk_description=${17:# Description of the system disk.}
	count=${18:1}
	count_tag=${19:# I(count) determines how many instances based on a specific tag criteria should be present. This can be expressed in multiple ways and is shown in the EXAMPLES section. The specified count_tag must already exist or be passed in as the I(instance_tags) option. If it is not specified, it will be replaced by I(instance_name).}
	allocate_public_ip=${20:no}
	instance_charge_type=${21:PrePaid|#PostPaid}
	period=${22:1}
	auto_renew=${23:no}
	auto_renew_period=${24:1|2|3|6|12}
	instance_ids=${25:# A list of instance ids. It is required when need to operate existing instances. If it is specified, I(count) will lose efficacy.}
	force=${26:no}
	instance_tags=${27:# A hash/dictionaries of instance tags, to add to the new instance or for starting/stopping instance by tag. C({"key":"value"})}
	key_name=${28:# The name of key pair which is used to access ECS instance in SSH.}
	user_data=${29:# User-defined data to customize the startup behaviors of an ECS instance and to pass data into an ECS instance. It only will take effect when launching the new ECS instances.}
	alicloud_access_key=${30:# Aliyun Cloud access key.}
	alicloud_secret_key=${31:# Aliyun Cloud secret key.}
	alicloud_region=${32:# The Aliyun Cloud region to use.}
	alicloud_security_token=${33:# The Aliyun Cloud security token.}

endsnippet

snippet ali_instance_info "Gather information on instances of Alibaba Cloud ECS." b
ali_instance_info: >
	availability_zone=${1:# Aliyun availability zone ID in which to launch the instance}
	instance_names=${2:# A list of ECS instance names.}
	instance_ids=${3:# A list of ECS instance ids.}
	instance_tags=${4:# A hash/dictionaries of instance tags. C({"key":"value"})}
	alicloud_access_key=${5:# Aliyun Cloud access key.}
	alicloud_secret_key=${6:# Aliyun Cloud secret key.}
	alicloud_region=${7:# The Aliyun Cloud region to use.}
	alicloud_security_token=${8:# The Aliyun Cloud security token.}

endsnippet

snippet ali_instance_info "Gather information on instances of Alibaba Cloud ECS." b
ali_instance_info: >
	availability_zone=${1:# Aliyun availability zone ID in which to launch the instance}
	instance_names=${2:# A list of ECS instance names.}
	instance_ids=${3:# A list of ECS instance ids.}
	instance_tags=${4:# A hash/dictionaries of instance tags. C({"key":"value"})}
	alicloud_access_key=${5:# Aliyun Cloud access key.}
	alicloud_secret_key=${6:# Aliyun Cloud secret key.}
	alicloud_region=${7:# The Aliyun Cloud region to use.}
	alicloud_security_token=${8:# The Aliyun Cloud security token.}

endsnippet

snippet webfaction_site "Add or remove a website on a Webfaction host" b
webfaction_site: >
	name=${1:# The name of the website}
	host=${2:# The webfaction host on which the site should be created.}
	login_name=${3:# The webfaction account to use}
	login_password=${4:# The webfaction password to use}

	state=${5:#present|absent}
	https=${6:no}
	site_apps=${7:[]}
	subdomains=${8:[]}

endsnippet

snippet webfaction_domain "Add or remove domains and subdomains on Webfaction" b
webfaction_domain: >
	name=${1:# The name of the domain}
	login_name=${2:# The webfaction account to use}
	login_password=${3:# The webfaction password to use}

	state=${4:#present|absent}
	subdomains=${5:[]}

endsnippet

snippet webfaction_db "Add or remove a database on Webfaction" b
webfaction_db: >
	name=${1:# The name of the database}
	type=${2:mysql|postgresql}
	login_name=${3:# The webfaction account to use}
	login_password=${4:# The webfaction password to use}

	state=${5:#present|absent}
	password=${6:# The password for the new database user.}
	machine=${7:# The machine name to use (optional for accounts with only one machine)}

endsnippet

snippet webfaction_mailbox "Add or remove mailboxes on Webfaction" b
webfaction_mailbox: >
	mailbox_name=${1:# The name of the mailbox}
	mailbox_password=${2:# The password for the mailbox}
	login_name=${3:# The webfaction account to use}
	login_password=${4:# The webfaction password to use}

	state=${5:#present|absent}

endsnippet

snippet webfaction_app "Add or remove applications on a Webfaction host" b
webfaction_app: >
	name=${1:# The name of the application}
	type=${2:# The type of application to create. See the Webfaction docs at U(https://docs.webfaction.com/xmlrpc-api/apps.html) for a list.}
	login_name=${3:# The webfaction account to use}
	login_password=${4:# The webfaction password to use}

	state=${5:#present|absent}
	autostart=${6:no}
	extra_info=${7:}
	port_open=${8:no}
	machine=${9:# The machine name to use (optional for accounts with only one machine)}

endsnippet

snippet serverless "Manages a Serverless Framework project" b
serverless: >
	service_path=${1:# The path to the root of the Serverless Service to be operated on.}

	state=${2:absent|#present}
	serverless_bin_path=${3:# The path of a serverless framework binary relative to the 'service_path' eg. node_module/.bin/serverless}
	stage=${4:# The name of the serverless framework project stage to deploy to.}
	functions=${5:[]}
	region=${6:# AWS region to deploy the service to.}
	deploy=${7:yes}
	force=${8:no}
	verbose=${9:no}

endsnippet

snippet rhevm "RHEV/oVirt automation" b
rhevm: >
	user=${1:admin@internal}
	password=${2:# The password for user authentication.}
	server=${3:127.0.0.1}
	port=${4:443}
	insecure_api=${5:no}
	name=${6:# The name of the VM.}
	cluster=${7:# The RHEV/oVirt cluster in which you want you VM to start.}
	datacenter=${8:Default}
	state=${9:absent|cd|down|info|ping|#present|restarted|up}
	image=${10:# The template to use for the VM.}
	type=${11:desktop|host|#server}
	vmhost=${12:# The host you wish your VM to run on.}
	vmcpu=${13:2}
	cpu_share=${14:0}
	vmmem=${15:1}
	osver=${16:rhel_6x64}
	mempol=${17:1}
	vm_ha=${18:yes}
	disks=${19:# This option uses complex arguments and is a list of disks with the options name, size and domain.}
	ifaces=${20:# This option uses complex arguments and is a list of interfaces with the options name and vlan.}
	boot_order=${21:['hd', 'network']}
	del_prot=${22:yes}
	cd_drive=${23:# The CD you wish to have mounted on the VM when I(state = 'CD').}
	timeout=${24:# The timeout you wish to define for power actions.}

endsnippet

snippet cloud_init_data_facts "Retrieve facts of cloud-init." b
cloud_init_data_facts: >
	filter=${1:status|result}

endsnippet

snippet terraform "Manages a Terraform deployment (and plans)" b
terraform: >
	project_path=${1:# The path to the root of the Terraform directory with the vars.tf/main.tf/etc to use.}

	state=${2:planned|#present|absent}
	binary_path=${3:# The path of a terraform binary to use, relative to the 'service_path' unless you supply an absolute path.}
	workspace=${4:default}
	purge_workspace=${5:no}
	plan_file=${6:# The path to an existing Terraform plan file to apply. If this is not specified, Ansible will build a new TF plan and execute it. Note that this option is required if 'state' has the 'planned' value.}
	state_file=${7:# The path to an existing Terraform state file to use when building plan. If this is not specified, the default `terraform.tfstate` will be used.}
	variables_file=${8:# The path to a variables file for Terraform to fill into the TF configurations.}
	variables=${9:# A group of key-values to override template variables or those in variables files.}
	targets=${10:# A list of specific resources to target in this plan/application. The resources selected here will also auto-include any dependencies.}
	lock=${11:# Enable statefile locking, if you use a service that accepts locks (such as S3+DynamoDB) to store your statefile.}
	lock_timeout=${12:# How long to maintain the lock on the statefile, if you use a service that accepts locks (such as S3+DynamoDB).}
	force_init=${13:no}
	backend_config=${14:# A group of key-values to provide at init stage to the -backend-config parameter.}

endsnippet

snippet virt "Manages virtual machines supported by libvirt" b
virt: >
	name=${1:# name of the guest VM being managed. Note that VM must be previously defined with xml.}
	state=${2:destroyed|paused|running|shutdown}
	command=${3:create|define|destroy|freemem|get_xml|info|list_vms|nodeinfo|pause|shutdown|start|status|stop|undefine|unpause|virttype}
	autostart=${4:# start VM at host startup.}
	uri=${5:qemu:///system}
	xml=${6:# XML document used with the define command.}

endsnippet

snippet ovirt "oVirt/RHEV platform management" b
ovirt: >
	user=${1:# The user to authenticate with.}
	url=${2:# The url of the oVirt instance.}
	instance_name=${3:# The name of the instance to use.}
	password=${4:# Password of the user to authenticate with.}

	image=${5:# The template to use for the instance.}
	resource_type=${6:new|template}
	zone=${7:# Deploy the image to this oVirt cluster.}
	instance_disksize=${8:# Size of the instance's disk in GB.}
	instance_cpus=${9:1}
	instance_nic=${10:# The name of the network interface in oVirt/RHEV.}
	instance_network=${11:rhevm}
	instance_mem=${12:# The instance's amount of memory in MB.}
	instance_type=${13:desktop|#server|high_performance}
	disk_alloc=${14:preallocated|#thin}
	disk_int=${15:ide|#virtio}
	instance_os=${16:# Type of Operating System.}
	instance_cores=${17:1}
	sdomain=${18:# The Storage Domain where you want to create the instance's disk on.}
	region=${19:# The oVirt/RHEV datacenter where you want to deploy to.}
	instance_dns=${20:# Define the instance's Primary DNS server.}
	instance_domain=${21:# Define the instance's Domain.}
	instance_hostname=${22:# Define the instance's Hostname.}
	instance_ip=${23:# Define the instance's IP.}
	instance_netmask=${24:# Define the instance's Netmask.}
	instance_rootpw=${25:# Define the instance's Root password.}
	instance_key=${26:# Define the instance's Authorized key.}
	state=${27:absent|#present|restarted|shutdown|started}

endsnippet

snippet proxmox "management of instances in Proxmox VE cluster" b
proxmox: >
	api_host=${1:# the host of the Proxmox VE cluster}
	api_user=${2:# the user to authenticate with}

	api_password=${3:# the password to authenticate with}
	vmid=${4:# the instance id}
	validate_certs=${5:no}
	node=${6:# Proxmox VE node, when new VM will be created}
	pool=${7:# Proxmox VE resource pool}
	password=${8:# the instance root password}
	hostname=${9:# the instance hostname}
	ostemplate=${10:# the template for VM creating}
	disk=${11:3}
	cores=${12:1}
	cpus=${13:1}
	memory=${14:512}
	swap=${15:0}
	netif=${16:# specifies network interfaces for the container. As a hash/dictionary defining interfaces.}
	mounts=${17:# specifies additional mounts (separate disks) for the container. As a hash/dictionary defining mount points}
	ip_address=${18:# specifies the address the container will be assigned}
	onboot=${19:no}
	storage=${20:local}
	cpuunits=${21:1000}
	nameserver=${22:# sets DNS server IP address for a container}
	searchdomain=${23:# sets DNS search domain for a container}
	timeout=${24:30}
	force=${25:no}
	state=${26:#present|started|absent|stopped|restarted}
	pubkey=${27:# Public key to add to /root/.ssh/authorized_keys. This was added on Proxmox 4.2, it is ignored for earlier versions}
	unprivileged=${28:no}

endsnippet

snippet proxmox_template "management of OS templates in Proxmox VE cluster" b
proxmox_template: >
	api_host=${1:# the host of the Proxmox VE cluster}
	api_user=${2:# the user to authenticate with}
	node=${3:# Proxmox VE node, when you will operate with template}

	api_password=${4:# the password to authenticate with}
	validate_certs=${5:no}
	src=${6:# path to uploaded file}
	template=${7:# the template name}
	content_type=${8:#vztmpl|iso}
	storage=${9:local}
	timeout=${10:30}
	force=${11:no}
	state=${12:#present|absent}

endsnippet

snippet virt_net "Manage libvirt network configuration" b
virt_net: >
	name=${1:# name of the network being managed. Note that network must be previously defined with xml.}

	state=${2:active|inactive|present|absent}
	command=${3:define|create|start|stop|destroy|undefine|get_xml|list_nets|facts|info|status|modify}
	autostart=${4:# Specify if a given network should be started automatically on system boot.}
	uri=${5:qemu:///system}
	xml=${6:# XML document used with the define command.}

endsnippet

snippet xenserver_facts "get facts reported on xenserver" b
xenserver_facts:

endsnippet

snippet helm "Manages Kubernetes packages with the Helm package manager" b
helm: >
	host=${1:localhost}
	port=${2:44134}
	namespace=${3:default}
	name=${4:# Release name to manage.}
	state=${5:absent|purged|#present}
	chart=${6:{}}
	values=${7:{}}
	disable_hooks=${8:no}

endsnippet

snippet virt_pool "Manage libvirt storage pools" b
virt_pool: >
	name=${1:# name of the storage pool being managed. Note that pool must be previously defined with xml.}
	state=${2:active|inactive|present|absent|undefined|deleted}
	command=${3:define|build|create|start|stop|destroy|delete|undefine|get_xml|list_pools|facts|info|status}
	autostart=${4:# Specify if a given storage pool should be started automatically on system boot.}
	uri=${5:qemu:///system}
	xml=${6:# XML document used with the define command.}
	mode=${7:new|repair|resize|no_overwrite|overwrite|normal|zeroed}

endsnippet

snippet proxmox_kvm "Management of Qemu(KVM) Virtual Machines in Proxmox VE cluster." b
proxmox_kvm: >
	api_host=${1:# Specify the target host of the Proxmox VE cluster.}
	api_user=${2:# Specify the user to authenticate with.}

	acpi=${3:yes}
	agent=${4:# Specify if the QEMU Guest Agent should be enabled/disabled.}
	args=${5:-serial unix:/var/run/qemu-server/VMID.serial,server,nowait}
	api_password=${6:# Specify the password to authenticate with.}
	autostart=${7:no}
	balloon=${8:0}
	bios=${9:seabios|ovmf}
	boot=${10:cnd}
	bootdisk=${11:# Enable booting from specified disk. C((ide|sata|scsi|virtio)\d+)}
	clone=${12:# Name of VM to be cloned. If C(vmid) is setted, C(clone) can take arbitrary value but required for initiating the clone.}
	cores=${13:1}
	cpu=${14:kvm64}
	cpulimit=${15:# Specify if CPU usage will be limited. Value 0 indicates no CPU limit.}
	cpuunits=${16:1000}
	delete=${17:# Specify a list of settings you want to delete.}
	description=${18:# Specify the description for the VM. Only used on the configuration web interface.}
	digest=${19:# Specify if to prevent changes if current configuration file has different SHA1 digest.}
	force=${20:# Allow to force stop VM.}
	format=${21:cloop|cow|qcow|#qcow2|qed|raw|vmdk}
	freeze=${22:# Specify if PVE should freeze CPU at startup (use 'c' monitor command to start execution).}
	full=${23:yes}
	hostpci=${24:# Specify a hash/dictionary of map host pci devices into guest. C(hostpci='{"key":"value", "key":"value"}').}
	hotplug=${25:# Selectively enable hotplug features.}
	hugepages=${26:any|2|1024}
	ide=${27:# A hash/dictionary of volume used as IDE hard disk or CD-ROM. C(ide='{"key":"value", "key":"value"}').}
	keyboard=${28:# Sets the keyboard layout for VNC server.}
	kvm=${29:yes}
	localtime=${30:# Sets the real time clock to local time.}
	lock=${31:migrate|backup|snapshot|rollback}
	machine=${32:# Specifies the Qemu machine type.}
	memory=${33:512}
	migrate_downtime=${34:# Sets maximum tolerated downtime (in seconds) for migrations.}
	migrate_speed=${35:# Sets maximum speed (in MB/s) for migrations.}
	name=${36:# Specifies the VM name. Only used on the configuration web interface.}
	net=${37:# A hash/dictionary of network interfaces for the VM. C(net='{"key":"value", "key":"value"}').}
	newid=${38:# VMID for the clone. Used only with clone.}
	node=${39:# Proxmox VE node, where the new VM will be created.}
	numa=${40:# A hash/dictionaries of NUMA topology. C(numa='{"key":"value", "key":"value"}').}
	onboot=${41:yes}
	ostype=${42:other|wxp|w2k|w2k3|w2k8|wvista|win7|win8|l24|#l26|solaris}
	parallel=${43:# A hash/dictionary of map host parallel devices. C(parallel='{"key":"value", "key":"value"}').}
	pool=${44:# Add the new VM to the specified pool.}
	protection=${45:# Enable/disable the protection flag of the VM. This will enable/disable the remove VM and remove disk operations.}
	reboot=${46:# Allow reboot. If set to C(yes), the VM exit on reboot.}
	revert=${47:# Revert a pending change.}
	sata=${48:# A hash/dictionary of volume used as sata hard disk or CD-ROM. C(sata='{"key":"value", "key":"value"}').}
	scsi=${49:# A hash/dictionary of volume used as SCSI hard disk or CD-ROM. C(scsi='{"key":"value", "key":"value"}').}
	scsihw=${50:lsi|lsi53c810|virtio-scsi-pci|virtio-scsi-single|megasas|pvscsi}
	serial=${51:# A hash/dictionary of serial device to create inside the VM. C('{"key":"value", "key":"value"}').}
	shares=${52:# Rets amount of memory shares for auto-ballooning. (0 - 50000).}
	skiplock=${53:# Ignore locks}
	smbios=${54:# Specifies SMBIOS type 1 fields.}
	snapname=${55:# The name of the snapshot. Used only with clone.}
	sockets=${56:1}
	startdate=${57:# Sets the initial date of the real time clock.}
	startup=${58:# Startup and shutdown behavior. C([[order=]\d+] [,up=\d+] [,down=\d+]).}
	state=${59:#present|started|absent|stopped|restarted|current}
	storage=${60:# Target storage for full clone.}
	tablet=${61:no}
	target=${62:# Target node. Only allowed if the original VM is on shared storage.}
	tdf=${63:# Enables/disables time drift fix.}
	template=${64:no}
	timeout=${65:30}
	update=${66:no}
	validate_certs=${67:no}
	vcpus=${68:# Sets number of hotplugged vcpus.}
	vga=${69:#std|cirrus|vmware|qxl|serial0|serial1|serial2|serial3|qxl2|qxl3|qxl4}
	virtio=${70:# A hash/dictionary of volume used as VIRTIO hard disk. C(virtio='{"key":"value", "key":"value"}').}
	vmid=${71:# Specifies the VM ID. Instead use I(name) parameter.}
	watchdog=${72:# Creates a virtual hardware watchdog device.}

endsnippet

snippet os_client_config "Get OpenStack Client config" b
os_client_config: >
	clouds=${1:[]}

endsnippet

snippet os_user_info "Retrieve information about one or more OpenStack users" b
os_user_info: >
	name=${1:# Name or ID of the user}

	domain=${2:# Name or ID of the domain containing the user if the cloud supports domains}
	filters=${3:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_pool "Add/Delete a pool in the load balancing service from OpenStack Cloud" b
os_pool: >
	name=${1:# Name that has to be given to the pool}

	state=${2:#present|absent}
	loadbalancer=${3:# The name or id of the load balancer that this pool belongs to. Either loadbalancer or listener must be specified for pool creation.}
	listener=${4:# The name or id of the listener that this pool belongs to. Either loadbalancer or listener must be specified for pool creation.}
	protocol=${5:#HTTP|HTTPS|PROXY|TCP|UDP}
	lb_algorithm=${6:LEAST_CONNECTIONS|#ROUND_ROBIN|SOURCE_IP}
	wait=${7:yes}
	timeout=${8:180}
	availability_zone=${9:# Ignored. Present for backwards compatibility}
	cloud=${10:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${12:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${13:# Name of the region.}
	api_timeout=${14:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${15:no}
	ca_cert=${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${17:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${18:# A path to a client key to use as part of the SSL transaction.}
	interface=${19:admin|internal|#public}

endsnippet

snippet os_subnets_info "Retrieve information about one or more OpenStack subnets." b
os_subnets_info: >
	name=${1:# Name or ID of the subnet.}
	filters=${2:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_nova_flavor "Manage OpenStack compute flavors" b
os_nova_flavor: >
	name=${1:# Flavor name.}

	state=${2:#present|absent}
	ram=${3:# Amount of memory, in MB.}
	vcpus=${4:# Number of virtual CPUs.}
	disk=${5:# Size of local disk, in GB.}
	ephemeral=${6:0}
	swap=${7:0}
	rxtx_factor=${8:1.0}
	is_public=${9:yes}
	flavorid=${10:auto}
	availability_zone=${11:# Ignored. Present for backwards compatibility}
	extra_specs=${12:# Metadata dictionary}
	cloud=${13:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${14:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${15:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${16:# Name of the region.}
	wait=${17:yes}
	timeout=${18:180}
	api_timeout=${19:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${20:no}
	ca_cert=${21:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${22:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${23:# A path to a client key to use as part of the SSL transaction.}
	interface=${24:admin|internal|#public}

endsnippet

snippet os_project_info "Retrieve information about one or more OpenStack projects" b
os_project_info: >
	name=${1:# Name or ID of the project}

	domain=${2:# Name or ID of the domain containing the project if the cloud supports domains}
	filters=${3:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_coe_cluster "Add/Remove COE cluster from OpenStack Cloud" b
os_coe_cluster: >
	cluster_template_id=${1:# The template ID of cluster template.}
	name=${2:# Name that has to be given to the cluster template}

	availability_zone=${3:# Ignored. Present for backwards compatibility}
	discovery_url=${4:# Url used for cluster node discovery}
	docker_volume_size=${5:# The size in GB of the docker volume}
	flavor_id=${6:# The flavor of the minion node for this ClusterTemplate}
	keypair=${7:# Name of the keypair to use.}
	labels=${8:# One or more key/value pairs}
	master_flavor_id=${9:# The flavor of the master node for this ClusterTemplate}
	master_count=${10:1}
	node_count=${11:1}
	state=${12:#present|absent}
	timeout=${13:60}
	cloud=${14:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${15:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${16:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${17:# Name of the region.}
	wait=${18:yes}
	api_timeout=${19:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${20:no}
	ca_cert=${21:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${22:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${23:# A path to a client key to use as part of the SSL transaction.}
	interface=${24:admin|internal|#public}

endsnippet

snippet os_security_group_rule "Add/Delete rule from an existing security group" b
os_security_group_rule: >
	security_group=${1:# Name or ID of the security group}

	protocol=${2:tcp|udp|icmp|112|None}
	port_range_min=${3:# Starting port}
	port_range_max=${4:# Ending port}
	remote_ip_prefix=${5:# Source IP address(es) in CIDR notation (exclusive with remote_group)}
	remote_group=${6:# Name or ID of the Security group to link (exclusive with remote_ip_prefix)}
	ethertype=${7:#IPv4|IPv6}
	direction=${8:egress|#ingress}
	state=${9:#present|absent}
	project=${10:# Unique name or ID of the project.}
	availability_zone=${11:# Ignored. Present for backwards compatibility}
	cloud=${12:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${13:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${14:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${15:# Name of the region.}
	wait=${16:yes}
	timeout=${17:180}
	api_timeout=${18:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${19:no}
	ca_cert=${20:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${21:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${22:# A path to a client key to use as part of the SSL transaction.}
	interface=${23:admin|internal|#public}

endsnippet

snippet os_stack "Add/Remove Heat Stack" b
os_stack: >
	name=${1:# Name of the stack that should be created, name could be char and digit, no space}

	state=${2:#present|absent}
	tag=${3:# Tag for the stack that should be created, name could be char and digit, no space}
	template=${4:# Path of the template file to use for the stack creation}
	environment=${5:# List of environment files that should be used for the stack creation}
	parameters=${6:# Dictionary of parameters for the stack creation}
	rollback=${7:yes}
	timeout=${8:3600}
	availability_zone=${9:# Ignored. Present for backwards compatibility}
	cloud=${10:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${12:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${13:# Name of the region.}
	wait=${14:yes}
	api_timeout=${15:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${16:no}
	ca_cert=${17:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${18:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${19:# A path to a client key to use as part of the SSL transaction.}
	interface=${20:admin|internal|#public}

endsnippet

snippet os_project_info "Retrieve information about one or more OpenStack projects" b
os_project_info: >
	name=${1:# Name or ID of the project}

	domain=${2:# Name or ID of the domain containing the project if the cloud supports domains}
	filters=${3:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_group "Manage OpenStack Identity Groups" b
os_group: >
	name=${1:# Group name}

	description=${2:# Group description}
	domain_id=${3:# Domain id to create the group in if the cloud supports domains.}
	state=${4:#present|absent}
	availability_zone=${5:# Ignored. Present for backwards compatibility}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_router "Create or delete routers from OpenStack" b
os_router: >
	name=${1:# Name to be give to the router}

	state=${2:#present|absent}
	admin_state_up=${3:yes}
	enable_snat=${4:# Enable Source NAT (SNAT) attribute.}
	network=${5:# Unique name or ID of the external gateway network.}
	project=${6:# Unique name or ID of the project.}
	external_fixed_ips=${7:# The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.}
	interfaces=${8:# List of subnets to attach to the router internal interface. Default gateway associated with the subnet will be automatically attached with the router's internal interface. In order to provide an ip address different from the default gateway,parameters are passed as dictionary with keys as network name or ID(net), subnet name or ID (subnet) and the IP of port (portip) from the network. User defined portip is often required when a multiple router need to be connected to a single subnet for which the default gateway has been already used.}
	availability_zone=${9:# Ignored. Present for backwards compatibility}
	cloud=${10:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${12:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${13:# Name of the region.}
	wait=${14:yes}
	timeout=${15:180}
	api_timeout=${16:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${17:no}
	ca_cert=${18:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${19:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${20:# A path to a client key to use as part of the SSL transaction.}
	interface=${21:admin|internal|#public}

endsnippet

snippet os_project_access "Manage OpenStack compute flavors access" b
os_project_access: >
	target_project_id=${1:# Project id.}

	state=${2:#present|absent}
	resource_type=${3:# The resource type (eg. nova_flavor, cinder_volume_type).}
	resource_name=${4:# The resource name (eg. tiny).}
	availability_zone=${5:# The availability zone of the resource.}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_server_metadata "Add/Update/Delete Metadata in Compute Instances from OpenStack" b
os_server_metadata: >
	server=${1:# Name of the instance to update the metadata}
	meta=${2:# A list of key value pairs that should be provided as a metadata to the instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"}

	state=${3:#present|absent}
	availability_zone=${4:# Availability zone in which to create the snapshot.}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_keystone_domain_info "Retrieve information about one or more OpenStack domains" b
os_keystone_domain_info: >
	name=${1:# Name or ID of the domain}
	filters=${2:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_keystone_domain_info "Retrieve information about one or more OpenStack domains" b
os_keystone_domain_info: >
	name=${1:# Name or ID of the domain}
	filters=${2:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_image_info "Retrieve information about an image within OpenStack." b
os_image_info: >
	image=${1:# Name or ID of the image}
	properties=${2:# Dict of properties of the images used for query}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_listener "Add/Delete a listener for a load balancer from OpenStack Cloud" b
os_listener: >
	name=${1:# Name that has to be given to the listener}
	loadbalancer=${2:# The name or id of the load balancer that this listener belongs to.}

	state=${3:#present|absent}
	protocol=${4:#HTTP|HTTPS|TCP|TERMINATED_HTTPS}
	protocol_port=${5:80}
	wait=${6:yes}
	timeout=${7:180}
	availability_zone=${8:# Ignored. Present for backwards compatibility}
	cloud=${9:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${11:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${12:# Name of the region.}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_server_info "Retrieve information about one or more compute instances" b
os_server_info: >
	server=${1:# restrict results to servers with names or UUID matching this glob expression (e.g., <web*>).}
	detailed=${2:no}
	filters=${3:# restrict results to servers matching a dictionary of filters}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	all_projects=${5:no}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_server_volume "Attach/Detach Volumes from OpenStack VM's" b
os_server_volume: >
	server=${1:# Name or ID of server you want to attach a volume to}
	volume=${2:# Name or id of volume you want to attach to a server}

	state=${3:#present|absent}
	device=${4:# Device you want to attach. Defaults to auto finding a device name.}
	availability_zone=${5:# Ignored. Present for backwards compatibility}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_image "Add/Delete images from OpenStack Cloud" b
os_image: >
	name=${1:# The name of the image when uploading - or the name/ID of the image if deleting}

	id=${2:# The ID of the image when uploading an image}
	checksum=${3:# The checksum of the image}
	disk_format=${4:qcow2}
	container_format=${5:bare}
	owner=${6:# The owner of the image}
	min_disk=${7:# The minimum disk space (in GB) required to boot this image}
	min_ram=${8:# The minimum ram (in MB) required to boot this image}
	is_public=${9:yes}
	protected=${10:no}
	filename=${11:# The path to the file which has to be uploaded}
	ramdisk=${12:# The name of an existing ramdisk image that will be associated with this image}
	kernel=${13:# The name of an existing kernel image that will be associated with this image}
	properties=${14:{}}
	state=${15:#present|absent}
	availability_zone=${16:# Ignored. Present for backwards compatibility}
	cloud=${17:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${18:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${19:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${20:# Name of the region.}
	wait=${21:yes}
	timeout=${22:180}
	api_timeout=${23:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${24:no}
	ca_cert=${25:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${26:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${27:# A path to a client key to use as part of the SSL transaction.}
	interface=${28:admin|internal|#public}

endsnippet

snippet os_user_group "Associate OpenStack Identity users and groups" b
os_user_group: >
	user=${1:# Name or id for the user}
	group=${2:# Name or id for the group.}

	state=${3:#present|absent}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_user_info "Retrieve information about one or more OpenStack users" b
os_user_info: >
	name=${1:# Name or ID of the user}

	domain=${2:# Name or ID of the domain containing the user if the cloud supports domains}
	filters=${3:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_nova_host_aggregate "Manage OpenStack host aggregates" b
os_nova_host_aggregate: >
	name=${1:# N}

	metadata=${2:# M}
	availability_zone=${3:# A}
	hosts=${4:# L}
	state=${5:#present|absent}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_subnets_info "Retrieve information about one or more OpenStack subnets." b
os_subnets_info: >
	name=${1:# Name or ID of the subnet.}
	filters=${2:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_volume "Create/Delete Cinder Volumes" b
os_volume: >
	display_name=${1:# Name of volume}

	size=${2:# Size of volume in GB. This parameter is required when the I(state) parameter is 'present'.}
	display_description=${3:# String describing the volume}
	volume_type=${4:# Volume type for volume}
	image=${5:# Image name or id for boot from volume}
	snapshot_id=${6:# Volume snapshot id to create from}
	volume=${7:# Volume name or id to create from}
	state=${8:#present|absent}
	availability_zone=${9:# Ignored. Present for backwards compatibility}
	scheduler_hints=${10:# Scheduler hints passed to volume API in form of dict}
	metadata=${11:# Metadata for the volume}
	cloud=${12:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${13:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${14:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${15:# Name of the region.}
	wait=${16:yes}
	timeout=${17:180}
	api_timeout=${18:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${19:no}
	ca_cert=${20:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${21:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${22:# A path to a client key to use as part of the SSL transaction.}
	interface=${23:admin|internal|#public}

endsnippet

snippet os_zone "Manage OpenStack DNS zones" b
os_zone: >
	name=${1:# Zone name}

	zone_type=${2:primary|secondary}
	email=${3:# Email of the zone owner (only applies if zone_type is primary)}
	description=${4:# Zone description}
	ttl=${5:# TTL (Time To Live) value in seconds}
	masters=${6:# Master nameservers (only applies if zone_type is secondary)}
	state=${7:#present|absent}
	availability_zone=${8:# Ignored. Present for backwards compatibility}
	cloud=${9:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${11:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${12:# Name of the region.}
	wait=${13:yes}
	timeout=${14:180}
	api_timeout=${15:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${16:no}
	ca_cert=${17:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${18:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${19:# A path to a client key to use as part of the SSL transaction.}
	interface=${20:admin|internal|#public}

endsnippet

snippet os_image_info "Retrieve information about an image within OpenStack." b
os_image_info: >
	image=${1:# Name or ID of the image}
	properties=${2:# Dict of properties of the images used for query}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_keystone_service "Manage OpenStack Identity services" b
os_keystone_service: >
	name=${1:# Name of the service}
	service_type=${2:# The type of service}

	description=${3:# Description of the service}
	enabled=${4:yes}
	state=${5:#present|absent}
	availability_zone=${6:# Ignored. Present for backwards compatibility}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	timeout=${12:180}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_keystone_endpoint "Manage OpenStack Identity service endpoints" b
os_keystone_endpoint: >
	service=${1:# Name or id of the service.}
	endpoint_interface=${2:admin|public|internal}
	url=${3:# URL of the service.}

	region=${4:# Region that the service belongs to. Note that I(region_name) is used for authentication.}
	enabled=${5:yes}
	state=${6:#present|absent}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	timeout=${12:180}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_group_info "Retrieve info about one or more OpenStack groups" b
os_group_info: >
	name=${1:# Name or ID of the group.}

	domain=${2:# Name or ID of the domain containing the group if the cloud supports domains}
	filters=${3:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_volume_snapshot "Create/Delete Cinder Volume Snapshots" b
os_volume_snapshot: >
	display_name=${1:# Name of the snapshot}
	volume=${2:# The volume name or id to create/delete the snapshot}

	display_description=${3:# String describing the snapshot}
	force=${4:no}
	state=${5:#present|absent}
	availability_zone=${6:# Availability zone in which to create the snapshot.}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	timeout=${12:180}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_member "Add/Delete a member for a pool in load balancer from OpenStack Cloud" b
os_member: >
	name=${1:# Name that has to be given to the member}
	pool=${2:# The name or id of the pool that this member belongs to.}

	state=${3:#present|absent}
	protocol_port=${4:80}
	address=${5:# The IP address of the member.}
	subnet_id=${6:# The subnet ID the member service is accessible from.}
	wait=${7:yes}
	timeout=${8:180}
	availability_zone=${9:# Ignored. Present for backwards compatibility}
	cloud=${10:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${11:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${12:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${13:# Name of the region.}
	api_timeout=${14:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${15:no}
	ca_cert=${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${17:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${18:# A path to a client key to use as part of the SSL transaction.}
	interface=${19:admin|internal|#public}

endsnippet

snippet os_project "Manage OpenStack Projects" b
os_project: >
	name=${1:# Name for the project}

	description=${2:# Description for the project}
	domain_id=${3:# Domain id to create the project in if the cloud supports domains.}
	enabled=${4:yes}
	state=${5:#present|absent}
	availability_zone=${6:# Ignored. Present for backwards compatibility}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	timeout=${12:180}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_port_info "Retrieve information about ports within OpenStack." b
os_port_info: >
	port=${1:# Unique name or ID of a port.}
	filters=${2:# A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_flavor_info "Retrieve information about one or more flavors" b
os_flavor_info: >
	name=${1:# A flavor name. Cannot be used with I(ram) or I(vcpus) or I(ephemeral).}
	ram=${2:no}
	vcpus=${3:no}
	limit=${4:# Limits the number of flavors returned. All matching flavors are returned by default.}
	ephemeral=${5:no}
	availability_zone=${6:# Ignored. Present for backwards compatibility}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	timeout=${12:180}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_recordset "Manage OpenStack DNS recordsets" b
os_recordset: >
	zone=${1:# Zone managing the recordset}
	name=${2:# Name of the recordset}
	recordset_type=${3:# Recordset type}
	records=${4:# List of recordset definitions}

	description=${5:# Description of the recordset}
	ttl=${6:# TTL (Time To Live) value in seconds}
	state=${7:#present|absent}
	availability_zone=${8:# Ignored. Present for backwards compatibility}
	cloud=${9:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${10:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${11:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${12:# Name of the region.}
	wait=${13:yes}
	timeout=${14:180}
	api_timeout=${15:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${16:no}
	ca_cert=${17:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${18:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${19:# A path to a client key to use as part of the SSL transaction.}
	interface=${20:admin|internal|#public}

endsnippet

snippet os_server_action "Perform actions on Compute Instances from OpenStack" b
os_server_action: >
	server=${1:# Name or ID of the instance}

	wait=${2:yes}
	timeout=${3:180}
	action=${4:stop|start|pause|unpause|lock|unlock|suspend|resume|rebuild}
	image=${5:# Image the server should be rebuilt with}
	availability_zone=${6:# Ignored. Present for backwards compatibility}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet os_networks_info "Retrieve information about one or more OpenStack networks." b
os_networks_info: >
	name=${1:# Name or ID of the Network}
	filters=${2:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_server_info "Retrieve information about one or more compute instances" b
os_server_info: >
	server=${1:# restrict results to servers with names or UUID matching this glob expression (e.g., <web*>).}
	detailed=${2:no}
	filters=${3:# restrict results to servers matching a dictionary of filters}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	all_projects=${5:no}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_ironic "Create/Delete Bare Metal Resources from OpenStack" b
os_ironic: >
	driver=${1:# The name of the Ironic Driver to use with this node.}
	nics=${2:# A list of network interface cards, eg, " - mac: aa:bb:cc:aa:bb:cc"}

	state=${3:#present|absent}
	uuid=${4:# globally unique identifier (UUID) to be given to the resource. Will be auto-generated if not specified, and name is specified.}
	name=${5:# unique name identifier to be given to the resource.}
	chassis_uuid=${6:# Associate the node with a pre-defined chassis.}
	ironic_url=${7:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.}
	driver_info=${8:# Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.}
	properties=${9:# Definition of the physical characteristics of this server, used for scheduling purposes}
	skip_update_of_driver_password=${10:no}
	availability_zone=${11:# Ignored. Present for backwards compatibility}
	cloud=${12:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${13:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${14:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${15:# Name of the region.}
	wait=${16:yes}
	timeout=${17:180}
	api_timeout=${18:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${19:no}
	ca_cert=${20:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${21:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${22:# A path to a client key to use as part of the SSL transaction.}
	interface=${23:admin|internal|#public}

endsnippet

snippet os_ironic_node "Activate/Deactivate Bare Metal Resources from OpenStack" b
os_ironic_node: >
	state=${1:#present|absent}
	deploy=${2:yes}
	uuid=${3:# globally unique identifier (UUID) to be given to the resource.}
	ironic_url=${4:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API.  Use with "auth" and "auth_type" settings set to None.}
	config_drive=${5:# A configdrive file or HTTP(S) URL that will be passed along to the node.}
	instance_info=${6:# Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.}
	power=${7:#present|absent}
	maintenance=${8:no}
	maintenance_reason=${9:# A string expression regarding the reason a node is in a maintenance mode.}
	wait=${10:no}
	timeout=${11:180}
	availability_zone=${12:# Ignored. Present for backwards compatibility}
	cloud=${13:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${14:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${15:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${16:# Name of the region.}
	api_timeout=${17:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${18:no}
	ca_cert=${19:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${20:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${21:# A path to a client key to use as part of the SSL transaction.}
	interface=${22:admin|internal|#public}

endsnippet

snippet os_security_group "Add/Delete security groups from an OpenStack cloud." b
os_security_group: >
	name=${1:# Name that has to be given to the security group. This module requires that security group names be unique.}

	description=${2:# Long description of the purpose of the security group}
	state=${3:#present|absent}
	project=${4:# Unique name or ID of the project.}
	availability_zone=${5:# Ignored. Present for backwards compatibility}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_keystone_role "Manage OpenStack Identity Roles" b
os_keystone_role: >
	name=${1:# Role Name}

	state=${2:#present|absent}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_loadbalancer "Add/Delete load balancer from OpenStack Cloud" b
os_loadbalancer: >
	name=${1:# Name that has to be given to the load balancer}

	state=${2:#present|absent}
	vip_network=${3:# The name or id of the network for the virtual IP of the load balancer. One of I(vip_network), I(vip_subnet), or I(vip_port) must be specified for creation.}
	vip_subnet=${4:# The name or id of the subnet for the virtual IP of the load balancer. One of I(vip_network), I(vip_subnet), or I(vip_port) must be specified for creation.}
	vip_port=${5:# The name or id of the load balancer virtual IP port. One of I(vip_network), I(vip_subnet), or I(vip_port) must be specified for creation.}
	vip_address=${6:# IP address of the load balancer virtual IP.}
	public_ip_address=${7:# Public IP address associated with the VIP.}
	auto_public_ip=${8:no}
	public_network=${9:# The name or ID of a Neutron external network.}
	delete_public_ip=${10:no}
	listeners=${11:# A list of listeners that attached to the load balancer.}
	wait=${12:yes}
	timeout=${13:180}
	availability_zone=${14:# Ignored. Present for backwards compatibility}
	cloud=${15:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${16:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${17:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${18:# Name of the region.}
	api_timeout=${19:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${20:no}
	ca_cert=${21:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${22:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${23:# A path to a client key to use as part of the SSL transaction.}
	interface=${24:admin|internal|#public}

endsnippet

snippet os_floating_ip "Add/Remove floating IP from an instance" b
os_floating_ip: >
	server=${1:# The name or ID of the instance to which the IP address should be assigned.}

	network=${2:# The name or ID of a neutron external network or a nova pool name.}
	floating_ip_address=${3:# A floating IP address to attach or to detach. Required only if I(state) is absent. When I(state) is present can be used to specify a IP address to attach.}
	reuse=${4:no}
	fixed_address=${5:# To which fixed IP of server the floating IP address should be attached to.}
	nat_destination=${6:# The name or id of a neutron private network that the fixed IP to attach floating IP is on}
	wait=${7:no}
	timeout=${8:60}
	state=${9:#present|absent}
	purge=${10:no}
	availability_zone=${11:# Ignored. Present for backwards compatibility}
	cloud=${12:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${13:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${14:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${15:# Name of the region.}
	api_timeout=${16:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${17:no}
	ca_cert=${18:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${19:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${20:# A path to a client key to use as part of the SSL transaction.}
	interface=${21:admin|internal|#public}

endsnippet

snippet os_networks_info "Retrieve information about one or more OpenStack networks." b
os_networks_info: >
	name=${1:# Name or ID of the Network}
	filters=${2:# A dictionary of meta data to use for further filtering.  Elements of this dictionary may be additional dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_user "Manage OpenStack Identity Users" b
os_user: >
	name=${1:# Username for the user}

	password=${2:# Password for the user}
	update_password=${3:always|on_create}
	email=${4:# Email address for the user}
	description=${5:# Description about the user}
	default_project=${6:# Project name or ID that the user should be associated with by default}
	domain=${7:# Domain to create the user in if the cloud supports domains}
	enabled=${8:yes}
	state=${9:#present|absent}
	availability_zone=${10:# Ignored. Present for backwards compatibility}
	cloud=${11:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${12:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${13:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${14:# Name of the region.}
	wait=${15:yes}
	timeout=${16:180}
	api_timeout=${17:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${18:no}
	ca_cert=${19:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${20:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${21:# A path to a client key to use as part of the SSL transaction.}
	interface=${22:admin|internal|#public}

endsnippet

snippet os_user_role "Associate OpenStack Identity users and roles" b
os_user_role: >
	role=${1:# Name or ID for the role.}

	user=${2:# Name or ID for the user. If I(user) is not specified, then I(group) is required. Both may not be specified.}
	group=${3:# Name or ID for the group. Valid only with keystone version 3. If I(group) is not specified, then I(user) is required. Both may not be specified.}
	project=${4:# Name or ID of the project to scope the role association to. If you are using keystone version 2, then this value is required.}
	domain=${5:# Name or ID of the domain to scope the role association to. Valid only with keystone version 3, and required if I(project) is not specified.}
	state=${6:#present|absent}
	availability_zone=${7:# Ignored. Present for backwards compatibility}
	cloud=${8:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${9:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${10:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${11:# Name of the region.}
	wait=${12:yes}
	timeout=${13:180}
	api_timeout=${14:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${15:no}
	ca_cert=${16:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${17:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${18:# A path to a client key to use as part of the SSL transaction.}
	interface=${19:admin|internal|#public}

endsnippet

snippet os_keystone_domain "Manage OpenStack Identity Domains" b
os_keystone_domain: >
	name=${1:# Name that has to be given to the instance}

	description=${2:# Description of the domain}
	enabled=${3:yes}
	state=${4:#present|absent}
	availability_zone=${5:# Ignored. Present for backwards compatibility}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_object "Create or Delete objects and containers from OpenStack" b
os_object: >
	container=${1:# The name of the container in which to create the object}

	name=${2:# Name to be give to the object. If omitted, operations will be on the entire container}
	filename=${3:# Path to local file to be uploaded.}
	container_access=${4:#private|public}
	state=${5:#present|absent}
	availability_zone=${6:# Ignored. Present for backwards compatibility}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	timeout=${12:180}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_network "Creates/removes networks from OpenStack" b
os_network: >
	name=${1:# Name to be assigned to the network.}

	shared=${2:no}
	admin_state_up=${3:yes}
	external=${4:no}
	state=${5:#present|absent}
	provider_physical_network=${6:# The physical network where this network object is implemented.}
	provider_network_type=${7:# The type of physical network that maps to this network resource.}
	provider_segmentation_id=${8:# An isolated segment on the physical network. The I(network_type) attribute defines the segmentation model. For example, if the I(network_type) value is vlan, this ID is a vlan identifier. If the I(network_type) value is gre, this ID is a gre key.}
	project=${9:# Project name or ID containing the network (name admin-only)}
	availability_zone=${10:# Ignored. Present for backwards compatibility}
	port_security_enabled=${11:# Whether port security is enabled on the network or not. Network will use OpenStack defaults if this option is not utilised.}
	mtu=${12:# The maximum transmission unit (MTU) value to address fragmentation. Network will use OpenStack defaults if this option is not provided.}
	dns_domain=${13:# The DNS domain value to set. Network will use Openstack defaults if this option is not provided.}
	cloud=${14:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${15:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${16:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${17:# Name of the region.}
	wait=${18:yes}
	timeout=${19:180}
	api_timeout=${20:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${21:no}
	ca_cert=${22:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${23:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${24:# A path to a client key to use as part of the SSL transaction.}
	interface=${25:admin|internal|#public}

endsnippet

snippet os_port_info "Retrieve information about ports within OpenStack." b
os_port_info: >
	port=${1:# Unique name or ID of a port.}
	filters=${2:# A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.}
	availability_zone=${3:# Ignored. Present for backwards compatibility}
	cloud=${4:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${5:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${6:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${7:# Name of the region.}
	wait=${8:yes}
	timeout=${9:180}
	api_timeout=${10:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${11:no}
	ca_cert=${12:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${13:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${14:# A path to a client key to use as part of the SSL transaction.}
	interface=${15:admin|internal|#public}

endsnippet

snippet os_port "Add/Update/Delete ports from an OpenStack cloud." b
os_port: >
	network=${1:# Network ID or name this port belongs to.}

	name=${2:# Name that has to be given to the port.}
	fixed_ips=${3:# Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.}
	admin_state_up=${4:# Sets admin state.}
	mac_address=${5:# MAC address of this port.}
	security_groups=${6:# Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)}
	no_security_groups=${7:no}
	allowed_address_pairs=${8:# Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.  allowed_address_pairs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...}
	extra_dhcp_opts=${9:# Extra dhcp options to be assigned to this port.  Extra options are supported with dictionary structure. e.g.  extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...}
	device_owner=${10:# The ID of the entity that uses this port.}
	device_id=${11:# Device ID of device using this port.}
	state=${12:#present|absent}
	availability_zone=${13:# Ignored. Present for backwards compatibility}
	vnic_type=${14:normal|direct|direct-physical|macvtap|baremetal|virtio-forwarder}
	port_security_enabled=${15:# Whether to enable or disable the port security on the network.}
	cloud=${16:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${17:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${18:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${19:# Name of the region.}
	wait=${20:yes}
	timeout=${21:180}
	api_timeout=${22:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${23:no}
	ca_cert=${24:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${25:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${26:# A path to a client key to use as part of the SSL transaction.}
	interface=${27:admin|internal|#public}

endsnippet

snippet os_quota "Manage OpenStack Quotas" b
os_quota: >
	name=${1:# Name of the OpenStack Project to manage.}

	state=${2:present}
	backup_gigabytes=${3:# M}
	backups=${4:# M}
	cores=${5:# M}
	fixed_ips=${6:# N}
	floating_ips=${7:# N}
	floatingip=${8:# N}
	gigabytes=${9:# M}
	gigabytes_lvm=${10:# M}
	injected_file_size=${11:# M}
	injected_files=${12:# N}
	injected_path_size=${13:# M}
	instances=${14:# M}
	key_pairs=${15:# N}
	loadbalancer=${16:# N}
	network=${17:# N}
	per_volume_gigabytes=${18:# M}
	pool=${19:# N}
	port=${20:# N}
	properties=${21:# N}
	ram=${22:# M}
	rbac_policy=${23:# N}
	router=${24:# N}
	security_group_rule=${25:# N}
	security_group=${26:# N}
	server_group_members=${27:# N}
	server_groups=${28:# N}
	snapshots=${29:# N}
	snapshots_lvm=${30:# N}
	subnet=${31:# N}
	subnetpool=${32:# N}
	volumes=${33:# N}
	volumes_lvm=${34:# N}
	availability_zone=${35:# Ignored. Present for backwards compatibility}
	cloud=${36:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${37:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${38:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${39:# Name of the region.}
	wait=${40:yes}
	timeout=${41:180}
	api_timeout=${42:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${43:no}
	ca_cert=${44:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${45:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${46:# A path to a client key to use as part of the SSL transaction.}
	interface=${47:admin|internal|#public}

endsnippet

snippet os_flavor_info "Retrieve information about one or more flavors" b
os_flavor_info: >
	name=${1:# A flavor name. Cannot be used with I(ram) or I(vcpus) or I(ephemeral).}
	ram=${2:no}
	vcpus=${3:no}
	limit=${4:# Limits the number of flavors returned. All matching flavors are returned by default.}
	ephemeral=${5:no}
	availability_zone=${6:# Ignored. Present for backwards compatibility}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	timeout=${12:180}
	api_timeout=${13:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${14:no}
	ca_cert=${15:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${16:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${17:# A path to a client key to use as part of the SSL transaction.}
	interface=${18:admin|internal|#public}

endsnippet

snippet os_auth "Retrieve an auth token" b
os_auth: >
	availability_zone=${1:# Ignored. Present for backwards compatibility}
	cloud=${2:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${3:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${4:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${5:# Name of the region.}
	wait=${6:yes}
	timeout=${7:180}
	api_timeout=${8:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${9:no}
	ca_cert=${10:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${11:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${12:# A path to a client key to use as part of the SSL transaction.}
	interface=${13:admin|internal|#public}

endsnippet

snippet os_ironic_inspect "Explicitly triggers baremetal node introspection in ironic." b
os_ironic_inspect: >
	mac=${1:# unique mac address that is used to attempt to identify the host.}
	uuid=${2:# globally unique identifier (UUID) to identify the host.}
	name=${3:# unique name identifier to identify the host in Ironic.}
	ironic_url=${4:# If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with "auth" and "auth_type" settings set to None.}
	timeout=${5:1200}
	availability_zone=${6:# Ignored. Present for backwards compatibility}
	cloud=${7:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${8:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${9:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${10:# Name of the region.}
	wait=${11:yes}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_subnet "Add/Remove subnet to an OpenStack network" b
os_subnet: >
	name=${1:# The name of the subnet that should be created. Although Neutron allows for non-unique subnet names, this module enforces subnet name uniqueness.}

	state=${2:#present|absent}
	network_name=${3:# Name of the network to which the subnet should be attached}
	cidr=${4:# The CIDR representation of the subnet that should be assigned to the subnet. Required when I(state) is 'present' and a subnetpool is not specified.}
	ip_version=${5:4}
	enable_dhcp=${6:yes}
	gateway_ip=${7:# The ip that would be assigned to the gateway for this subnet}
	no_gateway_ip=${8:no}
	dns_nameservers=${9:# List of DNS nameservers for this subnet.}
	allocation_pool_start=${10:# From the subnet pool the starting address from which the IP should be allocated.}
	allocation_pool_end=${11:# From the subnet pool the last IP that should be assigned to the virtual machines.}
	host_routes=${12:# A list of host route dictionaries for the subnet.}
	ipv6_ra_mode=${13:dhcpv6-stateful|dhcpv6-stateless|slaac}
	ipv6_address_mode=${14:dhcpv6-stateful|dhcpv6-stateless|slaac}
	use_default_subnetpool=${15:no}
	project=${16:# Project name or ID containing the subnet (name admin-only)}
	availability_zone=${17:# Ignored. Present for backwards compatibility}
	extra_specs=${18:{}}
	cloud=${19:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${20:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${21:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${22:# Name of the region.}
	wait=${23:yes}
	timeout=${24:180}
	api_timeout=${25:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${26:no}
	ca_cert=${27:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${28:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${29:# A path to a client key to use as part of the SSL transaction.}
	interface=${30:admin|internal|#public}

endsnippet

snippet os_server "Create/Delete Compute Instances from OpenStack" b
os_server: >
	name=${1:# Name that has to be given to the instance. It is also possible to specify the ID of the instance instead of its name if I(state) is I(absent).}
	image=${2:# The name or id of the base image to boot.}

	image_exclude=${3:# Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to "(deprecated)"}
	flavor=${4:1}
	flavor_ram=${5:1}
	flavor_include=${6:# Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.}
	key_name=${7:# The key pair name to be used when creating a instance}
	security_groups=${8:# Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.}
	network=${9:# Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.}
	nics=${10:# A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name/port-id or port-name.}
	auto_ip=${11:yes}
	floating_ips=${12:# list of valid floating IPs that pre-exist to assign to this node}
	floating_ip_pools=${13:# Name of floating IP pool from which to choose a floating IP}
	meta=${14:# A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key-value pairs. Eg:  meta: "key1=value1,key2=value2"}
	wait=${15:yes}
	timeout=${16:180}
	config_drive=${17:no}
	userdata=${18:# Opaque blob of data which is made available to the instance}
	boot_from_volume=${19:no}
	volume_size=${20:# The size of the volume to create in GB if booting from volume based on an image.}
	boot_volume=${21:# Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.}
	terminate_volume=${22:no}
	volumes=${23:[]}
	scheduler_hints=${24:# Arbitrary key/value pairs to the scheduler for custom use}
	state=${25:#present|absent}
	delete_fip=${26:no}
	reuse_ips=${27:yes}
	availability_zone=${28:# Availability zone in which to create the server.}
	cloud=${29:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${30:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${31:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${32:# Name of the region.}
	api_timeout=${33:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${34:no}
	ca_cert=${35:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${36:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${37:# A path to a client key to use as part of the SSL transaction.}
	interface=${38:admin|internal|#public}

endsnippet

snippet os_coe_cluster_template "Add/Remove COE cluster template from OpenStack Cloud" b
os_coe_cluster_template: >
	name=${1:# Name that has to be given to the cluster template}

	availability_zone=${2:# Ignored. Present for backwards compatibility}
	coe=${3:kubernetes|swarm|mesos}
	dns_nameserver=${4:8.8.8.8}
	docker_storage_driver=${5:devicemapper|overlay}
	docker_volume_size=${6:# The size in GB of the docker volume}
	external_network_id=${7:# The external network to attach to the Cluster}
	fixed_network=${8:# The fixed network name to attach to the Cluster}
	fixed_subnet=${9:# The fixed subnet name to attach to the Cluster}
	flavor_id=${10:# The flavor of the minion node for this ClusterTemplate}
	floating_ip_enabled=${11:yes}
	keypair_id=${12:# Name or ID of the keypair to use.}
	image_id=${13:# Image id the cluster will be based on}
	labels=${14:# One or more key/value pairs}
	http_proxy=${15:# Address of a proxy that will receive all HTTP requests and relay them The format is a URL including a port number}
	https_proxy=${16:# Address of a proxy that will receive all HTTPS requests and relay them. The format is a URL including a port number}
	master_flavor_id=${17:# The flavor of the master node for this ClusterTemplate}
	master_lb_enabled=${18:no}
	network_driver=${19:flannel|calico|docker}
	no_proxy=${20:# A comma separated list of IPs for which proxies should not be used in the cluster}
	public=${21:no}
	registry_enabled=${22:no}
	server_type=${23:#vm|bm}
	state=${24:#present|absent}
	tls_disabled=${25:no}
	volume_driver=${26:cinder|rexray}
	cloud=${27:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${28:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${29:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${30:# Name of the region.}
	wait=${31:yes}
	timeout=${32:180}
	api_timeout=${33:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${34:no}
	ca_cert=${35:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${36:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${37:# A path to a client key to use as part of the SSL transaction.}
	interface=${38:admin|internal|#public}

endsnippet

snippet os_keypair "Add/Delete a keypair from OpenStack" b
os_keypair: >
	name=${1:# Name that has to be given to the key pair}

	public_key=${2:# The public key that would be uploaded to nova and injected into VMs upon creation.}
	public_key_file=${3:# Path to local file containing ssh public key. Mutually exclusive with public_key.}
	state=${4:#present|absent}
	availability_zone=${5:# Ignored. Present for backwards compatibility}
	cloud=${6:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${7:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${8:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${9:# Name of the region.}
	wait=${10:yes}
	timeout=${11:180}
	api_timeout=${12:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${13:no}
	ca_cert=${14:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${15:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${16:# A path to a client key to use as part of the SSL transaction.}
	interface=${17:admin|internal|#public}

endsnippet

snippet os_server_group "Manage OpenStack server groups" b
os_server_group: >
	name=${1:# Server group name.}

	state=${2:#present|absent}
	policies=${3:# A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti-affinity, affinity, soft-anti-affinity and soft-affinity.}
	availability_zone=${4:# Ignored. Present for backwards compatibility}
	cloud=${5:# Named cloud or cloud config to operate against. If I(cloud) is a string, it references a named cloud config as defined in an OpenStack clouds.yaml file. Provides default values for I(auth) and I(auth_type). This parameter is not needed if I(auth) is provided or if OpenStack OS_* environment variables are present. If I(cloud) is a dict, it contains a complete cloud configuration like would be in a section of clouds.yaml.}
	auth=${6:# Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default I(password) plugin, this would contain I(auth_url), I(username), I(password), I(project_name) and any information about domains (for example, I(os_user_domain_name) or I(os_project_domain_name)) if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.}
	auth_type=${7:# Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the I(auth) parameter should be updated accordingly.}
	region_name=${8:# Name of the region.}
	wait=${9:yes}
	timeout=${10:180}
	api_timeout=${11:# How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.}
	validate_certs=${12:no}
	ca_cert=${13:# A path to a CA Cert bundle that can be used as part of verifying SSL API requests.}
	client_cert=${14:# A path to a client certificate to use as part of the SSL transaction.}
	client_key=${15:# A path to a client key to use as part of the SSL transaction.}
	interface=${16:admin|internal|#public}

endsnippet

snippet podman_image "Pull images for use by podman" b
podman_image: >
	name=${1:# Name of the image to pull, push, or delete. It may contain a tag using the format C(image:tag).}

	executable=${2:podman}
	ca_cert_dir=${3:# Path to directory containing TLS certificates and keys to use}
	tag=${4:latest}
	pull=${5:yes}
	push=${6:no}
	path=${7:# P}
	force=${8:# Whether or not to force push or pull an image. When building, force the build even if the image already exists.}
	state=${9:#present|absent|build}
	validate_certs=${10:yes}
	password=${11:# Password to use when authenticating to remote registries.}
	username=${12:# username to use when authenticating to remote registries.}
	auth_file=${13:# Path to file containing authorization credentials to the remote registry}
	build=${14:# A}
	push_args=${15:# A}

endsnippet

snippet podman_image_info "Gather info about images using podman" b
podman_image_info: >
	executable=${1:podman}
	name=${2:# List of tags or UID to gather info about. If no name is given return info about all images.}

endsnippet

snippet docker_compose "Manage multi-container Docker applications with Docker Compose." b
docker_compose: >
	project_src=${1:# Path to a directory containing a C(docker-compose.yml) or C(docker-compose.yaml) file.}
	project_name=${2:# Provide a project name. If not provided, the project name is taken from the basename of I(project_src).}
	files=${3:# List of Compose file names relative to I(project_src). Overrides C(docker-compose.yml) or C(docker-compose.yaml).}
	state=${4:absent|#present}
	services=${5:# When I(state) is C(present) run C(docker-compose up) resp. C(docker-compose stop) (with I(stopped)) resp. C(docker-compose restart) (with I(restarted)) on a subset of services.}
	scale=${6:# When I(state) is C(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.}
	dependencies=${7:yes}
	definition=${8:# Compose file describing one or more services, networks and volumes.}
	hostname_check=${9:no}
	recreate=${10:always|never|#smart}
	build=${11:no}
	pull=${12:no}
	nocache=${13:no}
	remove_images=${14:all|local}
	remove_volumes=${15:no}
	stopped=${16:no}
	restarted=${17:no}
	remove_orphans=${18:no}
	timeout=${19:10}
	docker_host=${20:unix://var/run/docker.sock}
	tls_hostname=${21:localhost}
	api_version=${22:auto}
	ca_cert=${23:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${24:# Path to the client's TLS certificate file.}
	client_key=${25:# Path to the client's TLS key file.}
	ssl_version=${26:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${27:no}
	validate_certs=${28:no}
	debug=${29:no}

endsnippet

snippet docker_prune "Allows to prune various docker objects" b
docker_prune: >
	containers=${1:no}
	containers_filters=${2:# A dictionary of filter values used for selecting containers to delete.}
	images=${3:no}
	images_filters=${4:# A dictionary of filter values used for selecting images to delete.}
	networks=${5:no}
	networks_filters=${6:# A dictionary of filter values used for selecting networks to delete.}
	volumes=${7:no}
	volumes_filters=${8:# A dictionary of filter values used for selecting volumes to delete.}
	builder_cache=${9:no}
	docker_host=${10:unix://var/run/docker.sock}
	tls_hostname=${11:localhost}
	api_version=${12:auto}
	timeout=${13:60}
	ca_cert=${14:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${15:# Path to the client's TLS certificate file.}
	client_key=${16:# Path to the client's TLS key file.}
	ssl_version=${17:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${18:no}
	validate_certs=${19:no}
	debug=${20:no}

endsnippet

snippet docker_stack "docker stack module" b
docker_stack: >
	name=${1:# Stack name}

	state=${2:#present|absent}
	compose=${3:[]}
	prune=${4:no}
	with_registry_auth=${5:no}
	resolve_image=${6:always|changed|never}
	absent_retries=${7:0}
	absent_retries_interval=${8:1}

endsnippet

snippet docker_compose "Manage multi-container Docker applications with Docker Compose." b
docker_compose: >
	project_src=${1:# Path to a directory containing a C(docker-compose.yml) or C(docker-compose.yaml) file.}
	project_name=${2:# Provide a project name. If not provided, the project name is taken from the basename of I(project_src).}
	files=${3:# List of Compose file names relative to I(project_src). Overrides C(docker-compose.yml) or C(docker-compose.yaml).}
	state=${4:absent|#present}
	services=${5:# When I(state) is C(present) run C(docker-compose up) resp. C(docker-compose stop) (with I(stopped)) resp. C(docker-compose restart) (with I(restarted)) on a subset of services.}
	scale=${6:# When I(state) is C(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.}
	dependencies=${7:yes}
	definition=${8:# Compose file describing one or more services, networks and volumes.}
	hostname_check=${9:no}
	recreate=${10:always|never|#smart}
	build=${11:no}
	pull=${12:no}
	nocache=${13:no}
	remove_images=${14:all|local}
	remove_volumes=${15:no}
	stopped=${16:no}
	restarted=${17:no}
	remove_orphans=${18:no}
	timeout=${19:10}
	docker_host=${20:unix://var/run/docker.sock}
	tls_hostname=${21:localhost}
	api_version=${22:auto}
	ca_cert=${23:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${24:# Path to the client's TLS certificate file.}
	client_key=${25:# Path to the client's TLS key file.}
	ssl_version=${26:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${27:no}
	validate_certs=${28:no}
	debug=${29:no}

endsnippet

snippet docker_node "Manage Docker Swarm node" b
docker_node: >
	hostname=${1:# The hostname or ID of node as registered in Swarm.}

	labels=${2:# User-defined key/value metadata that will be assigned as node attribute.}
	labels_state=${3:#merge|replace}
	labels_to_remove=${4:# List of labels that will be removed from the node configuration. The list has to contain only label names, not their values.}
	availability=${5:active|pause|drain}
	role=${6:manager|worker}
	docker_host=${7:unix://var/run/docker.sock}
	tls_hostname=${8:localhost}
	api_version=${9:auto}
	timeout=${10:60}
	ca_cert=${11:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${12:# Path to the client's TLS certificate file.}
	client_key=${13:# Path to the client's TLS key file.}
	ssl_version=${14:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${15:no}
	validate_certs=${16:no}
	debug=${17:no}

endsnippet

snippet docker_volume_info "Retrieve facts about Docker volumes" b
docker_volume_info: >
	name=${1:# Name of the volume to inspect.}

	docker_host=${2:unix://var/run/docker.sock}
	tls_hostname=${3:localhost}
	api_version=${4:auto}
	timeout=${5:60}
	ca_cert=${6:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${7:# Path to the client's TLS certificate file.}
	client_key=${8:# Path to the client's TLS key file.}
	ssl_version=${9:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${10:no}
	validate_certs=${11:no}
	debug=${12:no}

endsnippet

snippet docker_node_info "Retrieves facts about docker swarm node from Swarm Manager" b
docker_node_info: >
	name=${1:# The name of the node to inspect.}
	self=${2:no}
	docker_host=${3:unix://var/run/docker.sock}
	tls_hostname=${4:localhost}
	api_version=${5:auto}
	timeout=${6:60}
	ca_cert=${7:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${8:# Path to the client's TLS certificate file.}
	client_key=${9:# Path to the client's TLS key file.}
	ssl_version=${10:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${11:no}
	validate_certs=${12:no}
	debug=${13:no}

endsnippet

snippet docker_container_info "Retrieves facts about docker container" b
docker_container_info: >
	name=${1:# The name of the container to inspect.}

	docker_host=${2:unix://var/run/docker.sock}
	tls_hostname=${3:localhost}
	api_version=${4:auto}
	timeout=${5:60}
	ca_cert=${6:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${7:# Path to the client's TLS certificate file.}
	client_key=${8:# Path to the client's TLS key file.}
	ssl_version=${9:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${10:no}
	validate_certs=${11:no}
	debug=${12:no}

endsnippet

snippet docker_image "Manage docker images." b
docker_image: >
	name=${1:# Image name. Name format will be one of: name, repository/name, registry_server:port/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'.}

	source=${2:build|load|pull|local}
	build=${3:# Specifies options used for building images.}
	archive_path=${4:# Use with state C(present) to archive an image to a .tar file.}
	load_path=${5:# Use with state C(present) to load an image from a .tar file.}
	dockerfile=${6:# Use with state C(present) and source C(build) to provide an alternate name for the Dockerfile to use when building an image.}
	force=${7:# Use with state I(absent) to un-tag and remove all images matching the specified name. Use with state C(present) to build, load or pull an image when the image already exists. Also use with state C(present) to force tagging an image.}
	force_source=${8:no}
	force_absent=${9:no}
	force_tag=${10:no}
	http_timeout=${11:# Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.}
	path=${12:# Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image.}
	pull=${13:# When building an image downloads any updates to the FROM image in Dockerfile.}
	push=${14:no}
	rm=${15:yes}
	nocache=${16:no}
	repository=${17:# Full path to a repository. Use with state C(present) to tag the image into the repository. Expects format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest).}
	state=${18:absent|#present|build}
	tag=${19:latest}
	buildargs=${20:# Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.}
	container_limits=${21:# A dictionary of limits applied to each container created by the build process.}
	use_tls=${22:no|encrypt|verify}
	docker_host=${23:unix://var/run/docker.sock}
	tls_hostname=${24:localhost}
	api_version=${25:auto}
	timeout=${26:60}
	ca_cert=${27:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${28:# Path to the client's TLS certificate file.}
	client_key=${29:# Path to the client's TLS key file.}
	ssl_version=${30:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${31:no}
	validate_certs=${32:no}
	debug=${33:no}

endsnippet

snippet docker_secret "Manage docker secrets." b
docker_secret: >
	name=${1:# The name of the secret.}

	data=${2:# The value of the secret. Required when state is C(present).}
	data_is_b64=${3:no}
	labels=${4:# A map of key:value meta data, where both key and value are expected to be strings.}
	force=${5:no}
	state=${6:absent|#present}
	docker_host=${7:unix://var/run/docker.sock}
	tls_hostname=${8:localhost}
	api_version=${9:auto}
	timeout=${10:60}
	ca_cert=${11:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${12:# Path to the client's TLS certificate file.}
	client_key=${13:# Path to the client's TLS key file.}
	ssl_version=${14:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${15:no}
	validate_certs=${16:no}
	debug=${17:no}

endsnippet

snippet docker_login "Log into a Docker registry." b
docker_login: >
	registry_url=${1:https://index.docker.io/v1/}
	username=${2:# The username for the registry account.}
	password=${3:# The plaintext password for the registry account.}
	email=${4:# The email address for the registry account.}
	reauthorize=${5:no}
	config_path=${6:~/.docker/config.json}
	state=${7:#present|absent}
	docker_host=${8:unix://var/run/docker.sock}
	tls_hostname=${9:localhost}
	api_version=${10:auto}
	timeout=${11:60}
	ca_cert=${12:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${13:# Path to the client's TLS certificate file.}
	client_key=${14:# Path to the client's TLS key file.}
	ssl_version=${15:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${16:no}
	validate_certs=${17:no}
	debug=${18:no}

endsnippet

snippet docker_volume "Manage Docker volumes" b
docker_volume: >
	volume_name=${1:# Name of the volume to operate on.}

	driver=${2:local}
	driver_options=${3:# Dictionary of volume settings. Consult docker docs for valid options and values: U(https://docs.docker.com/engine/reference/commandline/volume_create/#driver-specific-options)}
	labels=${4:# Dictionary of label key/values to set for the volume}
	force=${5:no}
	recreate=${6:always|#never|options-changed}
	state=${7:absent|#present}
	docker_host=${8:unix://var/run/docker.sock}
	tls_hostname=${9:localhost}
	api_version=${10:auto}
	timeout=${11:60}
	ca_cert=${12:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${13:# Path to the client's TLS certificate file.}
	client_key=${14:# Path to the client's TLS key file.}
	ssl_version=${15:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${16:no}
	validate_certs=${17:no}
	debug=${18:no}

endsnippet

snippet docker_image_info "Inspect docker images" b
docker_image_info: >
	name=${1:# An image name or a list of image names. Name format will be C(name[:tag]) or C(repository/name[:tag]), where C(tag) is optional. If a tag is not provided, C(latest) will be used. Instead of image names, also image IDs can be used.}
	docker_host=${2:unix://var/run/docker.sock}
	tls_hostname=${3:localhost}
	api_version=${4:auto}
	timeout=${5:60}
	ca_cert=${6:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${7:# Path to the client's TLS certificate file.}
	client_key=${8:# Path to the client's TLS key file.}
	ssl_version=${9:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${10:no}
	validate_certs=${11:no}
	debug=${12:no}

endsnippet

snippet docker_swarm_service "docker swarm service" b
docker_swarm_service: >
	name=${1:# Service name.}

	args=${2:# List arguments to be passed to the container.}
	command=${3:# Command to execute when the container starts.}
	configs=${4:# List of dictionaries describing the service configs.}
	constraints=${5:# List of the service constraints.}
	container_labels=${6:# Dictionary of key value pairs.}
	dns=${7:# List of custom DNS servers.}
	dns_search=${8:# List of custom DNS search domains.}
	dns_options=${9:# List of custom DNS options.}
	endpoint_mode=${10:vip|dnsrr}
	env=${11:# List or dictionary of the service environment variables.}
	env_files=${12:# List of paths to files, present on the target, containing environment variables C(FOO=BAR).}
	force_update=${13:no}
	groups=${14:# List of additional group names and/or IDs that the container process will run as.}
	healthcheck=${15:# Configure a check that is run to determine whether or not containers for this service are "healthy". See the docs for the L(HEALTHCHECK Dockerfile instruction,https://docs.docker.com/engine/reference/builder/#healthcheck) for details on how healthchecks work.}
	hostname=${16:# Container hostname.}
	hosts=${17:# Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file.}
	image=${18:# Service image path and tag.}
	labels=${19:# Dictionary of key value pairs.}
	limits=${20:# Configures service resource limits.}
	limit_cpu=${21:# Service CPU limit. C(0) equals no limit.}
	limit_memory=${22:# Service memory limit in format C(<number>[<unit>]). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).}
	logging=${23:# Logging configuration for the service.}
	log_driver=${24:# Configure the logging driver for a service.}
	log_driver_options=${25:# Options for service logging driver.}
	mode=${26:#replicated|global}
	mounts=${27:# List of dictionaries describing the service mounts.}
	networks=${28:# List of the service networks names or dictionaries.}
	placement=${29:# Configures service placement preferences and constraints.}
	publish=${30:# List of dictionaries describing the service published ports.}
	read_only=${31:# Mount the containers root filesystem as read only.}
	replicas=${32:-1}
	reservations=${33:# Configures service resource reservations.}
	reserve_cpu=${34:# Service CPU reservation. C(0) equals no reservation.}
	reserve_memory=${35:# Service memory reservation in format C(<number>[<unit>]). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).}
	resolve_image=${36:no}
	restart_config=${37:# Configures if and how to restart containers when they exit.}
	restart_policy=${38:none|on-failure|any}
	restart_policy_attempts=${39:# Maximum number of service restarts.}
	restart_policy_delay=${40:# Delay between restarts.}
	restart_policy_window=${41:# Restart policy evaluation window.}
	rollback_config=${42:# Configures how the service should be rolled back in case of a failing update.}
	secrets=${43:# List of dictionaries describing the service secrets.}
	state=${44:#present|absent}
	stop_grace_period=${45:# Time to wait before force killing a container.}
	stop_signal=${46:# Override default signal used to stop the container.}
	tty=${47:# Allocate a pseudo-TTY.}
	update_config=${48:# Configures how the service should be updated. Useful for configuring rolling updates.}
	update_delay=${49:# Rolling update delay.}
	update_parallelism=${50:# Rolling update parallelism.}
	update_failure_action=${51:continue|pause|rollback}
	update_monitor=${52:# Time to monitor updated tasks for failures.}
	update_max_failure_ratio=${53:# Fraction of tasks that may fail during an update before the failure action is invoked.}
	update_order=${54:stop-first|start-first}
	user=${55:# Sets the username or UID used for the specified command.}
	working_dir=${56:# Path to the working directory.}
	docker_host=${57:unix://var/run/docker.sock}
	tls_hostname=${58:localhost}
	api_version=${59:auto}
	timeout=${60:60}
	ca_cert=${61:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${62:# Path to the client's TLS certificate file.}
	client_key=${63:# Path to the client's TLS key file.}
	ssl_version=${64:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${65:no}
	validate_certs=${66:no}
	debug=${67:no}

endsnippet

snippet docker_network "Manage Docker networks" b
docker_network: >
	name=${1:# Name of the network to operate on.}

	connected=${2:# List of container names or container IDs to connect to a network.}
	driver=${3:bridge}
	driver_options=${4:# Dictionary of network settings. Consult docker docs for valid options and values.}
	force=${5:no}
	appends=${6:no}
	enable_ipv6=${7:# Enable IPv6 networking.}
	ipam_driver=${8:# Specify an IPAM driver.}
	ipam_driver_options=${9:# Dictionary of IPAM driver options.}
	ipam_options=${10:# Dictionary of IPAM options.}
	ipam_config=${11:# List of IPAM config blocks. Consult L(Docker docs,https://docs.docker.com/compose/compose-file/compose-file-v2/#ipam) for valid options and values. Note that I(iprange) is spelled differently here (we use the notation from the Docker SDK for Python).}
	state=${12:absent|#present}
	internal=${13:# Restrict external access to the network.}
	labels=${14:# Dictionary of labels.}
	scope=${15:local|global|swarm}
	attachable=${16:# If enabled, and the network is in the global scope, non-service containers on worker nodes will be able to connect to the network.}
	docker_host=${17:unix://var/run/docker.sock}
	tls_hostname=${18:localhost}
	api_version=${19:auto}
	timeout=${20:60}
	ca_cert=${21:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${22:# Path to the client's TLS certificate file.}
	client_key=${23:# Path to the client's TLS key file.}
	ssl_version=${24:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${25:no}
	validate_certs=${26:no}
	debug=${27:no}

endsnippet

snippet docker_image_info "Inspect docker images" b
docker_image_info: >
	name=${1:# An image name or a list of image names. Name format will be C(name[:tag]) or C(repository/name[:tag]), where C(tag) is optional. If a tag is not provided, C(latest) will be used. Instead of image names, also image IDs can be used.}
	docker_host=${2:unix://var/run/docker.sock}
	tls_hostname=${3:localhost}
	api_version=${4:auto}
	timeout=${5:60}
	ca_cert=${6:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${7:# Path to the client's TLS certificate file.}
	client_key=${8:# Path to the client's TLS key file.}
	ssl_version=${9:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${10:no}
	validate_certs=${11:no}
	debug=${12:no}

endsnippet

snippet docker_swarm "Manage Swarm cluster" b
docker_swarm: >
	advertise_addr=${1:# Externally reachable address advertised to other nodes.}
	default_addr_pool=${2:# Default address pool in CIDR format.}
	subnet_size=${3:# Default address pool subnet mask length.}
	listen_addr=${4:0.0.0.0:2377}
	force=${5:no}
	state=${6:#present|join|absent|remove|inspect}
	node_id=${7:# Swarm id of the node to remove.}
	join_token=${8:# Swarm token used to join a swarm cluster.}
	remote_addrs=${9:# Remote address of one or more manager nodes of an existing Swarm to connect to.}
	task_history_retention_limit=${10:# Maximum number of tasks history stored.}
	snapshot_interval=${11:# Number of logs entries between snapshot.}
	keep_old_snapshots=${12:# Number of snapshots to keep beyond the current snapshot.}
	log_entries_for_slow_followers=${13:# Number of log entries to keep around to sync up slow followers after a snapshot is created.}
	heartbeat_tick=${14:# Amount of ticks (in seconds) between each heartbeat.}
	election_tick=${15:# Amount of ticks (in seconds) needed without a leader to trigger a new election.}
	dispatcher_heartbeat_period=${16:# The delay for an agent to send a heartbeat to the dispatcher.}
	node_cert_expiry=${17:# Automatic expiry for nodes certificates.}
	name=${18:# The name of the swarm.}
	labels=${19:# User-defined key/value metadata.}
	signing_ca_cert=${20:# The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.}
	signing_ca_key=${21:# The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.}
	ca_force_rotate=${22:# An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified.}
	autolock_managers=${23:# If set, generate a key and use it to lock data stored on the managers.}
	rotate_worker_token=${24:no}
	rotate_manager_token=${25:no}
	docker_host=${26:unix://var/run/docker.sock}
	tls_hostname=${27:localhost}
	api_version=${28:auto}
	timeout=${29:60}
	ca_cert=${30:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${31:# Path to the client's TLS certificate file.}
	client_key=${32:# Path to the client's TLS key file.}
	ssl_version=${33:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${34:no}
	validate_certs=${35:no}
	debug=${36:no}

endsnippet

snippet docker_host_info "Retrieves facts about docker host and lists of objects of the services." b
docker_host_info: >
	containers=${1:no}
	containers_filters=${2:# A dictionary of filter values used for selecting containers to delete.}
	images=${3:no}
	images_filters=${4:# A dictionary of filter values used for selecting images to delete.}
	networks=${5:no}
	networks_filters=${6:# A dictionary of filter values used for selecting networks to delete.}
	volumes=${7:no}
	volumes_filters=${8:# A dictionary of filter values used for selecting volumes to delete.}
	disk_usage=${9:no}
	verbose_output=${10:no}
	docker_host=${11:unix://var/run/docker.sock}
	tls_hostname=${12:localhost}
	api_version=${13:auto}
	timeout=${14:60}
	ca_cert=${15:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${16:# Path to the client's TLS certificate file.}
	client_key=${17:# Path to the client's TLS key file.}
	ssl_version=${18:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${19:no}
	validate_certs=${20:no}
	debug=${21:no}

endsnippet

snippet docker_network_info "Retrieves facts about docker network" b
docker_network_info: >
	name=${1:# The name of the network to inspect.}

	docker_host=${2:unix://var/run/docker.sock}
	tls_hostname=${3:localhost}
	api_version=${4:auto}
	timeout=${5:60}
	ca_cert=${6:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${7:# Path to the client's TLS certificate file.}
	client_key=${8:# Path to the client's TLS key file.}
	ssl_version=${9:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${10:no}
	validate_certs=${11:no}
	debug=${12:no}

endsnippet

snippet docker_config "Manage docker configs." b
docker_config: >
	name=${1:# The name of the config.}

	data=${2:# The value of the config. Required when state is C(present).}
	data_is_b64=${3:no}
	labels=${4:# A map of key:value meta data, where both the I(key) and I(value) are expected to be a string.}
	force=${5:no}
	state=${6:absent|#present}
	docker_host=${7:unix://var/run/docker.sock}
	tls_hostname=${8:localhost}
	api_version=${9:auto}
	timeout=${10:60}
	ca_cert=${11:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${12:# Path to the client's TLS certificate file.}
	client_key=${13:# Path to the client's TLS key file.}
	ssl_version=${14:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${15:no}
	validate_certs=${16:no}
	debug=${17:no}

endsnippet

snippet docker_swarm_info "Retrieves facts about Docker Swarm cluster." b
docker_swarm_info: >
	nodes=${1:no}
	nodes_filters=${2:# A dictionary of filter values used for selecting nodes to list.}
	services=${3:no}
	services_filters=${4:# A dictionary of filter values used for selecting services to list.}
	tasks=${5:no}
	tasks_filters=${6:# A dictionary of filter values used for selecting tasks to list.}
	unlock_key=${7:no}
	verbose_output=${8:no}
	docker_host=${9:unix://var/run/docker.sock}
	tls_hostname=${10:localhost}
	api_version=${11:auto}
	timeout=${12:60}
	ca_cert=${13:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${14:# Path to the client's TLS certificate file.}
	client_key=${15:# Path to the client's TLS key file.}
	ssl_version=${16:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${17:no}
	validate_certs=${18:no}
	debug=${19:no}

endsnippet

snippet docker_container "manage docker containers" b
docker_container: >
	name=${1:# Assign a name to a new container or match an existing container.}

	auto_remove=${2:no}
	blkio_weight=${3:# Block IO (relative weight), between 10 and 1000.}
	capabilities=${4:# List of capabilities to add to the container.}
	cap_drop=${5:# List of capabilities to drop from the container.}
	cleanup=${6:no}
	command=${7:# Command to execute when the container starts. A command may be either a string or a list.}
	comparisons=${8:# Allows to specify how properties of existing containers are compared with module options to decide whether the container should be recreated / updated or not.}
	cpu_period=${9:# Limit CPU CFS (Completely Fair Scheduler) period.}
	cpu_quota=${10:# Limit CPU CFS (Completely Fair Scheduler) quota.}
	cpuset_cpus=${11:# CPUs in which to allow execution C(1,3) or C(1-3).}
	cpuset_mems=${12:# Memory nodes (MEMs) in which to allow execution C(0-3) or C(0,1).}
	cpu_shares=${13:# CPU shares (relative weight).}
	detach=${14:yes}
	devices=${15:# List of host device bindings to add to the container.}
	device_read_bps=${16:# List of device path and read rate (bytes per second) from device.}
	device_write_bps=${17:# List of device and write rate (bytes per second) to device.}
	device_read_iops=${18:# List of device and read rate (IO per second) from device.}
	device_write_iops=${19:# List of device and write rate (IO per second) to device.}
	dns_opts=${20:# List of DNS options.}
	dns_servers=${21:# List of custom DNS servers.}
	dns_search_domains=${22:# List of custom DNS search domains.}
	domainname=${23:# Container domainname.}
	env=${24:# Dictionary of key,value pairs.}
	env_file=${25:# Path to a file, present on the target, containing environment variables I(FOO=BAR).}
	entrypoint=${26:# Command that overwrites the default C(ENTRYPOINT) of the image.}
	etc_hosts=${27:# Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's C(/etc/hosts) file.}
	exposed_ports=${28:# List of additional container ports which informs Docker that the container listens on the specified network ports at runtime.}
	force_kill=${29:no}
	groups=${30:# List of additional group names and/or IDs that the container process will run as.}
	healthcheck=${31:# Configure a check that is run to determine whether or not containers for this service are "healthy".}
	hostname=${32:# The container's hostname.}
	ignore_image=${33:no}
	image=${34:# Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, C(latest) will be used.}
	init=${35:no}
	interactive=${36:no}
	ipc_mode=${37:# Set the IPC mode for the container.}
	keep_volumes=${38:yes}
	kill_signal=${39:# Override default signal used to kill a running container.}
	kernel_memory=${40:# Kernel memory limit in format C(<number>[<unit>]). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte). Minimum is C(4M).}
	labels=${41:# Dictionary of key value pairs.}
	links=${42:# List of name aliases for linked containers in the format C(container_name:alias).}
	log_driver=${43:# Specify the logging driver. Docker uses C(json-file) by default.}
	log_options=${44:# Dictionary of options specific to the chosen I(log_driver).}
	mac_address=${45:# Container MAC address (e.g. 92:d0:c6:0a:29:33).}
	memory=${46:0}
	memory_reservation=${47:# Memory soft limit in format C(<number>[<unit>]). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).}
	memory_swap=${48:# Total memory limit (memory + swap) in format C(<number>[<unit>]). Number is a positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).}
	memory_swappiness=${49:# Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.}
	mounts=${50:# Specification for mounts to be added to the container. More powerful alternative to I(volumes).}
	network_mode=${51:# Connect the container to a network. Choices are C(bridge), C(host), C(none) or C(container:<name|id>).}
	userns_mode=${52:# Set the user namespace mode for the container. Currently, the only valid value are C(host) and the empty string.}
	networks=${53:# List of networks the container belongs to.}
	networks_cli_compatible=${54:# When networks are provided to the module via the I(networks) option, the module behaves differently than C(docker run --network): C(docker run --network other) will create a container with network C(other) attached, but the default network not attached. This module with I(networks: {name: other}) will create a container with both C(default) and C(other) attached. If I(purge_networks) is set to C(yes), the C(default) network will be removed afterwards.}
	oom_killer=${55:# Whether or not to disable OOM Killer for the container.}
	oom_score_adj=${56:# An integer value containing the score given to the container in order to tune OOM killer preferences.}
	output_logs=${57:no}
	paused=${58:no}
	pid_mode=${59:# Set the PID namespace mode for the container.}
	pids_limit=${60:# Set PIDs limit for the container. It accepts an integer value.}
	privileged=${61:no}
	published_ports=${62:# List of ports to publish from the container to the host.}
	pull=${63:no}
	purge_networks=${64:no}
	read_only=${65:no}
	recreate=${66:no}
	restart=${67:no}
	restart_policy=${68:no|on-failure|always|unless-stopped}
	restart_retries=${69:# Use with restart policy to control maximum number of restart attempts.}
	runtime=${70:# Runtime to use for the container.}
	shm_size=${71:# Size of C(/dev/shm) in format C(<number>[<unit>]). Number is positive integer. Unit can be C(B) (byte), C(K) (kibibyte, 1024B), C(M) (mebibyte), C(G) (gibibyte), C(T) (tebibyte), or C(P) (pebibyte).}
	security_opts=${72:# List of security options in the form of C("label:user:User").}
	state=${73:absent|present|stopped|#started}
	stop_signal=${74:# Override default signal used to stop the container.}
	stop_timeout=${75:# Number of seconds to wait for the container to stop before sending C(SIGKILL). When the container is created by this module, its C(StopTimeout) configuration will be set to this value.}
	trust_image_content=${76:no}
	tmpfs=${77:# Mount a tmpfs directory.}
	tty=${78:no}
	ulimits=${79:# List of ulimit options. A ulimit is specified as C(nofile:262144:262144).}
	sysctls=${80:# Dictionary of key,value pairs.}
	user=${81:# Sets the username or UID used and optionally the groupname or GID for the specified command.}
	uts=${82:# Set the UTS namespace mode for the container.}
	volumes=${83:# List of volumes to mount within the container.}
	volume_driver=${84:# The container volume driver.}
	volumes_from=${85:# List of container names or IDs to get volumes from.}
	working_dir=${86:# Path to the working directory.}
	docker_host=${87:unix://var/run/docker.sock}
	tls_hostname=${88:localhost}
	api_version=${89:auto}
	timeout=${90:60}
	ca_cert=${91:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${92:# Path to the client's TLS certificate file.}
	client_key=${93:# Path to the client's TLS key file.}
	ssl_version=${94:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${95:no}
	validate_certs=${96:no}
	debug=${97:no}

endsnippet

snippet docker_swarm_service_info "Retrieves information about docker services from a Swarm Manager" b
docker_swarm_service_info: >
	name=${1:# The name of the service to inspect.}

	docker_host=${2:unix://var/run/docker.sock}
	tls_hostname=${3:localhost}
	api_version=${4:auto}
	timeout=${5:60}
	ca_cert=${6:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	client_cert=${7:# Path to the client's TLS certificate file.}
	client_key=${8:# Path to the client's TLS key file.}
	ssl_version=${9:# Provide a valid SSL version number. Default value determined by ssl.py module.}
	tls=${10:no}
	validate_certs=${11:no}
	debug=${12:no}

endsnippet

snippet ovh_ip_loadbalancing_backend "Manage OVH IP LoadBalancing backends" b
ovh_ip_loadbalancing_backend: >
	name=${1:# Name of the LoadBalancing internal name (ip-X.X.X.X)}
	backend=${2:# The IP address of the backend to update / modify / delete}
	endpoint=${3:# The endpoint to use ( for instance ovh-eu)}
	application_key=${4:# The applicationKey to use}
	application_secret=${5:# The application secret to use}
	consumer_key=${6:# The consumer key to use}

	state=${7:#present|absent}
	probe=${8:#none|http|icmp|oco}
	weight=${9:8}
	timeout=${10:120}

endsnippet

snippet ovh_ip_failover "Manage OVH IP failover address" b
ovh_ip_failover: >
	name=${1:# The IP address to manage (can be a single IP like 1.1.1.1 or a block like 1.1.1.1/28 )}
	service=${2:# The name of the OVH service this IP address should be routed}
	endpoint=${3:# The endpoint to use ( for instance ovh-eu)}
	application_key=${4:# The applicationKey to use}
	application_secret=${5:# The application secret to use}
	consumer_key=${6:# The consumer key to use}

	wait_completion=${7:yes}
	wait_task_completion=${8:0}
	timeout=${9:120}

endsnippet

snippet hwc_smn_topic "Creates a resource of SMNTopic in Huaweicloud Cloud" b
hwc_smn_topic: >
	name=${1:# Name of the topic to be created. The topic name is a string of 1 to 256 characters. It must contain upper- or lower-case letters, digits, hyphens (-), and underscores C(_), and must start with a letter or digit.}
	identity_endpoint=${2:# The Identity authentication URL.}
	user=${3:# The user name to login with (currently only user names are supported, and not user IDs).}
	password=${4:# The password to login with.}
	domain=${5:# The name of the Domain to scope to (Identity v3). (currently only domain names are supported, and not domain IDs).}
	project=${6:# The name of the Tenant (Identity v2) or Project (Identity v3). (currently only project names are supported, and not project IDs).}

	state=${7:#present|absent}
	display_name=${8:# Topic display name, which is presented as the name of the email sender in an email message. The topic display name contains a maximum of 192 bytes.}
	region=${9:# The region to which the project belongs.}
	id=${10:# The id of resource to be managed.}

endsnippet

snippet hwc_network_vpc "Creates a Huawei Cloud VPC" b
hwc_network_vpc: >
	name=${1:# The name of vpc.}
	cidr=${2:# The range of available subnets in the vpc.}
	identity_endpoint=${3:# The Identity authentication URL.}
	user=${4:# The user name to login with (currently only user names are supported, and not user IDs).}
	password=${5:# The password to login with.}
	domain=${6:# The name of the Domain to scope to (Identity v3). (currently only domain names are supported, and not domain IDs).}
	project=${7:# The name of the Tenant (Identity v2) or Project (Identity v3). (currently only project names are supported, and not project IDs).}

	state=${8:#present|absent}
	timeouts=${9:# The timeouts for each operations.}
	region=${10:# The region to which the project belongs.}
	id=${11:# The id of resource to be managed.}

endsnippet

snippet sl_vm "create or cancel a virtual instance in SoftLayer" b
sl_vm: >
	cpus=${1:# Count of cpus to be assigned to new virtual instance.}
	memory=${2:# Amount of memory to be assigned to new virtual instance.}
	disks=${3:[25]}

	instance_id=${4:# Instance Id of the virtual instance to perform action option.}
	hostname=${5:# Hostname to be provided to a virtual instance.}
	domain=${6:# Domain name to be provided to a virtual instance.}
	datacenter=${7:# Datacenter for the virtual instance to be deployed.}
	tags=${8:# Tag or list of tags to be provided to a virtual instance.}
	hourly=${9:yes}
	private=${10:no}
	dedicated=${11:no}
	local_disk=${12:yes}
	os_code=${13:# OS Code to be used for new virtual instance.}
	image_id=${14:# Image Template to be used for new virtual instance.}
	nic_speed=${15:10}
	public_vlan=${16:# VLAN by its Id to be assigned to the public NIC.}
	private_vlan=${17:# VLAN by its Id to be assigned to the private NIC.}
	ssh_keys=${18:# List of ssh keys by their Id to be assigned to a virtual instance.}
	post_uri=${19:# URL of a post provisioning script to be loaded and executed on virtual instance.}
	state=${20:absent|#present}
	wait=${21:yes}
	wait_time=${22:600}

endsnippet

snippet ec2_placement_group_info "List EC2 Placement Group(s) details" b
ec2_placement_group_info: >
	names=${1:[]}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_ami "create or destroy an image in ec2" b
ec2_ami: >
	instance_id=${1:# Instance ID to create the AMI from.}
	name=${2:# The name of the new AMI.}
	architecture=${3:# The target architecture of the image to register}
	kernel_id=${4:# The target kernel id of the image to register.}
	virtualization_type=${5:# The virtualization type of the image to register.}
	root_device_name=${6:# The root device name of the image to register.}
	wait=${7:no}
	wait_timeout=${8:900}
	state=${9:absent|#present}
	description=${10:# Human-readable string describing the contents and purpose of the AMI.}
	no_reboot=${11:no}
	image_id=${12:# Image ID to be deregistered.}
	device_mapping=${13:# List of device hashes/dictionaries with custom configurations (same block-device-mapping parameters).}
	delete_snapshot=${14:no}
	tags=${15:# A dictionary of tags to add to the new image; '{"key":"value"}' and '{"key":"value","key":"value"}'}
	purge_tags=${16:no}
	launch_permissions=${17:# Users and groups that should be able to launch the AMI. Expects dictionary with a key of user_ids and/or group_names. user_ids should be a list of account ids. group_name should be a list of groups, "all" is the only acceptable value currently.}
	image_location=${18:# The s3 location of an image to use for the AMI.}
	enhanced_networking=${19:# A boolean representing whether enhanced networking with ENA is enabled or not.}
	billing_products=${20:# A list of valid billing codes. To be used with valid accounts by aws marketplace vendors.}
	ramdisk_id=${21:# The ID of the RAM disk.}
	sriov_net_support=${22:# Set to simple to enable enhanced networking with the Intel 82599 Virtual Function interface for the AMI and any instances that you launch from the AMI.}
	debug_botocore_endpoint_logs=${23:no}
	ec2_url=${24:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${25:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${26:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${27:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${28:yes}
	profile=${29:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${30:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudtrail "manage CloudTrail create, delete, update" b
cloudtrail: >
	state=${1:present|absent|enabled|disabled}
	name=${2:# Name for the CloudTrail.}

	enable_logging=${3:yes}
	s3_bucket_name=${4:# An existing S3 bucket where CloudTrail will deliver log files.}
	s3_key_prefix=${5:# S3 Key prefix for delivered log files. A trailing slash is not necessary and will be removed.}
	is_multi_region_trail=${6:no}
	enable_log_file_validation=${7:# Specifies whether log file integrity validation is enabled.}
	include_global_events=${8:yes}
	sns_topic_name=${9:# SNS Topic name to send notifications to when a log file is delivered.}
	cloudwatch_logs_role_arn=${10:# Specifies a full ARN for an IAM role that assigns the proper permissions for CloudTrail to create and write to the log group.}
	cloudwatch_logs_log_group_arn=${11:# A full ARN specifying a valid CloudWatch log group to which CloudTrail logs will be delivered. The log group should already exist.}
	kms_key_id=${12:# Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. This also has the effect of enabling log file encryption.}
	tags=${13:{}}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_waf_info "Retrieve information for WAF ACLs, Rule , Conditions and Filters." b
aws_waf_info: >
	name=${1:# The name of a Web Application Firewall}
	waf_regional=${2:no}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet redshift "create, delete, or modify an Amazon Redshift instance" b
redshift: >
	command=${1:create|facts|delete|modify}
	identifier=${2:# Redshift cluster identifier.}

	node_type=${3:ds1.xlarge|ds1.8xlarge|ds2.xlarge|ds2.8xlarge|dc1.large|dc1.8xlarge|dc2.large|dc2.8xlarge|dw1.xlarge|dw1.8xlarge|dw2.large|dw2.8xlarge}
	username=${4:# Master database username. Used only when command=create.}
	password=${5:# Master database password. Used only when command=create.}
	cluster_type=${6:multi-node|#single-node}
	db_name=${7:# Name of the database.}
	availability_zone=${8:# availability zone in which to launch cluster}
	number_of_nodes=${9:# Number of nodes. Only used when cluster_type=multi-node.}
	cluster_subnet_group_name=${10:# which subnet to place the cluster}
	cluster_security_groups=${11:# in which security group the cluster belongs}
	vpc_security_group_ids=${12:# VPC security group}
	skip_final_cluster_snapshot=${13:no}
	final_cluster_snapshot_identifier=${14:# identifier of the final snapshot to be created before deleting the cluster. If this parameter is provided, final_cluster_snapshot_identifier must be false. Used only when command=delete.}
	preferred_maintenance_window=${15:# maintenance window}
	cluster_parameter_group_name=${16:# name of the cluster parameter group}
	automated_snapshot_retention_period=${17:# period when the snapshot take place}
	port=${18:# which port the cluster is listening}
	cluster_version=${19:1.0}
	allow_version_upgrade=${20:yes}
	publicly_accessible=${21:no}
	encrypted=${22:no}
	elastic_ip=${23:# if the cluster has an elastic IP or not}
	new_cluster_identifier=${24:# Only used when command=modify.}
	wait=${25:no}
	wait_timeout=${26:300}
	debug_botocore_endpoint_logs=${27:no}
	ec2_url=${28:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${29:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${30:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${31:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${32:yes}
	profile=${33:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${34:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_elb_info "Gather information about EC2 Elastic Load Balancers in AWS" b
ec2_elb_info: >
	names=${1:# List of ELB names to gather information about. Pass this option to gather information about a set of ELBs, otherwise, all ELBs are returned.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_net_info "Gather information about ec2 VPCs in AWS" b
ec2_vpc_net_info: >
	vpc_ids=${1:# A list of VPC IDs that exist in your account.}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_ssm_parameter_store "Manage key-value pairs in aws parameter store." b
aws_ssm_parameter_store: >
	name=${1:# parameter key name.}

	description=${2:# parameter key description.}
	value=${3:# Parameter value.}
	state=${4:#present|absent}
	string_type=${5:#String|StringList|SecureString}
	decryption=${6:yes}
	key_id=${7:aws/ssm (this key is automatically generated at the first parameter created).}
	overwrite_value=${8:never|#changed|always}
	region=${9:# region.}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet aws_glue_job "Manage an AWS Glue job" b
aws_glue_job: >
	command_script_location=${1:# The S3 path to a script that executes a job.}
	name=${2:# The name you assign to this job definition. It must be unique in your account.}
	role=${3:# The name or ARN of the IAM role associated with this job.}
	state=${4:present|absent}

	allocated_capacity=${5:# The number of AWS Glue data processing units (DPUs) to allocate to this Job. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.}
	command_name=${6:glueetl}
	connections=${7:# A list of Glue connections used for this job.}
	default_arguments=${8:# A dict of default arguments for this job.  You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.}
	description=${9:# Description of the job being defined.}
	max_concurrent_runs=${10:# The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned when this threshold is reached. The maximum value you can specify is controlled by a service limit.}
	max_retries=${11:# The maximum number of times to retry this job if it fails.}
	timeout=${12:# The job timeout in minutes.}
	debug_botocore_endpoint_logs=${13:no}
	ec2_url=${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${15:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${16:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${17:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${18:yes}
	profile=${19:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${20:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudfront_distribution "create, update and delete aws cloudfront distributions." b
cloudfront_distribution: >
	state=${1:#present|absent}
	distribution_id=${2:# The id of the cloudfront distribution. This parameter can be exchanged with I(alias) or I(caller_reference) and is used in conjunction with I(e_tag).}
	e_tag=${3:# A unique identifier of a modified or existing distribution. Used in conjunction with I(distribution_id). Is determined automatically if not specified.}
	caller_reference=${4:# A unique identifier for creating and updating cloudfront distributions. Each caller reference must be unique across all distributions. e.g. a caller reference used in a web distribution cannot be reused in a streaming distribution. This parameter can be used instead of I(distribution_id) to reference an existing distribution. If not specified, this defaults to a datetime stamp of the format 'YYYY-MM-DDTHH:MM:SS.ffffff'.}
	tags=${5:# Should be input as a dict() of key-value pairs. Note that numeric keys or values must be wrapped in quotes. e.g. "Priority:" '1'}
	purge_tags=${6:no}
	alias=${7:# The name of an alias (CNAME) that is used in a distribution. This is used to effectively reference a distribution by its alias as an alias can only be used by one distribution per AWS account. This variable avoids having to provide the I(distribution_id) as well as the I(e_tag), or I(caller_reference) of an existing distribution.}
	aliases=${8:# A I(list[]) of domain name aliases (CNAMEs) as strings to be used for the distribution. Each alias must be unique across all distribution for the AWS account.}
	purge_aliases=${9:no}
	default_root_object=${10:# A config element that specifies the path to request when the user requests the origin. e.g. if specified as 'index.html', this maps to www.example.com/index.html when www.example.com is called by the user. This prevents the entire distribution origin from being exposed at the root.}
	default_origin_domain_name=${11:# The domain name to use for an origin if no I(origins) have been specified. Should only be used on a first run of generating a distribution and not on subsequent runs. Should not be used in conjunction with I(distribution_id), I(caller_reference) or I(alias).}
	default_origin_path=${12:# The default origin path to specify for an origin if no I(origins) have been specified. Defaults to empty if not specified.}
	origins=${13:# A config element that is a I(list[]) of complex origin objects to be specified for the distribution. Used for creating and updating distributions. Each origin item comprises the attributes I(id) I(domain_name) (defaults to default_origin_domain_name if not specified) I(origin_path) (defaults to default_origin_path if not specified) I(custom_headers[]) I(header_name) I(header_value) I(s3_origin_access_identity_enabled) I(custom_origin_config) I(http_port) I(https_port) I(origin_protocol_policy) I(origin_ssl_protocols[]) I(origin_read_timeout) I(origin_keepalive_timeout)}
	purge_origins=${14:no}
	default_cache_behavior=${15:# A config element that is a complex object specifying the default cache behavior of the distribution. If not specified, the I(target_origin_id) is defined as the I(target_origin_id) of the first valid I(cache_behavior) in I(cache_behaviors) with defaults. The default cache behavior comprises the attributes I(target_origin_id) I(forwarded_values) I(query_string) I(cookies) I(forward) I(whitelisted_names) I(headers[]) I(query_string_cache_keys[]) I(trusted_signers) I(enabled) I(items[]) I(viewer_protocol_policy) I(min_ttl) I(allowed_methods) I(items[]) I(cached_methods[]) I(smooth_streaming) I(default_ttl) I(max_ttl) I(compress) I(lambda_function_associations[]) I(lambda_function_arn) I(event_type) I(field_level_encryption_id)}
	cache_behaviors=${16:# A config element that is a I(list[]) of complex cache behavior objects to be specified for the distribution. The order of the list is preserved across runs unless C(purge_cache_behavior) is enabled. Each cache behavior comprises the attributes I(path_pattern) I(target_origin_id) I(forwarded_values) I(query_string) I(cookies) I(forward) I(whitelisted_names) I(headers[]) I(query_string_cache_keys[]) I(trusted_signers) I(enabled) I(items[]) I(viewer_protocol_policy) I(min_ttl) I(allowed_methods) I(items[]) I(cached_methods[]) I(smooth_streaming) I(default_ttl) I(max_ttl) I(compress) I(lambda_function_associations[]) I(field_level_encryption_id)}
	purge_cache_behaviors=${17:no}
	custom_error_responses=${18:# A config element that is a I(list[]) of complex custom error responses to be specified for the distribution. This attribute configures custom http error messages returned to the user. Each custom error response object comprises the attributes I(error_code) I(response_page_path) I(response_code) I(error_caching_min_ttl)}
	purge_custom_error_responses=${19:no}
	comment=${20:# A comment that describes the cloudfront distribution. If not specified, it defaults to a generic message that it has been created with Ansible, and a datetime stamp.}
	logging=${21:# A config element that is a complex object that defines logging for the distribution. The logging object comprises the attributes I(enabled) I(include_cookies) I(bucket) I(prefix)}
	price_class=${22:PriceClass_100|PriceClass_200|PriceClass_All}
	enabled=${23:yes}
	viewer_certificate=${24:# A config element that is a complex object that specifies the encryption details of the distribution. Comprises the following attributes I(cloudfront_default_certificate) I(iam_certificate_id) I(acm_certificate_arn) I(ssl_support_method) I(minimum_protocol_version) I(certificate) I(certificate_source)}
	restrictions=${25:# A config element that is a complex object that describes how a distribution should restrict it's content. The restriction object comprises the following attributes I(geo_restriction) I(restriction_type) I(items[])}
	web_acl_id=${26:# The id of a Web Application Firewall (WAF) Access Control List (ACL).}
	http_version=${27:http1.1|http2}
	ipv6_enabled=${28:no}
	wait=${29:no}
	wait_timeout=${30:1800}
	debug_botocore_endpoint_logs=${31:no}
	ec2_url=${32:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${33:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${34:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${35:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${36:yes}
	profile=${37:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${38:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet s3_logging "Manage logging facility of an s3 bucket in AWS" b
s3_logging: >
	name=${1:# Name of the s3 bucket.}

	state=${2:#present|absent}
	target_bucket=${3:# The bucket to log to. Required when state=present.}
	target_prefix=${4:}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_application_lb "Manage an Application load balancer" b
elb_application_lb: >
	name=${1:# The name of the load balancer. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.}

	access_logs_enabled=${2:# Whether or not to enable access logs. When true, I(access_logs_s3_bucket) must be set.}
	access_logs_s3_bucket=${3:# The name of the S3 bucket for the access logs.}
	access_logs_s3_prefix=${4:# The prefix for the log location in the S3 bucket.}
	deletion_protection=${5:no}
	http2=${6:no}
	idle_timeout=${7:60}
	listeners=${8:# A list of dicts containing listeners to attach to the ELB. See examples for detail of the dict required. Note that listener keys are CamelCased.}
	purge_listeners=${9:yes}
	purge_tags=${10:yes}
	subnets=${11:# A list of the IDs of the subnets to attach to the load balancer. You can specify only one subnet per Availability Zone. You must specify subnets from at least two Availability Zones. Required if state=present.}
	security_groups=${12:[]}
	scheme=${13:#internet-facing|internal}
	state=${14:#present|absent}
	tags=${15:# A dictionary of one or more tags to assign to the load balancer.}
	wait=${16:no}
	wait_timeout=${17:# The time in seconds to use in conjunction with I(wait).}
	purge_rules=${18:yes}
	debug_botocore_endpoint_logs=${19:no}
	ec2_url=${20:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${21:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${22:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${23:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${24:yes}
	profile=${25:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${26:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_application_scaling_policy "Manage Application Auto Scaling Scaling Policies" b
aws_application_scaling_policy: >
	policy_name=${1:# T}
	service_namespace=${2:ecs|elasticmapreduce|ec2|appstream|dynamodb}
	resource_id=${3:# T}
	scalable_dimension=${4:ecs:service:DesiredCount|ec2:spot-fleet-request:TargetCapacity|elasticmapreduce:instancegroup:InstanceCount|appstream:fleet:DesiredCapacity|dynamodb:table:ReadCapacityUnits|dynamodb:table:WriteCapacityUnits|dynamodb:index:ReadCapacityUnits|dynamodb:index:WriteCapacityUnits}
	policy_type=${5:StepScaling|TargetTrackingScaling}

	step_scaling_policy_configuration=${6:# A}
	target_tracking_scaling_policy_configuration=${7:# A}
	minimum_tasks=${8:# T}
	maximum_tasks=${9:# T}
	override_task_capacity=${10:no}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_key "create or delete an ec2 key pair" b
ec2_key: >
	name=${1:# Name of the key pair.}

	key_material=${2:# Public key material.}
	force=${3:yes}
	state=${4:#present|absent}
	wait=${5:no}
	wait_timeout=${6:300}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_caller_info "Get information about the user and account being used to make AWS calls." b
aws_caller_info: >
	debug_botocore_endpoint_logs=${1:no}
	ec2_url=${2:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${6:yes}
	profile=${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet rds "create, delete, or modify Amazon rds instances, rds snapshots, and related facts" b
rds: >
	command=${1:create|replicate|delete|facts|modify|promote|snapshot|reboot|restore}
	region=${2:# The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.}

	instance_name=${3:# Database instance identifier. Required except when using command=facts or command=delete on just a snapshot}
	source_instance=${4:# Name of the database to replicate. Used only when command=replicate.}
	db_engine=${5:mariadb|MySQL|oracle-se1|oracle-se2|oracle-se|oracle-ee|sqlserver-ee|sqlserver-se|sqlserver-ex|sqlserver-web|postgres|aurora}
	size=${6:# Size in gigabytes of the initial storage for the DB instance. Used only when command=create or command=modify.}
	instance_type=${7:# The instance type of the database.  Must be specified when command=create. Optional when command=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance.}
	username=${8:# Master database username. Used only when command=create.}
	password=${9:# Password for the master database username. Used only when command=create or command=modify.}
	db_name=${10:# Name of a database to create within the instance.  If not specified then no database is created. Used only when command=create.}
	engine_version=${11:# Version number of the database engine to use. Used only when command=create. If not specified then the current Amazon RDS default engine version is used}
	parameter_group=${12:# Name of the DB parameter group to associate with this instance.  If omitted then the RDS default DBParameterGroup will be used. Used only when command=create or command=modify.}
	license_model=${13:license-included|bring-your-own-license|general-public-license|postgresql-license}
	multi_zone=${14:# Specifies if this is a Multi-availability-zone deployment. Can not be used in conjunction with zone parameter. Used only when command=create or command=modify.}
	iops=${15:# Specifies the number of IOPS for the instance.  Used only when command=create or command=modify. Must be an integer greater than 1000.}
	security_groups=${16:# Comma separated list of one or more security groups.  Used only when command=create or command=modify.}
	vpc_security_groups=${17:# Comma separated list of one or more vpc security group ids. Also requires `subnet` to be specified. Used only when command=create or command=modify.}
	port=${18:3306 for mysql, 1521 for Oracle, 1433 for SQL Server, 5432 for PostgreSQL.}
	upgrade=${19:no}
	option_group=${20:# The name of the option group to use.  If not specified then the default option group is used. Used only when command=create.}
	maint_window=${21:# Maintenance window in format of ddd:hh24:mi-ddd:hh24:mi.  (Example: Mon:22:00-Mon:23:15) If not specified then a random maintenance window is assigned. Used only when command=create or command=modify.
}
	backup_window=${22:# Backup window in format of hh24:mi-hh24:mi.  If not specified then a random backup window is assigned. Used only when command=create or command=modify.}
	backup_retention=${23:# Number of days backups are retained.  Set to 0 to disable backups.  Default is 1 day.  Valid range: 0-35. Used only when command=create or command=modify.
}
	zone=${24:# availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore.}
	subnet=${25:# VPC subnet group.  If specified then a VPC instance is created. Used only when command=create.}
	snapshot=${26:# Name of snapshot to take. When command=delete, if no snapshot name is provided then no snapshot is taken. If used with command=delete with no instance_name, the snapshot is deleted. Used with command=facts, command=delete or command=snapshot.}
	aws_secret_key=${27:# AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.}
	aws_access_key=${28:# AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.}
	wait=${29:no}
	wait_timeout=${30:300}
	apply_immediately=${31:no}
	force_failover=${32:no}
	new_instance_name=${33:# Name to rename an instance to. Used only when command=modify.}
	character_set_name=${34:# Associate the DB instance with a specified character set. Used with command=create.}
	publicly_accessible=${35:# explicitly set whether the resource should be publicly accessible or not. Used with command=create, command=replicate. Requires boto >= 2.26.0}
	tags=${36:# tags dict to apply to a resource. Used with command=create, command=replicate, command=restore. Requires boto >= 2.26.0}
	debug_botocore_endpoint_logs=${37:no}
	ec2_url=${38:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	security_token=${39:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${40:yes}
	profile=${41:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet route53_health_check "add or delete health-checks in Amazons Route53 DNS service" b
route53_health_check: >
	state=${1:present|absent}
	type=${2:HTTP|HTTPS|HTTP_STR_MATCH|HTTPS_STR_MATCH|TCP}
	request_interval=${3:10|#30}
	failure_threshold=${4:1|2|#3|4|5|6|7|8|9|10}

	ip_address=${5:# IP address of the end-point to check. Either this or `fqdn` has to be provided.}
	port=${6:# The port on the endpoint on which you want Amazon Route 53 to perform health checks. Required for TCP checks.}
	resource_path=${7:# The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html.}
	fqdn=${8:# Domain name of the endpoint to check. Either this or `ip_address` has to be provided. When both are given the `fqdn` is used in the `Host:` header of the HTTP request.}
	string_match=${9:# If the check type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the first 5120 bytes of the response body, Amazon Route 53 considers the resource healthy.}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_igw "Manage an AWS VPC Internet gateway" b
ec2_vpc_igw: >
	vpc_id=${1:# The VPC ID for the VPC in which to manage the Internet Gateway.}

	tags=${2:# A dict of tags to apply to the internet gateway. Any tags currently applied to the internet gateway and not present here will be removed.}
	state=${3:#present|absent}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_network_lb "Manage a Network Load Balancer" b
elb_network_lb: >
	name=${1:# The name of the load balancer. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.}
	state=${2:present|absent}

	cross_zone_load_balancing=${3:no}
	deletion_protection=${4:no}
	listeners=${5:# A list of dicts containing listeners to attach to the ELB. See examples for detail of the dict required. Note that listener keys are CamelCased.}
	purge_listeners=${6:yes}
	purge_tags=${7:yes}
	subnet_mappings=${8:# A list of dicts containing the IDs of the subnets to attach to the load balancer. You can also specify the allocation ID of an Elastic IP to attach to the load balancer. You can specify one Elastic IP address per subnet. This parameter is mutually exclusive with I(subnets)}
	subnets=${9:# A list of the IDs of the subnets to attach to the load balancer. You can specify only one subnet per Availability Zone. You must specify subnets from at least two Availability Zones. Required if state=present. This parameter is mutually exclusive with I(subnet_mappings)}
	scheme=${10:#internet-facing|internal}
	tags=${11:# A dictionary of one or more tags to assign to the load balancer.}
	wait=${12:# Whether or not to wait for the network load balancer to reach the desired state.}
	wait_timeout=${13:# The duration in seconds to wait, used in conjunction with I(wait).}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_lc "Create or delete AWS Autoscaling Launch Configurations" b
ec2_lc: >
	name=${1:# Unique name for configuration}
	instance_type=${2:# Instance type to use for the instance}

	state=${3:#present|absent}
	image_id=${4:# The AMI unique identifier to be used for the group}
	key_name=${5:# The SSH key name to be used for access to managed instances}
	security_groups=${6:# A list of security groups to apply to the instances. Since version 2.4 you can specify either security group names or IDs or a mix.  Previous to 2.4, for VPC instances, specify security group IDs and for EC2-Classic, specify either security group names or IDs.}
	volumes=${7:# A list of volume dicts, each containing device name and optionally ephemeral id or snapshot id. Size and type (and number of iops for io device type) must be specified for a new volume or a root volume, and may be passed for a snapshot volume. For any volume, a volume size less than 1 will be interpreted as a request not to create the volume.}
	user_data=${8:# Opaque blob of data which is made available to the ec2 instance. Mutually exclusive with I(user_data_path).}
	user_data_path=${9:# Path to the file that contains userdata for the ec2 instances. Mutually exclusive with I(user_data).}
	kernel_id=${10:# Kernel id for the EC2 instance}
	spot_price=${11:# The spot price you are bidding. Only applies for an autoscaling group with spot instances.}
	instance_monitoring=${12:no}
	assign_public_ip=${13:# Used for Auto Scaling groups that launch instances into an Amazon Virtual Private Cloud. Specifies whether to assign a public IP address to each instance launched in a Amazon VPC.}
	ramdisk_id=${14:# A RAM disk id for the instances.}
	instance_profile_name=${15:# The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instances.}
	ebs_optimized=${16:no}
	classic_link_vpc_id=${17:# Id of ClassicLink enabled VPC}
	classic_link_vpc_security_groups=${18:# A list of security group IDs with which to associate the ClassicLink VPC instances.}
	vpc_id=${19:# VPC ID, used when resolving security group names to IDs.}
	instance_id=${20:# The Id of a running instance to use as a basis for a launch configuration. Can be used in place of image_id and instance_type.}
	placement_tenancy=${21:default}
	debug_botocore_endpoint_logs=${22:no}
	ec2_url=${23:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${24:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${25:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${26:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${27:yes}
	profile=${28:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${29:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vol_info "Gather information about ec2 volumes in AWS" b
ec2_vol_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html) for possible filters.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet redshift_info "Gather information about Redshift cluster(s)" b
redshift_info: >
	cluster_identifier=${1:# The prefix of cluster identifier of the Redshift cluster you are searching for.}
	tags=${2:# A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the security group(s) you are searching for.}
	region=${3:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet ec2_metadata_facts "Gathers facts (instance metadata) about remote hosts within ec2" b
ec2_metadata_facts:

endsnippet

snippet ecs_service_info "list or describe services in ecs" b
ecs_service_info: >
	details=${1:false}
	events=${2:true}
	cluster=${3:default}
	service=${4:# One or more services to get details for}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_igw_info "Gather information about internet gateways in AWS" b
ec2_vpc_igw_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html) for possible filters.}
	internet_gateway_ids=${2:# Get details of specific Internet Gateway ID. Provide this value as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_glue_connection "Manage an AWS Glue connection" b
aws_glue_connection: >
	connection_properties=${1:# A dict of key-value pairs used as parameters for this connection.}
	name=${2:# The name of the connection.}
	state=${3:present|absent}

	catalog_id=${4:# The ID of the Data Catalog in which to create the connection. If none is supplied, the AWS account ID is used by default.}
	connection_type=${5:#JDBC|SFTP}
	description=${6:# The description of the connection.}
	match_criteria=${7:# A list of UTF-8 strings that specify the criteria that you can use in selecting this connection.}
	security_groups=${8:# A list of security groups to be used by the connection. Use either security group name or ID.}
	subnet_id=${9:# The subnet ID used by the connection.}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_peering_info "Retrieves AWS VPC Peering details using AWS methods." b
ec2_vpc_peering_info: >
	peer_connection_ids=${1:# Get details of specific vpc peer IDs}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_role "Manage AWS IAM roles" b
iam_role: >
	name=${1:# The name of the role to create.}

	path=${2:/}
	description=${3:# Provide a description of the new role}
	boundary=${4:# Add the ARN of an IAM managed policy to restrict the permissions this role can pass on to IAM roles/users that it creates.}
	assume_role_policy_document=${5:# The trust relationship policy document that grants an entity permission to assume the role.}
	managed_policy=${6:# A list of managed policy ARNs or, since Ansible 2.4, a list of either managed policy ARNs or friendly names. To embed an inline policy, use M(iam_policy). To remove existing policies, use an empty list item.}
	purge_policies=${7:yes}
	state=${8:#present|absent}
	create_instance_profile=${9:yes}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_taskdefinition_info "describe a task definition in ecs" b
ecs_taskdefinition_info: >
	task_definition=${1:# The name of the task definition to get details for}

	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elasticache "Manage cache clusters in Amazon Elasticache." b
elasticache: >
	state=${1:present|absent|rebooted}
	name=${2:# The cache cluster identifier}

	engine=${3:redis|#memcached}
	cache_engine_version=${4:# The version number of the cache engine}
	node_type=${5:cache.m1.small}
	num_nodes=${6:# The initial number of cache nodes that the cache cluster will have. Required when state=present.}
	cache_port=${7:# The port number on which each of the cache nodes will accept connections}
	cache_parameter_group=${8:# The name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used.}
	cache_subnet_group=${9:# The subnet group name to associate with. Only use if inside a vpc. Required if inside a vpc}
	security_group_ids=${10:# A list of vpc security group IDs to associate with this cache cluster. Only use if inside a vpc}
	cache_security_groups=${11:# A list of cache security group names to associate with this cache cluster. Must be an empty list if inside a vpc}
	zone=${12:# The EC2 Availability Zone in which the cache cluster will be created}
	wait=${13:yes}
	hard_modify=${14:no}
	debug_botocore_endpoint_logs=${15:no}
	ec2_url=${16:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${17:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${18:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${19:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${20:yes}
	profile=${21:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${22:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_vpn_info "Gather information about VPN Connections in AWS." b
ec2_vpc_vpn_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnConnections.html) for possible filters.}
	vpn_connection_ids=${2:# Get details of a specific VPN connections using vpn connection ID/IDs. This value should be provided as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_asg_lifecycle_hook "Create, delete or update AWS ASG Lifecycle Hooks." b
ec2_asg_lifecycle_hook: >
	lifecycle_hook_name=${1:# The name of the lifecycle hook.}
	autoscaling_group_name=${2:# The name of the Auto Scaling group to which you want to assign the lifecycle hook.}
	transition=${3:autoscaling:EC2_INSTANCE_TERMINATING|autoscaling:EC2_INSTANCE_LAUNCHING}

	state=${4:#present|absent}
	role_arn=${5:# The ARN of the IAM role that allows the Auto Scaling group to publish to the specified notification target.}
	notification_target_arn=${6:# The ARN of the notification target that Auto Scaling will use to notify you when an instance is in the transition state for the lifecycle hook. This target can be either an SQS queue or an SNS topic. If you specify an empty string, this overrides the current ARN.}
	notification_meta_data=${7:# Contains additional information that you want to include any time Auto Scaling sends a message to the notification target.}
	heartbeat_timeout=${8:3600 (1 hour)}
	default_result=${9:#ABANDON|CONTINUE}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_route_table_info "Gather information about ec2 VPC route tables in AWS" b
ec2_vpc_route_table_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_nacl "create and delete Network ACLs." b
ec2_vpc_nacl: >
	name=${1:# Tagged name identifying a network ACL.}
	nacl_id=${2:# NACL id identifying a network ACL.}
	vpc_id=${3:# VPC id of the requesting VPC.}
	subnets=${4:# The list of subnets that should be associated with the network ACL.}
	egress=${5:[]}
	ingress=${6:[]}
	tags=${7:# Dictionary of tags to look for and apply when creating a network ACL.}
	state=${8:#present|absent}
	debug_botocore_endpoint_logs=${9:no}
	ec2_url=${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${14:yes}
	profile=${15:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_placement_group "Create or delete an EC2 Placement Group" b
ec2_placement_group: >
	name=${1:# The name for the placement group.}

	state=${2:#present|absent}
	strategy=${3:#cluster|spread}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_nat_gateway "Manage AWS VPC NAT Gateways." b
ec2_vpc_nat_gateway: >
	state=${1:#present|absent}
	nat_gateway_id=${2:# The id AWS dynamically allocates to the NAT Gateway on creation. This is required when the absent option is present.}
	subnet_id=${3:# The id of the subnet to create the NAT Gateway in. This is required with the present option.}
	allocation_id=${4:# The id of the elastic IP allocation. If this is not passed and the eip_address is not passed. An EIP is generated for this NAT Gateway.}
	eip_address=${5:# The elastic IP address of the EIP you want attached to this NAT Gateway. If this is not passed and the allocation_id is not passed, an EIP is generated for this NAT Gateway.}
	if_exist_do_not_create=${6:no}
	release_eip=${7:yes}
	wait=${8:no}
	wait_timeout=${9:300}
	client_token=${10:# Optional unique token to be used during create to ensure idempotency. When specifying this option, ensure you specify the eip_address parameter as well otherwise any subsequent runs will fail.}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elasticache_info "Retrieve information for AWS Elasticache clusters" b
elasticache_info: >
	name=${1:# The name of an Elasticache cluster}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_acm_info "Retrieve certificate information from AWS Certificate Manager service" b
aws_acm_info: >
	domain_name=${1:# The domain name of an ACM certificate to limit the search to}
	statuses=${2:PENDING_VALIDATION|ISSUED|INACTIVE|EXPIRED|VALIDATION_TIMED_OUT|REVOKED|FAILED}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_waf_condition "create and delete WAF Conditions" b
aws_waf_condition: >
	name=${1:# N}

	type=${2:byte|geo|ip|regex|size|sql|xss}
	filters=${3:# A list of the filters against which to match.}
	purge_filters=${4:no}
	waf_regional=${5:no}
	state=${6:#present|absent}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_waf_info "Retrieve information for WAF ACLs, Rule , Conditions and Filters." b
aws_waf_info: >
	name=${1:# The name of a Web Application Firewall}
	waf_regional=${2:no}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudfront_info "Obtain facts about an AWS CloudFront distribution" b
cloudfront_info: >
	distribution_id=${1:# The id of the CloudFront distribution. Used with I(distribution), I(distribution_config), I(invalidation), I(streaming_distribution), I(streaming_distribution_config), I(list_invalidations).}
	invalidation_id=${2:# The id of the invalidation to get information about. Used with I(invalidation).}
	origin_access_identity_id=${3:# The id of the cloudfront origin access identity to get information about.}
	web_acl_id=${4:# Used with I(list_distributions_by_web_acl_id).}
	domain_name_alias=${5:# Can be used instead of I(distribution_id) - uses the aliased CNAME for the cloudfront distribution to get the distribution id where required.}
	all_lists=${6:no}
	origin_access_identity=${7:no}
	origin_access_identity_config=${8:no}
	distribution=${9:no}
	distribution_config=${10:no}
	invalidation=${11:no}
	streaming_distribution=${12:no}
	streaming_distribution_config=${13:no}
	list_origin_access_identities=${14:no}
	list_distributions=${15:no}
	list_distributions_by_web_acl_id=${16:no}
	list_invalidations=${17:no}
	list_streaming_distributions=${18:no}
	summary=${19:no}
	debug_botocore_endpoint_logs=${20:no}
	ec2_url=${21:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${22:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${23:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${24:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${25:yes}
	profile=${26:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${27:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_snapshot "creates a snapshot from an existing volume" b
ec2_snapshot: >
	volume_id=${1:# volume from which to take the snapshot}
	description=${2:# description to be applied to the snapshot}
	instance_id=${3:# instance that has the required volume to snapshot mounted}
	device_name=${4:# device name of a mounted volume to be snapshotted}
	snapshot_tags=${5:# a hash/dictionary of tags to add to the snapshot}
	wait=${6:yes}
	wait_timeout=${7:0}
	state=${8:absent|#present}
	snapshot_id=${9:# snapshot id to remove}
	last_snapshot_min_age=${10:0}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_ami_info "Gather information about ec2 AMIs" b
ec2_ami_info: >
	image_ids=${1:# O}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value.}
	owners=${3:# Filter the images by the owner. Valid options are an AWS account ID, self,}
	executable_users=${4:# Filter images by users with explicit launch permissions. Valid options are an AWS account ID, self, or all (public AMIs).}
	describe_image_attributes=${5:no}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_config_delivery_channel "Manage AWS Config delivery channels" b
aws_config_delivery_channel: >
	name=${1:# The name of the AWS Config resource.}

	state=${2:#present|absent}
	s3_bucket=${3:# The name of the Amazon S3 bucket to which AWS Config delivers configuration snapshots and configuration history files.}
	s3_prefix=${4:# The prefix for the specified Amazon S3 bucket.}
	sns_topic_arn=${5:# The Amazon Resource Name (ARN) of the Amazon SNS topic to which AWS Config sends notifications about configuration changes.}
	delivery_frequency=${6:One_Hour|Three_Hours|Six_Hours|Twelve_Hours|TwentyFour_Hours}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_sgw_info "Fetch AWS Storage Gateway information" b
aws_sgw_info: >
	gather_local_disks=${1:yes}
	gather_tapes=${2:yes}
	gather_file_shares=${3:yes}
	gather_volumes=${4:yes}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet data_pipeline "Create and manage AWS Datapipelines" b
data_pipeline: >
	name=${1:# The name of the Datapipeline to create/modify/delete.}

	description=${2:}
	objects=${3:# A list of pipeline object definitions, each of which is a dict that takes the keys C(id), C(name) and C(fields).}
	parameters=${4:# A list of parameter objects (dicts) in the pipeline definition.}
	values=${5:# A list of parameter values (dicts) in the pipeline definition. Each dict takes the keys C(id) and C(stringValue) both of which are strings.}
	timeout=${6:300}
	state=${7:#present|absent|active|inactive}
	tags=${8:# A dict of key:value pair(s) to add to the pipeline.}
	debug_botocore_endpoint_logs=${9:no}
	ec2_url=${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${14:yes}
	profile=${15:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_ses_identity "Manages SES email and domain identity" b
aws_ses_identity: >
	identity=${1:# This is the email address or domain to verify / delete.}

	state=${2:#present|absent}
	bounce_notifications=${3:# Setup the SNS topic used to report bounce notifications.}
	complaint_notifications=${4:# Setup the SNS topic used to report complaint notifications.}
	delivery_notifications=${5:# Setup the SNS topic used to report delivery notifications.}
	feedback_forwarding=${6:yes}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet s3_bucket "Manage S3 buckets in AWS, DigitalOcean, Ceph, Walrus and FakeS3" b
s3_bucket: >
	name=${1:# Name of the s3 bucket}

	force=${2:no}
	policy=${3:# The JSON policy as a string.}
	s3_url=${4:# S3 URL endpoint for usage with DigitalOcean, Ceph, Eucalyptus and fakes3 etc.}
	ceph=${5:# Enable API compatibility with Ceph. It takes into account the S3 API subset working with Ceph in order to provide the same module behaviour where possible.}
	requester_pays=${6:no}
	state=${7:#present|absent}
	tags=${8:# tags dict to apply to bucket}
	purge_tags=${9:yes}
	versioning=${10:# Whether versioning is enabled or disabled (note that once versioning is enabled, it can only be suspended)}
	encryption=${11:none|AES256|aws:kms}
	encryption_key_id=${12:# K}
	debug_botocore_endpoint_logs=${13:no}
	ec2_url=${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${15:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${16:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${17:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${18:yes}
	profile=${19:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${20:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudfront_invalidation "create invalidations for aws cloudfront distributions" b
cloudfront_invalidation: >
	target_paths=${1:# A list of paths on the distribution to invalidate. Each path should begin with '/'. Wildcards are allowed. eg. '/foo/bar/*'}

	distribution_id=${2:# The id of the cloudfront distribution to invalidate paths for. Can be specified instead of the alias.}
	alias=${3:# The alias of the cloudfront distribution to invalidate paths for. Can be specified instead of distribution_id.}
	caller_reference=${4:current datetime stamp}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_target_group_info "Gather information about ELB target groups in AWS" b
elb_target_group_info: >
	load_balancer_arn=${1:# The Amazon Resource Name (ARN) of the load balancer.}
	target_group_arns=${2:# The Amazon Resource Names (ARN) of the target groups.}
	names=${3:# The names of the target groups.}
	collect_targets_health=${4:no}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam "Manage IAM users, groups, roles and keys" b
iam: >
	name=${1:# Name of IAM resource to create or identify}
	state=${2:present|absent|update}

	iam_type=${3:user|group|role}
	new_name=${4:# When state is update, will replace name with new_name on IAM resource}
	new_path=${5:# When state is update, will replace the path with new_path on the IAM resource}
	path=${6:/}
	trust_policy=${7:# The inline (JSON or YAML) trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy_filepath).}
	trust_policy_filepath=${8:# The path to the trust policy document that grants an entity permission to assume the role. Mutually exclusive with C(trust_policy).}
	access_key_state=${9:create|remove|active|inactive|Create|Remove|Active|Inactive}
	key_count=${10:1}
	access_key_ids=${11:# A list of the keys that you want impacted by the access_key_state parameter.}
	groups=${12:# A list of groups the user should belong to. When update, will gracefully remove groups not listed.}
	password=${13:# When type is user and state is present, define the users login password. Also works with update. Note that always returns changed.}
	update_password=${14:#always|on_create}
	debug_botocore_endpoint_logs=${15:no}
	ec2_url=${16:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${17:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${18:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${19:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${20:yes}
	profile=${21:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${22:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_eni_info "Gather information about ec2 ENI interfaces in AWS" b
ec2_eni_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html) for possible filters.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_vpn_info "Gather information about VPN Connections in AWS." b
ec2_vpc_vpn_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpnConnections.html) for possible filters.}
	vpn_connection_ids=${2:# Get details of a specific VPN connections using vpn connection ID/IDs. This value should be provided as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_application_lb_info "Gather information about application ELBs in AWS" b
elb_application_lb_info: >
	load_balancer_arns=${1:# The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load balancers in a single call.}
	names=${2:# The names of the load balancers.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_kms_info "Gather information about AWS KMS keys" b
aws_kms_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. The filters aren't natively supported by boto3, but are supported to provide similar functionality to other modules. Standard tag filters (C(tag-key), C(tag-value) and C(tag:tagName)) are available, as are C(key-id) and C(alias)}
	pending_deletion=${2:no}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_peer "create, delete, accept, and reject VPC peering connections between two VPCs." b
ec2_vpc_peer: >
	vpc_id=${1:# VPC id of the requesting VPC.}
	peering_id=${2:# Peering connection id.}
	peer_region=${3:# Region of the accepting VPC.}
	peer_vpc_id=${4:# VPC id of the accepting VPC.}
	peer_owner_id=${5:# The AWS account number for cross account peering.}
	tags=${6:# Dictionary of tags to look for and apply when creating a Peering Connection.}
	state=${7:#present|absent|accept|reject}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_ses_rule_set "Manages SES inbound receipt rule sets" b
aws_ses_rule_set: >
	name=${1:# The name of the receipt rule set.}

	state=${2:absent|#present}
	active=${3:# Whether or not this rule set should be the active rule set. Only has an impact if I(state) is C(present).}
	force=${4:no}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_asg_info "Gather information about ec2 Auto Scaling Groups (ASGs) in AWS" b
ec2_asg_info: >
	name=${1:# The prefix or name of the auto scaling group(s) you are searching for.}
	tags=${2:# A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for.
}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_endpoint_info "Retrieves AWS VPC endpoints details using AWS methods." b
ec2_vpc_endpoint_info: >
	query=${1:services|endpoints}

	vpc_endpoint_ids=${2:# Get details of specific endpoint IDs}
	filters=${3:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html) for possible filters.}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_sgw_info "Fetch AWS Storage Gateway information" b
aws_sgw_info: >
	gather_local_disks=${1:yes}
	gather_tapes=${2:yes}
	gather_file_shares=${3:yes}
	gather_volumes=${4:yes}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_route_table_info "Gather information about ec2 VPC route tables in AWS" b
ec2_vpc_route_table_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_classic_lb_info "Gather information about EC2 Elastic Load Balancers in AWS" b
elb_classic_lb_info: >
	names=${1:# List of ELB names to gather information about. Pass this option to gather information about a set of ELBs, otherwise, all ELBs are returned.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_target_info "Gathers which target groups a target is associated with." b
elb_target_info: >
	instance_id=${1:# What instance ID to get information for.}

	get_unused_target_groups=${2:yes}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_application_lb_info "Gather information about application ELBs in AWS" b
elb_application_lb_info: >
	load_balancer_arns=${1:# The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load balancers in a single call.}
	names=${2:# The names of the load balancers.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_caller_info "Get information about the user and account being used to make AWS calls." b
aws_caller_info: >
	debug_botocore_endpoint_logs=${1:no}
	ec2_url=${2:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${6:yes}
	profile=${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_igw_info "Gather information about internet gateways in AWS" b
ec2_vpc_igw_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInternetGateways.html) for possible filters.}
	internet_gateway_ids=${2:# Get details of specific Internet Gateway ID. Provide this value as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_region_info "Gather information about AWS regions." b
aws_region_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudformation "Create or delete an AWS CloudFormation stack" b
cloudformation: >
	stack_name=${1:# name of the cloudformation stack}

	disable_rollback=${2:no}
	on_create_failure=${3:DO_NOTHING|ROLLBACK|DELETE}
	create_timeout=${4:# The amount of time (in minutes) that can pass before the stack status becomes CREATE_FAILED}
	template_parameters=${5:{}}
	state=${6:#present|absent}
	template=${7:# The local path of the cloudformation template.}
	notification_arns=${8:# The Simple Notification Service (SNS) topic ARNs to publish stack related events.}
	stack_policy=${9:# the path of the cloudformation stack policy. A policy cannot be removed once placed, but it can be modified. for instance, allow all updates U(https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/protect-stack-resources.html#d0e9051)}
	tags=${10:# Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries.}
	template_url=${11:# Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.}
	create_changeset=${12:no}
	changeset_name=${13:# Name given to the changeset when creating a changeset, only used when create_changeset is true. By default a name prefixed with Ansible-STACKNAME is generated based on input parameters. See the AWS Change Sets docs U(https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html)}
	template_format=${14:#json|yaml}
	role_arn=${15:# The role that AWS CloudFormation assumes to create the stack. See the AWS CloudFormation Service Role docs U(https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-iam-servicerole.html)}
	termination_protection=${16:# enable or disable termination protection on the stack. Only works with botocore >= 1.7.18.}
	template_body=${17:# Template body. Use this to pass in the actual body of the Cloudformation template.}
	events_limit=${18:200}
	backoff_delay=${19:3}
	backoff_max_delay=${20:30}
	backoff_retries=${21:10}
	capabilities=${22:['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM']}
	debug_botocore_endpoint_logs=${23:no}
	ec2_url=${24:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${25:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${26:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${27:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${28:yes}
	profile=${29:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${30:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet dms_endpoint "creates or destroys a data migration services endpoint" b
dms_endpoint: >
	state=${1:#present|absent}
	endpointidentifier=${2:# An identifier name for the endpoint}
	endpointtype=${3:source|target}
	enginename=${4:mysql|oracle|postgres|mariadb|aurora|redshift|s3|db2|azuredb|sybase|dynamodb|mongodb|sqlserver}
	username=${5:# Username our endpoint will use to connect to the database}
	password=${6:# Password used to connect to the database this attribute can only be written the AWS API does not return this parameter}
	servername=${7:# Servername that the endpoint will connect to}
	port=${8:# TCP port for access to the database}
	databasename=${9:# Name for the database on the origin or target side}
	extraconnectionattributes=${10:# Extra attributes for the database connection, the AWS documentation states " For more information about extra connection attributes, see the documentation section for your data store."}
	kmskeyid=${11:# Encryption key to use to encrypt replication storage and connection information}
	tags=${12:# A list of tags to add to the endpoint}
	certificatearn=${13:# Amazon Resource Name (ARN) for the certificate}
	sslmode=${14:#none|require|verify-ca|verify-full}
	serviceaccessrolearn=${15:# Amazon Resource Name (ARN) for the service access role that you want to use to create the endpoint.}
	externaltabledefinition=${16:# The external table definition}
	dynamodbsettings=${17:# Settings in JSON format for the target Amazon DynamoDB endpoint if source or target is dynamodb}
	s3settings=${18:# S3 buckets settings for the target Amazon S3 endpoint.}
	dmstransfersettings=${19:# The settings in JSON format for the DMS transfer type of source endpoint}
	mongodbsettings=${20:# Settings in JSON format for the source MongoDB endpoint}
	kinesissettings=${21:# Settings in JSON format for the target Amazon Kinesis Data Streams endpoint}
	elasticsearchsettings=${22:# Settings in JSON format for the target Elasticsearch endpoint}
	wait=${23:false}
	timeout=${24:# time in seconds we should wait for when deleting a resource}
	retries=${25:# number of times we should retry when deleting a resource}
	region=${26:# aws region, should be read from the running aws config}
	ec2_region=${27:# alias for region}
	aws_region=${28:# alias for region}
	debug_botocore_endpoint_logs=${29:no}
	ec2_url=${30:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${31:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${32:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${33:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${34:yes}
	profile=${35:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet lambda "Manage AWS Lambda functions" b
lambda: >
	name=${1:# The name you want to assign to the function you are uploading. Cannot be changed.}

	state=${2:#present|absent}
	runtime=${3:# The runtime environment for the Lambda function you are uploading.}
	role=${4:# The Amazon Resource Name (ARN) of the IAM role that Lambda assumes when it executes your function to access any other Amazon Web Services (AWS) resources. You may use the bare ARN if the role belongs to the same AWS account.}
	handler=${5:# The function within your code that Lambda calls to begin execution.}
	zip_file=${6:# A .zip file containing your deployment package}
	s3_bucket=${7:# Amazon S3 bucket name where the .zip file containing your deployment package is stored.}
	s3_key=${8:# The Amazon S3 object (the deployment package) key name you want to upload.}
	s3_object_version=${9:# The Amazon S3 object (the deployment package) version you want to upload.}
	description=${10:# A short, user-defined function description. Lambda does not use this value. Assign a meaningful description as you see fit.}
	timeout=${11:3}
	memory_size=${12:128}
	vpc_subnet_ids=${13:# List of subnet IDs to run Lambda function in. Use this option if you need to access resources in your VPC. Leave empty if you don't want to run the function in a VPC.}
	vpc_security_group_ids=${14:# List of VPC security group IDs to associate with the Lambda function. Required when vpc_subnet_ids is used.}
	environment_variables=${15:# A dictionary of environment variables the Lambda function is given.}
	dead_letter_arn=${16:# The parent object that contains the target Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.}
	tags=${17:# tag dict to apply to the function (requires botocore 1.5.40 or above).}
	debug_botocore_endpoint_logs=${18:no}
	ec2_url=${19:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${20:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${21:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${22:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${23:yes}
	profile=${24:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${25:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_instance_info "Gather information about ec2 instances in AWS" b
ec2_instance_info: >
	instance_ids=${1:# If you specify one or more instance IDs, only instances that have the specified IDs are returned.}
	filters=${2:{}}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet dynamodb_table "Create, update or delete AWS Dynamo DB tables." b
dynamodb_table: >
	name=${1:# Name of the table.}

	state=${2:#present|absent}
	hash_key_name=${3:# Name of the hash key.}
	hash_key_type=${4:#STRING|NUMBER|BINARY}
	range_key_name=${5:# Name of the range key.}
	range_key_type=${6:#STRING|NUMBER|BINARY}
	read_capacity=${7:1}
	write_capacity=${8:1}
	indexes=${9:[]}
	tags=${10:# a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'}
	wait_for_active_timeout=${11:60}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_elb_lb "Creates, updates or destroys an Amazon ELB." b
ec2_elb_lb: >
	state=${1:absent|present}
	name=${2:# The name of the ELB}

	listeners=${3:# List of ports/protocols for this ELB to listen on (see example)}
	purge_listeners=${4:yes}
	instance_ids=${5:# List of instance ids to attach to this ELB}
	purge_instance_ids=${6:no}
	zones=${7:# List of availability zones to enable on this ELB}
	purge_zones=${8:no}
	security_group_ids=${9:# A list of security groups to apply to the elb}
	security_group_names=${10:# A list of security group names to apply to the elb}
	health_check=${11:# An associative array of health check configuration settings (see example)}
	access_logs=${12:# An associative array of access logs configuration settings (see example)}
	subnets=${13:# A list of VPC subnets to use when creating ELB. Zones should be empty if using this.}
	purge_subnets=${14:no}
	scheme=${15:internal|#internet-facing}
	validate_certs=${16:yes}
	connection_draining_timeout=${17:# Wait a specified timeout allowing connections to drain before terminating an instance}
	idle_timeout=${18:# ELB connections from clients and to servers are timed out after this amount of time}
	cross_az_load_balancing=${19:no}
	stickiness=${20:# An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )}
	wait=${21:no}
	wait_timeout=${22:60}
	tags=${23:# An associative array of tags. To delete all tags, supply an empty dict.}
	debug_botocore_endpoint_logs=${24:no}
	ec2_url=${25:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${26:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${27:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${28:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	profile=${29:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${30:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_ecr "Manage Elastic Container Registry repositories" b
ecs_ecr: >
	name=${1:# the name of the repository}

	registry_id=${2:# AWS account id associated with the registry.}
	policy=${3:# JSON or dict that represents the new policy}
	force_set_policy=${4:no}
	delete_policy=${5:no}
	state=${6:#present|absent}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_role_info "Gather information on IAM roles" b
iam_role_info: >
	name=${1:# Name of a role to search for}
	path_prefix=${2:# Prefix of role I(path) to restrict IAM role search for}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_subnet "Manage subnets in AWS virtual private clouds" b
ec2_vpc_subnet: >
	vpc_id=${1:# VPC ID of the VPC in which to create or delete the subnet.}

	az=${2:# The availability zone for the subnet.}
	cidr=${3:# The CIDR block for the subnet. E.g. 192.0.2.0/24.}
	ipv6_cidr=${4:# The IPv6 CIDR block for the subnet. The VPC must have a /56 block assigned and this value must be a valid IPv6 /64 that falls in the VPC range.}
	tags=${5:# A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed.}
	state=${6:#present|absent}
	map_public=${7:no}
	assign_instances_ipv6=${8:no}
	wait=${9:yes}
	wait_timeout=${10:300}
	purge_tags=${11:yes}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet sts_session_token "Obtain a session token from the AWS Security Token Service" b
sts_session_token: >
	duration_seconds=${1:# The duration, in seconds, of the session token. See U(https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html#API_GetSessionToken_RequestParameters) for acceptable and default values.}
	mfa_serial_number=${2:# The identification number of the MFA device that is associated with the user who is making the GetSessionToken call.}
	mfa_token=${3:# The value provided by the MFA device, if the trust policy of the user requires MFA.}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_server_certificate_info "Retrieve the information of a server certificate" b
iam_server_certificate_info: >
	name=${1:# The name of the server certificate you are retrieving attributes for.}

	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudfront_info "Obtain facts about an AWS CloudFront distribution" b
cloudfront_info: >
	distribution_id=${1:# The id of the CloudFront distribution. Used with I(distribution), I(distribution_config), I(invalidation), I(streaming_distribution), I(streaming_distribution_config), I(list_invalidations).}
	invalidation_id=${2:# The id of the invalidation to get information about. Used with I(invalidation).}
	origin_access_identity_id=${3:# The id of the cloudfront origin access identity to get information about.}
	web_acl_id=${4:# Used with I(list_distributions_by_web_acl_id).}
	domain_name_alias=${5:# Can be used instead of I(distribution_id) - uses the aliased CNAME for the cloudfront distribution to get the distribution id where required.}
	all_lists=${6:no}
	origin_access_identity=${7:no}
	origin_access_identity_config=${8:no}
	distribution=${9:no}
	distribution_config=${10:no}
	invalidation=${11:no}
	streaming_distribution=${12:no}
	streaming_distribution_config=${13:no}
	list_origin_access_identities=${14:no}
	list_distributions=${15:no}
	list_distributions_by_web_acl_id=${16:no}
	list_invalidations=${17:no}
	list_streaming_distributions=${18:no}
	summary=${19:no}
	debug_botocore_endpoint_logs=${20:no}
	ec2_url=${21:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${22:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${23:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${24:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${25:yes}
	profile=${26:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${27:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudformation_info "Obtain information about an AWS CloudFormation stack" b
cloudformation_info: >
	stack_name=${1:# The name or id of the CloudFormation stack. Gathers information on all stacks by default.}
	all_facts=${2:no}
	stack_events=${3:no}
	stack_template=${4:no}
	stack_resources=${5:no}
	stack_policy=${6:no}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_taskdefinition "register a task definition in ecs" b
ecs_taskdefinition: >
	state=${1:present|absent}

	arn=${2:# The arn of the task description to delete}
	family=${3:# A Name that would be given to the task definition}
	revision=${4:# A revision number for the task definition}
	force_create=${5:# Always create new task definition}
	containers=${6:# A list of containers definitions}
	network_mode=${7:#bridge|host|none|awsvpc}
	task_role_arn=${8:# The Amazon Resource Name (ARN) of the IAM role that containers in this task can assume. All containers in this task are granted the permissions that are specified in this role.}
	execution_role_arn=${9:# The Amazon Resource Name (ARN) of the task execution role that the Amazon ECS container agent and the Docker daemon can assume.}
	volumes=${10:# A list of names of volumes to be attached}
	launch_type=${11:EC2|FARGATE}
	cpu=${12:# The number of cpu units used by the task. If using the EC2 launch type, this field is optional and any value can be used. If using the Fargate launch type, this field is required and you must use one of [256, 512, 1024, 2048, 4096]}
	memory=${13:# The amount (in MiB) of memory used by the task. If using the EC2 launch type, this field is optional and any value can be used. If using the Fargate launch type, this field is required and is limited by the cpu}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_customer_gateway_info "Gather information about customer gateways in AWS" b
ec2_customer_gateway_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCustomerGateways.html) for possible filters.}
	customer_gateway_ids=${2:# Get details of a specific customer gateways using customer gateway ID/IDs. This value should be provided as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet rds_instance "Manage RDS instances" b
rds_instance: >
	db_instance_identifier=${1:# The DB instance (lowercase) identifier. The identifier must contain from 1 to 63 letters, numbers, or hyphens and the first character must be a letter and may not end in a hyphen or contain consecutive hyphens.}

	state=${2:#present|absent|terminated|running|started|stopped|rebooted|restarted}
	creation_source=${3:snapshot|s3|instance}
	force_update_password=${4:no}
	purge_cloudwatch_logs_exports=${5:yes}
	purge_tags=${6:yes}
	read_replica=${7:# Set to False to promote a read replica cluster or true to create one. When creating a read replica C(creation_source) should be set to 'instance' or not provided. C(source_db_instance_identifier) must be provided with this option.}
	wait=${8:yes}
	allocated_storage=${9:# The amount of storage (in gibibytes) to allocate for the DB instance.}
	allow_major_version_upgrade=${10:# Whether to allow major version upgrades.}
	apply_immediately=${11:no}
	auto_minor_version_upgrade=${12:# Whether minor version upgrades are applied automatically to the DB instance during the maintenance window.}
	availability_zone=${13:# A list of EC2 Availability Zones that instances in the DB cluster can be created in. May be used when creating a cluster or when restoring from S3 or a snapshot. Mutually exclusive with I(multi_az).}
	backup_retention_period=${14:# The number of days for which automated backups are retained (must be greater or equal to 1). May be used when creating a new cluster, when restoring from S3, or when modifying a cluster.}
	ca_certificate_identifier=${15:# The identifier of the CA certificate for the DB instance.}
	character_set_name=${16:# The character set to associate with the DB cluster.}
	copy_tags_to_snapshot=${17:# Whether or not to copy all tags from the DB instance to snapshots of the instance. When initially creating a DB instance the RDS API defaults this to false if unspecified.}
	db_cluster_identifier=${18:# The DB cluster (lowercase) identifier to add the aurora DB instance to. The identifier must contain from 1 to 63 letters, numbers, or hyphens and the first character must be a letter and may not end in a hyphen or contain consecutive hyphens.}
	db_instance_class=${19:# The compute and memory capacity of the DB instance, for example db.t2.micro.}
	db_name=${20:# The name for your database. If a name is not provided Amazon RDS will not create a database.}
	db_parameter_group_name=${21:# The name of the DB parameter group to associate with this DB instance. When creating the DB instance if this argument is omitted the default DBParameterGroup for the specified engine is used.}
	db_security_groups=${22:# (EC2-Classic platform) A list of DB security groups to associate with this DB instance.}
	db_snapshot_identifier=${23:# The identifier for the DB snapshot to restore from if using I(creation_source=snapshot).}
	db_subnet_group_name=${24:# The DB subnet group name to use for the DB instance.}
	domain=${25:# The Active Directory Domain to restore the instance in.}
	domain_iam_role_name=${26:# The name of the IAM role to be used when making API calls to the Directory Service.}
	enable_cloudwatch_logs_exports=${27:# A list of log types that need to be enabled for exporting to CloudWatch Logs.}
	enable_iam_database_authentication=${28:# Enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. If this option is omitted when creating the cluster, Amazon RDS sets this to False.}
	enable_performance_insights=${29:# Whether to enable Performance Insights for the DB instance.}
	engine=${30:# The name of the database engine to be used for this DB instance. This is required to create an instance. Valid choices are aurora | aurora-mysql | aurora-postgresql | mariadb | mysql | oracle-ee | oracle-se | oracle-se1 | oracle-se2 | postgres | sqlserver-ee | sqlserver-ex | sqlserver-se | sqlserver-web}
	engine_version=${31:# The version number of the database engine to use. For Aurora MySQL that could be 5.6.10a , 5.7.12. Aurora PostgreSQL example, 9.6.3}
	final_db_snapshot_identifier=${32:# The DB instance snapshot identifier of the new DB instance snapshot created when I(skip_final_snapshot) is false.}
	force_failover=${33:# Set to true to conduct the reboot through a MultiAZ failover.}
	iops=${34:# The Provisioned IOPS (I/O operations per second) value. Is only set when using I(storage_type) is set to io1.}
	kms_key_id=${35:# The ARN of the AWS KMS key identifier for an encrypted DB instance. If you are creating a DB instance with the same AWS account that owns the KMS encryption key used to encrypt the new DB instance, then you can use the KMS key alias instead of the ARN for the KM encryption key.}
	license_model=${36:# The license model for the DB instance.}
	master_user_password=${37:# An 8-41 character password for the master database user. The password can contain any printable ASCII character except "/", """, or "@". To modify the password use I(force_password_update). Use I(apply immediately) to change the password immediately, otherwise it is updated during the next maintenance window.}
	master_username=${38:# The name of the master user for the DB cluster. Must be 1-16 letters or numbers and begin with a letter.}
	max_allocated_storage=${39:# The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.}
	monitoring_interval=${40:# The interval, in seconds, when Enhanced Monitoring metrics are collected for the DB instance. To disable collecting metrics, specify 0. Amazon RDS defaults this to 0 if omitted when initially creating a DB instance.}
	monitoring_role_arn=${41:# The ARN for the IAM role that permits RDS to send enhanced monitoring metrics to Amazon CloudWatch Logs.}
	multi_az=${42:# Specifies if the DB instance is a Multi-AZ deployment. Mutually exclusive with I(availability_zone).}
	new_db_instance_identifier=${43:# The new DB cluster (lowercase) identifier for the DB cluster when renaming a DB instance. The identifier must contain from 1 to 63 letters, numbers, or hyphens and the first character must be a letter and may not end in a hyphen or contain consecutive hyphens. Use I(apply_immediately) to rename immediately, otherwise it is updated during the next maintenance window.}
	option_group_name=${44:# The option group to associate with the DB instance.}
	performance_insights_kms_key_id=${45:# The AWS KMS key identifier (ARN, name, or alias) for encryption of Performance Insights data.}
	performance_insights_retention_period=${46:# The amount of time, in days, to retain Performance Insights data. Valid values are 7 or 731.}
	port=${47:# The port number on which the instances accept connections.}
	preferred_backup_window=${48:# The daily time range (in UTC) of at least 30 minutes, during which automated backups are created if automated backups are enabled using I(backup_retention_period). The option must be in the format of "hh24:mi-hh24:mi" and not conflict with I(preferred_maintenance_window).}
	preferred_maintenance_window=${49:# The weekly time range (in UTC) of at least 30 minutes, during which system maintenance can occur. The option must be in the format "ddd:hh24:mi-ddd:hh24:mi" where ddd is one of Mon, Tue, Wed, Thu, Fri, Sat, Sun.}
	processor_features=${50:# A dictionary of Name, Value pairs to indicate the number of CPU cores and the number of threads per core for the DB instance class of the DB instance. Names are threadsPerCore and coreCount. Set this option to an empty dictionary to use the default processor features.}
	promotion_tier=${51:# An integer that specifies the order in which an Aurora Replica is promoted to the primary instance after a failure of the existing primary instance.}
	publicly_accessible=${52:# Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.}
	restore_time=${53:# If using I(creation_source=instance) this indicates the UTC date and time to restore from the source instance. For example, "2009-09-07T23:45:00Z". May alternatively set c(use_latest_restore_time) to True.}
	s3_bucket_name=${54:# The name of the Amazon S3 bucket that contains the data used to create the Amazon DB instance.}
	s3_ingestion_role_arn=${55:# The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon RDS to access the Amazon S3 bucket on your behalf.}
	s3_prefix=${56:# The prefix for all of the file names that contain the data used to create the Amazon DB instance. If you do not specify a SourceS3Prefix value, then the Amazon DB instance is created by using all of the files in the Amazon S3 bucket.}
	skip_final_snapshot=${57:no}
	snapshot_identifier=${58:# The ARN of the DB snapshot to restore from when using I(creation_source=snapshot).}
	source_db_instance_identifier=${59:# The identifier or ARN of the source DB instance from which to restore when creating a read replica or spinning up a point-in-time DB instance using I(creation_source=instance). If the source DB is not in the same region this should be an ARN.}
	source_engine=${60:mysql}
	source_engine_version=${61:# The version of the database that the backup files were created from.}
	source_region=${62:# The region of the DB instance from which the replica is created.}
	storage_encrypted=${63:# Whether the DB instance is encrypted.}
	storage_type=${64:standard|gp2|io1}
	tags=${65:# A dictionary of key value pairs to assign the DB cluster.}
	tde_credential_arn=${66:# The ARN from the key store with which to associate the instance for Transparent Data Encryption. This is supported by Oracle or SQL Server DB instances and may be used in conjunction with C(storage_encrypted) though it might slightly affect the performance of your database.}
	tde_credential_password=${67:# The password for the given ARN from the key store in order to access the device.}
	timezone=${68:# The time zone of the DB instance.}
	use_latest_restorable_time=${69:# Whether to restore the DB instance to the latest restorable backup time. Only one of I(use_latest_restorable_time) and I(restore_to_time) may be provided.}
	vpc_security_group_ids=${70:# A list of EC2 VPC security groups to associate with the DB cluster.}
	debug_botocore_endpoint_logs=${71:no}
	ec2_url=${72:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${73:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${74:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${75:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${76:yes}
	profile=${77:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${78:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_snapshot_info "Gather information about ec2 volume snapshots in AWS" b
ec2_snapshot_info: >
	snapshot_ids=${1:[]}
	owner_ids=${2:[]}
	restorable_by_user_ids=${3:[]}
	filters=${4:{}}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_vgw "Create and delete AWS VPN Virtual Gateways." b
ec2_vpc_vgw: >
	state=${1:#present|absent}
	name=${2:# name of the vgw to be created or deleted}
	type=${3:ipsec.1}
	vpn_gateway_id=${4:# vpn gateway id of an existing virtual gateway}
	vpc_id=${5:# the vpc-id of a vpc to attach or detach}
	asn=${6:# the BGP ASN of the amazon side}
	wait_timeout=${7:320}
	tags=${8:# dictionary of resource tags}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet aws_s3_bucket_info "Lists S3 buckets in AWS" b
aws_s3_bucket_info: >
	debug_botocore_endpoint_logs=${1:no}
	ec2_url=${2:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${6:yes}
	profile=${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_dhcp_option "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested" b
ec2_vpc_dhcp_option: >
	domain_name=${1:# The domain name to set in the DHCP option sets}
	dns_servers=${2:# A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)}
	ntp_servers=${3:# List of hosts to advertise as NTP servers for the VPC.}
	netbios_name_servers=${4:# List of hosts to advertise as NetBIOS servers.}
	netbios_node_type=${5:# NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) U(https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html)}
	vpc_id=${6:# VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.}
	delete_old=${7:yes}
	inherit_existing=${8:no}
	tags=${9:# Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)}
	dhcp_options_id=${10:# The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)}
	state=${11:absent|#present}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet lightsail "Create or delete a virtual machine instance in AWS Lightsail" b
lightsail: >
	name=${1:# Name of the instance}

	state=${2:#present|absent|running|restarted|stopped}
	zone=${3:# AWS availability zone in which to launch the instance. Required when state='present'}
	blueprint_id=${4:# ID of the instance blueprint image. Required when state='present'}
	bundle_id=${5:# Bundle of specification info for the instance. Required when state='present'}
	user_data=${6:# Launch script that can configure the instance with additional data}
	key_pair_name=${7:# Name of the key pair to use with the instance}
	wait=${8:yes}
	wait_timeout=${9:300}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_netapp_cvs_FileSystems "NetApp AWS Cloud Volumes Service Manage FileSystem." b
aws_netapp_cvs_FileSystems: >
	state=${1:present|absent}
	region=${2:# The region to which the filesystem belongs to.}
	creationToken=${3:# Name of the filesystem}
	api_key=${4:# The access key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	secret_key=${5:# The secret_key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	api_url=${6:# The url to the AWSCVS Web Services Proxy or Embedded Web Services API.}

	quotaInBytes=${7:# Size of the filesystem}
	serviceLevel=${8:standard|premium|extreme}
	exportPolicy=${9:# The policy rules to export the filesystem}
	validate_certs=${10:yes}

endsnippet

snippet cloudwatchlogs_log_group_info "get information about log_group in CloudWatchLogs" b
cloudwatchlogs_log_group_info: >
	log_group_name=${1:# The name or prefix of the log group to filter by.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet s3_bucket_notification "Creates, updates or deletes S3 Bucket notification for lambda" b
s3_bucket_notification: >
	event_name=${1:# unique name for event notification on bucket}
	bucket_name=${2:# S3 bucket name}
	state=${3:#present|absent}
	events=${4:s3:ObjectCreated:*|s3:ObjectCreated:Put|s3:ObjectCreated:Post|s3:ObjectCreated:Copy|s3:ObjectCreated:CompleteMultipartUpload|s3:ObjectRemoved:*|s3:ObjectRemoved:Delete|s3:ObjectRemoved:DeleteMarkerCreated|s3:ObjectRestore:Post|s3:ObjectRestore:Completed|s3:ReducedRedundancyLostObject}

	lambda_function_arn=${5:# The ARN of the lambda function.}
	lambda_alias=${6:# Name of the Lambda function alias. Mutually exclusive with C(lambda_version).}
	lambda_version=${7:# Version of the Lambda function. Mutually exclusive with C(lambda_alias).}
	prefix=${8:# Optional prefix to limit the notifications to objects with keys that start with matching characters.}
	suffix=${9:# Optional suffix to limit the notifications to objects with keys that end with matching characters.}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_scaling_policy "Create or delete AWS scaling policies for Autoscaling groups" b
ec2_scaling_policy: >
	state=${1:present|absent}
	name=${2:# Unique name for the scaling policy}
	asg_name=${3:# Name of the associated autoscaling group}

	adjustment_type=${4:ChangeInCapacity|ExactCapacity|PercentChangeInCapacity}
	scaling_adjustment=${5:# The amount by which the autoscaling group is adjusted by the policy}
	min_adjustment_step=${6:# Minimum amount of adjustment when policy is triggered}
	cooldown=${7:# The minimum period of time between which autoscaling actions can take place}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_managed_policy "Manage User Managed IAM policies" b
iam_managed_policy: >
	policy_name=${1:# The name of the managed policy.}

	policy_description=${2:}
	policy=${3:# A properly json formatted policy}
	make_default=${4:yes}
	only_version=${5:no}
	state=${6:#present|absent}
	fail_on_delete=${7:# The I(fail_on_delete) option does nothing.}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_group_info "Gather information about ec2 security groups in AWS." b
ec2_group_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_waf_rule "create and delete WAF Rules" b
aws_waf_rule: >
	name=${1:# N}

	metric_name=${2:# A friendly name or description for the metrics for the rule}
	state=${3:#present|absent}
	conditions=${4:# l}
	purge_conditions=${5:no}
	waf_regional=${6:no}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_attribute "manage ecs attributes" b
ecs_attribute: >
	cluster=${1:# The short name or full Amazon Resource Name (ARN) of the cluster that contains the resource to apply attributes.}
	attributes=${2:# List of attributes.}
	ec2_instance_id=${3:# EC2 instance ID of ECS cluster container instance.}

	state=${4:#present|absent}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_batch_job_definition "Manage AWS Batch Job Definitions" b
aws_batch_job_definition: >
	job_definition_name=${1:# The name for the job definition}
	type=${2:# The type of job definition}

	job_definition_arn=${3:# The arn for the job definition}
	state=${4:#present|absent}
	parameters=${5:# Default parameter substitution placeholders to set in the job definition. Parameters are specified as a key-value pair mapping. Parameters in a SubmitJob request override any corresponding parameter defaults from the job definition.}
	image=${6:# The image used to start a container. This string is passed directly to the Docker daemon. Images in the Docker Hub registry are available by default. Other repositories are specified with `` repository-url /image <colon>tag ``. Up to 255 letters (uppercase and lowercase), numbers, hyphens, underscores, colons, periods, forward slashes, and number signs are allowed. This parameter maps to Image in the Create a container section of the Docker Remote API and the IMAGE parameter of docker run.}
	vcpus=${7:# The number of vCPUs reserved for the container. This parameter maps to CpuShares in the Create a container section of the Docker Remote API and the --cpu-shares option to docker run. Each vCPU is equivalent to 1,024 CPU shares.}
	memory=${8:# The hard limit (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed. This parameter maps to Memory in the Create a container section of the Docker Remote API and the --memory option to docker run.}
	command=${9:# The command that is passed to the container. This parameter maps to Cmd in the Create a container section of the Docker Remote API and the COMMAND parameter to docker run. For more information, see https://docs.docker.com/engine/reference/builder/#cmd.}
	job_role_arn=${10:# The Amazon Resource Name (ARN) of the IAM role that the container can assume for AWS permissions.}
	volumes=${11:# A list of data volumes used in a job. List of dictionaries.}
	environment=${12:# The environment variables to pass to a container. This parameter maps to Env in the Create a container section of the Docker Remote API and the --env option to docker run. List of dictionaries.}
	mount_points=${13:# The mount points for data volumes in your container. This parameter maps to Volumes in the Create a container section of the Docker Remote API and the --volume option to docker run. List of dictionaries.}
	readonly_root_filesystem=${14:# When this parameter is true, the container is given read-only access to its root file system. This parameter maps to ReadonlyRootfs in the Create a container section of the Docker Remote API and the --read-only option to docker run.}
	privileged=${15:# When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). This parameter maps to Privileged in the Create a container section of the Docker Remote API and the --privileged option to docker run.}
	ulimits=${16:# A list of ulimits to set in the container. This parameter maps to Ulimits in the Create a container section of the Docker Remote API and the --ulimit option to docker run. List of dictionaries.}
	user=${17:# The user name to use inside the container. This parameter maps to User in the Create a container section of the Docker Remote API and the --user option to docker run.}
	attempts=${18:# Retry strategy - The number of times to move a job to the RUNNABLE status. You may specify between 1 and 10 attempts. If attempts is greater than one, the job is retried if it fails until it has moved to RUNNABLE that many times.}
	debug_botocore_endpoint_logs=${19:no}
	ec2_url=${20:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${21:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${22:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${23:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${24:yes}
	profile=${25:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${26:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_transit_gateway_info "Gather information about ec2 transit gateways in AWS" b
ec2_transit_gateway_info: >
	transit_gateway_ids=${1:# A list of transit gateway IDs to gather information for.}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeTransitGateways.html) for filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_service "create, terminate, start or stop a service in ecs" b
ecs_service: >
	state=${1:present|absent|deleting}
	name=${2:# The name of the service}

	cluster=${3:# The name of the cluster in which the service exists}
	task_definition=${4:# The task definition the service will run. This parameter is required when state=present}
	load_balancers=${5:# The list of ELBs defined for this service}
	desired_count=${6:# The count of how many instances of the service. This parameter is required when state=present}
	client_token=${7:# Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.}
	role=${8:# The name or full Amazon Resource Name (ARN) of the IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service, in a network mode other than `awsvpc`.}
	delay=${9:10}
	repeat=${10:10}
	force_new_deployment=${11:# Force deployment of service even if there are no changes}
	deployment_configuration=${12:# Optional parameters that control the deployment_configuration; format is '{"maximum_percent":<integer>, "minimum_healthy_percent":<integer>}}
	placement_constraints=${13:# The placement constraints for the tasks in the service}
	placement_strategy=${14:# The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules per service}
	network_configuration=${15:# network configuration of the service. Only applicable for task definitions created with C(awsvpc) I(network_mode).}
	launch_type=${16:EC2|FARGATE}
	health_check_grace_period_seconds=${17:# Seconds to wait before health checking the freshly added/updated services. This option requires botocore >= 1.8.20.}
	service_registries=${18:# describes service discovery registries this service will register with.}
	scheduling_strategy=${19:DAEMON|REPLICA}
	debug_botocore_endpoint_logs=${20:no}
	ec2_url=${21:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${22:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${23:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${24:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${25:yes}
	profile=${26:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${27:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_nacl_info "Gather information about Network ACLs in an AWS VPC" b
ec2_vpc_nacl_info: >
	nacl_ids=${1:[]}
	filters=${2:{}}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_vgw_info "Gather information about virtual gateways in AWS" b
ec2_vpc_vgw_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
	vpn_gateway_ids=${2:# Get details of a specific Virtual Gateway ID. This value should be provided as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_ses_identity_policy "Manages SES sending authorization policies" b
aws_ses_identity_policy: >
	identity=${1:# T}
	policy_name=${2:# T}

	policy=${3:# A}
	state=${4:#present|absent}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet sqs_queue "Creates or deletes AWS SQS queues." b
sqs_queue: >
	name=${1:# Name of the queue.}

	state=${2:#present|absent}
	default_visibility_timeout=${3:# The default visibility timeout in seconds.}
	message_retention_period=${4:# The message retention period in seconds.}
	maximum_message_size=${5:# The maximum message size in bytes.}
	delivery_delay=${6:# The delivery delay in seconds.}
	receive_message_wait_time=${7:# The receive message wait time in seconds.}
	policy=${8:# The json dict policy to attach to queue}
	redrive_policy=${9:# json dict with the redrive_policy (see example)}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_vpn "Create, modify, and delete EC2 VPN connections." b
ec2_vpc_vpn: >
	state=${1:#present|absent}
	customer_gateway_id=${2:# The ID of the customer gateway.}
	connection_type=${3:#ipsec.1}
	vpn_gateway_id=${4:# The ID of the virtual private gateway.}
	vpn_connection_id=${5:# The ID of the VPN connection. Required to modify or delete a connection if the filters option does not provide a unique match.}
	tags=${6:# Tags to attach to the VPN connection.}
	purge_tags=${7:no}
	static_only=${8:no}
	tunnel_options=${9:# An optional list object containing no more than two dict members, each of which may contain 'TunnelInsideCidr' and/or 'PreSharedKey' keys with appropriate string values.  AWS defaults will apply in absence of either of the aforementioned keys.}
	filters=${10:# An alternative to using vpn_connection_id. If multiple matches are found, vpn_connection_id is required. If one of the following suboptions is a list of items to filter by, only one item needs to match to find the VPN that correlates. e.g. if the filter 'cidr' is ['194.168.2.0/24', '192.168.2.0/24'] and the VPN route only has the destination cidr block of '192.168.2.0/24' it will be found with this filter (assuming there are not multiple VPNs that are matched). Another example, if the filter 'vpn' is equal to ['vpn-ccf7e7ad', 'vpn-cb0ae2a2'] and one of of the VPNs has the state deleted (exists but is unmodifiable) and the other exists and is not deleted, it will be found via this filter. See examples.}
	routes=${11:# Routes to add to the connection.}
	purge_routes=${12:# Whether or not to delete VPN connections routes that are not specified in the task.}
	wait_timeout=${13:600}
	delay=${14:15}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
	debug_botocore_endpoint_logs=${16:no}
	ec2_url=${17:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${18:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${19:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${20:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${21:yes}
	profile=${22:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet iam_server_certificate_info "Retrieve the information of a server certificate" b
iam_server_certificate_info: >
	name=${1:# The name of the server certificate you are retrieving attributes for.}

	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_dhcp_option_info "Gather information about dhcp options sets in AWS" b
ec2_vpc_dhcp_option_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeDhcpOptions.html) for possible filters.}
	dhcp_options_ids=${2:# Get details of specific DHCP Option ID}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_snapshot_info "Gather information about ec2 volume snapshots in AWS" b
ec2_snapshot_info: >
	snapshot_ids=${1:[]}
	owner_ids=${2:[]}
	restorable_by_user_ids=${3:[]}
	filters=${4:{}}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_placement_group_info "List EC2 Placement Group(s) details" b
ec2_placement_group_info: >
	names=${1:[]}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_direct_connect_connection "Creates, deletes, modifies a DirectConnect connection" b
aws_direct_connect_connection: >
	state=${1:present|absent}
	name=${2:# The name of the Direct Connect connection. This is required to create a new connection. To recreate or delete a connection I(name) or I(connection_id) is required.}
	connection_id=${3:# The ID of the Direct Connect connection. I(name) or I(connection_id) is required to recreate or delete a connection. Modifying attributes of a connection with I(forced_update) will result in a new Direct Connect connection ID.}
	location=${4:# Where the Direct Connect connection is located. Required when I(state=present).}
	bandwidth=${5:1Gbps|10Gbps}
	link_aggregation_group=${6:# The ID of the link aggregation group you want to associate with the connection. This is optional in case a stand-alone connection is desired.}
	forced_update=${7:# To modify bandwidth or location the connection will need to be deleted and recreated. By default this will not happen - this option must be set to True.}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_instance_info "Gather information about ec2 instances in AWS" b
ec2_instance_info: >
	instance_ids=${1:# If you specify one or more instance IDs, only instances that have the specified IDs are returned.}
	filters=${2:{}}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elasticache_parameter_group "Manage cache security groups in Amazon Elasticache." b
elasticache_parameter_group: >
	name=${1:# A user-specified name for the cache parameter group.}
	state=${2:present|absent|reset}

	group_family=${3:memcached1.4|memcached1.5|redis2.6|redis2.8|redis3.2|redis4.0|redis5.0}
	description=${4:# A user-specified description for the cache parameter group.}
	values=${5:# A user-specified dictionary of parameters to reset or modify for the cache parameter group.}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_batch_job_queue "Manage AWS Batch Job Queues" b
aws_batch_job_queue: >
	job_queue_name=${1:# The name for the job queue}
	priority=${2:# The priority of the job queue. Job queues with a higher priority (or a lower integer value for the priority parameter) are evaluated first when associated with same compute environment. Priority is determined in ascending order, for example, a job queue with a priority value of 1 is given scheduling preference over a job queue with a priority value of 10.}
	compute_environment_order=${3:# The set of compute environments mapped to a job queue and their order relative to each other. The job scheduler uses this parameter to determine which compute environment should execute a given job. Compute environments must be in the VALID state before you can associate them with a job queue. You can associate up to 3 compute environments with a job queue.}

	state=${4:#present|absent}
	job_queue_state=${5:#ENABLED|DISABLED}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_config_aggregation_authorization "Manage cross-account AWS Config authorizations" b
aws_config_aggregation_authorization: >
	state=${1:#present|absent}
	authorized_account_id=${2:# The 12-digit account ID of the account authorized to aggregate data.}
	authorized_aws_region=${3:# The region authorized to collect aggregated data.}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_user "Manage AWS IAM users" b
iam_user: >
	name=${1:# The name of the user to create.}
	state=${2:present|absent}

	managed_policy=${3:# A list of managed policy ARNs or friendly names to attach to the user. To embed an inline policy, use M(iam_policy).}
	purge_policy=${4:no}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_taskdefinition_info "describe a task definition in ecs" b
ecs_taskdefinition_info: >
	task_definition=${1:# The name of the task definition to get details for}

	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_direct_connect_virtual_interface "Manage Direct Connect virtual interfaces." b
aws_direct_connect_virtual_interface: >
	state=${1:present|absent}
	id_to_associate=${2:# The ID of the link aggregation group or connection to associate with the virtual interface.}
	public=${3:# The type of virtual interface.}
	name=${4:# The name of the virtual interface.}
	vlan=${5:100}
	bgp_asn=${6:65000}
	authentication_key=${7:# The authentication key for BGP configuration.}
	amazon_address=${8:# The amazon address CIDR with which to create the virtual interface.}
	customer_address=${9:# The customer address CIDR with which to create the virtual interface.}
	address_type=${10:# The type of IP address for the BGP peer.}
	cidr=${11:# A list of route filter prefix CIDRs with which to create the public virtual interface.}
	virtual_gateway_id=${12:# The virtual gateway ID required for creating a private virtual interface.}
	virtual_interface_id=${13:# The virtual interface ID.}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet efs_info "Get information about Amazon EFS file systems" b
efs_info: >
	name=${1:# Creation Token of Amazon EFS file system.}
	id=${2:# ID of Amazon EFS.}
	tags=${3:# List of tags of Amazon EFS. Should be defined as dictionary.}
	targets=${4:# List of targets on which to filter the returned results.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_s3_bucket_info "Lists S3 buckets in AWS" b
aws_s3_bucket_info: >
	debug_botocore_endpoint_logs=${1:no}
	ec2_url=${2:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${3:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${4:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${5:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${6:yes}
	profile=${7:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${8:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_netapp_cvs_active_directory "NetApp AWS CloudVolumes Service Manage Active Directory." b
aws_netapp_cvs_active_directory: >
	state=${1:present|absent}
	region=${2:# The region to which the Active Directory credentials are associated.}
	domain=${3:# Name of the Active Directory domain}
	api_key=${4:# The access key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	secret_key=${5:# The secret_key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	api_url=${6:# The url to the AWSCVS Web Services Proxy or Embedded Web Services API.}

	DNS=${7:# DNS server address for the Active Directory domain}
	netBIOS=${8:# NetBIOS name of the server.}
	username=${9:# Username of the Active Directory domain administrator}
	password=${10:# Password of the Active Directory domain administrator}
	validate_certs=${11:yes}

endsnippet

snippet cloudfront_origin_access_identity "create, update and delete origin access identities for a cloudfront distribution." b
cloudfront_origin_access_identity: >
	state=${1:present|absent}
	origin_access_identity_id=${2:# The origin_access_identity_id of the cloudfront distribution.}
	comment=${3:# A comment to describe the cloudfront origin access identity.}
	caller_reference=${4:# A unique identifier to reference the origin access identity by.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_az_info "Gather information about availability zones in AWS." b
aws_az_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_target_info "Gathers which target groups a target is associated with." b
elb_target_info: >
	instance_id=${1:# What instance ID to get information for.}

	get_unused_target_groups=${2:yes}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_s3 "manage objects in S3." b
aws_s3: >
	bucket=${1:# Bucket name.}
	mode=${2:get|put|delete|create|geturl|getstr|delobj|list}

	aws_access_key=${3:# AWS access key id. If not set then the value of the AWS_ACCESS_KEY environment variable is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.}
	dest=${5:# The destination file path when downloading an object/key with a GET operation.}
	encrypt=${6:yes}
	encryption_mode=${7:#AES256|aws:kms}
	expiration=${8:600}
	headers=${9:# Custom headers for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
	marker=${10:# Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.}
	max_keys=${11:1000}
	metadata=${12:# Metadata for PUT operation, as a dictionary of 'key=value' and 'key=value,key=value'.}
	object=${13:# Keyname of the object inside the bucket. Can be used to create "virtual directories", see examples.}
	permission=${14:private}
	prefix=${15:}
	version=${16:# Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.}
	overwrite=${17:always}
	region=${18:# AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file. If none of those are set the region defaults to the S3 Location: US Standard. Prior to ansible 1.8 this parameter could be specified but had no effect.}
	retries=${19:0}
	s3_url=${20:# S3 URL endpoint for usage with Ceph, Eucalyptus and fakes3 etc. Otherwise assumes AWS.}
	dualstack=${21:no}
	rgw=${22:no}
	src=${23:# The source file path when performing a PUT operation.}
	ignore_nonexistent_bucket=${24:# Overrides initial bucket lookups in case bucket or iam policies are restrictive. Example: a user may have the GetObject permission but no other permissions. In this case using the option mode: get will fail without specifying ignore_nonexistent_bucket: True.}
	encryption_kms_key_id=${25:# KMS key id to use when encrypting objects using C(aws:kms) encryption. Ignored if encryption is not C(aws:kms)}
	debug_botocore_endpoint_logs=${26:no}
	ec2_url=${27:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	security_token=${28:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${29:yes}
	profile=${30:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet aws_codepipeline "Create or delete AWS CodePipelines" b
aws_codepipeline: >
	name=${1:# Name of the pipeline}
	role_arn=${2:# ARN of the IAM role to use when executing the pipeline}
	artifact_store=${3:# Location information where artifacts are stored (on S3). Dictionary with fields type and location.}
	stages=${4:# List of stages to perform in the CodePipeline. List of dictionaries containing name and actions for each stage.}

	version=${5:# Version number of the pipeline. This number is automatically incremented when a pipeline is updated.}
	state=${6:#present|absent}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_endpoint_info "Retrieves AWS VPC endpoints details using AWS methods." b
ec2_vpc_endpoint_info: >
	query=${1:services|endpoints}

	vpc_endpoint_ids=${2:# Get details of specific endpoint IDs}
	filters=${3:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcEndpoints.html) for possible filters.}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_net "Configure AWS virtual private clouds" b
ec2_vpc_net: >
	name=${1:# The name to give your VPC. This is used in combination with C(cidr_block) to determine if a VPC already exists.}
	cidr_block=${2:# The primary CIDR of the VPC. After 2.5 a list of CIDRs can be provided. The first in the list will be used as the primary CIDR and is used in conjunction with the C(name) to ensure idempotence.}

	purge_cidrs=${3:no}
	tenancy=${4:#default|dedicated}
	dns_support=${5:yes}
	dns_hostnames=${6:yes}
	dhcp_opts_id=${7:# the id of the DHCP options to use for this vpc}
	tags=${8:# The tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different.}
	state=${9:#present|absent}
	multi_ok=${10:no}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_nacl_info "Gather information about Network ACLs in an AWS VPC" b
ec2_vpc_nacl_info: >
	nacl_ids=${1:[]}
	filters=${2:{}}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_batch_compute_environment "Manage AWS Batch Compute Environments" b
aws_batch_compute_environment: >
	compute_environment_name=${1:# The name for your compute environment. Up to 128 letters (uppercase and lowercase), numbers, and underscores are allowed.}
	type=${2:MANAGED|UNMANAGED}
	service_role=${3:# The full Amazon Resource Name (ARN) of the IAM role that allows AWS Batch to make calls to other AWS services on your behalf.}
	compute_resource_type=${4:EC2|SPOT}
	minv_cpus=${5:# The minimum number of EC2 vCPUs that an environment should maintain.}
	maxv_cpus=${6:# The maximum number of EC2 vCPUs that an environment can reach.}
	instance_types=${7:# The instance types that may be launched.}
	subnets=${8:# The VPC subnets into which the compute resources are launched.}
	security_group_ids=${9:# The EC2 security groups that are associated with instances launched in the compute environment.}
	instance_role=${10:# The Amazon ECS instance role applied to Amazon EC2 instances in a compute environment.}

	state=${11:#present|absent}
	compute_environment_state=${12:#ENABLED|DISABLED}
	desiredv_cpus=${13:# The desired number of EC2 vCPUS in the compute environment.}
	image_id=${14:# The Amazon Machine Image (AMI) ID used for instances launched in the compute environment.}
	ec2_key_pair=${15:# The EC2 key pair that is used for instances launched in the compute environment.}
	tags=${16:# Key-value pair tags to be applied to resources that are launched in the compute environment.}
	bid_percentage=${17:# The minimum percentage that a Spot Instance price must be when compared with the On-Demand price for that instance type before instances are launched. For example, if your bid percentage is 20%, then the Spot price must be below 20% of the current On-Demand price for that EC2 instance.}
	spot_iam_fleet_role=${18:# The Amazon Resource Name (ARN) of the Amazon EC2 Spot Fleet IAM role applied to a SPOT compute environment.}
	debug_botocore_endpoint_logs=${19:no}
	ec2_url=${20:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${21:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${22:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${23:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${24:yes}
	profile=${25:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${26:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_eni "Create and optionally attach an Elastic Network Interface (ENI) to an instance" b
ec2_eni: >
	eni_id=${1:# The ID of the ENI (to modify); if null and state is present, a new eni will be created.}
	instance_id=${2:# Instance ID that you wish to attach ENI to. Since version 2.2, use the 'attached' parameter to attach or detach an ENI. Prior to 2.2, to detach an ENI from an instance, use 'None'.}
	private_ip_address=${3:# Private IP address.}
	subnet_id=${4:# ID of subnet in which to create the ENI.}
	description=${5:# Optional description of the ENI.}
	security_groups=${6:# List of security groups associated with the interface. Only used when state=present. Since version 2.2, you can specify security groups by ID or by name or a combination of both. Prior to 2.2, you can specify only by ID.}
	state=${7:#present|absent}
	device_index=${8:0}
	attached=${9:# Specifies if network interface should be attached or detached from instance. If omitted, attachment status won't change}
	force_detach=${10:no}
	delete_on_termination=${11:# Delete the interface when the instance it is attached to is terminated. You can only specify this flag when the interface is being modified, not on creation.}
	source_dest_check=${12:# By default, interfaces perform source/destination checks. NAT instances however need this check to be disabled. You can only specify this flag when the interface is being modified, not on creation.}
	secondary_private_ip_addresses=${13:# A list of IP addresses to assign as secondary IP addresses to the network interface. This option is mutually exclusive of secondary_private_ip_address_count}
	purge_secondary_private_ip_addresses=${14:no}
	secondary_private_ip_address_count=${15:# The number of secondary IP addresses to assign to the network interface. This option is mutually exclusive of secondary_private_ip_addresses}
	allow_reassignment=${16:no}
	debug_botocore_endpoint_logs=${17:no}
	ec2_url=${18:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${19:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${20:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${21:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${22:yes}
	profile=${23:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${24:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_net_info "Gather information about ec2 VPCs in AWS" b
ec2_vpc_net_info: >
	vpc_ids=${1:# A list of VPC IDs that exist in your account.}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcs.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_asg "Create or delete AWS Autoscaling Groups" b
ec2_asg: >
	name=${1:# Unique name for group to be created or deleted}

	state=${2:#present|absent}
	load_balancers=${3:# List of ELB names to use for the group. Use for classic load balancers.}
	target_group_arns=${4:# List of target group ARNs to use for the group. Use for application load balancers.}
	availability_zones=${5:# List of availability zone names in which to create the group.  Defaults to all the availability zones in the region if vpc_zone_identifier is not set.}
	launch_config_name=${6:# Name of the Launch configuration to use for the group. See the ec2_lc module for managing these. If unspecified then the current group value will be used.  One of launch_config_name or launch_template must be provided.}
	launch_template=${7:# Dictionary describing the Launch Template to use}
	min_size=${8:# Minimum number of instances in group, if unspecified then the current group value will be used.}
	max_size=${9:# Maximum number of instances in group, if unspecified then the current group value will be used.}
	placement_group=${10:# Physical location of your cluster placement group created in Amazon EC2.}
	desired_capacity=${11:# Desired number of instances in group, if unspecified then the current group value will be used.}
	replace_all_instances=${12:no}
	replace_batch_size=${13:1}
	replace_instances=${14:# List of instance_ids belonging to the named ASG that you would like to terminate and be replaced with instances matching the current launch configuration.}
	lc_check=${15:yes}
	lt_check=${16:yes}
	vpc_zone_identifier=${17:# List of VPC subnets to use}
	tags=${18:# A list of tags to add to the Auto Scale Group. Optional key is 'propagate_at_launch', which defaults to true.}
	health_check_period=${19:300 seconds}
	health_check_type=${20:#EC2|ELB}
	default_cooldown=${21:300 seconds}
	wait_timeout=${22:300}
	wait_for_instances=${23:yes}
	termination_policies=${24:OldestInstance|NewestInstance|OldestLaunchConfiguration|ClosestToNextInstanceHour|#Default}
	notification_topic=${25:# A SNS topic ARN to send auto scaling notifications to.}
	notification_types=${26:['autoscaling:EC2_INSTANCE_LAUNCH', 'autoscaling:EC2_INSTANCE_LAUNCH_ERROR', 'autoscaling:EC2_INSTANCE_TERMINATE', 'autoscaling:EC2_INSTANCE_TERMINATE_ERROR']}
	suspend_processes=${27:['Launch', 'Terminate', 'HealthCheck', 'ReplaceUnhealthy', 'AZRebalance', 'AlarmNotification', 'ScheduledActions', 'AddToLoadBalancer'}
	metrics_collection=${28:no}
	metrics_granularity=${29:1minute}
	metrics_list=${30:['GroupMinSize', 'GroupMaxSize', 'GroupDesiredCapacity', 'GroupInServiceInstances', 'GroupPendingInstances', 'GroupStandbyInstances', 'GroupTerminatingInstances', 'GroupTotalInstances']}
	debug_botocore_endpoint_logs=${31:no}
	ec2_url=${32:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${33:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${34:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${35:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${36:yes}
	profile=${37:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${38:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_eni_info "Gather information about ec2 ENI interfaces in AWS" b
ec2_eni_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNetworkInterfaces.html) for possible filters.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_group "Manage AWS IAM groups" b
iam_group: >
	name=${1:# The name of the group to create.}
	state=${2:present|absent}

	managed_policy=${3:# A list of managed policy ARNs or friendly names to attach to the role. To embed an inline policy, use M(iam_policy).}
	users=${4:# A list of existing users to add as members of the group.}
	purge_policy=${5:no}
	purge_users=${6:no}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudformation_stack_set "Manage groups of CloudFormation stacks" b
cloudformation_stack_set: >
	name=${1:# name of the cloudformation stack set}

	description=${2:# A description of what this stack set creates}
	parameters=${3:{}}
	state=${4:#present|absent}
	template=${5:# The local path of the cloudformation template.}
	template_body=${6:# Template body. Use this to pass in the actual body of the Cloudformation template.}
	template_url=${7:# Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack.}
	purge_stacks=${8:yes}
	wait=${9:no}
	wait_timeout=${10:900}
	capabilities=${11:CAPABILITY_IAM|CAPABILITY_NAMED_IAM}
	regions=${12:# A list of AWS regions to create instances of a stack in. The I(region) parameter chooses where the Stack Set is created, and I(regions) specifies the region for stack instances.}
	accounts=${13:# A list of AWS accounts in which to create instance of CloudFormation stacks.}
	administration_role_arn=${14:# ARN of the administration role, meaning the role that CloudFormation Stack Sets use to assume the roles in your child accounts.}
	execution_role_name=${15:# ARN of the execution role, meaning the role that CloudFormation Stack Sets assumes in your child accounts.}
	tags=${16:# Dictionary of tags to associate with stack and its resources during stack creation. Can be updated later, updating tags removes previous entries.}
	failure_tolerance=${17:# Settings to change what is considered "failed" when running stack instance updates, and how many to do at a time.}
	debug_botocore_endpoint_logs=${18:no}
	ec2_url=${19:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${20:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${21:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${22:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${23:yes}
	profile=${24:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${25:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_metric_alarm "Create/update or delete AWS Cloudwatch 'metric alarms'" b
ec2_metric_alarm: >
	state=${1:present|absent}
	name=${2:# Unique name for the alarm}

	metric=${3:# Name of the monitored metric (e.g. CPUUtilization)}
	namespace=${4:# Name of the appropriate namespace ('AWS/EC2', 'System/Linux', etc.), which determines the category it will appear under in cloudwatch}
	statistic=${5:SampleCount|Average|Sum|Minimum|Maximum}
	comparison=${6:<=|<|>|>=}
	threshold=${7:# Sets the min/max bound for triggering the alarm}
	period=${8:# The time (in seconds) between metric evaluations}
	evaluation_periods=${9:# The number of times in which the metric is evaluated before final calculation}
	unit=${10:Seconds|Microseconds|Milliseconds|Bytes|Kilobytes|Megabytes|Gigabytes|Terabytes|Bits|Kilobits|Megabits|Gigabits|Terabits|Percent|Count|Bytes/Second|Kilobytes/Second|Megabytes/Second|Gigabytes/Second|Terabytes/Second|Bits/Second|Kilobits/Second|Megabits/Second|Gigabits/Second|Terabits/Second|Count/Second|None}
	description=${11:# A longer description of the alarm}
	dimensions=${12:# Describes to what the alarm is applied}
	alarm_actions=${13:# A list of the names action(s) taken when the alarm is in the 'alarm' status, denoted as Amazon Resource Name(s)}
	insufficient_data_actions=${14:# A list of the names of action(s) to take when the alarm is in the 'insufficient_data' status}
	ok_actions=${15:# A list of the names of action(s) to take when the alarm is in the 'ok' status, denoted as Amazon Resource Name(s)}
	debug_botocore_endpoint_logs=${16:no}
	ec2_url=${17:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${18:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${19:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${20:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${21:yes}
	profile=${22:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${23:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudwatchlogs_log_group_info "get information about log_group in CloudWatchLogs" b
cloudwatchlogs_log_group_info: >
	log_group_name=${1:# The name or prefix of the log group to filter by.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_ami_copy "copies AMI between AWS regions, return new image id" b
ec2_ami_copy: >
	source_region=${1:# The source region the AMI should be copied from.}
	source_image_id=${2:# The ID of the AMI in source region that should be copied.}

	name=${3:default}
	description=${4:# An optional human-readable string describing the contents and purpose of the new AMI.}
	encrypted=${5:# Whether or not the destination snapshots of the copied AMI should be encrypted.}
	kms_key_id=${6:# KMS key id used to encrypt image. If not specified, uses default EBS Customer Master Key (CMK) for your account.}
	wait=${7:no}
	wait_timeout=${8:600}
	tags=${9:# A hash/dictionary of tags to add to the new copied AMI; '{"key":"value"}' and '{"key":"value","key":"value"}'}
	tag_equality=${10:no}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_asg_info "Gather information about ec2 Auto Scaling Groups (ASGs) in AWS" b
ec2_asg_info: >
	name=${1:# The prefix or name of the auto scaling group(s) you are searching for.}
	tags=${2:# A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for.
}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_lc_info "Gather information about AWS Autoscaling Launch Configurations" b
ec2_lc_info: >
	name=${1:[]}
	sort=${2:launch_configuration_name|image_id|created_time|instance_type|kernel_id|ramdisk_id|key_name}
	sort_order=${3:#ascending|descending}
	sort_start=${4:# Which result to start with (when sorting).}
	sort_end=${5:# Which result to end with (when sorting).}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_eip "manages EC2 elastic IP (EIP) addresses." b
ec2_eip: >
	device_id=${1:# The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id.}
	public_ip=${2:# The IP address of a previously allocated EIP.}
	state=${3:#present|absent}
	in_vpc=${4:no}
	reuse_existing_ip_allowed=${5:no}
	release_on_disassociation=${6:no}
	private_ip_address=${7:# The primary or secondary private IP address to associate with the Elastic IP address.}
	allow_reassociation=${8:no}
	tag_name=${9:no}
	tag_value=${10:no}
	public_ipv4_pool=${11:no}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudwatchevent_rule "Manage CloudWatch Event rules and targets" b
cloudwatchevent_rule: >
	name=${1:# The name of the rule you are creating, updating or deleting. No spaces or special characters allowed (i.e. must match C([\.\-_A-Za-z0-9]+))}

	schedule_expression=${2:# A cron or rate expression that defines the schedule the rule will trigger on. For example, C(cron(0 20 * * ? *)), C(rate(5 minutes))}
	event_pattern=${3:# A string pattern (in valid JSON format) that is used to match against incoming events to determine if the rule should be triggered}
	state=${4:#present|disabled|absent}
	description=${5:# A description of the rule}
	role_arn=${6:# The Amazon Resource Name (ARN) of the IAM role associated with the rule}
	targets=${7:# A dictionary array of targets to add to or update for the rule, in the form C({ id: [string], arn: [string], role_arn: [string], input: [valid JSON string], input_path: [valid JSONPath string], ecs_parameters: {task_definition_arn: [string], task_count: [int]}}). I(id) [required] is the unique target assignment ID. I(arn) (required) is the Amazon Resource Name associated with the target. I(role_arn) (optional) is The Amazon Resource Name of the IAM role to be used for this target when the rule is triggered. I(input) (optional) is a JSON object that will override the event data when passed to the target.  I(input_path) (optional) is a JSONPath string (e.g. C($.detail)) that specifies the part of the event data to be passed to the target. If neither I(input) nor I(input_path) is specified, then the entire event is passed to the target in JSON form. I(task_definition_arn) [optional] is ecs task definition arn. I(task_count) [optional] is ecs task count.}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_codebuild "Create or delete an AWS CodeBuild project" b
aws_codebuild: >
	name=${1:# Name of the CodeBuild project}
	source=${2:# Configure service and location for the build input source.}
	artifacts=${3:# Information about the build output artifacts for the build project.}
	environment=${4:# Information about the build environment for the build project.}

	description=${5:# Descriptive text of the CodeBuild project}
	cache=${6:# Caching params to speed up following builds.}
	service_role=${7:# The ARN of the AWS IAM role that enables AWS CodeBuild to interact with dependent AWS services on behalf of the AWS account.}
	timeout_in_minutes=${8:60}
	encryption_key=${9:# The AWS Key Management Service (AWS KMS) customer master key (CMK) to be used for encrypting the build output artifacts.}
	tags=${10:# A set of tags for the build project.}
	vpc_config=${11:# The VPC config enables AWS CodeBuild to access resources in an Amazon VPC.}
	state=${12:#present|absent}
	debug_botocore_endpoint_logs=${13:no}
	ec2_url=${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${15:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${16:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${17:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${18:yes}
	profile=${19:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${20:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_server_certificate_info "Retrieve the information of a server certificate" b
iam_server_certificate_info: >
	name=${1:# The name of the server certificate you are retrieving attributes for.}

	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet rds_snapshot_info "obtain information about one or more RDS snapshots" b
rds_snapshot_info: >
	db_snapshot_identifier=${1:# Name of an RDS (unclustered) snapshot. Mutually exclusive with I(db_instance_identifier), I(db_cluster_identifier), I(db_cluster_snapshot_identifier)}
	db_instance_identifier=${2:# RDS instance name for which to find snapshots. Mutually exclusive with I(db_snapshot_identifier), I(db_cluster_identifier), I(db_cluster_snapshot_identifier)}
	db_cluster_identifier=${3:# RDS cluster name for which to find snapshots. Mutually exclusive with I(db_snapshot_identifier), I(db_instance_identifier), I(db_cluster_snapshot_identifier)}
	db_cluster_snapshot_identifier=${4:# Name of an RDS cluster snapshot. Mutually exclusive with I(db_instance_identifier), I(db_snapshot_identifier), I(db_cluster_identifier)}
	snapshot_type=${5:automated|manual|shared|public}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_direct_connect_gateway "Manage AWS Direct Connect Gateway." b
aws_direct_connect_gateway: >
	amazon_asn=${1:# amazon side asn}

	state=${2:#present|absent}
	name=${3:# name of the dxgw to be created or deleted}
	direct_connect_gateway_id=${4:# id of an existing direct connect gateway}
	virtual_gateway_id=${5:# vpn gateway id of an existing virtual gateway}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_eip_info "List EC2 EIP details" b
ec2_eip_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet route53 "add or delete entries in Amazons Route53 DNS service" b
route53: >
	state=${1:present|absent|get|create|delete}
	record=${2:# The full DNS record to create or delete}
	type=${3:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|CAA|NS|SOA}

	zone=${4:# The DNS zone to modify}
	hosted_zone_id=${5:# The Hosted Zone ID of the DNS zone to modify}
	ttl=${6:3600 (one hour)}
	alias=${7:no}
	alias_hosted_zone_id=${8:# The hosted zone identifier.}
	alias_evaluate_target_health=${9:no}
	value=${10:# The new value when creating a DNS record.  YAML lists or multiple comma-spaced values are allowed for non-alias records.}
	overwrite=${11:# Whether an existing record should be overwritten on create if values do not match}
	retry_interval=${12:500}
	private_zone=${13:no}
	identifier=${14:# Have to be specified for Weighted, latency-based and failover resource record sets only. An identifier that differentiates among multiple resource record sets that have the same combination of DNS name and type.}
	weight=${15:# Weighted resource record sets only. Among resource record sets that have the same combination of DNS name and type, a value that determines what portion of traffic for the current resource record set is routed to the associated location.}
	region=${16:# Latency-based resource record sets only Among resource record sets that have the same combination of DNS name and type, a value that determines which region this should be associated with for the latency-based routing}
	health_check=${17:# Health check to associate with this record}
	failover=${18:# Failover resource record sets only. Whether this is the primary or secondary resource record set. Allowed values are PRIMARY and SECONDARY}
	vpc_id=${19:# When used in conjunction with private_zone: true, this will only modify records in the private hosted zone attached to this VPC.}
	wait=${20:no}
	wait_timeout=${21:300}
	debug_botocore_endpoint_logs=${22:no}
	ec2_url=${23:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${24:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${25:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${26:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${27:yes}
	profile=${28:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet rds_param_group "manage RDS parameter groups" b
rds_param_group: >
	state=${1:#present|absent}
	name=${2:# Database parameter group identifier.}

	description=${3:# Database parameter group description. Only set when a new group is added.}
	engine=${4:# The type of database for this group. Required for state=present.}
	immediate=${5:# Whether to apply the changes immediately, or after the next reboot of any associated instances.}
	params=${6:# Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group.}
	tags=${7:# Dictionary of tags to attach to the parameter group}
	purge_tags=${8:no}
	debug_botocore_endpoint_logs=${9:no}
	ec2_url=${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${14:yes}
	profile=${15:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_dhcp_option_info "Gather information about dhcp options sets in AWS" b
ec2_vpc_dhcp_option_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeDhcpOptions.html) for possible filters.}
	dhcp_options_ids=${2:# Get details of specific DHCP Option ID}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_nat_gateway_info "Retrieves AWS VPC Managed Nat Gateway details using AWS methods." b
ec2_vpc_nat_gateway_info: >
	nat_gateway_ids=${1:# Get details of specific nat gateway IDs}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2 "create, terminate, start or stop an instance in ec2" b
ec2: >
	instance_type=${1:# Instance type to use for the instance, see U(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html).}
	image=${2:# I(ami) ID to use for the instance.}

	key_name=${3:# key pair to use on the instance. The SSH key must exist on AWS in order to use this argument. If you want to generate keys from Ansible, take a look at `ec2_key` module.}
	id=${4:# Identifier for this instance or set of instances, so that the module will be idempotent with respect to EC2 instances.}
	group=${5:# Security group (or list of groups) to use with the instance.}
	group_id=${6:# Security group id (or list of ids) to use with the instance.}
	region=${7:# The AWS region to use.  Must be specified if ec2_url is not used.}
	zone=${8:# AWS availability zone in which to launch the instance.}
	tenancy=${9:#default|dedicated}
	spot_price=${10:# Maximum spot price to bid. If not set, a regular on-demand instance is requested.}
	spot_type=${11:#one-time|persistent}
	kernel=${12:# Kernel I(eki) to use for the instance.}
	ramdisk=${13:# Ramdisk I(eri) to use for the instance.}
	wait=${14:no}
	wait_timeout=${15:300}
	spot_wait_timeout=${16:600}
	count=${17:1}
	monitoring=${18:no}
	user_data=${19:# Opaque blob of data which is made available to the EC2 instance.}
	instance_tags=${20:# A hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{"key":"value"}' and '{"key":"value","key":"value"}'.}
	placement_group=${21:# Placement group for the instance when using EC2 Clustered Compute.}
	vpc_subnet_id=${22:# the subnet ID in which to launch the instance (VPC).}
	assign_public_ip=${23:# When provisioning within vpc, assign a public IP address. Boto library must be 2.13.0+.}
	private_ip=${24:# The private ip address to assign the instance (from the vpc subnet).}
	instance_profile_name=${25:# Name of the IAM instance profile (i.e. what the EC2 console refers to as an "IAM Role") to use. Boto library must be 2.5.0+.}
	instance_ids=${26:# list of instance ids, currently used for states: absent, running, stopped}
	source_dest_check=${27:# Enable or Disable the Source/Destination checks (for NAT instances and Virtual Routers). When initially creating an instance the EC2 API defaults this to True.}
	termination_protection=${28:no}
	instance_initiated_shutdown_behavior=${29:#stop|terminate}
	state=${30:absent|#present|restarted|running|stopped}
	volumes=${31:# a list of hash/dictionaries of volumes to add to the new instance; '[{"key":"value", "key":"value"}]'; keys allowed are - device_name (str; required), delete_on_termination (bool; False), ephemeral (str), encrypted (bool; False), snapshot (str), volume_type (str), volume_size (int, GiB), iops (int) - iops must be set when volume_type='io1', ephemeral and snapshot are mutually exclusive.}
	ebs_optimized=${32:no}
	exact_count=${33:# An integer value which indicates how many instances that match the 'count_tag' parameter should be running. Instances are either created or terminated based on this value.}
	count_tag=${34:# Used with 'exact_count' to determine how many nodes based on a specific tag criteria should be running. This can be expressed in multiple ways and is shown in the EXAMPLES section.  For instance, one can request 25 servers that are tagged with "class=webserver". The specified tag must already exist or be passed in as the 'instance_tags' option.}
	network_interfaces=${35:# A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)}
	spot_launch_group=${36:# Launch group for spot request, see U(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/how-spot-instances-work.html#spot-launch-group).}
	debug_botocore_endpoint_logs=${37:no}
	ec2_url=${38:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${39:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${40:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${41:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${42:yes}
	profile=${43:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet elasticache_snapshot "Manage cache snapshots in Amazon Elasticache." b
elasticache_snapshot: >
	name=${1:# The name of the snapshot we want to create, copy, delete}

	state=${2:present|absent|copy}
	replication_id=${3:# The name of the existing replication group to make the snapshot.}
	cluster_id=${4:# The name of an existing cache cluster in the replication group to make the snapshot.}
	target=${5:# The name of a snapshot copy}
	bucket=${6:# The s3 bucket to which the snapshot is exported}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet redshift_cross_region_snapshots "Manage Redshift Cross Region Snapshots" b
redshift_cross_region_snapshots: >
	cluster_name=${1:# The name of the cluster to configure cross-region snapshots for.}
	state=${2:#present|absent}
	region=${3:# The clusters region}
	destination_region=${4:# The region to copy snapshots to}
	snapshot_retention_period=${5:# Keep cross-region snapshots for N number of days}

	snapshot_copy_grant=${6:# A grant for Amazon Redshift to use a master key in the destination region.}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet rds_subnet_group "manage RDS database subnet groups" b
rds_subnet_group: >
	state=${1:#present|absent}
	name=${2:# Database subnet group identifier.}

	description=${3:# Database subnet group description. Only set when a new group is added.}
	subnets=${4:# List of subnet IDs that make up the database subnet group.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_config_rule "Manage AWS Config resources" b
aws_config_rule: >
	name=${1:# The name of the AWS Config resource.}

	state=${2:#present|absent}
	description=${3:# The description that you provide for the AWS Config rule.}
	scope=${4:# Defines which resources can trigger an evaluation for the rule.}
	source=${5:# Provides the rule owner (AWS or customer), the rule identifier, and the notifications that cause the function to evaluate your AWS resources.}
	input_parameters=${6:# A string, in JSON format, that is passed to the AWS Config rule Lambda function.}
	execution_frequency=${7:One_Hour|Three_Hours|Six_Hours|Twelve_Hours|TwentyFour_Hours}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_kms "Perform various KMS management tasks." b
aws_kms: >
	alias=${1:# A}
	key_id=${2:# Key ID or ARN of the key. One of C(alias) or C(key_id) are required.}
	policy_mode=${3:#grant|deny}
	policy_role_name=${4:# (deprecated) Role to allow/deny access. One of C(policy_role_name) or C(policy_role_arn) are required.}
	policy_role_arn=${5:# (deprecated) ARN of role to allow/deny access. One of C(policy_role_name) or C(policy_role_arn) are required.}
	policy_grant_types=${6:# (deprecated) List of grants to give to user/role. Likely "role,role grant" or "role,role grant,admin". Required when C(policy_mode=grant).}
	policy_clean_invalid_entries=${7:yes}
	state=${8:#present|absent}
	enabled=${9:yes}
	description=${10:# A}
	tags=${11:# A}
	purge_tags=${12:no}
	purge_grants=${13:no}
	grants=${14:# A list of grants to apply to the key. Each item must contain I(grantee_principal). Each item can optionally contain I(retiring_principal), I(operations), I(constraints), I(name).}
	policy=${15:# policy to apply to the KMS key}
	debug_botocore_endpoint_logs=${16:no}
	ec2_url=${17:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${18:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${19:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${20:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${21:yes}
	profile=${22:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${23:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet lambda_info "Gathers AWS Lambda function details" b
lambda_info: >
	query=${1:aliases|#all|config|mappings|policy|versions}

	function_name=${2:# The name of the lambda function for which information is requested.}
	event_source_arn=${3:# For query type 'mappings', this is the Amazon Resource Name (ARN) of the Amazon Kinesis or DynamoDB stream.}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet rds_snapshot "manage Amazon RDS snapshots." b
rds_snapshot: >
	db_snapshot_identifier=${1:# The snapshot to manage.}

	state=${2:#present|absent}
	db_instance_identifier=${3:# Database instance identifier. Required when state is present.}
	wait=${4:no}
	wait_timeout=${5:300}
	tags=${6:# tags dict to apply to a snapshot.}
	purge_tags=${7:yes}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_tag "create and remove tags on ec2 resources." b
ec2_tag: >
	resource=${1:# The EC2 resource id.}
	tags=${2:# A dictionary of tags to add or remove from the resource.}

	state=${3:#present|absent|list}
	purge_tags=${4:no}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet dms_replication_subnet_group "creates or destroys a data migration services subnet group" b
dms_replication_subnet_group: >
	state=${1:#present|absent}
	identifier=${2:# The name for the replication subnet group. This value is stored as a lowercase string. Must contain no more than 255 alphanumeric characters, periods, spaces, underscores, or hyphens. Must not be "default".}
	description=${3:# The description for the subnet group.}
	subnet_ids=${4:# A list containing the subnet ids for the replication subnet group, needs to be at least 2 items in the list}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_nat_gateway_info "Retrieves AWS VPC Managed Nat Gateway details using AWS methods." b
ec2_vpc_nat_gateway_info: >
	nat_gateway_ids=${1:# Get details of specific nat gateway IDs}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeNatGateways.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_target_group "Manage a target group for an Application or Network load balancer" b
elb_target_group: >
	name=${1:# The name of the target group.}
	state=${2:present|absent}

	deregistration_delay_timeout=${3:# The amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds.}
	health_check_protocol=${4:http|https|tcp}
	health_check_port=${5:The port on which each target receives traffic from the load balancer.}
	health_check_path=${6:# The ping path that is the destination on the targets for health checks. The path must be defined in order to set a health check.}
	health_check_interval=${7:# The approximate amount of time, in seconds, between health checks of an individual target.}
	health_check_timeout=${8:# The amount of time, in seconds, during which no response from a target means a failed health check.}
	healthy_threshold_count=${9:# The number of consecutive health checks successes required before considering an unhealthy target healthy.}
	modify_targets=${10:yes}
	port=${11:# The port on which the targets receive traffic. This port is used unless you specify a port override when registering the target. Required if I(state) is C(present).}
	protocol=${12:http|https|tcp}
	purge_tags=${13:yes}
	stickiness_enabled=${14:# Indicates whether sticky sessions are enabled.}
	stickiness_lb_cookie_duration=${15:# The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds).}
	stickiness_type=${16:lb_cookie}
	successful_response_codes=${17:# The HTTP codes to use when checking for a successful response from a target.}
	tags=${18:# A dictionary of one or more tags to assign to the target group.}
	target_type=${19:#instance|ip|lambda}
	targets=${20:# A list of targets to assign to the target group. This parameter defaults to an empty list. Unless you set the 'modify_targets' parameter then all existing targets will be removed from the group. The list should be an Id and a Port parameter. See the Examples for detail.}
	unhealthy_threshold_count=${21:# The number of consecutive health check failures required before considering a target unhealthy.}
	vpc_id=${22:# The identifier of the virtual private cloud (VPC). Required when I(state) is C(present).}
	wait=${23:no}
	wait_timeout=${24:200}
	debug_botocore_endpoint_logs=${25:no}
	ec2_url=${26:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${27:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${28:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${29:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${30:yes}
	profile=${31:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${32:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_classic_lb "Creates or destroys Amazon ELB." b
elb_classic_lb: >
	state=${1:present|absent}
	name=${2:# The name of the ELB}

	listeners=${3:# List of ports/protocols for this ELB to listen on (see example)}
	purge_listeners=${4:yes}
	instance_ids=${5:# List of instance ids to attach to this ELB}
	purge_instance_ids=${6:no}
	zones=${7:# List of availability zones to enable on this ELB}
	purge_zones=${8:no}
	security_group_ids=${9:# A list of security groups to apply to the elb}
	security_group_names=${10:# A list of security group names to apply to the elb}
	health_check=${11:# An associative array of health check configuration settings (see example)}
	access_logs=${12:# An associative array of access logs configuration settings (see example)}
	subnets=${13:# A list of VPC subnets to use when creating ELB. Zones should be empty if using this.}
	purge_subnets=${14:no}
	scheme=${15:internal|#internet-facing}
	validate_certs=${16:yes}
	connection_draining_timeout=${17:# Wait a specified timeout allowing connections to drain before terminating an instance}
	idle_timeout=${18:# ELB connections from clients and to servers are timed out after this amount of time}
	cross_az_load_balancing=${19:no}
	stickiness=${20:# An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )}
	wait=${21:no}
	wait_timeout=${22:60}
	tags=${23:# An associative array of tags. To delete all tags, supply an empty dict.}
	debug_botocore_endpoint_logs=${24:no}
	ec2_url=${25:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${26:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${27:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${28:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	profile=${29:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${30:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet sns_topic "Manages AWS SNS topics and subscriptions" b
sns_topic: >
	name=${1:# The name or ARN of the SNS topic to manage}

	state=${2:absent|#present}
	display_name=${3:# Display name of the topic}
	policy=${4:# Policy to apply to the SNS topic}
	delivery_policy=${5:# Delivery policy to apply to the SNS topic}
	subscriptions=${6:[]}
	purge_subscriptions=${7:yes}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet sts_assume_role "Assume a role using AWS Security Token Service and obtain temporary credentials" b
sts_assume_role: >
	role_arn=${1:# The Amazon Resource Name (ARN) of the role that the caller is assuming U(https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html#Identifiers_ARNs).}
	role_session_name=${2:# Name of the role's session - will be used by CloudTrail}

	policy=${3:# Supplemental policy to use in addition to assumed role's policies.}
	duration_seconds=${4:# The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 43200 seconds (12 hours). The max depends on the IAM role's sessions duration setting. By default, the value is set to 3600 seconds.}
	external_id=${5:# A unique identifier that is used by third parties to assume a role in their customers' accounts.}
	mfa_serial_number=${6:# The identification number of the MFA device that is associated with the user who is making the AssumeRole call.}
	mfa_token=${7:# The value provided by the MFA device, if the trust policy of the role being assumed requires MFA.}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet s3_sync "Efficiently upload multiple files to S3" b
s3_sync: >
	bucket=${1:# Bucket name.}
	file_root=${2:# File/directory path for synchronization. This is a local path.}

	mode=${3:#push}
	file_change_strategy=${4:force|checksum|#date_size}
	key_prefix=${5:# In addition to file path, prepend s3 path with this prefix. Module will add slash at end of prefix if necessary.}
	permission=${6:|private|public-read|public-read-write|authenticated-read|aws-exec-read|bucket-owner-read|bucket-owner-full-control}
	mime_map=${7:# Dict entry from extension to MIME type. This will override any default/sniffed MIME type. For example C({".txt": "application/text", ".yml": "application/text"})
}
	include=${8:*}
	exclude=${9:.*}
	cache_control=${10:# This is a string.}
	delete=${11:no}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet route53_info "Retrieves route53 details using AWS methods" b
route53_info: >
	query=${1:change|checker_ip_range|health_check|hosted_zone|record_sets|reusable_delegation_set}

	change_id=${2:# The ID of the change batch request.}
	hosted_zone_id=${3:# The Hosted Zone ID of the DNS zone.}
	max_items=${4:# Maximum number of items to return for various get/list requests.}
	next_marker=${5:# Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100 or the number specified by max_items. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results.}
	delegation_set_id=${6:# The DNS Zone delegation set ID.}
	start_record_name=${7:# The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from.}
	type=${8:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|CAA|NS}
	dns_name=${9:# The first name in the lexicographic ordering of domain names that you want the list_command to start listing from.}
	resource_id=${10:# The ID/s of the specified resource/s.}
	health_check_id=${11:# The ID of the health check.}
	hosted_zone_method=${12:details|#list|list_by_name|count|tags}
	health_check_method=${13:#list|details|status|failure_reason|count|tags}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_direct_connect_link_aggregation_group "Manage Direct Connect LAG bundles." b
aws_direct_connect_link_aggregation_group: >
	state=${1:present|absent}
	name=${2:# The name of the Direct Connect link aggregation group.}
	link_aggregation_group_id=${3:# The ID of the Direct Connect link aggregation group.}
	num_connections=${4:# The number of connections with which to initialize the link aggregation group.}
	min_links=${5:# The minimum number of physical connections that must be operational for the LAG itself to be operational.}
	location=${6:# The location of the link aggregation group.}
	bandwidth=${7:# The bandwidth of the link aggregation group.}
	force_delete=${8:# This allows the minimum number of links to be set to 0, any hosted connections disassociated, and any virtual interfaces associated to the LAG deleted.}
	connection_id=${9:# A connection ID to link with the link aggregation group upon creation.}
	delete_with_disassociation=${10:# To be used with I(state=absent) to delete connections after disassociating them with the LAG.}
	wait=${11:# Whether or not to wait for the operation to complete. May be useful when waiting for virtual interfaces to be deleted. May modify the time of waiting with C(wait_timeout).}
	wait_timeout=${12:120}
	debug_botocore_endpoint_logs=${13:no}
	ec2_url=${14:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${15:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${16:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${17:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${18:yes}
	profile=${19:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${20:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_config_recorder "Manage AWS Config Recorders" b
aws_config_recorder: >
	name=${1:# The name of the AWS Config resource.}

	state=${2:#present|absent}
	role_arn=${3:# Amazon Resource Name (ARN) of the IAM role used to describe the AWS resources associated with the account.}
	recording_group=${4:# Specifies the types of AWS resources for which AWS Config records configuration changes.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_group "maintain an ec2 VPC security group." b
ec2_group: >
	name=${1:# Name of the security group.}
	group_id=${2:# Id of group to delete (works only with absent).}
	description=${3:# Description of the security group. Required when C(state) is C(present).}
	vpc_id=${4:# ID of the VPC to create the group in.}
	rules=${5:# List of firewall inbound rules to enforce in this group (see example). If none are supplied, no inbound rules will be enabled. Rules list may include its own name in `group_name`. This allows idempotent loopback additions (e.g. allow group to access itself). Rule sources list support was added in version 2.4. This allows to define multiple sources per source type as well as multiple source types per rule. Prior to 2.4 an individual source is allowed. In version 2.5 support for rule descriptions was added.}
	rules_egress=${6:# List of firewall outbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no outbound rules will be enabled. Rule Egress sources list support was added in version 2.4. In version 2.5 support for rule descriptions was added.}
	state=${7:#present|absent}
	purge_rules=${8:true}
	purge_rules_egress=${9:true}
	tags=${10:# A dictionary of one or more tags to assign to the security group.}
	purge_tags=${11:yes}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_waf_web_acl "create and delete WAF Web ACLs" b
aws_waf_web_acl: >
	name=${1:# N}

	default_action=${2:block|allow|count}
	state=${3:#present|absent}
	metric_name=${4:# A friendly name or description for the metrics for this WebACL}
	rules=${5:# A list of rules that the Web ACL will enforce.}
	purge_rules=${6:no}
	waf_regional=${7:no}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_eip_info "List EC2 EIP details" b
ec2_eip_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_policy "Manage IAM policies for users, groups, and roles" b
iam_policy: >
	iam_type=${1:user|group|role}
	iam_name=${2:# Name of IAM resource you wish to target for policy actions. In other words, the user name, group name or role name.}
	policy_name=${3:# The name label for the policy to create or remove.}
	state=${4:present|absent}

	policy_document=${5:# The path to the properly json formatted policy file (mutually exclusive with C(policy_json))}
	policy_json=${6:# A properly json formatted policy as string (mutually exclusive with C(policy_document), see https://github.com/ansible/ansible/issues/7005#issuecomment-42894813 on how to use it properly)}
	skip_duplicates=${7:/}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_transit_gateway "Create and delete AWS Transit Gateways." b
ec2_transit_gateway: >
	asn=${1:# A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs.}
	auto_associate=${2:yes}
	auto_attach=${3:no}
	auto_propagate=${4:yes}
	description=${5:# The description of the transit gateway.}
	dns_support=${6:yes}
	purge_tags=${7:yes}
	state=${8:#present|absent}
	tags=${9:# A dictionary of resource tags}
	transit_gateway_id=${10:# The ID of the transit gateway.}
	vpn_ecmp_support=${11:yes}
	wait=${12:yes}
	wait_timeout=${13:300}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_target_group_info "Gather information about ELB target groups in AWS" b
elb_target_group_info: >
	load_balancer_arn=${1:# The Amazon Resource Name (ARN) of the load balancer.}
	target_group_arns=${2:# The Amazon Resource Names (ARN) of the target groups.}
	names=${3:# The names of the target groups.}
	collect_targets_health=${4:no}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_route_table "Manage route tables for AWS virtual private clouds" b
ec2_vpc_route_table: >
	vpc_id=${1:# V}

	lookup=${2:#tag|id}
	propagating_vgw_ids=${3:# E}
	purge_routes=${4:yes}
	purge_subnets=${5:true}
	purge_tags=${6:no}
	route_table_id=${7:# T}
	routes=${8:# L}
	state=${9:#present|absent}
	subnets=${10:# A}
	tags=${11:# A}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${19:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_acm_info "Retrieve certificate information from AWS Certificate Manager service" b
aws_acm_info: >
	domain_name=${1:# The domain name of an ACM certificate to limit the search to}
	statuses=${2:PENDING_VALIDATION|ISSUED|INACTIVE|EXPIRED|VALIDATION_TIMED_OUT|REVOKED|FAILED}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_config_aggregator "Manage AWS Config aggregations across multiple accounts" b
aws_config_aggregator: >
	name=${1:# The name of the AWS Config resource.}

	state=${2:#present|absent}
	account_sources=${3:# Provides a list of source accounts and regions to be aggregated.}
	organization_source=${4:# The region authorized to collect aggregated data.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_service_info "list or describe services in ecs" b
ecs_service_info: >
	details=${1:false}
	events=${2:true}
	cluster=${3:default}
	service=${4:# One or more services to get details for}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet route53_info "Retrieves route53 details using AWS methods" b
route53_info: >
	query=${1:change|checker_ip_range|health_check|hosted_zone|record_sets|reusable_delegation_set}

	change_id=${2:# The ID of the change batch request.}
	hosted_zone_id=${3:# The Hosted Zone ID of the DNS zone.}
	max_items=${4:# Maximum number of items to return for various get/list requests.}
	next_marker=${5:# Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100 or the number specified by max_items. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results.}
	delegation_set_id=${6:# The DNS Zone delegation set ID.}
	start_record_name=${7:# The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from.}
	type=${8:A|CNAME|MX|AAAA|TXT|PTR|SRV|SPF|CAA|NS}
	dns_name=${9:# The first name in the lexicographic ordering of domain names that you want the list_command to start listing from.}
	resource_id=${10:# The ID/s of the specified resource/s.}
	health_check_id=${11:# The ID of the health check.}
	hosted_zone_method=${12:details|#list|list_by_name|count|tags}
	health_check_method=${13:#list|details|status|failure_reason|count|tags}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_api_gateway "Manage AWS API Gateway APIs" b
aws_api_gateway: >
	api_id=${1:# The ID of the API you want to manage.}
	state=${2:#present|absent}
	swagger_file=${3:# JSON or YAML file containing swagger definitions for API. Exactly one of swagger_file, swagger_text or swagger_dict must be present.}
	swagger_text=${4:# Swagger definitions for API in JSON or YAML as a string direct from playbook.}
	swagger_dict=${5:# Swagger definitions API ansible dictionary which will be converted to JSON and uploaded.}
	stage=${6:# The name of the stage the API should be deployed to.}
	deploy_desc=${7:Automatic deployment by Ansible.}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet rds_instance_info "obtain information about one or more RDS instances" b
rds_instance_info: >
	db_instance_identifier=${1:# The RDS instance's unique identifier.}
	filters=${2:# A filter that specifies one or more DB instances to describe. See U(https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html)}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_az_info "Gather information about availability zones in AWS." b
aws_az_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet efs "create and maintain EFS file systems" b
efs: >
	encrypt=${1:no}
	kms_key_id=${2:# The id of the AWS KMS CMK that will be used to protect the encrypted file system. This parameter is only required if you want to use a non-default CMK. If this parameter is not specified, the default CMK for Amazon EFS is used. The key id can be Key ID, Key ID ARN, Key Alias or Key Alias ARN.}
	purge_tags=${3:yes}
	state=${4:#present|absent}
	name=${5:# Creation Token of Amazon EFS file system. Required for create and update. Either name or ID required for delete.}
	id=${6:# ID of Amazon EFS. Either name or ID required for delete.}
	performance_mode=${7:#general_purpose|max_io}
	tags=${8:# List of tags of Amazon EFS. Should be defined as dictionary In case of 'present' state with list of tags and existing EFS (matched by 'name'), tags of EFS will be replaced with provided data.}
	targets=${9:# List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - subnet_id - Mandatory. The ID of the subnet to add the mount target in. - ip_address - Optional. A valid IPv4 address within the address range of the specified subnet. - security_groups - Optional. List of security group IDs, of the form 'sg-xxxxxxxx'. These must be for the same VPC as subnet specified This data may be modified for existing EFS using state 'present' and new list of mount targets.}
	throughput_mode=${10:bursting|provisioned}
	provisioned_throughput_in_mibps=${11:# If the throughput_mode is provisioned, select the amount of throughput to provisioned in Mibps.}
	wait=${12:no}
	wait_timeout=${13:0}
	debug_botocore_endpoint_logs=${14:no}
	ec2_url=${15:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${16:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${17:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${18:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${19:yes}
	profile=${20:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${21:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet lambda_policy "Creates, updates or deletes AWS Lambda policy statements." b
lambda_policy: >
	function_name=${1:# Name of the Lambda function whose resource policy you are updating by adding a new permission.}
	statement_id=${2:# A unique statement identifier.}
	action=${3:# The AWS Lambda action you want to allow in this statement. Each Lambda action is a string starting with lambda: followed by the API name (see Operations ). For example, lambda:CreateFunction . You can use wildcard (lambda:* ) to grant permission for all AWS Lambda actions.}
	principal=${4:# The principal who is getting this permission. It can be Amazon S3 service Principal (s3.amazonaws.com ) if you want Amazon S3 to invoke the function, an AWS account ID if you are granting cross-account permission, or any valid AWS service principal such as sns.amazonaws.com . For example, you might want to allow a custom application in another AWS account to push events to AWS Lambda by invoking your function.}

	state=${5:#present|absent}
	alias=${6:# Name of the function alias. Mutually exclusive with C(version).}
	version=${7:# Version of the Lambda function. Mutually exclusive with C(alias).}
	source_arn=${8:# This is optional; however, when granting Amazon S3 permission to invoke your function, you should specify this field with the bucket Amazon Resource Name (ARN) as its value. This ensures that only events generated from the specified bucket can invoke the function.}
	source_account=${9:# The AWS account ID (without a hyphen) of the source owner. For example, if the SourceArn identifies a bucket, then this is the bucket owner's account ID. You can use this additional condition to ensure the bucket you specify is owned by a specific account (it is possible the bucket owner deleted the bucket and some other AWS account created the bucket). You can also use this condition to specify all sources (that is, you don't specify the SourceArn ) owned by a specific account.}
	event_source_token=${10:# Token string representing source ARN or account. Mutually exclusive with C(source_arn) or C(source_account).}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet execute_lambda "Execute an AWS Lambda function" b
execute_lambda: >
	name=${1:# The name of the function to be invoked. This can only be used for invocations within the calling account. To invoke a function in another account, use I(function_arn) to specify the full ARN.}
	function_arn=${2:# The name of the function to be invoked}
	tail_log=${3:no}
	wait=${4:yes}
	dry_run=${5:no}
	version_qualifier=${6:LATEST}
	payload=${7:{}}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_target "Manage a target in a target group" b
elb_target: >
	target_id=${1:# The ID of the target.}
	state=${2:present|absent}

	deregister_unused=${3:# The default behaviour for targets that are unused is to leave them registered. If instead you would like to remove them set I(deregister_unused) to yes.}
	target_az=${4:# An Availability Zone or all. This determines whether the target receives traffic from the load balancer nodes in the specified Availability Zone or from all enabled Availability Zones for the load balancer. This parameter is not supported if the target type of the target group is instance.}
	target_group_arn=${5:# The Amazon Resource Name (ARN) of the target group. Mutually exclusive of I(target_group_name).}
	target_group_name=${6:# The name of the target group. Mutually exclusive of I(target_group_arn).}
	target_port=${7:The default port for a target is the port for the target group.}
	target_status=${8:initial|healthy|unhealthy|unused|draining|unavailable}
	target_status_timeout=${9:60}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_netapp_cvs_snapshots "NetApp AWS Cloud Volumes Service Manage Snapshots." b
aws_netapp_cvs_snapshots: >
	state=${1:present|absent}
	region=${2:# The region to which the snapshot belongs to.}
	name=${3:# Name of the snapshot}
	api_key=${4:# The access key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	secret_key=${5:# The secret_key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	api_url=${6:# The url to the AWSCVS Web Services Proxy or Embedded Web Services API.}

	fileSystemId=${7:# Name or Id of the filesystem.}
	from_name=${8:# ID or Name of the snapshot to rename.}
	validate_certs=${9:yes}

endsnippet

snippet kinesis_stream "Manage a Kinesis Stream." b
kinesis_stream: >
	name=${1:# The name of the Kinesis Stream you are managing.}

	shards=${2:# The number of shards you want to have with this stream.}
	retention_period=${3:# The default retention period is 24 hours and can not be less than 24 hours.}
	state=${4:#present|absent}
	wait=${5:yes}
	wait_timeout=${6:300}
	tags=${7:# A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }.}
	encryption_state=${8:enabled|disabled}
	encryption_type=${9:KMS}
	key_id=${10:# The GUID or alias for the KMS key.}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudformation_info "Obtain information about an AWS CloudFormation stack" b
cloudformation_info: >
	stack_name=${1:# The name or id of the CloudFormation stack. Gathers information on all stacks by default.}
	all_facts=${2:no}
	stack_events=${3:no}
	stack_template=${4:no}
	stack_resources=${5:no}
	stack_policy=${6:no}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_customer_gateway_info "Gather information about customer gateways in AWS" b
ec2_customer_gateway_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeCustomerGateways.html) for possible filters.}
	customer_gateway_ids=${2:# Get details of a specific customer gateways using customer gateway ID/IDs. This value should be provided as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_subnet_info "Gather information about ec2 VPC subnets in AWS" b
ec2_vpc_subnet_info: >
	subnet_ids=${1:# A list of subnet IDs to gather information for.}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_subnet_info "Gather information about ec2 VPC subnets in AWS" b
ec2_vpc_subnet_info: >
	subnet_ids=${1:# A list of subnet IDs to gather information for.}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSubnets.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_ami_info "Gather information about ec2 AMIs" b
ec2_ami_info: >
	image_ids=${1:# O}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value.}
	owners=${3:# Filter the images by the owner. Valid options are an AWS account ID, self,}
	executable_users=${4:# Filter images by users with explicit launch permissions. Valid options are an AWS account ID, self, or all (public AMIs).}
	describe_image_attributes=${5:no}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elasticache_info "Retrieve information for AWS Elasticache clusters" b
elasticache_info: >
	name=${1:# The name of an Elasticache cluster}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet route53_zone "add or delete Route53 zones" b
route53_zone: >
	zone=${1:# The DNS zone record (eg: foo.com.)}

	state=${2:#present|absent}
	vpc_id=${3:# The VPC ID the zone should be a part of (if this is going to be a private zone)}
	vpc_region=${4:# The VPC Region the zone should be a part of (if this is going to be a private zone)}
	comment=${5:}
	hosted_zone_id=${6:# The unique zone identifier you want to delete or "all" if there are many zones with the same domain name. Required if there are multiple zones identified with the above options}
	delegation_set_id=${7:# The reusable delegation set ID to be associated with the zone. Note that you can't associate a reusable delegation set with a private hosted zone.}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${13:yes}
	profile=${14:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${15:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_lc_info "Gather information about AWS Autoscaling Launch Configurations" b
ec2_lc_info: >
	name=${1:[]}
	sort=${2:launch_configuration_name|image_id|created_time|instance_type|kernel_id|ramdisk_id|key_name}
	sort_order=${3:#ascending|descending}
	sort_start=${4:# Which result to start with (when sorting).}
	sort_end=${5:# Which result to end with (when sorting).}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_region_info "Gather information about AWS regions." b
aws_region_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet dynamodb_ttl "set TTL for a given DynamoDB table." b
dynamodb_ttl: >
	table_name=${1:# name of the DynamoDB table to work on}
	attribute_name=${2:# the name of the Time to Live attribute used to store the expiration time for items in the table}

	state=${3:#enable|disable}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet s3_website "Configure an s3 bucket as a website" b
s3_website: >
	name=${1:# Name of the s3 bucket}

	error_key=${2:# The object key name to use when a 4XX class error occurs. To remove an error key, set to None.}
	redirect_all_requests=${3:# Describes the redirect behavior for every request to this s3 bucket website endpoint}
	region=${4:# AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file.  If none of those are set the region defaults to the S3 Location: US Standard.
}
	state=${5:#present|absent}
	suffix=${6:index.html}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet s3_lifecycle "Manage s3 bucket lifecycle rules in AWS" b
s3_lifecycle: >
	name=${1:# Name of the s3 bucket}

	expiration_date=${2:# Indicates the lifetime of the objects that are subject to the rule by the date they will expire. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified.
}
	expiration_days=${3:# Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.}
	prefix=${4:# Prefix identifying one or more objects to which the rule applies.  If no prefix is specified, the rule will apply to the whole bucket.}
	purge_transitions=${5:yes}
	noncurrent_version_expiration_days=${6:# Delete noncurrent versions this many days after they become noncurrent}
	noncurrent_version_storage_class=${7:#glacier|onezone_ia|standard_ia}
	noncurrent_version_transition_days=${8:# Transition noncurrent versions this many days after they become noncurrent}
	noncurrent_version_transitions=${9:# A list of transition behaviors to be applied to noncurrent versions for the rule. Each storage class may be used only once. Each transition behavior contains these elements
  I(transition_days)
  I(storage_class)
}
	rule_id=${10:# Unique identifier for the rule. The value cannot be longer than 255 characters. A unique value for the rule will be generated if no value is provided.}
	state=${11:#present|absent}
	status=${12:#enabled|disabled}
	storage_class=${13:#glacier|onezone_ia|standard_ia}
	transition_date=${14:# Indicates the lifetime of the objects that are subject to the rule by the date they will transition to a different storage class. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified. If transition_days is not specified, this parameter is required."
}
	transition_days=${15:# Indicates when, in days, an object transitions to a different storage class. If transition_date is not specified, this parameter is required.}
	transitions=${16:# A list of transition behaviors to be applied to the rule. Each storage class may be used only once. Each transition behavior may contain these elements I(transition_days) I(transition_date) I(storage_class)}
	debug_botocore_endpoint_logs=${17:no}
	ec2_url=${18:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${19:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${20:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${21:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${22:yes}
	profile=${23:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${24:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet redshift_subnet_group "manage Redshift cluster subnet groups" b
redshift_subnet_group: >
	group_name=${1:# Cluster subnet group name.}

	state=${2:#present|absent}
	group_description=${3:# Database subnet group description.}
	group_subnets=${4:# List of subnet IDs that make up the cluster subnet group.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_instance "Create & manage EC2 instances" b
ec2_instance: >
	instance_ids=${1:# If you specify one or more instance IDs, only instances that have the specified IDs are returned.}
	state=${2:#present|terminated|running|started|stopped|restarted|rebooted|absent}
	wait=${3:yes}
	wait_timeout=${4:600}
	instance_type=${5:t2.micro}
	user_data=${6:# Opaque blob of data which is made available to the ec2 instance}
	tower_callback=${7:# Preconfigured user-data to enable an instance to perform a Tower callback (Linux only).}
	tags=${8:# A hash/dictionary of tags to add to the new instance or to add/remove from an existing one.}
	purge_tags=${9:no}
	image=${10:# An image to use for the instance. The M(ec2_ami_info) module may be used to retrieve images. One of I(image) or I(image_id) are required when instance is not already present.}
	image_id=${11:# I(ami) ID to use for the instance. One of I(image) or I(image_id) are required when instance is not already present.}
	security_groups=${12:# A list of security group IDs or names (strings). Mutually exclusive with I(security_group).}
	security_group=${13:# A security group ID or name. Mutually exclusive with I(security_groups).}
	name=${14:# The Name tag for the instance.}
	vpc_subnet_id=${15:# The subnet ID in which to launch the instance (VPC) If none is provided, ec2_instance will chose the default zone of the default VPC.}
	network=${16:# Either a dictionary containing the key 'interfaces' corresponding to a list of network interface IDs or containing specifications for a single network interface.}
	volumes=${17:# A list of block device mappings, by default this will always use the AMI root device so the volumes option is primarily for adding more storage.}
	launch_template=${18:# The EC2 launch template to base instance configuration on.}
	key_name=${19:# Name of the SSH access key to assign to the instance - must exist in the region the instance is created.}
	availability_zone=${20:# Specify an availability zone to use the default subnet it. Useful if not specifying the I(vpc_subnet_id) parameter.}
	instance_initiated_shutdown_behavior=${21:stop|terminate}
	tenancy=${22:dedicated|default}
	termination_protection=${23:# Whether to enable termination protection. This module will not terminate an instance with termination protection active, it must be turned off first.}
	cpu_credit_specification=${24:unlimited|standard}
	cpu_options=${25:# Reduce the number of vCPU exposed to the instance.}
	detailed_monitoring=${26:# Whether to allow detailed cloudwatch metrics to be collected, enabling more detailed alerting.}
	ebs_optimized=${27:# Whether instance is should use optimized EBS volumes, see U(https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html).}
	filters=${28:{'tag:Name': '<provided-Name-attribute>', 'subnet-id': '<provided-or-default subnet>'}}
	instance_role=${29:# The ARN or name of an EC2-enabled instance role to be used. If a name is not provided in arn format then the ListInstanceProfiles permission must also be granted. U(https://docs.aws.amazon.com/IAM/latest/APIReference/API_ListInstanceProfiles.html) If no full ARN is provided, the role with a matching name will be used from the active AWS account.}
	placement_group=${30:# The placement group that needs to be assigned to the instance}
	debug_botocore_endpoint_logs=${31:no}
	ec2_url=${32:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${33:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${34:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${35:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${36:yes}
	profile=${37:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${38:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet lambda_event "Creates, updates or deletes AWS Lambda function event mappings." b
lambda_event: >
	lambda_function_arn=${1:# The name or ARN of the lambda function.}
	state=${2:#present|absent}
	alias=${3:# Name of the function alias. Mutually exclusive with C(version).}
	source_params=${4:# Sub-parameters required for event source.}

	version=${5:# Version of the Lambda function. Mutually exclusive with C(alias).}
	event_source=${6:#stream|sqs}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_peering_info "Retrieves AWS VPC Peering details using AWS methods." b
ec2_vpc_peering_info: >
	peer_connection_ids=${1:# Get details of specific vpc peer IDs}
	filters=${2:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVpcPeeringConnections.html) for possible filters.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_password_policy "Update an IAM Password Policy" b
iam_password_policy: >
	state=${1:present|absent}

	min_pw_length=${2:6}
	require_symbols=${3:no}
	require_numbers=${4:no}
	require_uppercase=${5:no}
	require_lowercase=${6:no}
	allow_pw_change=${7:no}
	pw_max_age=${8:0}
	pw_reuse_prevent=${9:0}
	pw_expire=${10:no}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_elasticbeanstalk_app "create, update, and delete an elastic beanstalk application" b
aws_elasticbeanstalk_app: >
	app_name=${1:# name of the beanstalk application you wish to manage}
	description=${2:# the description of the application}
	state=${3:absent|#present}
	terminate_by_force=${4:no}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_snapshot_copy "copies an EC2 snapshot and returns the new Snapshot ID." b
ec2_snapshot_copy: >
	source_region=${1:# The source region the Snapshot should be copied from.}
	source_snapshot_id=${2:# The ID of the Snapshot in source region that should be copied.}

	description=${3:# An optional human-readable string describing purpose of the new Snapshot.}
	encrypted=${4:no}
	kms_key_id=${5:# KMS key id used to encrypt snapshot. If not specified, defaults to EBS Customer Master Key (CMK) for that account.}
	wait=${6:no}
	wait_timeout=${7:600}
	tags=${8:# A hash/dictionary of tags to add to the new Snapshot; '{"key":"value"}' and '{"key":"value","key":"value"}'}
	debug_botocore_endpoint_logs=${9:no}
	ec2_url=${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${14:yes}
	profile=${15:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_classic_lb_info "Gather information about EC2 Elastic Load Balancers in AWS" b
elb_classic_lb_info: >
	names=${1:# List of ELB names to gather information about. Pass this option to gather information about a set of ELBs, otherwise, all ELBs are returned.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_vgw_info "Gather information about virtual gateways in AWS" b
ec2_vpc_vgw_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeRouteTables.html) for possible filters.}
	vpn_gateway_ids=${2:# Get details of a specific Virtual Gateway ID. This value should be provided as a list.}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet lambda_alias "Creates, updates or deletes AWS Lambda function aliases." b
lambda_alias: >
	function_name=${1:# The name of the function alias.}
	state=${2:#present|absent}
	name=${3:# Name of the function alias.}

	description=${4:# A short, user-defined function alias description.}
	version=${5:# Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vol_info "Gather information about ec2 volumes in AWS" b
ec2_vol_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. See U(https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeVolumes.html) for possible filters.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_group_info "Gather information about ec2 security groups in AWS." b
ec2_group_info: >
	filters=${1:{}}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_netapp_cvs_pool "NetApp AWS Cloud Volumes Service Manage Pools." b
aws_netapp_cvs_pool: >
	state=${1:present|absent}
	region=${2:# The region to which the Pool is associated.}
	name=${3:# pool name ( The human readable name of the Pool )}
	api_key=${4:# The access key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	secret_key=${5:# The secret_key to authenticate with the AWSCVS Web Services Proxy or Embedded Web Services API.}
	api_url=${6:# The url to the AWSCVS Web Services Proxy or Embedded Web Services API.}

	serviceLevel=${7:basic|standard|extreme}
	sizeInBytes=${8:# Size of the Pool in bytes}
	vendorID=${9:# A vendor ID for the Pool. E.g. an ID allocated by a vendor service for the Pool.}
	from_name=${10:# rename the existing pool name ( The human readable name of the Pool )}
	validate_certs=${11:yes}

endsnippet

snippet ec2_elb "De-registers or registers instances from EC2 ELBs" b
ec2_elb: >
	state=${1:present|absent}
	instance_id=${2:# EC2 Instance ID}

	ec2_elbs=${3:# List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.}
	enable_availability_zone=${4:yes}
	wait=${5:yes}
	validate_certs=${6:yes}
	wait_timeout=${7:0}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elb_instance "De-registers or registers instances from EC2 ELBs" b
elb_instance: >
	state=${1:present|absent}
	instance_id=${2:# EC2 Instance ID}

	ec2_elbs=${3:# List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de-register.}
	enable_availability_zone=${4:yes}
	wait=${5:yes}
	validate_certs=${6:yes}
	wait_timeout=${7:0}
	debug_botocore_endpoint_logs=${8:no}
	ec2_url=${9:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${10:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${11:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${12:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_cluster "create or terminate ecs clusters" b
ecs_cluster: >
	state=${1:present|absent|has_instances}
	name=${2:# The cluster name}

	delay=${3:# Number of seconds to wait}
	repeat=${4:# The number of times to wait for the cluster to have an instance}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_win_password "gets the default administrator password for ec2 windows instances" b
ec2_win_password: >
	instance_id=${1:# The instance id to get the password data from.}

	key_file=${2:# Path to the file containing the key pair used on the instance, conflicts with key_data.}
	key_data=${3:# Variable that references the private key (usually stored in vault), conflicts with key_file.}
	key_passphrase=${4:# The passphrase for the instance key pair. The key must use DES or 3DES encryption for this module to decrypt it. You can use openssl to convert your password protected keys if they do not use DES or 3DES. ex) C(openssl rsa -in current_key -out new_key -des3).}
	wait=${5:no}
	wait_timeout=${6:120}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet elasticache_subnet_group "manage Elasticache subnet groups" b
elasticache_subnet_group: >
	state=${1:#present|absent}
	name=${2:# Database subnet group identifier.}

	description=${3:# Elasticache subnet group description. Only set when a new group is added.}
	subnets=${4:# List of subnet IDs that make up the Elasticache subnet group.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_kms_info "Gather information about AWS KMS keys" b
aws_kms_info: >
	filters=${1:# A dict of filters to apply. Each dict item consists of a filter key and a filter value. The filters aren't natively supported by boto3, but are supported to provide similar functionality to other modules. Standard tag filters (C(tag-key), C(tag-value) and C(tag:tagName)) are available, as are C(key-id) and C(alias)}
	pending_deletion=${2:no}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_role_info "Gather information on IAM roles" b
iam_role_info: >
	name=${1:# Name of a role to search for}
	path_prefix=${2:# Prefix of role I(path) to restrict IAM role search for}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_eks_cluster "Manage Elastic Kubernetes Service Clusters" b
aws_eks_cluster: >
	name=${1:# N}

	version=${2:# K}
	role_arn=${3:# A}
	subnets=${4:# l}
	security_groups=${5:# l}
	state=${6:absent|#present}
	wait=${7:no}
	wait_timeout=${8:1200}
	debug_botocore_endpoint_logs=${9:no}
	ec2_url=${10:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${11:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${12:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${13:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${14:yes}
	profile=${15:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${16:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet rds_snapshot_info "obtain information about one or more RDS snapshots" b
rds_snapshot_info: >
	db_snapshot_identifier=${1:# Name of an RDS (unclustered) snapshot. Mutually exclusive with I(db_instance_identifier), I(db_cluster_identifier), I(db_cluster_snapshot_identifier)}
	db_instance_identifier=${2:# RDS instance name for which to find snapshots. Mutually exclusive with I(db_snapshot_identifier), I(db_cluster_identifier), I(db_cluster_snapshot_identifier)}
	db_cluster_identifier=${3:# RDS cluster name for which to find snapshots. Mutually exclusive with I(db_snapshot_identifier), I(db_instance_identifier), I(db_cluster_snapshot_identifier)}
	db_cluster_snapshot_identifier=${4:# Name of an RDS cluster snapshot. Mutually exclusive with I(db_instance_identifier), I(db_snapshot_identifier), I(db_cluster_identifier)}
	snapshot_type=${5:automated|manual|shared|public}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet cloudwatchlogs_log_group "create or delete log_group in CloudWatchLogs" b
cloudwatchlogs_log_group: >
	log_group_name=${1:# The name of the log group.}

	state=${2:#present|absent}
	kms_key_id=${3:# The Amazon Resource Name (ARN) of the CMK to use when encrypting log data.}
	tags=${4:# The key-value pairs to use for the tags.}
	retention=${5:# The number of days to retain the log events in the specified log group. Valid values are: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]}
	overwrite=${6:no}
	debug_botocore_endpoint_logs=${7:no}
	ec2_url=${8:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${9:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${10:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${11:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${12:yes}
	profile=${13:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ecs_task "run, start or stop a task in ecs" b
ecs_task: >
	operation=${1:run|start|stop}

	cluster=${2:# The name of the cluster to run the task on}
	task_definition=${3:# The task definition to start or run}
	overrides=${4:# A dictionary of values to pass to the new instances}
	count=${5:# How many new instances to start}
	task=${6:# The task to stop}
	container_instances=${7:# The list of container instances on which to deploy the task}
	started_by=${8:# A value showing who or what started the task (for informational purposes)}
	network_configuration=${9:# network configuration of the service. Only applicable for task definitions created with C(awsvpc) I(network_mode).}
	launch_type=${10:EC2|FARGATE}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_cert "Manage server certificates for use on ELBs and CloudFront" b
iam_cert: >
	name=${1:# Name of certificate to add, update or remove.}
	state=${2:present|absent}

	new_name=${3:# When state is present, this will update the name of the cert.}
	new_path=${4:# When state is present, this will update the path of the cert.}
	path=${5:/}
	cert_chain=${6:# The path to, or content of the CA certificate chain in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.}
	cert=${7:# The path to, or content of the certificate body in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.}
	key=${8:# The path to, or content of the private key in PEM encoded format. As of 2.4 content is accepted. If the parameter is not a file, it is assumed to be content.}
	dup_ok=${9:no}
	debug_botocore_endpoint_logs=${10:no}
	ec2_url=${11:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${12:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${13:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${14:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${15:yes}
	profile=${16:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${17:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_customer_gateway "Manage an AWS customer gateway" b
ec2_customer_gateway: >
	ip_address=${1:# Internet-routable IP address for customers gateway, must be a static address.}
	name=${2:# Name of the customer gateway.}

	bgp_asn=${3:# Border Gateway Protocol (BGP) Autonomous System Number (ASN), required when state=present.}
	routing=${4:static|#dynamic}
	state=${5:#present|absent}
	debug_botocore_endpoint_logs=${6:no}
	ec2_url=${7:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${8:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${9:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${10:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${11:yes}
	profile=${12:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${13:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_codecommit "Manage repositories in AWS CodeCommit" b
aws_codecommit: >
	name=${1:# name of repository.}
	state=${2:present|absent}

	comment=${3:# description or comment of repository.}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_launch_template "Manage EC2 launch templates" b
ec2_launch_template: >
	template_id=${1:# The ID for the launch template, can be used for all cases except creating a new Launch Template.}
	template_name=${2:# The template name. This must be unique in the region-account combination you are using.}
	default_version=${3:latest}
	state=${4:#present|absent}
	block_device_mappings=${5:# The block device mapping. Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action.}
	cpu_options=${6:# Choose CPU settings for the EC2 instances that will be created with this template.}
	credit_specification=${7:# T}
	disable_api_termination=${8:# T}
	ebs_optimized=${9:# I}
	elastic_gpu_specifications=${10:# S}
	iam_instance_profile=${11:# T}
	image_id=${12:# T}
	instance_initiated_shutdown_behavior=${13:stop|terminate}
	instance_market_options=${14:# O}
	instance_type=${15:# T}
	kernel_id=${16:# T}
	key_name=${17:# The name of the key pair. You can create a key pair using I(CreateKeyPair) or I(ImportKeyPair).}
	monitoring=${18:# S}
	network_interfaces=${19:# O}
	placement=${20:# T}
	ram_disk_id=${21:# T}
	security_group_ids=${22:# A}
	security_groups=${23:# A}
	tags=${24:# A set of key-value pairs to be applied to resources when this Launch Template is used.}
	user_data=${25:# T}
	debug_botocore_endpoint_logs=${26:no}
	ec2_url=${27:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${28:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${29:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${30:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${31:yes}
	profile=${32:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${33:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_mfa_device_info "List the MFA (Multi-Factor Authentication) devices registered for a user" b
iam_mfa_device_info: >
	user_name=${1:# The name of the user whose MFA devices will be listed}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet efs_info "Get information about Amazon EFS file systems" b
efs_info: >
	name=${1:# Creation Token of Amazon EFS file system.}
	id=${2:# ID of Amazon EFS.}
	tags=${3:# List of tags of Amazon EFS. Should be defined as dictionary.}
	targets=${4:# List of targets on which to filter the returned results.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${12:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet rds_instance_info "obtain information about one or more RDS instances" b
rds_instance_info: >
	db_instance_identifier=${1:# The RDS instance's unique identifier.}
	filters=${2:# A filter that specifies one or more DB instances to describe. See U(https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_DescribeDBInstances.html)}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet redshift_info "Gather information about Redshift cluster(s)" b
redshift_info: >
	cluster_identifier=${1:# The prefix of cluster identifier of the Redshift cluster you are searching for.}
	tags=${2:# A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the security group(s) you are searching for.}
	region=${3:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet sns "Send Amazon Simple Notification Service messages" b
sns: >
	msg=${1:# Default message for subscriptions without a more specific message.}
	topic=${2:# The name or ARN of the topic to publish to.}

	subject=${3:# Message subject}
	email=${4:# Message to send to email subscriptions.}
	email_json=${5:# Message to send to email-json subscriptions}
	sqs=${6:# Message to send to SQS subscriptions}
	sms=${7:# Message to send to SMS subscriptions}
	http=${8:# Message to send to HTTP subscriptions}
	https=${9:# Message to send to HTTPS subscriptions}
	application=${10:# Message to send to application subscriptions}
	lambda=${11:# Message to send to Lambda subscriptions}
	message_attributes=${12:# Dictionary of message attributes. These are optional structured data entries to be sent along to the endpoint.}
	message_structure=${13:#json|string}
	region=${14:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
	debug_botocore_endpoint_logs=${15:no}
	ec2_url=${16:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${17:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${18:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${19:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${20:yes}
	profile=${21:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet ec2_elb_info "Gather information about EC2 Elastic Load Balancers in AWS" b
ec2_elb_info: >
	names=${1:# List of ELB names to gather information about. Pass this option to gather information about a set of ELBs, otherwise, all ELBs are returned.}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_vpc_endpoint "Create and delete AWS VPC Endpoints." b
ec2_vpc_endpoint: >
	vpc_id=${1:# Required when creating a VPC endpoint.}
	service=${2:# An AWS supported vpc endpoint service. Use the M(ec2_vpc_endpoint_info) module to describe the supported endpoint services.}
	policy=${3:# A properly formatted json policy as string, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813). Cannot be used with I(policy_file).}
	policy_file=${4:# The path to the properly json formatted policy file, see U(https://github.com/ansible/ansible/issues/7005#issuecomment-42894813) on how to use it properly. Cannot be used with I(policy).}
	state=${5:#present|absent}
	wait=${6:no}
	wait_timeout=${7:320}
	route_table_ids=${8:# List of one or more route table ids to attach to the endpoint. A route is added to the route table with the destination of the endpoint if provided.}
	vpc_endpoint_id=${9:# One or more vpc endpoint ids to remove from the AWS account}
	client_token=${10:# Optional client token to ensure idempotency}
	debug_botocore_endpoint_logs=${11:no}
	ec2_url=${12:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${13:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${14:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${15:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${16:yes}
	profile=${17:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${18:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_inspector_target "Create, Update and Delete Amazon Inspector Assessment Targets" b
aws_inspector_target: >
	name=${1:# The user-defined name that identifies the assessment target.  The name must be unique within the AWS account.}

	state=${2:absent|#present}
	tags=${3:# Tags of the EC2 instances to be added to the assessment target.}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet iam_mfa_device_info "List the MFA (Multi-Factor Authentication) devices registered for a user" b
iam_mfa_device_info: >
	user_name=${1:# The name of the user whose MFA devices will be listed}
	debug_botocore_endpoint_logs=${2:no}
	ec2_url=${3:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${4:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${5:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${6:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${7:yes}
	profile=${8:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${9:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_secret "Manage secrets stored in AWS Secrets Manager." b
aws_secret: >
	name=${1:# Friendly name for the secret you are creating.}

	state=${2:#present|absent}
	recovery_window=${3:30}
	description=${4:# Specifies a user-provided description of the secret.}
	kms_key_id=${5:# Specifies the ARN or alias of the AWS KMS customer master key (CMK) to be used to encrypt the `secret_string` or `secret_binary` values in the versions stored in this secret.}
	secret_type=${6:binary|#string}
	secret=${7:}
	tags=${8:# Specifies a list of user-defined tags that are attached to the secret.}
	rotation_lambda=${9:# Specifies the ARN of the Lambda function that can rotate the secret.}
	rotation_interval=${10:30}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}
	debug_botocore_endpoint_logs=${12:no}
	ec2_url=${13:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${14:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${15:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${16:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${17:yes}
	profile=${18:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet ec2_vpc_egress_igw "Manage an AWS VPC Egress Only Internet gateway" b
ec2_vpc_egress_igw: >
	vpc_id=${1:# The VPC ID for the VPC that this Egress Only Internet Gateway should be attached.}

	state=${2:#present|absent}
	debug_botocore_endpoint_logs=${3:no}
	ec2_url=${4:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${5:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${6:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${7:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${8:yes}
	profile=${9:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${10:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet aws_s3_cors "Manage CORS for S3 buckets in AWS" b
aws_s3_cors: >
	name=${1:# Name of the s3 bucket}
	state=${2:present|absent}

	rules=${3:# Cors rules to put on the s3 bucket}
	debug_botocore_endpoint_logs=${4:no}
	ec2_url=${5:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${6:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${7:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${8:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${9:yes}
	profile=${10:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${11:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet ec2_lc_find "Find AWS Autoscaling Launch Configurations" b
ec2_lc_find: >
	region=${1:# The AWS region to use.}
	name_regex=${2:# A Launch Configuration to match}

	sort_order=${3:#ascending|descending}
	limit=${4:# How many results to show.}
	debug_botocore_endpoint_logs=${5:no}
	ec2_url=${6:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${7:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${8:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${9:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	validate_certs=${10:yes}
	profile=${11:# Uses a boto profile. Only works with boto >= 2.24.0.}

endsnippet

snippet ec2_vol "create and attach a volume, return volume id and device map" b
ec2_vol: >
	instance=${1:# instance ID if you wish to attach the volume. Since 1.9 you can set to None to detach.}
	name=${2:# volume Name tag if you wish to attach an existing volume (requires instance)}
	id=${3:# volume id if you wish to attach an existing volume (requires instance) or remove an existing volume}
	volume_size=${4:# size of volume (in GiB) to create.}
	volume_type=${5:standard}
	iops=${6:100}
	encrypted=${7:no}
	kms_key_id=${8:# Specify the id of the KMS key to use.}
	device_name=${9:# device id to override device mapping. Assumes /dev/sdf for Linux/UNIX and /dev/xvdf for Windows.}
	delete_on_termination=${10:no}
	zone=${11:# zone in which to create the volume, if unset uses the zone the instance is in (if set)}
	snapshot=${12:# snapshot ID on which to base the volume}
	validate_certs=${13:yes}
	state=${14:absent|#present|list}
	tags=${15:{}}
	debug_botocore_endpoint_logs=${16:no}
	ec2_url=${17:# Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required. Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.}
	aws_secret_key=${18:# AWS secret key. If not set then the value of the AWS_SECRET_ACCESS_KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.}
	aws_access_key=${19:# AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID, AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.}
	security_token=${20:# AWS STS security token. If not set then the value of the AWS_SECURITY_TOKEN or EC2_SECURITY_TOKEN environment variable is used.}
	profile=${21:# Uses a boto profile. Only works with boto >= 2.24.0.}
	region=${22:# The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See U(http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)}

endsnippet

snippet profitbricks_datacenter "Create or destroy a ProfitBricks Virtual Datacenter." b
profitbricks_datacenter: >
	name=${1:# The name of the virtual datacenter.}

	description=${2:# The description of the virtual datacenter.}
	location=${3:#us/las|de/fra|de/fkb}
	subscription_user=${4:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
	subscription_password=${5:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
	wait=${6:yes}
	wait_timeout=${7:600}
	state=${8:#present|absent}

endsnippet

snippet profitbricks_nic "Create or Remove a NIC." b
profitbricks_nic: >
	datacenter=${1:# The datacenter in which to operate.}
	server=${2:# The server name or ID.}
	name=${3:# The name or ID of the NIC. This is only required on deletes, but not on create.}
	lan=${4:# The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.}

	subscription_user=${5:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
	subscription_password=${6:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
	wait=${7:yes}
	wait_timeout=${8:600}
	state=${9:#present|absent}

endsnippet

snippet profitbricks "Create, destroy, start, stop, and reboot a ProfitBricks virtual machine." b
profitbricks: >
	name=${1:# The name of the virtual machine.}
	image=${2:# The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8.}

	auto_increment=${3:yes}
	image_password=${4:# Password set for the administrative user.}
	ssh_keys=${5:# Public SSH keys allowing access to the virtual machine.}
	datacenter=${6:# The datacenter to provision this virtual machine.}
	cores=${7:2}
	ram=${8:2048}
	cpu_family=${9:#AMD_OPTERON|INTEL_XEON}
	volume_size=${10:10}
	bus=${11:IDE|#VIRTIO}
	instance_ids=${12:# list of instance ids, currently only used when state='absent' to remove instances.}
	count=${13:1}
	location=${14:#us/las|de/fra|de/fkb}
	assign_public_ip=${15:no}
	lan=${16:1}
	subscription_user=${17:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
	subscription_password=${18:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
	wait=${19:yes}
	wait_timeout=${20:600}
	remove_boot_volume=${21:yes}
	state=${22:running|stopped|absent|#present}

endsnippet

snippet profitbricks_volume_attachments "Attach or detach a volume." b
profitbricks_volume_attachments: >
	datacenter=${1:# The datacenter in which to operate.}
	server=${2:# The name of the server you wish to detach or attach the volume.}
	volume=${3:# The volume name or ID.}

	subscription_user=${4:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
	subscription_password=${5:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
	wait=${6:yes}
	wait_timeout=${7:600}
	state=${8:#present|absent}

endsnippet

snippet profitbricks_volume "Create or destroy a volume." b
profitbricks_volume: >
	datacenter=${1:# The datacenter in which to create the volumes.}
	name=${2:# The name of the volumes. You can enumerate the names using auto_increment.}
	image=${3:# The system image ID for the volume, e.g. a3eae284-a2fe-11e4-b187-5f1f641608c8. This can also be a snapshot image ID.}

	size=${4:10}
	bus=${5:IDE|#VIRTIO}
	image_password=${6:# Password set for the administrative user.}
	ssh_keys=${7:# Public SSH keys allowing access to the virtual machine.}
	disk_type=${8:#HDD|SSD}
	licence_type=${9:LINUX|WINDOWS|#UNKNOWN|OTHER}
	count=${10:1}
	auto_increment=${11:yes}
	instance_ids=${12:# list of instance ids, currently only used when state='absent' to remove instances.}
	subscription_user=${13:# The ProfitBricks username. Overrides the PB_SUBSCRIPTION_ID environment variable.}
	subscription_password=${14:# THe ProfitBricks password. Overrides the PB_PASSWORD environment variable.}
	wait=${15:yes}
	wait_timeout=${16:600}
	state=${17:#present|absent}

endsnippet

snippet memset_dns_reload "Request reload of Memset's DNS infrastructure," b
memset_dns_reload: >
	api_key=${1:# The API key obtained from the Memset control panel.}

	poll=${2:no}

endsnippet

snippet memset_server_info "Retrieve server information." b
memset_server_info: >
	api_key=${1:# The API key obtained from the Memset control panel.}
	name=${2:# The server product name (i.e. C(testyaa1)).}

endsnippet

snippet memset_zone_domain "Create and delete domains in Memset DNS zones." b
memset_zone_domain: >
	api_key=${1:# The API key obtained from the Memset control panel.}
	domain=${2:# The zone domain name. Ensure this value has at most 250 characters.}
	zone=${3:# The zone to add the domain to (this must already exist).}

	state=${4:absent|#present}

endsnippet

snippet memset_memstore_info "Retrieve Memstore product usage information." b
memset_memstore_info: >
	api_key=${1:# The API key obtained from the Memset control panel.}
	name=${2:# The Memstore product name (i.e. C(mstestyaa1)).}

endsnippet

snippet memset_server_info "Retrieve server information." b
memset_server_info: >
	api_key=${1:# The API key obtained from the Memset control panel.}
	name=${2:# The server product name (i.e. C(testyaa1)).}

endsnippet

snippet memset_zone_record "Create and delete records in Memset DNS zones." b
memset_zone_record: >
	api_key=${1:# The API key obtained from the Memset control panel.}
	address=${2:# The address for this record (can be IP or text string depending on record type).}
	type=${3:A|AAAA|CNAME|MX|NS|SRV|TXT}
	zone=${4:# The name of the zone to which to add the record to.}

	state=${5:absent|#present}
	priority=${6:# C(SRV) and C(TXT) record priority, in the range 0 > 999 (inclusive).}
	record=${7:# The subdomain to create.}
	relative=${8:# If set then the current domain is added onto the address field for C(CNAME), C(MX), C(NS) and C(SRV)record types.}
	ttl=${9:0|300|600|900|1800|3600|7200|10800|21600|43200|86400}

endsnippet

snippet memset_memstore_info "Retrieve Memstore product usage information." b
memset_memstore_info: >
	api_key=${1:# The API key obtained from the Memset control panel.}
	name=${2:# The Memstore product name (i.e. C(mstestyaa1)).}

endsnippet

snippet memset_zone "Creates and deletes Memset DNS zones." b
memset_zone: >
	state=${1:absent|present}
	api_key=${2:# The API key obtained from the Memset control panel.}
	name=${3:# The zone nickname; usually the same as the main domain. Ensure this value has at most 250 characters.}

	ttl=${4:0|300|600|900|1800|3600|7200|10800|21600|43200|86400}
	force=${5:no}

endsnippet

snippet heroku_collaborator "Add or delete app collaborators on Heroku" b
heroku_collaborator: >
	apps=${1:# List of Heroku App names}
	user=${2:# User ID or e-mail}

	api_key=${3:# Heroku API key}
	suppress_invitation=${4:no}
	state=${5:#present|absent}

endsnippet

snippet azure_rm_cosmosdbaccount_info "Get Azure Cosmos DB Account facts" b
azure_rm_cosmosdbaccount_info: >
	resource_group=${1:# Name of an Azure resource group.}
	name=${2:# Cosmos DB database account name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	retrieve_keys=${4:all|readonly}
	retrieve_connection_strings=${5:# Retrieve connection strings.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_devtestlabpolicy "Manage Azure Policy instance" b
azure_rm_devtestlabpolicy: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	policy_set_name=${3:# The name of the policy set.}
	name=${4:# The name of the policy.}

	description=${5:# The description of the policy.}
	fact_name=${6:user_owned_lab_vm_count|user_owned_lab_premium_vm_count|lab_vm_count|lab_premium_vm_count|lab_vm_size|gallery_image|user_owned_lab_vm_count_in_subnet|lab_target_cost}
	threshold=${7:# The threshold of the policy (it could be either a maximum value or a list of allowed values).}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_automationaccount_info "Get Azure automation account facts" b
azure_rm_automationaccount_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the automation account.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	list_statistics=${4:# List statistics details for a automation account.}
	list_usages=${5:# List usage details for a automation account.}
	list_keys=${6:# List keys for a automation account.}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_functionapp_info "Get Azure Function App facts" b
azure_rm_functionapp_info: >
	name=${1:# Only show results for a specific Function App.}
	resource_group=${2:# Limit results to a resource group. Required when filtering by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualnetworkpeering_info "Get facts of Azure Virtual Network Peering" b
azure_rm_virtualnetworkpeering_info: >
	resource_group=${1:# Name of a resource group where the vnet exists.}
	virtual_network=${2:# Name or resource ID of a virtual network.}

	name=${3:# Name of the virtual network peering.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_cdnendpoint_info "Get Azure CDN endpoint facts" b
azure_rm_cdnendpoint_info: >
	resource_group=${1:# Name of resource group where this CDN profile belongs to.}
	profile_name=${2:# Name of CDN profile.}

	name=${3:# Limit results to a specific Azure CDN endpoint.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_resourcegroup_info "Get resource group facts" b
azure_rm_resourcegroup_info: >
	name=${1:# Limit results to a specific resource group.}
	tags=${2:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	list_resources=${3:# List all resources under the resource group.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_iothubconsumergroup "Manage Azure IoT hub" b
azure_rm_iothubconsumergroup: >
	resource_group=${1:# Name of resource group.}
	hub=${2:# Name of the IoT hub.}

	state=${3:absent|#present}
	event_hub=${4:events}
	name=${5:# Name of the consumer group.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}
	tags=${18:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${19:yes}

endsnippet

snippet azure_rm_storageaccount_info "Get storage account facts" b
azure_rm_storageaccount_info: >
	name=${1:# Only show results for a specific account.}
	resource_group=${2:# Limit results to a resource group. Required when filtering by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	show_connection_string=${4:# Show the connection string for each of the storageaccount's endpoints.}
	show_blob_cors=${5:# Show the blob CORS settings for each blob related to the storage account.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_virtualmachinescalesetinstance "Get Azure Virtual Machine Scale Set Instance facts" b
azure_rm_virtualmachinescalesetinstance: >
	resource_group=${1:# The name of the resource group.}
	vmss_name=${2:# The name of the VM scale set.}
	instance_id=${3:# The instance ID of the virtual machine.}
	power_state=${4:running|stopped|deallocated}

	latest_model=${5:# Set to C(yes) to upgrade to the latest model.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_postgresqlconfiguration_info "Get Azure PostgreSQL Configuration facts" b
azure_rm_postgresqlconfiguration_info: >
	resource_group=${1:# The name of the resource group that contains the resource.}
	server_name=${2:# The name of the server.}

	name=${3:# Setting name.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_trafficmanagerendpoint_info "Get Azure Traffic Manager endpoint facts" b
azure_rm_trafficmanagerendpoint_info: >
	resource_group=${1:# The resource group to search for the desired Traffic Manager profile.}
	profile_name=${2:# Name of Traffic Manager Profile.}

	name=${3:# Limit results to a specific Traffic Manager endpoint.}
	type=${4:azure_endpoints|external_endpoints|nested_endpoints}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_storageaccount "Manage Azure storage accounts" b
azure_rm_storageaccount: >
	resource_group=${1:# Name of the resource group to use.}

	name=${2:# Name of the storage account to update or create.}
	state=${3:absent|#present}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	account_type=${5:Premium_LRS|Standard_GRS|Standard_LRS|StandardSSD_LRS|Standard_RAGRS|Standard_ZRS|Premium_ZRS}
	custom_domain=${6:# User domain assigned to the storage account.}
	kind=${7:#Storage|StorageV2|BlobStorage}
	access_tier=${8:Hot|Cool}
	force_delete_nonempty=${9:# Attempt deletion if resource already exists and cannot be updated.}
	https_only=${10:# Allows https traffic only to storage service when set to C(true).}
	blob_cors=${11:# Specifies CORS rules for the Blob service.}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_containerregistry "Manage an Azure Container Registry" b
azure_rm_containerregistry: >
	resource_group=${1:# Name of a resource group where the Container Registry exists or will be created.}
	name=${2:# Name of the Container Registry.}

	state=${3:absent|#present}
	location=${4:# Valid azure location. Defaults to location of the resource group.}
	admin_user_enabled=${5:no}
	sku=${6:Basic|#Standard|Premium}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}
	tags=${19:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${20:yes}

endsnippet

snippet azure_rm_cdnendpoint_info "Get Azure CDN endpoint facts" b
azure_rm_cdnendpoint_info: >
	resource_group=${1:# Name of resource group where this CDN profile belongs to.}
	profile_name=${2:# Name of CDN profile.}

	name=${3:# Limit results to a specific Azure CDN endpoint.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_virtualmachinescaleset "Manage Azure virtual machine scale sets" b
azure_rm_virtualmachinescaleset: >
	resource_group=${1:# Name of the resource group containing the virtual machine scale set.}
	name=${2:# Name of the virtual machine.}
	image=${3:# Specifies the image used to build the VM.}

	state=${4:absent|#present}
	location=${5:# Valid Azure location. Defaults to location of the resource group.}
	short_hostname=${6:# Short host name.}
	vm_size=${7:# A valid Azure VM size value. For example, C(Standard_D4).}
	capacity=${8:1}
	tier=${9:Basic|Standard}
	upgrade_policy=${10:Manual|Automatic}
	admin_username=${11:# Admin username used to access the host after it is created. Required when creating a VM.}
	admin_password=${12:# Password for the admin username.}
	ssh_password_enabled=${13:yes}
	ssh_public_keys=${14:# For I(os_type=Linux) provide a list of SSH keys.}
	os_disk_caching=${15:#ReadOnly|ReadWrite}
	os_type=${16:Windows|#Linux}
	managed_disk_type=${17:Standard_LRS|Premium_LRS}
	data_disks=${18:# Describes list of data disks.}
	virtual_network_resource_group=${19:# When creating a virtual machine, if a specific virtual network from another resource group should be used.}
	virtual_network_name=${20:# Virtual Network name.}
	subnet_name=${21:# Subnet name.}
	load_balancer=${22:# Load balancer name.}
	application_gateway=${23:# Application gateway name.}
	remove_on_absent=${24:['all']}
	enable_accelerated_networking=${25:# Indicates whether user wants to allow accelerated networking for virtual machines in scaleset being created.}
	security_group=${26:# Existing security group with which to associate the subnet.}
	overprovision=${27:yes}
	single_placement_group=${28:yes}
	zones=${29:# A list of Availability Zones for your virtual machine scale set.}
	custom_data=${30:# Data which is made available to the virtual machine and used by e.g., C(cloud-init).}
	ad_user=${31:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${32:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${33:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${34:# Your Azure subscription Id.}
	client_id=${35:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${36:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${37:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${38:AzureCloud}
	adfs_authority_url=${39:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${40:ignore|validate}
	auth_source=${41:auto|cli|credential_file|env|msi}
	api_profile=${42:latest}
	tags=${43:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${44:yes}

endsnippet

snippet azure_rm_dnszone "Manage Azure DNS zones" b
azure_rm_dnszone: >
	resource_group=${1:# name of resource group.}
	name=${2:# Name of the DNS zone.}

	state=${3:absent|#present}
	type=${4:public|private}
	registration_virtual_networks=${5:# A list of references to virtual networks that register hostnames in this DNS zone.}
	resolution_virtual_networks=${6:# A list of references to virtual networks that resolve records in this DNS zone.}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}
	tags=${19:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${20:yes}

endsnippet

snippet azure_rm_devtestlabschedule "Manage Azure DevTest Lab Schedule instance" b
azure_rm_devtestlabschedule: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	name=${3:lab_vms_startup|lab_vms_shutdown}

	time=${4:# The time of day the schedule will occur.}
	time_zone_id=${5:# The time zone ID.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}
	tags=${19:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${20:yes}

endsnippet

snippet azure_rm_rediscache_info "Get Azure Cache for Redis instance facts" b
azure_rm_rediscache_info: >
	resource_group=${1:# The resource group to search for the desired Azure Cache for Redis.}

	name=${2:# Limit results to a specific Azure Cache for Redis.}
	return_access_keys=${3:no}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_applicationsecuritygroup_info "Get Azure Application Security Group facts" b
azure_rm_applicationsecuritygroup_info: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the application security group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualmachineextension "Managed Azure Virtual Machine extension" b
azure_rm_virtualmachineextension: >
	resource_group=${1:# Name of a resource group where the vm extension exists or will be created.}
	name=${2:# Name of the vm extension.}

	state=${3:absent|#present}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	virtual_machine_name=${5:# The name of the virtual machine where the extension should be create or updated.}
	publisher=${6:# The name of the extension handler publisher.}
	virtual_machine_extension_type=${7:# The type of the extension handler.}
	type_handler_version=${8:# The type version of the extension handler.}
	settings=${9:# Json formatted public settings for the extension.}
	protected_settings=${10:# Json formatted protected settings for the extension.}
	auto_upgrade_minor_version=${11:# Whether the extension handler should be automatically upgraded across minor versions.}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}

endsnippet

snippet azure_rm_virtualmachinescaleset_info "Get Virtual Machine Scale Set facts" b
azure_rm_virtualmachinescaleset_info: >
	name=${1:# Limit results to a specific virtual machine scale set.}
	resource_group=${2:# The resource group to search for the desired virtual machine scale set.}
	tags=${3:# List of tags to be matched.}
	format=${4:curated|#raw}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_gallery_info "Get Azure Shared Image Gallery info." b
azure_rm_gallery_info: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# Resource name}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}

endsnippet

snippet azure_rm_sqlserver "Manage SQL Server instance" b
azure_rm_sqlserver: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	name=${2:# The name of the server.}

	location=${3:# Resource location.}
	admin_username=${4:# Administrator username for the server. Once created it cannot be changed.}
	admin_password=${5:# The administrator login password (required for server creation).}
	version=${6:# The version of the server. For example C(12.0).}
	identity=${7:# The identity type. Set this to C(SystemAssigned) in order to automatically create and assign an Azure Active Directory principal for the resource.}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_galleryimage_info "Get Azure SIG Image info." b
azure_rm_galleryimage_info: >
	resource_group=${1:# The name of the resource group.}
	gallery_name=${2:# The name of the shared image gallery from which the image definitions are to be retrieved.}

	name=${3:# Resource name}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_trafficmanagerprofile "Manage Azure Traffic Manager profile" b
azure_rm_trafficmanagerprofile: >
	resource_group=${1:# Name of a resource group where the Traffic Manager profile exists or will be created.}
	name=${2:# Name of the Traffic Manager profile.}

	state=${3:absent|#present}
	location=${4:global}
	profile_status=${5:#enabled|disabled}
	routing_method=${6:#performance|priority|weighted|geographic}
	dns_config=${7:# The DNS settings of the Traffic Manager profile.}
	monitor_config=${8:{'protocol': 'HTTP', 'port': 80, 'path': '/'}}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_devtestlabpolicy_info "Get Azure DTL Policy facts" b
azure_rm_devtestlabpolicy_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	policy_set_name=${3:# The name of the policy set.}

	name=${4:# The name of the policy.}
	tags=${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_manageddisk_info "Get managed disk facts" b
azure_rm_manageddisk_info: >
	name=${1:# Limit results to a specific managed disk.}
	resource_group=${2:# Limit results to a specific resource group.}
	tags=${3:# Limit results by providing a list of tags.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}
	append_tags=${16:yes}

endsnippet

snippet azure_rm_devtestlabenvironment "Manage Azure DevTest Lab Environment instance" b
azure_rm_devtestlabenvironment: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	user_name=${3:# The name of the user profile.}
	name=${4:# The name of the environment.}

	location=${5:# The location of the resource.}
	deployment_template=${6:# The Azure Resource Manager template's identifier.}
	deployment_parameters=${7:# The parameters of the Azure Resource Manager template.}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_devtestlabartifactsource "Manage Azure DevTest Labs Artifacts Source instance" b
azure_rm_devtestlabartifactsource: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	name=${3:# The name of the artifact source.}

	display_name=${4:# The artifact source's display name.}
	uri=${5:# The artifact source's URI.}
	source_type=${6:vso|github}
	folder_path=${7:# The folder containing artifacts.}
	arm_template_folder_path=${8:# The folder containing Azure Resource Manager templates.}
	branch_ref=${9:# The artifact source's branch reference.}
	security_token=${10:# The security token to authenticate to the artifact source.}
	is_enabled=${11:# Indicates whether the artifact source is enabled.}
	state=${12:absent|#present}
	ad_user=${13:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${15:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${16:# Your Azure subscription Id.}
	client_id=${17:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${18:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${19:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${20:AzureCloud}
	adfs_authority_url=${21:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${22:ignore|validate}
	auth_source=${23:auto|cli|credential_file|env|msi}
	api_profile=${24:latest}
	tags=${25:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${26:yes}

endsnippet

snippet azure_rm_acs "Manage an Azure Container Service(ACS) instance" b
azure_rm_acs: >
	resource_group=${1:# Name of a resource group where the Container Services exists or will be created.}
	name=${2:# Name of the Azure Container Services(ACS) instance.}
	orchestration_platform=${3:DCOS|Kubernetes|Swarm}
	master_profile=${4:# Master profile suboptions.}
	linux_profile=${5:# The Linux profile suboptions.}
	agent_pool_profiles=${6:# The agent pool profile suboptions.}
	diagnostics_profile=${7:# Should VM Diagnostics be enabled for the Container Service VM's.}

	state=${8:absent|#present}
	location=${9:# Valid azure location. Defaults to location of the resource group.}
	service_principal=${10:# The service principal suboptions.}
	ad_user=${11:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${12:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${13:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${14:# Your Azure subscription Id.}
	client_id=${15:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${16:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${18:AzureCloud}
	adfs_authority_url=${19:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${20:ignore|validate}
	auth_source=${21:auto|cli|credential_file|env|msi}
	api_profile=${22:latest}
	tags=${23:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${24:yes}

endsnippet

snippet azure_rm_hdinsightcluster_info "Get Azure HDInsight Cluster facts" b
azure_rm_hdinsightcluster_info: >
	resource_group=${1:# Name of an Azure resource group.}
	name=${2:# HDInsight cluster name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_subnet_info "Get Azure Subnet facts" b
azure_rm_subnet_info: >
	resource_group=${1:# The name of the resource group.}
	virtual_network_name=${2:# The name of the virtual network.}

	name=${3:# The name of the subnet.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_sqldatabase_info "Get Azure SQL Database facts" b
azure_rm_sqldatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	elastic_pool_name=${4:# The name of the elastic pool.}
	tags=${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_devtestlabvirtualmachine_info "Get Azure DevTest Lab Virtual Machine facts" b
azure_rm_devtestlabvirtualmachine_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}

	name=${3:# The name of the virtual machine.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_dnsrecordset "Create, delete and update DNS record sets and records" b
azure_rm_dnsrecordset: >
	resource_group=${1:# Name of resource group.}
	zone_name=${2:# Name of the existing DNS zone in which to manage the record set.}
	relative_name=${3:# Relative name of the record set.}
	record_type=${4:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR|CAA|SOA}

	record_mode=${5:append|#purge}
	state=${6:absent|#present}
	time_to_live=${7:3600}
	records=${8:# List of records to be created depending on the type of record (set).}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_cdnprofile_info "Get Azure CDN profile facts" b
azure_rm_cdnprofile_info: >
	name=${1:# Limit results to a specific CDN profile.}
	resource_group=${2:# The resource group to search for the desired CDN profile.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_postgresqlserver_info "Get Azure PostgreSQL Server facts" b
azure_rm_postgresqlserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	name=${2:# The name of the server.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_hdinsightcluster "Manage Azure HDInsight Cluster instance" b
azure_rm_hdinsightcluster: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the cluster.}

	location=${3:# Resource location. If not set, location from the resource group will be used as default.}
	cluster_version=${4:# The version of the cluster. For example C(3.6).}
	os_type=${5:linux}
	tier=${6:standard|premium}
	cluster_definition=${7:# The cluster definition.}
	compute_profile_roles=${8:# The list of roles in the cluster.}
	storage_accounts=${9:# The list of storage accounts in the cluster.}
	state=${10:absent|#present}
	ad_user=${11:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${12:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${13:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${14:# Your Azure subscription Id.}
	client_id=${15:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${16:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${18:AzureCloud}
	adfs_authority_url=${19:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${20:ignore|validate}
	auth_source=${21:auto|cli|credential_file|env|msi}
	api_profile=${22:latest}
	tags=${23:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${24:yes}

endsnippet

snippet azure_rm_dnsrecordset_info "Get DNS Record Set facts" b
azure_rm_dnsrecordset_info: >
	relative_name=${1:# Only show results for a Record Set.}
	resource_group=${2:# Limit results by resource group. Required when filtering by name or type.}
	zone_name=${3:# Limit results by zones. Required when filtering by name or type.}
	record_type=${4:# Limit record sets by record type.}
	top=${5:# Limit the maximum number of record sets to return.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}
	tags=${18:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${19:yes}

endsnippet

snippet azure_rm_autoscale_info "Get Azure Auto Scale Setting facts" b
azure_rm_autoscale_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the Auto Scale Setting.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_galleryimageversion_info "Get Azure SIG Image Version info." b
azure_rm_galleryimageversion_info: >
	resource_group=${1:# The name of the resource group.}
	gallery_name=${2:# The name of the Shared Image Gallery in which the Image Definition resides.}
	gallery_image_name=${3:# The name of the gallery Image Definition in which the Image Version resides.}

	name=${4:# Resource name}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_loadbalancer_info "Get load balancer facts" b
azure_rm_loadbalancer_info: >
	name=${1:# Limit results to a specific resource group.}
	resource_group=${2:# The resource group to search for the desired load balancer.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_storageblob "Manage blob containers and blob objects" b
azure_rm_storageblob: >
	storage_account_name=${1:# Name of the storage account to use.}
	container=${2:# Name of a blob container within the storage account.}
	resource_group=${3:# Name of the resource group to use.}

	blob=${4:# Name of a blob object within the container.}
	blob_type=${5:#block|page}
	content_type=${6:# Set the blob content-type header. For example C(image/png).}
	cache_control=${7:# Set the blob cache-control header.}
	content_disposition=${8:# Set the blob content-disposition header.}
	content_encoding=${9:# Set the blob encoding header.}
	content_language=${10:# Set the blob content-language header.}
	content_md5=${11:# Set the blob md5 hash value.}
	dest=${12:# Destination file path. Use with state C(present) to download a blob.}
	force=${13:no}
	src=${14:# Source file path. Use with state C(present) to upload a blob.}
	state=${15:absent|#present}
	public_access=${16:container|blob}
	ad_user=${17:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${18:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${19:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${20:# Your Azure subscription Id.}
	client_id=${21:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${22:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${23:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${24:AzureCloud}
	adfs_authority_url=${25:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${26:ignore|validate}
	auth_source=${27:auto|cli|credential_file|env|msi}
	api_profile=${28:latest}
	tags=${29:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${30:yes}

endsnippet

snippet azure_rm_virtualmachinescalesetextension_info "Get Azure Virtual Machine Scale Set Extension facts" b
azure_rm_virtualmachinescalesetextension_info: >
	resource_group=${1:# The name of the resource group.}
	vmss_name=${2:# The name of VMSS containing the extension.}

	name=${3:# The name of the virtual machine extension.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_availabilityset_info "Get Azure Availability Set facts" b
azure_rm_availabilityset_info: >
	name=${1:# Limit results to a specific availability set.}
	resource_group=${2:# The resource group to search for the desired availability set.}
	tags=${3:# List of tags to be matched.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_manageddisk_info "Get managed disk facts" b
azure_rm_manageddisk_info: >
	name=${1:# Limit results to a specific managed disk.}
	resource_group=${2:# Limit results to a specific resource group.}
	tags=${3:# Limit results by providing a list of tags.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}
	append_tags=${16:yes}

endsnippet

snippet azure_rm_mysqlfirewallrule_info "Get Azure MySQL Firewall Rule facts" b
azure_rm_mysqlfirewallrule_info: >
	resource_group=${1:# The name of the resource group.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the server firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_rediscache "Manage Azure Cache for Redis instance" b
azure_rm_rediscache: >
	resource_group=${1:# Name of the resource group to which the resource belongs.}
	name=${2:# Unique name of the Azure Cache for Redis to create or update.}

	location=${3:# Resource location. If not set, location from the resource group will be used as default.}
	sku=${4:# SKU info of Azure Cache for Redis.}
	enable_non_ssl_port=${5:no}
	maxfragmentationmemory_reserved=${6:# Configures the amount of memory in MB that is reserved to accommodate for memory fragmentation.}
	maxmemory_reserved=${7:# Configures the amount of memory in MB that is reserved for non-cache operations.}
	maxmemory_policy=${8:volatile_lru|allkeys_lru|volatile_random|allkeys_random|volatile_ttl|noeviction}
	notify_keyspace_events=${9:# Allows clients to receive notifications when certain events occur.}
	shard_count=${10:# The number of shards to be created when I(sku=premium).}
	static_ip=${11:# Static IP address. Required when deploying an Azure Cache for Redis inside an existing Azure virtual network.}
	subnet=${12:# Subnet in a virtual network to deploy the Azure Cache for Redis in.}
	tenant_settings=${13:# Dict of tenant settings.}
	reboot=${14:# Reboot specified Redis node(s). There can be potential data loss.}
	regenerate_key=${15:# Regenerate Redis cache's access keys.}
	wait_for_provisioning=${16:yes}
	state=${17:absent|#present}
	ad_user=${18:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${19:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${20:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${21:# Your Azure subscription Id.}
	client_id=${22:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${23:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${24:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${25:AzureCloud}
	adfs_authority_url=${26:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${27:ignore|validate}
	auth_source=${28:auto|cli|credential_file|env|msi}
	api_profile=${29:latest}
	tags=${30:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${31:yes}

endsnippet

snippet azure_rm_route "Manage Azure route resource" b
azure_rm_route: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the route.}
	route_table_name=${3:# The name of the route table.}

	state=${4:absent|#present}
	address_prefix=${5:# The destination CIDR to which the route applies.}
	next_hop_type=${6:virtual_network_gateway|vnet_local|internet|virtual_appliance|#none}
	next_hop_ip_address=${7:# The IP address packets should be forwarded to.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_mysqldatabase_info "Get Azure MySQL Database facts" b
azure_rm_mysqldatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_functionapp "Manage Azure Function Apps" b
azure_rm_functionapp: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the Azure Function App.}
	storage_account=${3:# Name of the storage account to use.}

	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	plan=${5:# App service plan.}
	container_settings=${6:# W}
	app_settings=${7:# Dictionary containing application settings.}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_applicationsecuritygroup_info "Get Azure Application Security Group facts" b
azure_rm_applicationsecuritygroup_info: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the application security group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_deployment_info "Get Azure Deployment facts" b
azure_rm_deployment_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the deployment.}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}

endsnippet

snippet azure_rm_postgresqlfirewallrule_info "Get Azure PostgreSQL Firewall Rule facts" b
azure_rm_postgresqlfirewallrule_info: >
	resource_group=${1:# The name of the resource group.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the server firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_roleassignment_info "Gets Azure Role Assignment facts" b
azure_rm_roleassignment_info: >
	scope=${1:# The scope that the role assignment applies to.}
	name=${2:# Name of role assignment.}
	assignee=${3:# Object id of a user, group or service principal.}
	role_definition_id=${4:# Resource id of role definition.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_resourcegroup_info "Get resource group facts" b
azure_rm_resourcegroup_info: >
	name=${1:# Limit results to a specific resource group.}
	tags=${2:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	list_resources=${3:# List all resources under the resource group.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualmachinescalesetinstance_info "Get Azure Virtual Machine Scale Set Instance facts" b
azure_rm_virtualmachinescalesetinstance_info: >
	resource_group=${1:# The name of the resource group.}
	vmss_name=${2:# The name of the VM scale set.}

	instance_id=${3:# The instance ID of the virtual machine.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_postgresqlfirewallrule "Manage PostgreSQL firewall rule instance" b
azure_rm_postgresqlfirewallrule: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the PostgreSQL firewall rule.}

	start_ip_address=${4:# The start IP address of the PostgreSQL firewall rule. Must be IPv4 format.}
	end_ip_address=${5:# The end IP address of the PostgreSQL firewall rule. Must be IPv4 format.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_virtualnetwork "Manage Azure virtual networks" b
azure_rm_virtualnetwork: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the virtual network.}

	address_prefixes_cidr=${3:# List of IPv4 address ranges where each is formatted using CIDR notation.}
	dns_servers=${4:# Custom list of DNS servers. Maximum length of two.}
	location=${5:# Valid Azure location. Defaults to location of the resource group.}
	purge_address_prefixes=${6:no}
	purge_dns_servers=${7:no}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_servicebus "Manage Azure Service Bus" b
azure_rm_servicebus: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the servicebus namespace.}

	state=${3:absent|#present}
	location=${4:# The servicebus's location.}
	sku=${5:#standard|basic|premium}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}
	tags=${18:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${19:yes}

endsnippet

snippet azure_rm_automationaccount_info "Get Azure automation account facts" b
azure_rm_automationaccount_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the automation account.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	list_statistics=${4:# List statistics details for a automation account.}
	list_usages=${5:# List usage details for a automation account.}
	list_keys=${6:# List keys for a automation account.}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_devtestlabenvironment_info "Get Azure Environment facts" b
azure_rm_devtestlabenvironment_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	user_name=${3:# The name of the user profile.}

	name=${4:# The name of the environment.}
	tags=${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_iothub_info "Get IoT Hub facts" b
azure_rm_iothub_info: >
	name=${1:# Limit results to a specific resource group.}
	resource_group=${2:# The resource group to search for the desired IoT Hub.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	show_stats=${4:# Show the statistics for IoT Hub.}
	show_quota_metrics=${5:# Get the quota metrics for an IoT hub.}
	show_endpoint_health=${6:# Get the health for routing endpoints.}
	test_route_message=${7:# Test routes message. It will be used to test all routes.}
	list_consumer_groups=${8:# List the consumer group of the built-in event hub.}
	list_keys=${9:# List the keys of IoT Hub.}
	ad_user=${10:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${12:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${13:# Your Azure subscription Id.}
	client_id=${14:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${15:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${16:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${17:AzureCloud}
	adfs_authority_url=${18:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${19:ignore|validate}
	auth_source=${20:auto|cli|credential_file|env|msi}
	api_profile=${21:latest}

endsnippet

snippet azure_rm_securitygroup_info "Get security group facts" b
azure_rm_securitygroup_info: >
	resource_group=${1:# Name of the resource group to use.}

	name=${2:# Only show results for a specific security group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_devtestlabschedule_info "Get Azure Schedule facts" b
azure_rm_devtestlabschedule_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}

	name=${3:# The name of the schedule.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_snapshot "Manage Azure Snapshot instance." b
azure_rm_snapshot: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# Resource name}
	location=${3:# Resource location}
	sku=${4:# SKU}
	os_type=${5:Linux|Windows}
	creation_data=${6:# Disk source information. CreationData information cannot be changed after the disk has been created.}
	state=${7:absent|#present}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_mariadbfirewallrule "Manage MariaDB firewall rule instance" b
azure_rm_mariadbfirewallrule: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the MariaDB firewall rule.}

	start_ip_address=${4:# The start IP address of the MariaDB firewall rule. Must be IPv4 format.}
	end_ip_address=${5:# The end IP address of the MariaDB firewall rule. Must be IPv4 format.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_trafficmanagerendpoint_info "Get Azure Traffic Manager endpoint facts" b
azure_rm_trafficmanagerendpoint_info: >
	resource_group=${1:# The resource group to search for the desired Traffic Manager profile.}
	profile_name=${2:# Name of Traffic Manager Profile.}

	name=${3:# Limit results to a specific Traffic Manager endpoint.}
	type=${4:azure_endpoints|external_endpoints|nested_endpoints}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_mysqlconfiguration "Manage Configuration instance" b
azure_rm_mysqlconfiguration: >
	resource_group=${1:# The name of the resource group that contains the resource.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the server configuration.}

	value=${4:# Value of the configuration.}
	state=${5:absent|#present}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_virtualmachinescalesetinstance_info "Get Azure Virtual Machine Scale Set Instance facts" b
azure_rm_virtualmachinescalesetinstance_info: >
	resource_group=${1:# The name of the resource group.}
	vmss_name=${2:# The name of the VM scale set.}

	instance_id=${3:# The instance ID of the virtual machine.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_resourcegroup "Manage Azure resource groups" b
azure_rm_resourcegroup: >
	name=${1:# Name of the resource group.}

	force_delete_nonempty=${2:no}
	location=${3:# Azure location for the resource group. Required when creating a new resource group.}
	state=${4:absent|#present}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}
	tags=${17:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${18:yes}

endsnippet

snippet azure_rm_mysqlfirewallrule "Manage MySQL firewall rule instance" b
azure_rm_mysqlfirewallrule: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the MySQL firewall rule.}
	start_ip_address=${4:# The start IP address of the MySQL firewall rule. Must be IPv4 format.}
	end_ip_address=${5:# The end IP address of the MySQL firewall rule. Must be IPv4 format.}

	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_availabilityset "Manage Azure Availability Set" b
azure_rm_availabilityset: >
	resource_group=${1:# Name of a resource group where the availability set exists or will be created.}
	name=${2:# Name of the availability set.}

	state=${3:absent|#present}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	platform_update_domain_count=${5:5}
	platform_fault_domain_count=${6:3}
	sku=${7:#Classic|Aligned}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_containerinstance "Manage an Azure Container Instance" b
azure_rm_containerinstance: >
	resource_group=${1:# Name of resource group.}
	name=${2:# The name of the container group.}

	os_type=${3:#linux|windows}
	state=${4:absent|#present}
	ip_address=${5:public|#none}
	dns_name_label=${6:# The Dns name label for the IP.}
	ports=${7:# List of ports exposed within the container group.}
	location=${8:# Valid azure location. Defaults to location of the resource group.}
	registry_login_server=${9:# The container image registry login server.}
	registry_username=${10:# The username to log in container image registry server.}
	registry_password=${11:# The password to log in container image registry server.}
	containers=${12:# List of containers.}
	restart_policy=${13:always|on_failure|never}
	force_update=${14:no}
	ad_user=${15:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${16:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${17:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${18:# Your Azure subscription Id.}
	client_id=${19:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${20:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${21:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${22:AzureCloud}
	adfs_authority_url=${23:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${24:ignore|validate}
	auth_source=${25:auto|cli|credential_file|env|msi}
	api_profile=${26:latest}
	tags=${27:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${28:yes}

endsnippet

snippet azure_rm_devtestlabvirtualmachine "Manage Azure DevTest Lab Virtual Machine instance" b
azure_rm_devtestlabvirtualmachine: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	name=${3:# The name of the virtual machine.}

	notes=${4:# The notes of the virtual machine.}
	os_type=${5:windows|linux}
	vm_size=${6:# A valid Azure VM size value. For example, C(Standard_D4).}
	user_name=${7:# The user name of the virtual machine.}
	password=${8:# The password of the virtual machine administrator.}
	ssh_key=${9:# The SSH key of the virtual machine administrator.}
	lab_subnet=${10:# An existing subnet within lab's virtual network.}
	disallow_public_ip_address=${11:# Indicates whether the virtual machine is to be created without a public IP address.}
	artifacts=${12:# The artifacts to be installed on the virtual machine.}
	image=${13:# The Microsoft Azure Marketplace image reference of the virtual machine.}
	expiration_date=${14:# The expiration date for VM.}
	allow_claim=${15:# Indicates whether another user can take ownership of the virtual machine.}
	storage_type=${16:standard|premium}
	state=${17:absent|#present}
	ad_user=${18:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${19:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${20:# Your Azure subscription Id.}
	client_id=${21:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${22:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${23:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${24:AzureCloud}
	adfs_authority_url=${25:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${26:ignore|validate}
	auth_source=${27:auto|cli|credential_file|env|msi}
	api_profile=${28:latest}
	tags=${29:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${30:yes}

endsnippet

snippet azure_rm_mysqlserver_info "Get Azure MySQL Server facts" b
azure_rm_mysqlserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	name=${2:# The name of the server.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_sqldatabase_info "Get Azure SQL Database facts" b
azure_rm_sqldatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	elastic_pool_name=${4:# The name of the elastic pool.}
	tags=${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_mysqldatabase "Manage MySQL Database instance" b
azure_rm_mysqldatabase: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the database.}

	charset=${4:# The charset of the database. Check MySQL documentation for possible values.}
	collation=${5:# The collation of the database. Check MySQL documentation for possible values.}
	force_update=${6:no}
	state=${7:absent|#present}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_lock_info "Manage Azure locks" b
azure_rm_lock_info: >
	name=${1:# Name of the lock.}

	managed_resource_id=${2:# ID of the resource where need to manage the lock.}
	resource_group=${3:# Resource group name where need to manage the lock.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_containerregistry_info "Get Azure Container Registry facts" b
azure_rm_containerregistry_info: >
	resource_group=${1:# The name of the resource group to which the container registry belongs.}

	name=${2:# The name of the container registry.}
	retrieve_credentials=${3:no}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_devtestlabvirtualnetwork "Manage Azure DevTest Lab Virtual Network instance" b
azure_rm_devtestlabvirtualnetwork: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	name=${3:# The name of the virtual network.}

	location=${4:# The location of the resource.}
	description=${5:# The description of the virtual network.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}
	tags=${19:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${20:yes}

endsnippet

snippet azure_rm_postgresqlfirewallrule_info "Get Azure PostgreSQL Firewall Rule facts" b
azure_rm_postgresqlfirewallrule_info: >
	resource_group=${1:# The name of the resource group.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the server firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_aksversion_info "Get available kubernetes versions supported by Azure Kubernetes Service" b
azure_rm_aksversion_info: >
	location=${1:# Get the versions available for creating a managed Kubernetes cluster.}

	version=${2:# Get the upgrade versions available for a managed Kubernetes cluster version.}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}

endsnippet

snippet azure_rm_virtualmachine_info "Get virtual machine facts" b
azure_rm_virtualmachine_info: >
	resource_group=${1:# Name of the resource group containing the virtual machines (required when filtering by vm name).}
	name=${2:# Name of the virtual machine.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_functionapp_info "Get Azure Function App facts" b
azure_rm_functionapp_info: >
	name=${1:# Only show results for a specific Function App.}
	resource_group=${2:# Limit results to a resource group. Required when filtering by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_devtestlabartifact_info "Get Azure DevTest Lab Artifact facts" b
azure_rm_devtestlabartifact_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	artifact_source_name=${3:# The name of the artifact source.}

	name=${4:# The name of the artifact.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_mysqlconfiguration_info "Get Azure MySQL Configuration facts" b
azure_rm_mysqlconfiguration_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# Setting name.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_servicebustopic "Manage Azure Service Bus" b
azure_rm_servicebustopic: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the topic.}
	namespace=${3:# Servicebus namespace name.}

	state=${4:absent|#present}
	auto_delete_on_idle_in_seconds=${5:# Time idle interval after which a topic is automatically deleted.}
	default_message_time_to_live_seconds=${6:# Default message timespan to live value.}
	enable_batched_operations=${7:# Value that indicates whether server-side batched operations are enabled.}
	enable_express=${8:# Value that indicates whether Express Entities are enabled.}
	enable_partitioning=${9:# A value that indicates whether the topic is to be partitioned across multiple message brokers.}
	max_size_in_mb=${10:# The maximum size of the topic in megabytes, which is the size of memory allocated for the topic.}
	requires_duplicate_detection=${11:# A value indicating if this topic requires duplicate detection.}
	duplicate_detection_time_in_seconds=${12:# TimeSpan structure that defines the duration of the duplicate detection history.}
	support_ordering=${13:# Value that indicates whether the topic supports ordering.}
	status=${14:active|disabled|send_disabled|receive_disabled}
	ad_user=${15:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${16:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${17:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${18:# Your Azure subscription Id.}
	client_id=${19:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${20:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${21:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${22:AzureCloud}
	adfs_authority_url=${23:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${24:ignore|validate}
	auth_source=${25:auto|cli|credential_file|env|msi}
	api_profile=${26:latest}
	tags=${27:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${28:yes}

endsnippet

snippet azure_rm_mariadbdatabase_info "Get Azure MariaDB Database facts" b
azure_rm_mariadbdatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_containerinstance_info "Get Azure Container Instance facts" b
azure_rm_containerinstance_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the container instance.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_cdnprofile "Manage a Azure CDN profile" b
azure_rm_cdnprofile: >
	resource_group=${1:# Name of a resource group where the CDN profile exists or will be created.}
	name=${2:# Name of the CDN profile.}

	location=${3:# Valid Azure location. Defaults to location of the resource group.}
	sku=${4:standard_verizon|premium_verizon|custom_verizon|standard_akamai|standard_chinacdn|standard_microsoft}
	state=${5:absent|#present}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}
	tags=${18:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${19:yes}

endsnippet

snippet azure_rm_postgresqldatabase_info "Get Azure PostgreSQL Database facts" b
azure_rm_postgresqldatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualnetworkpeering "Manage Azure Virtual Network Peering" b
azure_rm_virtualnetworkpeering: >
	resource_group=${1:# Name of a resource group where the vnet exists.}
	name=${2:# Name of the virtual network peering.}
	virtual_network=${3:# Name or resource ID of the virtual network to be peered.}

	remote_virtual_network=${4:# Remote virtual network to be peered.}
	allow_virtual_network_access=${5:no}
	allow_forwarded_traffic=${6:no}
	use_remote_gateways=${7:no}
	allow_gateway_transit=${8:no}
	state=${9:absent|#present}
	ad_user=${10:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${12:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${13:# Your Azure subscription Id.}
	client_id=${14:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${15:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${16:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${17:AzureCloud}
	adfs_authority_url=${18:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${19:ignore|validate}
	auth_source=${20:auto|cli|credential_file|env|msi}
	api_profile=${21:latest}

endsnippet

snippet azure_rm_servicebustopicsubscription "Manage Azure Service Bus subscription" b
azure_rm_servicebustopicsubscription: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the servicebus subscription.}
	namespace=${3:# Servicebus namespace name.}
	topic=${4:# Topic name which the subscription subscribe to.}

	state=${5:absent|#present}
	auto_delete_on_idle_in_seconds=${6:# Time idle interval after which a subscription is automatically deleted.}
	dead_lettering_on_message_expiration=${7:# A value that indicates whether a subscription has dead letter support when a message expires.}
	dead_lettering_on_filter_evaluation_exceptions=${8:# Value that indicates whether a subscription has dead letter support on filter evaluation exceptions.}
	default_message_time_to_live_seconds=${9:# Default message timespan to live value.}
	enable_batched_operations=${10:# Value that indicates whether server-side batched operations are enabled.}
	forward_dead_lettered_messages_to=${11:# Queue or topic name to forward the Dead Letter message for a subscription.}
	forward_to=${12:# Queue or topic name to forward the messages for a subscription.}
	lock_duration_in_seconds=${13:# Timespan duration of a peek-lock.}
	max_delivery_count=${14:# he maximum delivery count.}
	requires_session=${15:# A value that indicates whether the subscription supports the concept of sessions.}
	duplicate_detection_time_in_seconds=${16:# TimeSpan structure that defines the duration of the duplicate detection history.}
	status=${17:active|disabled|send_disabled|receive_disabled}
	ad_user=${18:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${19:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${20:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${21:# Your Azure subscription Id.}
	client_id=${22:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${23:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${24:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${25:AzureCloud}
	adfs_authority_url=${26:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${27:ignore|validate}
	auth_source=${28:auto|cli|credential_file|env|msi}
	api_profile=${29:latest}
	tags=${30:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${31:yes}

endsnippet

snippet azure_rm_dnszone_info "Get DNS zone facts" b
azure_rm_dnszone_info: >
	resource_group=${1:# Limit results by resource group. Required when filtering by name.}
	name=${2:# Only show results for a specific zone.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}
	append_tags=${16:yes}

endsnippet

snippet azure_rm_mysqlfirewallrule_info "Get Azure MySQL Firewall Rule facts" b
azure_rm_mysqlfirewallrule_info: >
	resource_group=${1:# The name of the resource group.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the server firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_devtestlabcustomimage_info "Get Azure DevTest Lab Custom Image facts" b
azure_rm_devtestlabcustomimage_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}

	name=${3:# The name of the custom image.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_mysqlserver "Manage MySQL Server instance" b
azure_rm_mysqlserver: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	name=${2:# The name of the server.}

	sku=${3:# The SKU (pricing tier) of the server.}
	location=${4:# Resource location. If not set, location from the resource group will be used as default.}
	storage_mb=${5:# The maximum storage allowed for a server.}
	version=${6:5.6|5.7}
	enforce_ssl=${7:no}
	admin_username=${8:# The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).}
	admin_password=${9:# The password of the administrator login.}
	create_mode=${10:Default}
	state=${11:absent|#present}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_batchaccount "Manages a Batch Account on Azure." b
azure_rm_batchaccount: >
	resource_group=${1:# The name of the resource group in which to create the Batch Account.}
	name=${2:# The name of the Batch Account.}

	location=${3:# Specifies the supported Azure location where the resource exists.}
	auto_storage_account=${4:# Existing storage account with which to associate the Batch Account.}
	key_vault=${5:# Existing key vault with which to associate the Batch Account.}
	pool_allocation_mode=${6:#batch_service|user_subscription}
	state=${7:#present|absent}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_virtualmachine "Manage Azure virtual machines" b
azure_rm_virtualmachine: >
	resource_group=${1:# Name of the resource group containing the VM.}
	name=${2:# Name of the VM.}
	image=${3:# The image used to build the VM.}

	custom_data=${4:# Data made available to the VM and used by C(cloud-init).}
	state=${5:absent|#present}
	started=${6:yes}
	allocated=${7:yes}
	generalized=${8:# Whether the VM is generalized or not.}
	restarted=${9:# Set to C(true) with I(state=present) to restart a running VM.}
	location=${10:# Valid Azure location for the VM. Defaults to location of the resource group.}
	short_hostname=${11:# Name assigned internally to the host. On a Linux VM this is the name returned by the C(hostname) command.}
	vm_size=${12:# A valid Azure VM size value. For example, C(Standard_D4).}
	admin_username=${13:# Admin username used to access the VM after it is created.}
	admin_password=${14:# Password for the admin username.}
	ssh_password_enabled=${15:yes}
	ssh_public_keys=${16:# For I(os_type=Linux) provide a list of SSH keys.}
	availability_set=${17:# Name or ID of an existing availability set to add the VM to. The I(availability_set) should be in the same resource group as VM.}
	storage_account_name=${18:# Name of a storage account that supports creation of VHD blobs.}
	storage_container_name=${19:vhds}
	storage_blob_name=${20:# Name of the storage blob used to hold the OS disk image of the VM.}
	managed_disk_type=${21:Standard_LRS|StandardSSD_LRS|Premium_LRS}
	os_disk_name=${22:# OS disk name.}
	os_disk_caching=${23:#ReadOnly|ReadWrite}
	os_disk_size_gb=${24:# Type of OS disk size in GB.}
	os_type=${25:Windows|#Linux}
	data_disks=${26:# Describes list of data disks.}
	public_ip_allocation_method=${27:Dynamic|#Static|Disabled}
	open_ports=${28:# List of ports to open in the security group for the VM, when a security group and network interface are created with a VM.}
	network_interface_names=${29:# Network interface names to add to the VM.}
	virtual_network_resource_group=${30:# The resource group to use when creating a VM with another resource group's virtual network.}
	virtual_network_name=${31:# The virtual network to use when creating a VM.}
	subnet_name=${32:# Subnet for the VM.}
	remove_on_absent=${33:['all']}
	plan=${34:# Third-party billing plan for the VM.}
	accept_terms=${35:no}
	zones=${36:# A list of Availability Zones for your VM.}
	license_type=${37:Windows_Server|Windows_Client}
	vm_identity=${38:SystemAssigned}
	winrm=${39:# List of Windows Remote Management configurations of the VM.}
	boot_diagnostics=${40:# Manage boot diagnostics settings for a VM.}
	ad_user=${41:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${42:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${43:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${44:# Your Azure subscription Id.}
	client_id=${45:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${46:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${47:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${48:AzureCloud}
	adfs_authority_url=${49:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${50:ignore|validate}
	auth_source=${51:auto|cli|credential_file|env|msi}
	api_profile=${52:latest}
	tags=${53:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${54:yes}

endsnippet

snippet azure_rm_azurefirewall_info "Get AzureFirewall info." b
azure_rm_azurefirewall_info: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# Resource name.}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}

endsnippet

snippet azure_rm_keyvaultsecret "Use Azure KeyVault Secrets" b
azure_rm_keyvaultsecret: >
	keyvault_uri=${1:# URI of the keyvault endpoint.}
	secret_name=${2:# Name of the keyvault secret.}

	secret_value=${3:# Secret to be secured by keyvault.}
	state=${4:absent|#present}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}
	tags=${17:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${18:yes}

endsnippet

snippet azure_rm_postgresqldatabase "Manage PostgreSQL Database instance" b
azure_rm_postgresqldatabase: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the database.}

	charset=${4:# The charset of the database. Check PostgreSQL documentation for possible values.}
	collation=${5:# The collation of the database. Check PostgreSQL documentation for possible values.}
	force_update=${6:no}
	state=${7:absent|#present}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_virtualnetworkgateway "Manage Azure virtual network gateways" b
azure_rm_virtualnetworkgateway: >
	resource_group=${1:# Name of a resource group where VPN Gateway exists or will be created.}
	name=${2:# Name of VPN Gateway.}
	virtual_network=${3:# An existing virtual network with which the VPN Gateway will be associated.}

	state=${4:absent|#present}
	location=${5:# Valid Azure location. Defaults to location of the resource group.}
	ip_configurations=${6:# List of IP configurations.}
	gateway_type=${7:#vpn|express_route}
	vpn_type=${8:#route_based|policy_based}
	enable_bgp=${9:no}
	sku=${10:#VpnGw1|VpnGw2|VpnGw3}
	bgp_settings=${11:# Virtual network gateway's BGP speaker settings.}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_mariadbconfiguration "Manage Configuration instance" b
azure_rm_mariadbconfiguration: >
	resource_group=${1:# The name of the resource group that contains the resource.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the server configuration.}

	value=${4:# Value of the configuration.}
	state=${5:absent|#present}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_devtestlabenvironment_info "Get Azure Environment facts" b
azure_rm_devtestlabenvironment_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	user_name=${3:# The name of the user profile.}

	name=${4:# The name of the environment.}
	tags=${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_keyvault_info "Get Azure Key Vault facts" b
azure_rm_keyvault_info: >
	resource_group=${1:# The name of the resource group to which the key vault belongs.}
	name=${2:# The name of the key vault.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_roledefinition_info "Get Azure Role Definition facts" b
azure_rm_roledefinition_info: >
	scope=${1:# The scope of role definition.}

	id=${2:# Role definition id.}
	role_name=${3:# Role name.}
	type=${4:system|custom}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_devtestlab_info "Get Azure DevTest Lab facts" b
azure_rm_devtestlab_info: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the lab.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_iotdevice_info "Facts of Azure IoT hub device" b
azure_rm_iotdevice_info: >
	hub=${1:# Name of IoT Hub.}
	hub_policy_name=${2:# Policy name of the IoT Hub which will be used to query from IoT hub.}
	hub_policy_key=${3:# Key of the I(hub_policy_name).}

	name=${4:# Name of the IoT hub device identity.}
	module_id=${5:# Name of the IoT hub device module.}
	query=${6:# Query an IoT hub to retrieve information regarding device twins using a SQL-like language.}
	top=${7:# Used when I(name) not defined.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_virtualmachineextension "Managed Azure Virtual Machine extension" b
azure_rm_virtualmachineextension: >
	resource_group=${1:# Name of a resource group where the vm extension exists or will be created.}
	name=${2:# Name of the vm extension.}

	state=${3:absent|#present}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	virtual_machine_name=${5:# The name of the virtual machine where the extension should be create or updated.}
	publisher=${6:# The name of the extension handler publisher.}
	virtual_machine_extension_type=${7:# The type of the extension handler.}
	type_handler_version=${8:# The type version of the extension handler.}
	settings=${9:# Json formatted public settings for the extension.}
	protected_settings=${10:# Json formatted protected settings for the extension.}
	auto_upgrade_minor_version=${11:# Whether the extension handler should be automatically upgraded across minor versions.}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}

endsnippet

snippet azure_rm_appserviceplan_info "Get azure app service plan facts" b
azure_rm_appserviceplan_info: >
	name=${1:# Only show results for a specific app service plan.}
	resource_group=${2:# Limit results by resource group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_aks_info "Get Azure Kubernetes Service facts" b
azure_rm_aks_info: >
	name=${1:# Limit results to a specific resource group.}
	resource_group=${2:# The resource group to search for the desired Azure Kubernetes Service}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	show_kubeconfig=${4:user|admin}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_routetable "Manage Azure route table resource" b
azure_rm_routetable: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the route table.}

	state=${3:absent|#present}
	disable_bgp_route_propagation=${4:no}
	location=${5:# Region of the resource.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}
	tags=${18:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${19:yes}

endsnippet

snippet azure_rm_sqlfirewallrule "Manage Firewall Rule instance" b
azure_rm_sqlfirewallrule: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the firewall rule.}

	start_ip_address=${4:# The start IP address of the firewall rule.}
	end_ip_address=${5:# The end IP address of the firewall rule.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_galleryimageversion "Manage Azure SIG Image Version instance." b
azure_rm_galleryimageversion: >
	resource_group=${1:# The name of the resource group.}
	gallery_name=${2:# The name of the Shared Image Gallery in which the Image Definition resides.}
	gallery_image_name=${3:# The name of the gallery Image Definition in which the Image Version is to be created.}
	name=${4:# The name of the gallery Image Version to be created. Needs to follow semantic version name pattern: The allowed characters are digit and period. Digits must be within the range of a 32-bit integer. Format: <MajorVersion>.<MinorVersion>.<Patch>}
	publishing_profile=${5:# Publishing profile.}

	location=${6:# Resource location}
	state=${7:absent|#present}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_aks_info "Get Azure Kubernetes Service facts" b
azure_rm_aks_info: >
	name=${1:# Limit results to a specific resource group.}
	resource_group=${2:# The resource group to search for the desired Azure Kubernetes Service}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	show_kubeconfig=${4:user|admin}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_webapp_info "Get Azure web app facts" b
azure_rm_webapp_info: >
	name=${1:# Only show results for a specific web app.}
	resource_group=${2:# Limit results by resource group.}
	return_publish_profile=${3:no}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_subnet_info "Get Azure Subnet facts" b
azure_rm_subnet_info: >
	resource_group=${1:# The name of the resource group.}
	virtual_network_name=${2:# The name of the virtual network.}

	name=${3:# The name of the subnet.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualmachinescaleset_info "Get Virtual Machine Scale Set facts" b
azure_rm_virtualmachinescaleset_info: >
	name=${1:# Limit results to a specific virtual machine scale set.}
	resource_group=${2:# The resource group to search for the desired virtual machine scale set.}
	tags=${3:# List of tags to be matched.}
	format=${4:curated|#raw}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_manageddisk "Manage Azure Manage Disks" b
azure_rm_manageddisk: >
	resource_group=${1:# Name of a resource group where the managed disk exists or will be created.}
	name=${2:# Name of the managed disk.}

	state=${3:absent|#present}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	storage_account_type=${5:Standard_LRS|StandardSSD_LRS|Premium_LRS|UltraSSD_LRS}
	create_option=${6:empty|import|copy}
	source_uri=${7:# URI to a valid VHD file to be used or the resource ID of the managed disk to copy.}
	os_type=${8:linux|windows}
	disk_size_gb=${9:# Size in GB of the managed disk to be created.}
	managed_by=${10:# Name of an existing virtual machine with which the disk is or will be associated, this VM should be in the same resource group.}
	attach_caching=${11:|read_only|read_write}
	tags=${12:# Tags to assign to the managed disk.}
	zone=${13:1|2|3|}
	ad_user=${14:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${15:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${16:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${17:# Your Azure subscription Id.}
	client_id=${18:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${19:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${20:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${21:AzureCloud}
	adfs_authority_url=${22:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${23:ignore|validate}
	auth_source=${24:auto|cli|credential_file|env|msi}
	api_profile=${25:latest}
	append_tags=${26:yes}

endsnippet

snippet azure_rm_azurefirewall "Manage Azure Firewall instance." b
azure_rm_azurefirewall: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the Azure Firewall.}

	location=${3:# Resource location.}
	application_rule_collections=${4:# Collection of application rule collections used by Azure Firewall.}
	nat_rule_collections=${5:# Collection of NAT rule collections used by Azure Firewall.}
	network_rule_collections=${6:# Collection of network rule collections used by Azure Firewall.}
	ip_configurations=${7:# IP configuration of the Azure Firewall resource.}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_postgresqlconfiguration "Manage Azure PostgreSQL Configuration" b
azure_rm_postgresqlconfiguration: >
	resource_group=${1:# The name of the resource group that contains the resource.}
	server_name=${2:# The name of the server.}
	name=${3:# Setting name.}

	value=${4:# Setting value.}
	state=${5:absent|#present}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_devtestlabschedule_info "Get Azure Schedule facts" b
azure_rm_devtestlabschedule_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}

	name=${3:# The name of the schedule.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_devtestlabarmtemplate_info "Get Azure DevTest Lab ARM Template facts" b
azure_rm_devtestlabarmtemplate_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	artifact_source_name=${3:# The name of the artifact source.}

	name=${4:# The name of the ARM template.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_cdnendpoint "Manage a Azure CDN endpoint" b
azure_rm_cdnendpoint: >
	resource_group=${1:# Name of a resource group where the Azure CDN endpoint exists or will be created.}
	name=${2:# Name of the Azure CDN endpoint.}
	profile_name=${3:# Name of the CDN profile where the endpoint attached to.}
	origins=${4:# Set of source of the content being delivered via CDN.}

	location=${5:# Valid azure location. Defaults to location of the resource group.}
	started=${6:# Use with I(state=present) to start the endpoint.}
	purge=${7:no}
	purge_content_paths=${8:['/']}
	origin_host_header=${9:# The host header value sent to the origin with each request.}
	origin_path=${10:# A directory path on the origin that CDN can use to retrieve content from.}
	content_types_to_compress=${11:# List of content types on which compression applies.}
	is_compression_enabled=${12:no}
	is_http_allowed=${13:yes}
	is_https_allowed=${14:yes}
	query_string_caching_behavior=${15:#ignore_query_string|bypass_caching|use_query_string|not_set}
	state=${16:absent|#present}
	ad_user=${17:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${18:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${19:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${20:# Your Azure subscription Id.}
	client_id=${21:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${22:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${23:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${24:AzureCloud}
	adfs_authority_url=${25:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${26:ignore|validate}
	auth_source=${27:auto|cli|credential_file|env|msi}
	api_profile=${28:latest}
	tags=${29:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${30:yes}

endsnippet

snippet azure_rm_securitygroup_info "Get security group facts" b
azure_rm_securitygroup_info: >
	resource_group=${1:# Name of the resource group to use.}

	name=${2:# Only show results for a specific security group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_devtestlabvirtualmachine_info "Get Azure DevTest Lab Virtual Machine facts" b
azure_rm_devtestlabvirtualmachine_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}

	name=${3:# The name of the virtual machine.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_devtestlabcustomimage "Manage Azure DevTest Lab Custom Image instance" b
azure_rm_devtestlabcustomimage: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	name=${3:# The name of the custom image.}

	source_vm=${4:# Source DevTest Lab virtual machine name.}
	windows_os_state=${5:non_sysprepped|sysprep_requested|sysprep_applied}
	linux_os_state=${6:non_deprovisioned|deprovision_requested|deprovision_applied}
	description=${7:# The description of the custom image.}
	author=${8:# The author of the custom image.}
	state=${9:absent|#present}
	ad_user=${10:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${12:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${13:# Your Azure subscription Id.}
	client_id=${14:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${15:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${16:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${17:AzureCloud}
	adfs_authority_url=${18:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${19:ignore|validate}
	auth_source=${20:auto|cli|credential_file|env|msi}
	api_profile=${21:latest}
	tags=${22:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${23:yes}

endsnippet

snippet azure_rm_keyvaultkey_info "Get Azure Key Vault key facts." b
azure_rm_keyvaultkey_info: >
	vault_uri=${1:# Vault uri where the key stored in.}

	name=${2:# Key name. If not set, will list all keys in vault_uri.}
	version=${3:current}
	show_deleted_key=${4:no}
	tags=${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_postgresqldatabase_info "Get Azure PostgreSQL Database facts" b
azure_rm_postgresqldatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_mariadbconfiguration_info "Get Azure MariaDB Configuration facts" b
azure_rm_mariadbconfiguration_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# Setting name.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_devtestlabpolicy_info "Get Azure DTL Policy facts" b
azure_rm_devtestlabpolicy_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	policy_set_name=${3:# The name of the policy set.}

	name=${4:# The name of the policy.}
	tags=${5:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_trafficmanagerprofile_info "Get Azure Traffic Manager profile facts" b
azure_rm_trafficmanagerprofile_info: >
	name=${1:# Limit results to a specific Traffic Manager profile.}
	resource_group=${2:# The resource group to search for the desired Traffic Manager profile.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_loganalyticsworkspace_info "Get facts of Azure Log Analytics workspaces" b
azure_rm_loganalyticsworkspace_info: >
	resource_group=${1:# Name of resource group.}

	name=${2:# Name of the workspace.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	show_intelligence_packs=${4:# Show the intelligence packs for a workspace.}
	show_management_groups=${5:# Show the management groups for a workspace.}
	show_shared_keys=${6:# Show the shared keys for a workspace.}
	show_usages=${7:# Show the list of usages for a workspace.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_cosmosdbaccount "Manage Azure Database Account instance" b
azure_rm_cosmosdbaccount: >
	resource_group=${1:# Name of an Azure resource group.}
	name=${2:# Cosmos DB database account name.}

	location=${3:# The location of the resource group to which the resource belongs.}
	kind=${4:global_document_db|mongo_db|parse}
	consistency_policy=${5:# The consistency policy for the Cosmos DB account.}
	geo_rep_locations=${6:# An array that contains the georeplication locations enabled for the Cosmos DB account.}
	database_account_offer_type=${7:# Database account offer type, for example I(Standard)}
	ip_range_filter=${8:# Cosmos DB Firewall support. This value specifies the set of IP addresses or IP address ranges.}
	is_virtual_network_filter_enabled=${9:# Flag to indicate whether to enable/disable Virtual Network ACL rules.}
	enable_automatic_failover=${10:# Enables automatic failover of the write region in the rare event that the region is unavailable due to an outage.}
	enable_cassandra=${11:# Enable Cassandra.}
	enable_table=${12:# Enable Table.}
	enable_gremlin=${13:# Enable Gremlin.}
	virtual_network_rules=${14:# List of Virtual Network ACL rules configured for the Cosmos DB account.}
	enable_multiple_write_locations=${15:# Enables the account to write in multiple locations}
	state=${16:absent|#present}
	ad_user=${17:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${18:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${19:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${20:# Your Azure subscription Id.}
	client_id=${21:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${22:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${23:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${24:AzureCloud}
	adfs_authority_url=${25:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${26:ignore|validate}
	auth_source=${27:auto|cli|credential_file|env|msi}
	api_profile=${28:latest}
	tags=${29:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${30:yes}

endsnippet

snippet azure_rm_dnsrecordset_info "Get DNS Record Set facts" b
azure_rm_dnsrecordset_info: >
	relative_name=${1:# Only show results for a Record Set.}
	resource_group=${2:# Limit results by resource group. Required when filtering by name or type.}
	zone_name=${3:# Limit results by zones. Required when filtering by name or type.}
	record_type=${4:# Limit record sets by record type.}
	top=${5:# Limit the maximum number of record sets to return.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}
	tags=${18:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${19:yes}

endsnippet

snippet azure_rm_virtualmachine_info "Get virtual machine facts" b
azure_rm_virtualmachine_info: >
	resource_group=${1:# Name of the resource group containing the virtual machines (required when filtering by vm name).}
	name=${2:# Name of the virtual machine.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualmachinescalesetextension_info "Get Azure Virtual Machine Scale Set Extension facts" b
azure_rm_virtualmachinescalesetextension_info: >
	resource_group=${1:# The name of the resource group.}
	vmss_name=${2:# The name of VMSS containing the extension.}

	name=${3:# The name of the virtual machine extension.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_mariadbfirewallrule_info "Get Azure MariaDB Firewall Rule facts" b
azure_rm_mariadbfirewallrule_info: >
	resource_group=${1:# The name of the resource group.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the server firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_networkinterface_info "Get network interface facts" b
azure_rm_networkinterface_info: >
	name=${1:# Only show results for a specific network interface.}
	resource_group=${2:# Name of the resource group containing the network interface(s). Required when searching by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualmachineextension_info "Get Azure Virtual Machine Extension facts" b
azure_rm_virtualmachineextension_info: >
	resource_group=${1:# The name of the resource group.}
	virtual_machine_name=${2:# The name of the virtual machine containing the extension.}

	name=${3:# The name of the virtual machine extension.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_virtualmachinescaleset "Manage Azure virtual machine scale sets" b
azure_rm_virtualmachinescaleset: >
	resource_group=${1:# Name of the resource group containing the virtual machine scale set.}
	name=${2:# Name of the virtual machine.}
	image=${3:# Specifies the image used to build the VM.}

	state=${4:absent|#present}
	location=${5:# Valid Azure location. Defaults to location of the resource group.}
	short_hostname=${6:# Short host name.}
	vm_size=${7:# A valid Azure VM size value. For example, C(Standard_D4).}
	capacity=${8:1}
	tier=${9:Basic|Standard}
	upgrade_policy=${10:Manual|Automatic}
	admin_username=${11:# Admin username used to access the host after it is created. Required when creating a VM.}
	admin_password=${12:# Password for the admin username.}
	ssh_password_enabled=${13:yes}
	ssh_public_keys=${14:# For I(os_type=Linux) provide a list of SSH keys.}
	os_disk_caching=${15:#ReadOnly|ReadWrite}
	os_type=${16:Windows|#Linux}
	managed_disk_type=${17:Standard_LRS|Premium_LRS}
	data_disks=${18:# Describes list of data disks.}
	virtual_network_resource_group=${19:# When creating a virtual machine, if a specific virtual network from another resource group should be used.}
	virtual_network_name=${20:# Virtual Network name.}
	subnet_name=${21:# Subnet name.}
	load_balancer=${22:# Load balancer name.}
	application_gateway=${23:# Application gateway name.}
	remove_on_absent=${24:['all']}
	enable_accelerated_networking=${25:# Indicates whether user wants to allow accelerated networking for virtual machines in scaleset being created.}
	security_group=${26:# Existing security group with which to associate the subnet.}
	overprovision=${27:yes}
	single_placement_group=${28:yes}
	zones=${29:# A list of Availability Zones for your virtual machine scale set.}
	custom_data=${30:# Data which is made available to the virtual machine and used by e.g., C(cloud-init).}
	ad_user=${31:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${32:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${33:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${34:# Your Azure subscription Id.}
	client_id=${35:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${36:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${37:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${38:AzureCloud}
	adfs_authority_url=${39:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${40:ignore|validate}
	auth_source=${41:auto|cli|credential_file|env|msi}
	api_profile=${42:latest}
	tags=${43:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${44:yes}

endsnippet

snippet azure_rm_loganalyticsworkspace_info "Get facts of Azure Log Analytics workspaces" b
azure_rm_loganalyticsworkspace_info: >
	resource_group=${1:# Name of resource group.}

	name=${2:# Name of the workspace.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	show_intelligence_packs=${4:# Show the intelligence packs for a workspace.}
	show_management_groups=${5:# Show the management groups for a workspace.}
	show_shared_keys=${6:# Show the shared keys for a workspace.}
	show_usages=${7:# Show the list of usages for a workspace.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_mariadbconfiguration_info "Get Azure MariaDB Configuration facts" b
azure_rm_mariadbconfiguration_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# Setting name.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_mariadbfirewallrule_info "Get Azure MariaDB Firewall Rule facts" b
azure_rm_mariadbfirewallrule_info: >
	resource_group=${1:# The name of the resource group.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the server firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_devtestlabartifactsource_info "Get Azure DevTest Lab Artifact Source facts" b
azure_rm_devtestlabartifactsource_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of DevTest Lab.}

	name=${3:# The name of DevTest Lab Artifact Source.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_mariadbserver_info "Get Azure MariaDB Server facts" b
azure_rm_mariadbserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	name=${2:# The name of the server.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_mariadbserver "Manage MariaDB Server instance" b
azure_rm_mariadbserver: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	name=${2:# The name of the server.}

	sku=${3:# The SKU (pricing tier) of the server.}
	location=${4:# Resource location. If not set, location from the resource group will be used as default.}
	storage_mb=${5:# The maximum storage allowed for a server.}
	version=${6:10.2}
	enforce_ssl=${7:no}
	admin_username=${8:# The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).}
	admin_password=${9:# The password of the administrator login.}
	create_mode=${10:Default}
	state=${11:absent|#present}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_trafficmanagerendpoint "Manage Azure Traffic Manager endpoint" b
azure_rm_trafficmanagerendpoint: >
	resource_group=${1:# Name of a resource group where the Traffic Manager endpoint exists or will be created.}
	name=${2:# The name of the endpoint.}
	profile_name=${3:# Name of Traffic Manager profile where this endpoints attaches to.}
	type=${4:azure_endpoints|external_endpoints|nested_endpoints}

	target_resource_id=${5:# The Azure Resource URI of the of the endpoint.}
	target=${6:# The fully-qualified DNS name of the endpoint.}
	enabled=${7:yes}
	weight=${8:# The weight of this endpoint when traffic manager profile has routing_method of C(weighted).}
	priority=${9:# The priority of this endpoint when traffic manager profile has routing_method of I(priority).}
	location=${10:# Specifies the location of the external or nested endpoints when using the 'Performance' traffic routing method.}
	min_child_endpoints=${11:# The minimum number of endpoints that must be available in the child profile in order for the parent profile to be considered available.}
	geo_mapping=${12:# The list of countries/regions mapped to this endpoint when traffic manager profile has routing_method of C(geographic).}
	state=${13:absent|#present}
	ad_user=${14:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${15:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${16:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${17:# Your Azure subscription Id.}
	client_id=${18:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${19:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${20:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${21:AzureCloud}
	adfs_authority_url=${22:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${23:ignore|validate}
	auth_source=${24:auto|cli|credential_file|env|msi}
	api_profile=${25:latest}

endsnippet

snippet azure_rm_image_info "Get facts about azure custom images" b
azure_rm_image_info: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the image to filter from existing images.}
	tags=${3:# List of tags to be matched.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_iothub "Manage Azure IoT hub" b
azure_rm_iothub: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the IoT hub.}

	state=${3:absent|#present}
	location=${4:# Location of the IoT hub.}
	sku=${5:b1|b2|b3|f1|s1|s2|s3}
	unit=${6:# Units in your IoT Hub.}
	event_endpoint=${7:# The Event Hub-compatible endpoint property.}
	enable_file_upload_notifications=${8:# File upload notifications are enabled if set to C(True).}
	ip_filters=${9:# Configure rules for rejecting or accepting traffic from specific IPv4 addresses.}
	routing_endpoints=${10:# Custom endpoints.}
	routes=${11:# Route device-to-cloud messages to service-facing endpoints.}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_rediscache_info "Get Azure Cache for Redis instance facts" b
azure_rm_rediscache_info: >
	resource_group=${1:# The resource group to search for the desired Azure Cache for Redis.}

	name=${2:# Limit results to a specific Azure Cache for Redis.}
	return_access_keys=${3:no}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_appgateway "Manage Application Gateway instance" b
azure_rm_appgateway: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the application gateway.}

	location=${3:# Resource location. If not set, location from the resource group will be used as default.}
	sku=${4:# SKU of the application gateway resource.}
	ssl_policy=${5:# SSL policy of the application gateway resource.}
	gateway_ip_configurations=${6:# List of subnets used by the application gateway.}
	authentication_certificates=${7:# Authentication certificates of the application gateway resource.}
	redirect_configurations=${8:# Redirect configurations of the application gateway resource.}
	ssl_certificates=${9:# SSL certificates of the application gateway resource.}
	frontend_ip_configurations=${10:# Frontend IP addresses of the application gateway resource.}
	frontend_ports=${11:# List of frontend ports of the application gateway resource.}
	backend_address_pools=${12:# List of backend address pool of the application gateway resource.}
	probes=${13:# Probes available to the application gateway resource.}
	backend_http_settings_collection=${14:# Backend http settings of the application gateway resource.}
	http_listeners=${15:# List of HTTP listeners of the application gateway resource.}
	request_routing_rules=${16:# List of request routing rules of the application gateway resource.}
	state=${17:absent|#present}
	ad_user=${18:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${19:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${20:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${21:# Your Azure subscription Id.}
	client_id=${22:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${23:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${24:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${25:AzureCloud}
	adfs_authority_url=${26:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${27:ignore|validate}
	auth_source=${28:auto|cli|credential_file|env|msi}
	api_profile=${29:latest}
	tags=${30:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${31:yes}

endsnippet

snippet azure_rm_cosmosdbaccount_info "Get Azure Cosmos DB Account facts" b
azure_rm_cosmosdbaccount_info: >
	resource_group=${1:# Name of an Azure resource group.}
	name=${2:# Cosmos DB database account name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	retrieve_keys=${4:all|readonly}
	retrieve_connection_strings=${5:# Retrieve connection strings.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_cdnprofile_info "Get Azure CDN profile facts" b
azure_rm_cdnprofile_info: >
	name=${1:# Limit results to a specific CDN profile.}
	resource_group=${2:# The resource group to search for the desired CDN profile.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_mariadbserver_info "Get Azure MariaDB Server facts" b
azure_rm_mariadbserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	name=${2:# The name of the server.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_iotdevice "Manage Azure IoT hub device" b
azure_rm_iotdevice: >
	hub=${1:# Name of IoT Hub.}
	hub_policy_name=${2:# Policy name of the IoT Hub which will be used to query from IoT hub.}
	hub_policy_key=${3:# Key of the I(hub_policy_name).}
	name=${4:# Name of the IoT hub device identity.}

	state=${5:absent|#present}
	auth_method=${6:#sas|certificate_authority|self_signed}
	primary_key=${7:# Explicit self-signed certificate thumbprint to use for primary key.}
	secondary_key=${8:# Explicit self-signed certificate thumbprint to use for secondary key.}
	status=${9:# Set device status upon creation.}
	edge_enabled=${10:# Flag indicating edge enablement.}
	twin_tags=${11:# A section that the solution back end can read from and write to.}
	desired=${12:# Used along with reported properties to synchronize device configuration or conditions.}
	ad_user=${13:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${15:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${16:# Your Azure subscription Id.}
	client_id=${17:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${18:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${19:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${20:AzureCloud}
	adfs_authority_url=${21:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${22:ignore|validate}
	auth_source=${23:auto|cli|credential_file|env|msi}
	api_profile=${24:latest}
	tags=${25:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${26:yes}

endsnippet

snippet azure_rm_image_info "Get facts about azure custom images" b
azure_rm_image_info: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the image to filter from existing images.}
	tags=${3:# List of tags to be matched.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_deployment "Create or destroy Azure Resource Manager template deployments" b
azure_rm_deployment: >
	resource_group=${1:# The resource group name to use or create to host the deployed template.}

	name=${2:ansible-arm}
	location=${3:westus}
	deployment_mode=${4:complete|#incremental}
	template=${5:# A hash containing the templates inline. This parameter is mutually exclusive with I(template_link).}
	template_link=${6:# Uri of file containing the template body. This parameter is mutually exclusive with I(template).}
	parameters=${7:# A hash of all the required template variables for the deployment template. This parameter is mutually exclusive with I(parameters_link).}
	parameters_link=${8:# Uri of file containing the parameters body. This parameter is mutually exclusive with I(parameters).}
	wait_for_deployment_completion=${9:yes}
	wait_for_deployment_polling_period=${10:10}
	state=${11:#present|absent}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_virtualmachineimage_info "Get virtual machine image facts" b
azure_rm_virtualmachineimage_info: >
	location=${1:# Azure location value, for example C(westus), C(eastus), C(eastus2), C(northcentralus), etc.}

	publisher=${2:# Name of an image publisher. List image offerings associated with a particular publisher.}
	offer=${3:# Name of an image offering. Combine with SKU to see a list of available image versions.}
	sku=${4:# Image offering SKU. Combine with offer to see a list of available versions.}
	version=${5:# Specific version number of an image.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_subnet "Manage Azure subnets" b
azure_rm_subnet: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the subnet.}
	virtual_network_name=${3:# Name of an existing virtual network with which the subnet is or will be associated.}

	address_prefix_cidr=${4:# CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network.}
	security_group=${5:# Existing security group with which to associate the subnet.}
	state=${6:absent|#present}
	route_table=${7:# The reference of the RouteTable resource.}
	service_endpoints=${8:# An array of service endpoints.}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}

endsnippet

snippet azure_rm_resource_info "Generic facts of Azure resources" b
azure_rm_resource_info: >
	url=${1:# Azure RM Resource URL.}
	api_version=${2:# Specific API version to be used.}
	provider=${3:# Provider type, should be specified in no URL is given.}
	resource_group=${4:# Resource group to be used.}
	resource_type=${5:# Resource type.}
	resource_name=${6:# Resource name.}
	subresource=${7:# List of subresources.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_virtualnetwork_info "Get virtual network facts" b
azure_rm_virtualnetwork_info: >
	name=${1:# Only show results for a specific security group.}
	resource_group=${2:# Limit results by resource group. Required when filtering by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_publicipaddress_info "Get public IP facts" b
azure_rm_publicipaddress_info: >
	name=${1:# Only show results for a specific Public IP.}
	resource_group=${2:# Limit results by resource group. Required when using name parameter.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_devtestlabcustomimage_info "Get Azure DevTest Lab Custom Image facts" b
azure_rm_devtestlabcustomimage_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}

	name=${3:# The name of the custom image.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_virtualmachinescaleset_info "Get Virtual Machine Scale Set facts" b
azure_rm_virtualmachinescaleset_info: >
	name=${1:# Limit results to a specific virtual machine scale set.}
	resource_group=${2:# The resource group to search for the desired virtual machine scale set.}
	tags=${3:# List of tags to be matched.}
	format=${4:curated|#raw}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_dnszone_info "Get DNS zone facts" b
azure_rm_dnszone_info: >
	resource_group=${1:# Limit results by resource group. Required when filtering by name.}
	name=${2:# Only show results for a specific zone.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}
	append_tags=${16:yes}

endsnippet

snippet azure_rm_roleassignment_info "Gets Azure Role Assignment facts" b
azure_rm_roleassignment_info: >
	scope=${1:# The scope that the role assignment applies to.}
	name=${2:# Name of role assignment.}
	assignee=${3:# Object id of a user, group or service principal.}
	role_definition_id=${4:# Resource id of role definition.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_routetable_info "Get route table facts" b
azure_rm_routetable_info: >
	name=${1:# Limit results to a specific route table.}
	resource_group=${2:# Limit results in a specific resource group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_appserviceplan "Manage App Service Plan" b
azure_rm_appserviceplan: >
	resource_group=${1:# Name of the resource group to which the resource belongs.}
	name=${2:# Unique name of the app service plan to create or update.}

	location=${3:# Resource location. If not set, location from the resource group will be used as default.}
	sku=${4:# The pricing tiers, e.g., C(F1), C(D1), C(B1), C(B2), C(B3), C(S1), C(P1), C(P1V2) etc.}
	is_linux=${5:no}
	number_of_workers=${6:# Describe number of workers to be allocated.}
	state=${7:absent|#present}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_devtestlabarmtemplate_info "Get Azure DevTest Lab ARM Template facts" b
azure_rm_devtestlabarmtemplate_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	artifact_source_name=${3:# The name of the artifact source.}

	name=${4:# The name of the ARM template.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_lock_info "Manage Azure locks" b
azure_rm_lock_info: >
	name=${1:# Name of the lock.}

	managed_resource_id=${2:# ID of the resource where need to manage the lock.}
	resource_group=${3:# Resource group name where need to manage the lock.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualnetwork_info "Get virtual network facts" b
azure_rm_virtualnetwork_info: >
	name=${1:# Only show results for a specific security group.}
	resource_group=${2:# Limit results by resource group. Required when filtering by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_sqlfirewallrule_info "Get Azure SQL Firewall Rule facts" b
azure_rm_sqlfirewallrule_info: >
	resource_group=${1:# The name of the resource group that contains the server.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_mysqlconfiguration_info "Get Azure MySQL Configuration facts" b
azure_rm_mysqlconfiguration_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# Setting name.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_roleassignment "Manage Azure Role Assignment" b
azure_rm_roleassignment: >
	name=${1:# Unique name of role assignment.}
	assignee_object_id=${2:# The object id of assignee. This maps to the ID inside the Active Directory.}
	role_definition_id=${3:# The role definition id used in the role assignment.}
	scope=${4:# The scope of the role assignment to create.}
	state=${5:absent|#present}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_autoscale "Manage Azure autoscale setting" b
azure_rm_autoscale: >
	resource_group=${1:# Resource group of the resource.}
	name=${2:# name of the resource.}

	target=${3:# The identifier of the resource to apply autoscale setting.}
	enabled=${4:yes}
	profiles=${5:# The collection of automatic scaling profiles that specify different scaling parameters for different time periods.}
	notifications=${6:# The collection of notifications.}
	state=${7:#present|absent}
	location=${8:# location of the resource.}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_resource "Create any Azure resource" b
azure_rm_resource: >
	url=${1:# Azure RM Resource URL.}
	api_version=${2:# Specific API version to be used.}
	provider=${3:# Provider type.}
	resource_group=${4:# Resource group to be used.}
	resource_type=${5:# Resource type.}
	resource_name=${6:# Resource name.}
	subresource=${7:# List of subresources.}
	body=${8:# The body of the HTTP request/response to the web service.}
	method=${9:GET|#PUT|POST|HEAD|PATCH|DELETE|MERGE}
	status_code=${10:[200, 201, 202]}
	idempotency=${11:no}
	polling_timeout=${12:0}
	polling_interval=${13:60}
	state=${14:absent|#present}
	ad_user=${15:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${16:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${17:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${18:# Your Azure subscription Id.}
	client_id=${19:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${20:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${21:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${22:AzureCloud}
	adfs_authority_url=${23:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${24:ignore|validate}
	auth_source=${25:auto|cli|credential_file|env|msi}
	api_profile=${26:latest}

endsnippet

snippet azure_rm_loadbalancer_info "Get load balancer facts" b
azure_rm_loadbalancer_info: >
	name=${1:# Limit results to a specific resource group.}
	resource_group=${2:# The resource group to search for the desired load balancer.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_aksversion_info "Get available kubernetes versions supported by Azure Kubernetes Service" b
azure_rm_aksversion_info: >
	location=${1:# Get the versions available for creating a managed Kubernetes cluster.}

	version=${2:# Get the upgrade versions available for a managed Kubernetes cluster version.}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}

endsnippet

snippet azure_rm_webapp_info "Get Azure web app facts" b
azure_rm_webapp_info: >
	name=${1:# Only show results for a specific web app.}
	resource_group=${2:# Limit results by resource group.}
	return_publish_profile=${3:no}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_networkinterface "Manage Azure network interfaces" b
azure_rm_networkinterface: >
	resource_group=${1:# Name of a resource group where the network interface exists or will be created.}
	name=${2:# Name of the network interface.}
	virtual_network=${3:# An existing virtual network with which the network interface will be associated. Required when creating a network interface.}
	subnet_name=${4:# Name of an existing subnet within the specified virtual network. Required when creating a network interface.}

	state=${5:absent|#present}
	location=${6:# Valid Azure location. Defaults to location of the resource group.}
	os_type=${7:Windows|#Linux}
	private_ip_address=${8:# (Deprecate) Valid IPv4 address that falls within the specified subnet.}
	private_ip_allocation_method=${9:#Dynamic|Static}
	public_ip=${10:yes}
	public_ip_address_name=${11:# (Deprecate) Name of an existing public IP address object to associate with the security group.}
	public_ip_allocation_method=${12:#Dynamic|Static}
	ip_configurations=${13:# List of IP configurations. Each configuration object should include field I(private_ip_address), I(private_ip_allocation_method), I(public_ip_address_name), I(public_ip), I(public_ip_allocation_method), I(name).}
	enable_accelerated_networking=${14:no}
	create_with_security_group=${15:yes}
	security_group=${16:# An existing security group with which to associate the network interface.}
	open_ports=${17:# When a default security group is created for a Linux host a rule will be added allowing inbound TCP connections to the default SSH port C(22), and for a Windows host rules will be added allowing inbound access to RDP ports C(3389) and C(5986). Override the default ports by providing a list of open ports.}
	enable_ip_forwarding=${18:no}
	dns_servers=${19:# Which DNS servers should the NIC lookup.}
	ad_user=${20:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${21:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${22:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${23:# Your Azure subscription Id.}
	client_id=${24:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${25:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${26:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${27:AzureCloud}
	adfs_authority_url=${28:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${29:ignore|validate}
	auth_source=${30:auto|cli|credential_file|env|msi}
	api_profile=${31:latest}
	tags=${32:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${33:yes}

endsnippet

snippet azure_rm_devtestlab "Manage Azure DevTest Lab instance" b
azure_rm_devtestlab: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the lab.}

	location=${3:# The location of the resource.}
	storage_type=${4:standard|premium}
	premium_data_disks=${5:# Allow creation of premium data disks.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}
	tags=${19:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${20:yes}

endsnippet

snippet azure_rm_galleryimage "Manage Azure SIG Image instance." b
azure_rm_galleryimage: >
	resource_group=${1:# The name of the resource group.}
	gallery_name=${2:# The name of the Shared Image Gallery in which the Image Definition is to be created.}
	name=${3:# The name of the gallery Image Definition to be created or updated. The allowed characters are alphabets and numbers with dots, dashes, and periods allowed in the middle. The maximum length is 80 characters.}
	os_type=${4:windows|linux}
	os_state=${5:generalized|specialized}
	identifier=${6:# Image identifier.}

	location=${7:# Resource location}
	description=${8:# The description of this gallery Image Definition resource. This property is updatable.}
	eula=${9:# The Eula agreement for the gallery Image Definition.}
	privacy_statement_uri=${10:# The privacy statement uri.}
	release_note_uri=${11:# The release note uri.}
	end_of_life_date=${12:# The end of life date of the gallery Image Definition. This property can be used for decommissioning purposes. This property is updatable. Format should be according to ISO-8601, for instance "2019-06-26".}
	recommended=${13:# Recommended parameter values.}
	disallowed=${14:# Disallowed parameter values.}
	purchase_plan=${15:# Purchase plan.}
	state=${16:absent|#present}
	ad_user=${17:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${18:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${19:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${20:# Your Azure subscription Id.}
	client_id=${21:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${22:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${23:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${24:AzureCloud}
	adfs_authority_url=${25:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${26:ignore|validate}
	auth_source=${27:auto|cli|credential_file|env|msi}
	api_profile=${28:latest}
	tags=${29:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${30:yes}

endsnippet

snippet azure_rm_networkinterface_info "Get network interface facts" b
azure_rm_networkinterface_info: >
	name=${1:# Only show results for a specific network interface.}
	resource_group=${2:# Name of the resource group containing the network interface(s). Required when searching by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_postgresqlserver "Manage PostgreSQL Server instance" b
azure_rm_postgresqlserver: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	name=${2:# The name of the server.}

	sku=${3:# The SKU (pricing tier) of the server.}
	location=${4:# Resource location. If not set, location from the resource group will be used as default.}
	storage_mb=${5:# The maximum storage allowed for a server.}
	version=${6:9.5|9.6|10}
	enforce_ssl=${7:no}
	admin_username=${8:# The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).}
	admin_password=${9:# The password of the administrator login.}
	create_mode=${10:Default}
	state=${11:#present|absent}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_loganalyticsworkspace "Manage Azure Log Analytics workspaces" b
azure_rm_loganalyticsworkspace: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the workspace.}

	state=${3:absent|#present}
	location=${4:# Resource location.}
	sku=${5:free|standard|premium|unlimited|per_node|#per_gb2018|standalone}
	retention_in_days=${6:# The workspace data retention in days.}
	intelligence_packs=${7:# Manage intelligence packs possible for this workspace.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_manageddisk "Manage Azure Manage Disks" b
azure_rm_manageddisk: >
	resource_group=${1:# Name of a resource group where the managed disk exists or will be created.}
	name=${2:# Name of the managed disk.}

	state=${3:absent|#present}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	storage_account_type=${5:Standard_LRS|StandardSSD_LRS|Premium_LRS|UltraSSD_LRS}
	create_option=${6:empty|import|copy}
	source_uri=${7:# URI to a valid VHD file to be used or the resource ID of the managed disk to copy.}
	os_type=${8:linux|windows}
	disk_size_gb=${9:# Size in GB of the managed disk to be created.}
	managed_by=${10:# Name of an existing virtual machine with which the disk is or will be associated, this VM should be in the same resource group.}
	attach_caching=${11:|read_only|read_write}
	tags=${12:# Tags to assign to the managed disk.}
	zone=${13:1|2|3|}
	ad_user=${14:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${15:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${16:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${17:# Your Azure subscription Id.}
	client_id=${18:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${19:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${20:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${21:AzureCloud}
	adfs_authority_url=${22:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${23:ignore|validate}
	auth_source=${24:auto|cli|credential_file|env|msi}
	api_profile=${25:latest}
	append_tags=${26:yes}

endsnippet

snippet azure_rm_mariadbdatabase_info "Get Azure MariaDB Database facts" b
azure_rm_mariadbdatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_lock "Manage Azure locks" b
azure_rm_lock: >
	name=${1:# Name of the lock.}

	managed_resource_id=${2:# Manage a lock for the specified resource ID.}
	resource_group=${3:# Manage a lock for the named resource group.}
	state=${4:absent|#present}
	level=${5:can_not_delete|read_only}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_keyvaultkey "Use Azure KeyVault keys" b
azure_rm_keyvaultkey: >
	keyvault_uri=${1:# URI of the keyvault endpoint.}
	key_name=${2:# Name of the keyvault key.}

	byok_file=${3:# BYOK file.}
	pem_file=${4:# PEM file.}
	pem_password=${5:# PEM password.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}
	tags=${19:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${20:yes}

endsnippet

snippet azure_rm_hdinsightcluster_info "Get Azure HDInsight Cluster facts" b
azure_rm_hdinsightcluster_info: >
	resource_group=${1:# Name of an Azure resource group.}
	name=${2:# HDInsight cluster name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_storageaccount_info "Get storage account facts" b
azure_rm_storageaccount_info: >
	name=${1:# Only show results for a specific account.}
	resource_group=${2:# Limit results to a resource group. Required when filtering by name.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	show_connection_string=${4:# Show the connection string for each of the storageaccount's endpoints.}
	show_blob_cors=${5:# Show the blob CORS settings for each blob related to the storage account.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_sqlserver_info "Get SQL Server facts" b
azure_rm_sqlserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	server_name=${2:# The name of the server.}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}
	tags=${15:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${16:yes}

endsnippet

snippet azure_rm_roledefinition_info "Get Azure Role Definition facts" b
azure_rm_roledefinition_info: >
	scope=${1:# The scope of role definition.}

	id=${2:# Role definition id.}
	role_name=${3:# Role name.}
	type=${4:system|custom}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_iotdevicemodule "Manage Azure IoT hub device module" b
azure_rm_iotdevicemodule: >
	hub=${1:# Name of IoT Hub.}
	hub_policy_name=${2:# Policy name of the IoT Hub which will be used to query from IoT hub.}
	hub_policy_key=${3:# Key of the I(hub_policy_name).}
	name=${4:# Name of the IoT hub device identity.}
	device=${5:# Device name the module associate with.}

	state=${6:absent|#present}
	auth_method=${7:#sas|certificate_authority|self_signed}
	primary_key=${8:# Explicit self-signed certificate thumbprint to use for primary key.}
	secondary_key=${9:# Explicit self-signed certificate thumbprint to use for secondary key.}
	twin_tags=${10:# A section that the solution back end can read from and write to.}
	desired=${11:# Used along with reported properties to synchronize device configuration or conditions.}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}
	tags=${24:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${25:yes}

endsnippet

snippet azure_rm_roledefinition "Manage Azure Role Definition" b
azure_rm_roledefinition: >
	name=${1:# Unique name of role definition.}

	permissions=${2:# Set of role definition permissions.}
	assignable_scopes=${3:# List of assignable scopes of this definition.}
	scope=${4:# The scope of the role definition.}
	description=${5:# The role definition description.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_virtualmachinescalesetextension "Manage Azure Virtual Machine Scale Set (VMSS) extensions" b
azure_rm_virtualmachinescalesetextension: >
	resource_group=${1:# Name of a resource group where the VMSS extension exists or will be created.}
	vmss_name=${2:# The name of the virtual machine where the extension should be create or updated.}

	name=${3:# Name of the VMSS extension.}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	publisher=${5:# The name of the extension handler publisher.}
	type=${6:# The type of the extension handler.}
	type_handler_version=${7:# The type version of the extension handler.}
	settings=${8:# A dictionary containing extension settings.}
	protected_settings=${9:# A dictionary containing protected extension settings.}
	auto_upgrade_minor_version=${10:# Whether the extension handler should be automatically upgraded across minor versions.}
	state=${11:absent|#present}
	ad_user=${12:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${13:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${14:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${15:# Your Azure subscription Id.}
	client_id=${16:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${17:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${18:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${19:AzureCloud}
	adfs_authority_url=${20:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${21:ignore|validate}
	auth_source=${22:auto|cli|credential_file|env|msi}
	api_profile=${23:latest}

endsnippet

snippet azure_rm_resource_info "Generic facts of Azure resources" b
azure_rm_resource_info: >
	url=${1:# Azure RM Resource URL.}
	api_version=${2:# Specific API version to be used.}
	provider=${3:# Provider type, should be specified in no URL is given.}
	resource_group=${4:# Resource group to be used.}
	resource_type=${5:# Resource type.}
	resource_name=${6:# Resource name.}
	subresource=${7:# List of subresources.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_autoscale_info "Get Azure Auto Scale Setting facts" b
azure_rm_autoscale_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the Auto Scale Setting.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_postgresqlserver_info "Get Azure PostgreSQL Server facts" b
azure_rm_postgresqlserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	name=${2:# The name of the server.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_servicebussaspolicy "Manage Azure Service Bus SAS policy" b
azure_rm_servicebussaspolicy: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the SAS policy.}
	namespace=${3:# Manage SAS policy for a namespace without C(queue) or C(topic) set.}
	rights=${4:manage|listen|send|listen_send}

	state=${5:absent|#present}
	queue=${6:# Type of the messaging queue.}
	topic=${7:# Name of the messaging topic.}
	regenerate_primary_key=${8:no}
	regenerate_secondary_key=${9:no}
	ad_user=${10:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${11:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${12:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${13:# Your Azure subscription Id.}
	client_id=${14:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${15:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${16:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${17:AzureCloud}
	adfs_authority_url=${18:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${19:ignore|validate}
	auth_source=${20:auto|cli|credential_file|env|msi}
	api_profile=${21:latest}
	tags=${22:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${23:yes}

endsnippet

snippet azure_rm_devtestlab_info "Get Azure DevTest Lab facts" b
azure_rm_devtestlab_info: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the lab.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_keyvault "Manage Key Vault instance" b
azure_rm_keyvault: >
	resource_group=${1:# The name of the Resource Group to which the server belongs.}
	vault_name=${2:# Name of the vault.}

	location=${3:# Resource location. If not set, location from the resource group will be used as default.}
	vault_tenant=${4:# The Azure Active Directory tenant ID that should be used for authenticating requests to the key vault.}
	sku=${5:# SKU details.}
	access_policies=${6:# An array of 0 to 16 identities that have access to the key vault.}
	enabled_for_deployment=${7:# Property to specify whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the key vault.}
	enabled_for_disk_encryption=${8:# Property to specify whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.}
	enabled_for_template_deployment=${9:# Property to specify whether Azure Resource Manager is permitted to retrieve secrets from the key vault.}
	enable_soft_delete=${10:# Property to specify whether the soft delete functionality is enabled for this key vault.}
	recover_mode=${11:# Create vault in recovery mode.}
	state=${12:absent|#present}
	ad_user=${13:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${14:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${15:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${16:# Your Azure subscription Id.}
	client_id=${17:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${18:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${19:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${20:AzureCloud}
	adfs_authority_url=${21:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${22:ignore|validate}
	auth_source=${23:auto|cli|credential_file|env|msi}
	api_profile=${24:latest}
	tags=${25:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${26:yes}

endsnippet

snippet azure_rm_servicebusqueue "Manage Azure Service Bus queue" b
azure_rm_servicebusqueue: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the queue.}
	namespace=${3:# Servicebus namespace name.}

	state=${4:absent|#present}
	auto_delete_on_idle_in_seconds=${5:# Time idle interval after which a queue is automatically deleted.}
	dead_lettering_on_message_expiration=${6:# A value that indicates whether a queue has dead letter support when a message expires.}
	default_message_time_to_live_seconds=${7:# Default message timespan to live value.}
	enable_batched_operations=${8:# Value that indicates whether server-side batched operations are enabled.}
	enable_express=${9:# Value that indicates whether Express Entities are enabled.}
	enable_partitioning=${10:# A value that indicates whether the topic or queue is to be partitioned across multiple message brokers.}
	forward_dead_lettered_messages_to=${11:# Queue or topic name to forward the Dead Letter message for a queue.}
	forward_to=${12:# Queue or topic name to forward the messages for a queue.}
	lock_duration_in_seconds=${13:# Timespan duration of a peek-lock.}
	max_delivery_count=${14:# The maximum delivery count.}
	max_size_in_mb=${15:# The maximum size of the queue in megabytes, which is the size of memory allocated for the queue.}
	requires_duplicate_detection=${16:# A value indicating if this queue or topic requires duplicate detection.}
	duplicate_detection_time_in_seconds=${17:# TimeSpan structure that defines the duration of the duplicate detection history.}
	requires_session=${18:# A value that indicates whether the queue supports the concept of sessions.}
	status=${19:active|disabled|send_disabled|receive_disabled}
	ad_user=${20:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${21:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${22:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${23:# Your Azure subscription Id.}
	client_id=${24:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${25:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${26:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${27:AzureCloud}
	adfs_authority_url=${28:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${29:ignore|validate}
	auth_source=${30:auto|cli|credential_file|env|msi}
	api_profile=${31:latest}
	tags=${32:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${33:yes}

endsnippet

snippet azure_rm_mariadbdatabase "Manage MariaDB Database instance" b
azure_rm_mariadbdatabase: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the database.}

	charset=${4:# The charset of the database. Check MariaDB documentation for possible values.}
	collation=${5:# The collation of the database. Check MariaDB documentation for possible values.}
	force_update=${6:no}
	state=${7:absent|#present}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_publicipaddress "Manage Azure Public IP Addresses" b
azure_rm_publicipaddress: >
	resource_group=${1:# Name of resource group with which the Public IP is associated.}
	name=${2:# Name of the Public IP.}

	allocation_method=${3:#dynamic|static|Static|Dynamic}
	domain_name=${4:# The customizable portion of the FQDN assigned to public IP address. This is an explicit setting.}
	state=${5:absent|#present}
	location=${6:# Valid Azure location. Defaults to location of the resource group.}
	sku=${7:basic|standard|Basic|Standard}
	ip_tags=${8:# List of IpTag associated with the public IP address.}
	idle_timeout=${9:# Idle timeout in minutes.}
	version=${10:#ipv4|ipv6}
	ad_user=${11:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${12:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${13:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${14:# Your Azure subscription Id.}
	client_id=${15:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${16:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${17:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${18:AzureCloud}
	adfs_authority_url=${19:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${20:ignore|validate}
	auth_source=${21:auto|cli|credential_file|env|msi}
	api_profile=${22:latest}
	tags=${23:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${24:yes}

endsnippet

snippet azure_rm_publicipaddress_info "Get public IP facts" b
azure_rm_publicipaddress_info: >
	name=${1:# Only show results for a specific Public IP.}
	resource_group=${2:# Limit results by resource group. Required when using name parameter.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualmachineimage_info "Get virtual machine image facts" b
azure_rm_virtualmachineimage_info: >
	location=${1:# Azure location value, for example C(westus), C(eastus), C(eastus2), C(northcentralus), etc.}

	publisher=${2:# Name of an image publisher. List image offerings associated with a particular publisher.}
	offer=${3:# Name of an image offering. Combine with SKU to see a list of available image versions.}
	sku=${4:# Image offering SKU. Combine with offer to see a list of available versions.}
	version=${5:# Specific version number of an image.}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}

endsnippet

snippet azure_rm_routetable_info "Get route table facts" b
azure_rm_routetable_info: >
	name=${1:# Limit results to a specific route table.}
	resource_group=${2:# Limit results in a specific resource group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_servicebus_info "Get servicebus facts" b
azure_rm_servicebus_info: >
	name=${1:# Limit results to a specific servicebus.}
	resource_group=${2:# Limit results in a specific resource group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	namespace=${4:# Servicebus namespace name.}
	type=${5:namespace|queue|topic|subscription}
	topic=${6:# Topic name.}
	show_sas_policies=${7:# Whether to show the SAS policies.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_availabilityset_info "Get Azure Availability Set facts" b
azure_rm_availabilityset_info: >
	name=${1:# Limit results to a specific availability set.}
	resource_group=${2:# The resource group to search for the desired availability set.}
	tags=${3:# List of tags to be matched.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_postgresqlconfiguration_info "Get Azure PostgreSQL Configuration facts" b
azure_rm_postgresqlconfiguration_info: >
	resource_group=${1:# The name of the resource group that contains the resource.}
	server_name=${2:# The name of the server.}

	name=${3:# Setting name.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_aks "Manage a managed Azure Container Service (AKS) instance" b
azure_rm_aks: >
	resource_group=${1:# Name of a resource group where the managed Azure Container Services (AKS) exists or will be created.}
	name=${2:# Name of the managed Azure Container Services (AKS) instance.}

	state=${3:absent|#present}
	location=${4:# Valid azure location. Defaults to location of the resource group.}
	dns_prefix=${5:# DNS prefix specified when creating the managed cluster.}
	kubernetes_version=${6:# Version of Kubernetes specified when creating the managed cluster.}
	linux_profile=${7:# The Linux profile suboptions.}
	agent_pool_profiles=${8:# The agent pool profile suboptions.}
	service_principal=${9:# The service principal suboptions.}
	enable_rbac=${10:no}
	network_profile=${11:# Profile of network configuration.}
	aad_profile=${12:# Profile of Azure Active Directory configuration.}
	addon=${13:# Profile of managed cluster add-on.}
	ad_user=${14:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${15:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${16:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${17:# Your Azure subscription Id.}
	client_id=${18:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${19:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${20:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${21:AzureCloud}
	adfs_authority_url=${22:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${23:ignore|validate}
	auth_source=${24:auto|cli|credential_file|env|msi}
	api_profile=${25:latest}
	tags=${26:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${27:yes}

endsnippet

snippet azure_rm_servicebus_info "Get servicebus facts" b
azure_rm_servicebus_info: >
	name=${1:# Limit results to a specific servicebus.}
	resource_group=${2:# Limit results in a specific resource group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	namespace=${4:# Servicebus namespace name.}
	type=${5:namespace|queue|topic|subscription}
	topic=${6:# Topic name.}
	show_sas_policies=${7:# Whether to show the SAS policies.}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}

endsnippet

snippet azure_rm_rediscachefirewallrule "Manage Azure Cache for Redis Firewall rules" b
azure_rm_rediscachefirewallrule: >
	resource_group=${1:# Name of the resource group to which the resource belongs.}
	cache_name=${2:# Name of the Azure Cache for Redis.}
	name=${3:# Name of the Firewall rule.}

	start_ip_address=${4:# The start IP address of the Azure Cache for Redis Firewall rule. Must be IPv4 format.}
	end_ip_address=${5:# The end IP address of the Azure Cache for Redis Firewall rule. Must be IPv4 format.}
	state=${6:absent|#present}
	ad_user=${7:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${8:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${9:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${10:# Your Azure subscription Id.}
	client_id=${11:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${12:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${13:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${14:AzureCloud}
	adfs_authority_url=${15:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${16:ignore|validate}
	auth_source=${17:auto|cli|credential_file|env|msi}
	api_profile=${18:latest}

endsnippet

snippet azure_rm_virtualmachineextension_info "Get Azure Virtual Machine Extension facts" b
azure_rm_virtualmachineextension_info: >
	resource_group=${1:# The name of the resource group.}
	virtual_machine_name=${2:# The name of the virtual machine containing the extension.}

	name=${3:# The name of the virtual machine extension.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_containerregistry_info "Get Azure Container Registry facts" b
azure_rm_containerregistry_info: >
	resource_group=${1:# The name of the resource group to which the container registry belongs.}

	name=${2:# The name of the container registry.}
	retrieve_credentials=${3:no}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_applicationsecuritygroup "Manage Azure Application Security Group" b
azure_rm_applicationsecuritygroup: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the application security group.}

	location=${3:# Resource location. If not set, location from the resource group will be used as default.}
	state=${4:absent|#present}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}
	tags=${17:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${18:yes}

endsnippet

snippet azure_rm_sqlfirewallrule_info "Get Azure SQL Firewall Rule facts" b
azure_rm_sqlfirewallrule_info: >
	resource_group=${1:# The name of the resource group that contains the server.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the firewall rule.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_webappslot "Manage Azure Web App slot" b
azure_rm_webappslot: >
	resource_group=${1:# Name of the resource group to which the resource belongs.}
	name=${2:# Unique name of the deployment slot to create or update.}
	webapp_name=${3:# Web app name which this deployment slot belongs to.}

	location=${4:# Resource location. If not set, location from the resource group will be used as default.}
	configuration_source=${5:# Source slot to clone configurations from when creating slot. Use webapp's name to refer to the production slot.}
	auto_swap_slot_name=${6:# Used to configure target slot name to auto swap, or disable auto swap.}
	swap=${7:# Swap deployment slots of a web app.}
	frameworks=${8:# Set of run time framework settings. Each setting is a dictionary.}
	container_settings=${9:# Web app slot container settings.}
	startup_file=${10:# The slot startup file.}
	app_settings=${11:# Configure web app slot application settings. Suboptions are in key value pair format.}
	purge_app_settings=${12:# Purge any existing application settings. Replace slot application settings with app_settings.}
	deployment_source=${13:# Deployment source for git.}
	app_state=${14:#started|stopped|restarted}
	state=${15:absent|#present}
	ad_user=${16:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${17:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${18:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${19:# Your Azure subscription Id.}
	client_id=${20:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${21:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${22:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${23:AzureCloud}
	adfs_authority_url=${24:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${25:ignore|validate}
	auth_source=${26:auto|cli|credential_file|env|msi}
	api_profile=${27:latest}
	tags=${28:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${29:yes}

endsnippet

snippet azure_rm_deployment_info "Get Azure Deployment facts" b
azure_rm_deployment_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the deployment.}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}

endsnippet

snippet azure_rm_loadbalancer "Manage Azure load balancers" b
azure_rm_loadbalancer: >
	resource_group=${1:# Name of a resource group where the load balancer exists or will be created.}
	name=${2:# Name of the load balancer.}

	state=${3:absent|#present}
	location=${4:# Valid Azure location. Defaults to location of the resource group.}
	sku=${5:Basic|Standard}
	frontend_ip_configurations=${6:# List of frontend IPs to be used.}
	backend_address_pools=${7:# List of backend address pools.}
	probes=${8:# List of probe definitions used to check endpoint health.}
	inbound_nat_pools=${9:# Defines an external port range for inbound NAT to a single backend port on NICs associated with a load balancer.}
	load_balancing_rules=${10:# Object collection representing the load balancing rules Gets the provisioning.}
	inbound_nat_rules=${11:# Collection of inbound NAT Rules used by a load balancer.}
	public_ip_address_name=${12:# (deprecated) Name of an existing public IP address object to associate with the security group.}
	probe_port=${13:# (deprecated) The port that the health probe will use.}
	probe_protocol=${14:Tcp|Http|Https}
	probe_interval=${15:15}
	probe_fail_count=${16:3}
	probe_request_path=${17:# (deprecated) The URL that an HTTP probe or HTTPS probe will use (only relevant if I(probe_protocol=Http) or I(probe_protocol=Https)).}
	protocol=${18:Tcp|Udp}
	load_distribution=${19:Default|SourceIP|SourceIPProtocol}
	frontend_port=${20:# (deprecated) Frontend port that will be exposed for the load balancer.}
	backend_port=${21:# (deprecated) Backend port that will be exposed for the load balancer.}
	idle_timeout=${22:4}
	natpool_frontend_port_start=${23:# (deprecated) Start of the port range for a NAT pool.}
	natpool_frontend_port_end=${24:# (deprecated) End of the port range for a NAT pool.}
	natpool_backend_port=${25:# (deprecated) Backend port used by the NAT pool.}
	natpool_protocol=${26:# (deprecated) The protocol for the NAT pool.}
	ad_user=${27:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${28:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${29:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${30:# Your Azure subscription Id.}
	client_id=${31:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${32:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${33:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${34:AzureCloud}
	adfs_authority_url=${35:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${36:ignore|validate}
	auth_source=${37:auto|cli|credential_file|env|msi}
	api_profile=${38:latest}
	tags=${39:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${40:yes}

endsnippet

snippet azure_rm_devtestlabartifactsource_info "Get Azure DevTest Lab Artifact Source facts" b
azure_rm_devtestlabartifactsource_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of DevTest Lab.}

	name=${3:# The name of DevTest Lab Artifact Source.}
	tags=${4:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_sqldatabase "Manage SQL Database instance" b
azure_rm_sqldatabase: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}
	name=${3:# The name of the database to be operated on (updated or created).}

	location=${4:# Resource location. If not set, location from the resource group will be used as default.}
	collation=${5:# The collation of the database. If not I(create_mode=default), this value is ignored.}
	create_mode=${6:copy|default|non_readable_secondary|online_secondary|point_in_time_restore|recovery|restore|restore_long_term_retention_backup}
	source_database_id=${7:# Required unless I(create_mode=default) or I(create_mode=restore_long_term_retention_backup).}
	source_database_deletion_date=${8:# Required if I(create_mode=restore) and I(source_database_id) is the deleted database's original resource id when it existed (as opposed to its current restorable dropped database ID), then this value is required. Specifies the time that the database was deleted.}
	restore_point_in_time=${9:# Required if I(create_mode=point_in_time_restore), this value is required. If I(create_mode=restore), this value is optional.}
	recovery_services_recovery_point_resource_id=${10:# Required if I(create_mode=restore_long_term_retention_backup), then this value is required.}
	edition=${11:web|business|basic|standard|premium|free|stretch|data_warehouse|system|system2}
	max_size_bytes=${12:# The max size of the database expressed in bytes.}
	elastic_pool_name=${13:# The name of the elastic pool the database is in. Not supported for I(edition=data_warehouse).}
	read_scale=${14:no}
	sample_name=${15:adventure_works_lt}
	zone_redundant=${16:no}
	force_update=${17:# SQL Database will be updated if given parameters differ from existing resource state.}
	state=${18:absent|#present}
	ad_user=${19:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${20:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${21:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${22:# Your Azure subscription Id.}
	client_id=${23:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${24:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${25:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${26:AzureCloud}
	adfs_authority_url=${27:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${28:ignore|validate}
	auth_source=${29:auto|cli|credential_file|env|msi}
	api_profile=${30:latest}
	tags=${31:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${32:yes}

endsnippet

snippet azure_rm_devtestlabartifact_info "Get Azure DevTest Lab Artifact facts" b
azure_rm_devtestlabartifact_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of the lab.}
	artifact_source_name=${3:# The name of the artifact source.}

	name=${4:# The name of the artifact.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}

endsnippet

snippet azure_rm_image "Manage Azure image" b
azure_rm_image: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the image.}
	source=${3:# OS disk source from the same region.}

	data_disk_sources=${4:# List of data disk sources, including unmanaged blob URI, managed disk id or name, or snapshot id or name.}
	location=${5:# Location of the image. Derived from I(resource_group) if not specified.}
	os_type=${6:Windows|Linux}
	state=${7:absent|#present}
	ad_user=${8:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${9:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${10:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${11:# Your Azure subscription Id.}
	client_id=${12:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${13:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${14:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${15:AzureCloud}
	adfs_authority_url=${16:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${17:ignore|validate}
	auth_source=${18:auto|cli|credential_file|env|msi}
	api_profile=${19:latest}
	tags=${20:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${21:yes}

endsnippet

snippet azure_rm_devtestlabvirtualnetwork_info "Get Azure DevTest Lab Virtual Network facts" b
azure_rm_devtestlabvirtualnetwork_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of DevTest Lab.}

	name=${3:# The name of DevTest Lab Virtual Network.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_automationaccount "Manage Azure Automation account" b
azure_rm_automationaccount: >
	resource_group=${1:# Name of resource group.}
	name=${2:# Name of the automation account.}

	state=${3:absent|#present}
	location=${4:# Location of the resource.}
	ad_user=${5:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${6:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${7:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${8:# Your Azure subscription Id.}
	client_id=${9:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${10:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${11:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${12:AzureCloud}
	adfs_authority_url=${13:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${14:ignore|validate}
	auth_source=${15:auto|cli|credential_file|env|msi}
	api_profile=${16:latest}
	tags=${17:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${18:yes}

endsnippet

snippet azure_rm_containerinstance_info "Get Azure Container Instance facts" b
azure_rm_containerinstance_info: >
	resource_group=${1:# The name of the resource group.}

	name=${2:# The name of the container instance.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_mysqldatabase_info "Get Azure MySQL Database facts" b
azure_rm_mysqldatabase_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}
	server_name=${2:# The name of the server.}

	name=${3:# The name of the database.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_sqlserver_info "Get SQL Server facts" b
azure_rm_sqlserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	server_name=${2:# The name of the server.}
	ad_user=${3:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${4:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${5:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${6:# Your Azure subscription Id.}
	client_id=${7:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${8:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${9:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${10:AzureCloud}
	adfs_authority_url=${11:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${12:ignore|validate}
	auth_source=${13:auto|cli|credential_file|env|msi}
	api_profile=${14:latest}
	tags=${15:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${16:yes}

endsnippet

snippet azure_rm_monitorlogprofile "Manage Azure Monitor log profile" b
azure_rm_monitorlogprofile: >
	name=${1:# Unique name of the log profile to create or update.}

	location=${2:# Resource location.}
	locations=${3:# List of regions for which Activity Log events should be stored.}
	categories=${4:# List of categories of logs. These categories are created as is convenient to  user. Some Values are C(Write), C(Delete) and/or C(Action).}
	retention_policy=${5:# Retention policy for events in the log.}
	service_bus_rule_id=${6:# The service bus rule  ID of the service bus namespace in which you would like to have Event Hubs created for streaming in the Activity Log.}
	storage_account=${7:# The storage account to which send the Activity Log.}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_devtestlabvirtualnetwork_info "Get Azure DevTest Lab Virtual Network facts" b
azure_rm_devtestlabvirtualnetwork_info: >
	resource_group=${1:# The name of the resource group.}
	lab_name=${2:# The name of DevTest Lab.}

	name=${3:# The name of DevTest Lab Virtual Network.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_gallery "Manage Azure Shared Image Gallery instance." b
azure_rm_gallery: >
	resource_group=${1:# The name of the resource group.}
	name=${2:# The name of the Shared Image Gallery. Valid names consist of less than 80 alphanumeric characters, underscores and periods.}

	location=${3:# Resource location}
	description=${4:# The description of this Shared Image Gallery resource. This property is updatable.}
	state=${5:absent|#present}
	ad_user=${6:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${7:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${8:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${9:# Your Azure subscription Id.}
	client_id=${10:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${11:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${12:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${13:AzureCloud}
	adfs_authority_url=${14:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${15:ignore|validate}
	auth_source=${16:auto|cli|credential_file|env|msi}
	api_profile=${17:latest}
	tags=${18:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${19:yes}

endsnippet

snippet azure_rm_webapp "Manage Web App instances" b
azure_rm_webapp: >
	resource_group=${1:# Name of the resource group to which the resource belongs.}
	name=${2:# Unique name of the app to create or update. To create or update a deployment slot, use the {slot} parameter.}

	location=${3:# Resource location. If not set, location from the resource group will be used as default.}
	plan=${4:# App service plan. Required for creation.}
	frameworks=${5:# Set of run time framework settings. Each setting is a dictionary.}
	container_settings=${6:# Web app container settings.}
	scm_type=${7:# Repository type of deployment source, for example C(LocalGit), C(GitHub).}
	deployment_source=${8:# Deployment source for git.}
	startup_file=${9:# The web's startup file.}
	client_affinity_enabled=${10:yes}
	https_only=${11:# Configures web site to accept only https requests.}
	dns_registration=${12:# Whether or not the web app hostname is registered with DNS on creation. Set to C(false) to register.}
	skip_custom_domain_verification=${13:# Whether or not to skip verification of custom (non *.azurewebsites.net) domains associated with web app. Set to C(true) to skip.}
	ttl_in_seconds=${14:# Time to live in seconds for web app default domain name.}
	app_settings=${15:# Configure web app application settings. Suboptions are in key value pair format.}
	purge_app_settings=${16:# Purge any existing application settings. Replace web app application settings with app_settings.}
	app_state=${17:#started|stopped|restarted}
	state=${18:absent|#present}
	ad_user=${19:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${20:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${21:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${22:# Your Azure subscription Id.}
	client_id=${23:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${24:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${25:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${26:AzureCloud}
	adfs_authority_url=${27:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${28:ignore|validate}
	auth_source=${29:auto|cli|credential_file|env|msi}
	api_profile=${30:latest}
	tags=${31:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${32:yes}

endsnippet

snippet azure_rm_mysqlserver_info "Get Azure MySQL Server facts" b
azure_rm_mysqlserver_info: >
	resource_group=${1:# The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.}

	name=${2:# The name of the server.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_appserviceplan_info "Get azure app service plan facts" b
azure_rm_appserviceplan_info: >
	name=${1:# Only show results for a specific app service plan.}
	resource_group=${2:# Limit results by resource group.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_virtualnetworkpeering_info "Get facts of Azure Virtual Network Peering" b
azure_rm_virtualnetworkpeering_info: >
	resource_group=${1:# Name of a resource group where the vnet exists.}
	virtual_network=${2:# Name or resource ID of a virtual network.}

	name=${3:# Name of the virtual network peering.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet azure_rm_manageddisk_info "Get managed disk facts" b
azure_rm_manageddisk_info: >
	name=${1:# Limit results to a specific managed disk.}
	resource_group=${2:# Limit results to a specific resource group.}
	tags=${3:# Limit results by providing a list of tags.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}
	append_tags=${16:yes}

endsnippet

snippet azure_rm_securitygroup "Manage Azure network security groups" b
azure_rm_securitygroup: >
	resource_group=${1:# Name of the resource group the security group belongs to.}

	default_rules=${2:# The set of default rules automatically added to a security group at creation.}
	location=${3:# Valid azure location. Defaults to location of the resource group.}
	name=${4:# Name of the security group to operate on.}
	purge_default_rules=${5:no}
	purge_rules=${6:no}
	rules=${7:# Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.}
	state=${8:absent|#present}
	ad_user=${9:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${10:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${11:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${12:# Your Azure subscription Id.}
	client_id=${13:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${14:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${15:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${16:AzureCloud}
	adfs_authority_url=${17:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${18:ignore|validate}
	auth_source=${19:auto|cli|credential_file|env|msi}
	api_profile=${20:latest}
	tags=${21:# Dictionary of string:string pairs to assign as metadata to the object.}
	append_tags=${22:yes}

endsnippet

snippet azure_rm_trafficmanagerprofile_info "Get Azure Traffic Manager profile facts" b
azure_rm_trafficmanagerprofile_info: >
	name=${1:# Limit results to a specific Traffic Manager profile.}
	resource_group=${2:# The resource group to search for the desired Traffic Manager profile.}
	tags=${3:# Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.}
	ad_user=${4:# Active Directory username. Use when authenticating with an Active Directory user rather than service principal.}
	password=${5:# Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.}
	profile=${6:# Security profile found in ~/.azure/credentials file.}
	subscription_id=${7:# Your Azure subscription Id.}
	client_id=${8:# Azure client ID. Use when authenticating with a Service Principal.}
	secret=${9:# Azure client secret. Use when authenticating with a Service Principal.}
	tenant=${10:# Azure tenant ID. Use when authenticating with a Service Principal.}
	cloud_environment=${11:AzureCloud}
	adfs_authority_url=${12:# Azure AD authority url. Use when authenticating with Username/password, and has your own ADFS authority.}
	cert_validation_mode=${13:ignore|validate}
	auth_source=${14:auto|cli|credential_file|env|msi}
	api_profile=${15:latest}

endsnippet

snippet linode "Manage instances on the Linode Public Cloud" b
linode: >
	name=${1:# Name to give the instance (alphanumeric, dashes, underscore).}

	state=${2:absent|active|deleted|#present|restarted|started|stopped}
	api_key=${3:# Linode API key}
	displaygroup=${4:# Add the instance to a Display Group in Linode Manager.}
	linode_id=${5:# Unique ID of a linode server. This value is read-only in the sense that if you specify it on creation of a Linode it will not be used. The Linode API generates these IDs and we can those generated value here to reference a Linode more specifically. This is useful for idempotence.}
	additional_disks=${6:# List of dictionaries for creating additional disks that are added to the Linode configuration settings.}
	alert_bwin_enabled=${7:# Set status of bandwidth in alerts.}
	alert_bwin_threshold=${8:# Set threshold in MB of bandwidth in alerts.}
	alert_bwout_enabled=${9:# Set status of bandwidth out alerts.}
	alert_bwout_threshold=${10:# Set threshold in MB of bandwidth out alerts.}
	alert_bwquota_enabled=${11:# Set status of bandwidth quota alerts as percentage of network transfer quota.}
	alert_bwquota_threshold=${12:# Set threshold in MB of bandwidth quota alerts.}
	alert_cpu_enabled=${13:# Set status of receiving CPU usage alerts.}
	alert_cpu_threshold=${14:# Set percentage threshold for receiving CPU usage alerts. Each CPU core adds 100% to total.}
	alert_diskio_enabled=${15:# Set status of receiving disk IO alerts.}
	alert_diskio_threshold=${16:# Set threshold for average IO ops/sec over 2 hour period.}
	backupweeklyday=${17:# Integer value for what day of the week to store weekly backups.}
	plan=${18:# plan to use for the instance (Linode plan)}
	payment_term=${19:#1|12|24}
	password=${20:# root password to apply to a new server (auto generated if missing)}
	private_ip=${21:no}
	ssh_pub_key=${22:# SSH public key applied to root user}
	swap=${23:512}
	distribution=${24:# distribution to use for the instance (Linode Distribution)}
	datacenter=${25:# datacenter to create an instance in (Linode Datacenter)}
	kernel_id=${26:# kernel to use for the instance (Linode Kernel)}
	wait=${27:no}
	wait_timeout=${28:300}
	watchdog=${29:True}

endsnippet

snippet linode_v4 "Manage instances on the Linode cloud." b
linode_v4: >
	label=${1:# The instance label. This label is used as the main determiner for idempotence for the module and is therefore mandatory.}
	state=${2:present|absent}
	access_token=${3:# The Linode API v4 access token. It may also be specified by exposing the C(LINODE_ACCESS_TOKEN) environment variable. See U(https://developers.linode.com/api/v4#section/Access-and-Authentication).}

	region=${4:# The region of the instance. This is a required parameter only when creating Linode instances. See U(https://developers.linode.com/api/v4#tag/Regions).}
	image=${5:# The image of the instance. This is a required parameter only when creating Linode instances. See U(https://developers.linode.com/api/v4#tag/Images).}
	type=${6:# The type of the instance. This is a required parameter only when creating Linode instances. See U(https://developers.linode.com/api/v4#tag/Linode-Types).}
	group=${7:# The group that the instance should be marked under. Please note, that group labelling is deprecated but still supported. The encouraged method for marking instances is to use tags.}
	tags=${8:# The tags that the instance should be marked under. See U(https://developers.linode.com/api/v4#tag/Tags).}
	root_pass=${9:# The password for the root user. If not specified, one will be generated. This generated password will be available in the task success JSON.}
	authorized_keys=${10:# A list of SSH public key parts to deploy for the root user.}

endsnippet

snippet rax_cdb_user "create / delete a Rackspace Cloud Database" b
rax_cdb_user: >
	cdb_id=${1:# The databases server UUID}
	db_username=${2:# Name of the database user}
	db_password=${3:# Database user password}
	databases=${4:[]}
	host=${5:%}
	state=${6:#present|absent}
	api_key=${7:# Rackspace API key, overrides I(credentials).}
	credentials=${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${10:DFW}
	username=${11:# Rackspace username, overrides I(credentials).}
	validate_certs=${12:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${13:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${14:rackspace}
	tenant_id=${15:# The tenant ID used for authentication.}
	tenant_name=${16:# The tenant name used for authentication.}

endsnippet

snippet rax_dns_record "Manage DNS records on Rackspace Cloud DNS" b
rax_dns_record: >
	data=${1:# IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT}
	name=${2:# FQDN record name to create}
	type=${3:A|AAAA|CNAME|MX|NS|SRV|TXT|PTR}

	comment=${4:# Brief description of the domain. Maximum length of 160 characters}
	domain=${5:# Domain name to create the record in. This is an invalid option when type=PTR}
	loadbalancer=${6:# Load Balancer ID to create a PTR record for. Only used with type=PTR}
	overwrite=${7:yes}
	priority=${8:# Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.}
	server=${9:# Server ID to create a PTR record for. Only used with type=PTR}
	state=${10:#present|absent}
	ttl=${11:3600}
	api_key=${12:# Rackspace API key, overrides I(credentials).}
	credentials=${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${15:DFW}
	username=${16:# Rackspace username, overrides I(credentials).}
	validate_certs=${17:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${18:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${19:rackspace}
	tenant_id=${20:# The tenant ID used for authentication.}
	tenant_name=${21:# The tenant name used for authentication.}

endsnippet

snippet rax_mon_notification "Create or delete a Rackspace Cloud Monitoring notification." b
rax_mon_notification: >
	label=${1:# Defines a friendly name for this notification. String between 1 and 255 characters long.}
	notification_type=${2:webhook|email|pagerduty}
	details=${3:# Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/ service-notification-types-crud.html for details.}

	state=${4:present|absent}
	api_key=${5:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${6:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${7:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${9:rackspace}
	region=${10:DFW}
	tenant_id=${11:# The tenant ID used for authentication.}
	tenant_name=${12:# The tenant name used for authentication.}
	username=${13:# Rackspace username, overrides I(credentials).}
	validate_certs=${14:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_files_objects "Upload, download, and delete objects in Rackspace Cloud Files" b
rax_files_objects: >
	container=${1:# The container to use for file object operations.}

	clear_meta=${2:no}
	dest=${3:# The destination of a "get" operation; i.e. a local directory, "/home/user/myfolder". Used to specify the destination of an operation on a remote object; i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17"}
	expires=${4:# Used to set an expiration on a file or folder uploaded to Cloud Files. Requires an integer, specifying expiration in seconds}
	meta=${5:# A hash of items to set as metadata values on an uploaded file or folder}
	method=${6:#get|put|delete}
	src=${7:# Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, "file1", or a comma-separated list of remote objects, "file1,file2,file17".  src and dest are mutually exclusive on remote-only object operations}
	structure=${8:yes}
	state=${9:#present|absent}
	type=${10:#file|meta}
	api_key=${11:# Rackspace API key, overrides I(credentials).}
	credentials=${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${13:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${14:DFW}
	username=${15:# Rackspace username, overrides I(credentials).}
	validate_certs=${16:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${17:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${18:rackspace}
	tenant_id=${19:# The tenant ID used for authentication.}
	tenant_name=${20:# The tenant name used for authentication.}

endsnippet

snippet rax_cbs "Manipulate Rackspace Cloud Block Storage Volumes" b
rax_cbs: >
	name=${1:# Name to give the volume being created}
	size=${2:100}
	state=${3:#present|absent}
	volume_type=${4:#SATA|SSD}

	description=${5:# Description to give the volume being created}
	image=${6:# image to use for bootable volumes. Can be an C(id), C(human_id) or C(name). This option requires C(pyrax>=1.9.3)}
	meta=${7:# A hash of metadata to associate with the volume}
	snapshot_id=${8:# The id of the snapshot to create the volume from}
	wait=${9:no}
	wait_timeout=${10:300}
	api_key=${11:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${12:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${15:rackspace}
	region=${16:DFW}
	tenant_id=${17:# The tenant ID used for authentication.}
	tenant_name=${18:# The tenant name used for authentication.}
	username=${19:# Rackspace username, overrides I(credentials).}
	validate_certs=${20:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_facts "Gather facts for Rackspace Cloud Servers" b
rax_facts: >
	address=${1:# Server IP address to retrieve facts for, will match any IP assigned to the server}
	id=${2:# Server ID to retrieve facts for}
	name=${3:# Server name to retrieve facts for}
	api_key=${4:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${5:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${6:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${7:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${8:rackspace}
	region=${9:DFW}
	tenant_id=${10:# The tenant ID used for authentication.}
	tenant_name=${11:# The tenant name used for authentication.}
	username=${12:# Rackspace username, overrides I(credentials).}
	validate_certs=${13:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_files "Manipulate Rackspace Cloud Files Containers" b
rax_files: >
	container=${1:# The container to use for container or metadata operations.}

	clear_meta=${2:no}
	meta=${3:# A hash of items to set as metadata values on a container}
	private=${4:# Used to set a container as private, removing it from the CDN.  B(Warning!) Private containers, if previously made public, can have live objects available until the TTL on cached objects expires}
	public=${5:# Used to set a container as public, available via the Cloud Files CDN}
	region=${6:DFW}
	state=${7:#present|absent}
	ttl=${8:# In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public}
	type=${9:#file|meta}
	web_error=${10:# Sets an object to be presented as the HTTP error page when accessed by the CDN URL}
	web_index=${11:# Sets an object to be presented as the HTTP index page when accessed by the CDN URL}
	api_key=${12:# Rackspace API key, overrides I(credentials).}
	credentials=${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	username=${15:# Rackspace username, overrides I(credentials).}
	validate_certs=${16:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${17:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${18:rackspace}
	tenant_id=${19:# The tenant ID used for authentication.}
	tenant_name=${20:# The tenant name used for authentication.}

endsnippet

snippet rax_queue "create / delete a queue in Rackspace Public Cloud" b
rax_queue: >
	name=${1:# Name to give the queue}
	state=${2:#present|absent}
	api_key=${3:# Rackspace API key, overrides I(credentials).}
	credentials=${4:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${5:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${6:DFW}
	username=${7:# Rackspace username, overrides I(credentials).}
	validate_certs=${8:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${9:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${10:rackspace}
	tenant_id=${11:# The tenant ID used for authentication.}
	tenant_name=${12:# The tenant name used for authentication.}

endsnippet

snippet rax_clb_nodes "add, modify and remove nodes from a Rackspace Cloud Load Balancer" b
rax_clb_nodes: >
	load_balancer_id=${1:# Load balancer id}

	address=${2:# IP address or domain name of the node}
	condition=${3:enabled|disabled|draining}
	node_id=${4:# Node id}
	port=${5:# Port number of the load balanced service on the node}
	state=${6:#present|absent}
	type=${7:primary|secondary}
	wait=${8:no}
	wait_timeout=${9:30}
	weight=${10:# Weight of node}
	api_key=${11:# Rackspace API key, overrides I(credentials).}
	credentials=${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${13:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${14:DFW}
	username=${15:# Rackspace username, overrides I(credentials).}
	validate_certs=${16:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${17:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${18:rackspace}
	tenant_id=${19:# The tenant ID used for authentication.}
	tenant_name=${20:# The tenant name used for authentication.}

endsnippet

snippet rax_network "create / delete an isolated network in Rackspace Public Cloud" b
rax_network: >
	state=${1:#present|absent}
	label=${2:# Label (name) to give the network}
	cidr=${3:# cidr of the network being created}
	api_key=${4:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${5:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${6:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${7:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${8:rackspace}
	region=${9:DFW}
	tenant_id=${10:# The tenant ID used for authentication.}
	tenant_name=${11:# The tenant name used for authentication.}
	username=${12:# Rackspace username, overrides I(credentials).}
	validate_certs=${13:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_meta "Manipulate metadata for Rackspace Cloud Servers" b
rax_meta: >
	address=${1:# Server IP address to modify metadata for, will match any IP assigned to the server}
	id=${2:# Server ID to modify metadata for}
	name=${3:# Server name to modify metadata for}
	meta=${4:# A hash of metadata to associate with the instance}
	api_key=${5:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${6:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${7:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${9:rackspace}
	region=${10:DFW}
	tenant_id=${11:# The tenant ID used for authentication.}
	tenant_name=${12:# The tenant name used for authentication.}
	username=${13:# Rackspace username, overrides I(credentials).}
	validate_certs=${14:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_scaling_policy "Manipulate Rackspace Cloud Autoscale Scaling Policy" b
rax_scaling_policy: >
	name=${1:# Name to give the policy}
	policy_type=${2:webhook|schedule}
	scaling_group=${3:# Name of the scaling group that this policy will be added to}

	at=${4:# The UTC time when this policy will be executed. The time must be formatted according to C(yyyy-MM-dd'T'HH:mm:ss.SSS) such as C(2013-05-19T08:07:08Z)}
	change=${5:# The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set I(is_percent) to C(true) also.}
	cron=${6:# The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to C(1 0 * * *)}
	cooldown=${7:# The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).}
	desired_capacity=${8:# The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.}
	is_percent=${9:no}
	state=${10:#present|absent}
	api_key=${11:# Rackspace API key, overrides I(credentials).}
	credentials=${12:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${13:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${14:DFW}
	username=${15:# Rackspace username, overrides I(credentials).}
	validate_certs=${16:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${17:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${18:rackspace}
	tenant_id=${19:# The tenant ID used for authentication.}
	tenant_name=${20:# The tenant name used for authentication.}

endsnippet

snippet rax_clb "create / delete a load balancer in Rackspace Public Cloud" b
rax_clb: >
	algorithm=${1:RANDOM|#LEAST_CONNECTIONS|ROUND_ROBIN|WEIGHTED_LEAST_CONNECTIONS|WEIGHTED_ROUND_ROBIN}
	meta=${2:# A hash of metadata to associate with the instance}
	name=${3:# Name to give the load balancer}
	port=${4:80}
	protocol=${5:DNS_TCP|DNS_UDP|FTP|#HTTP|HTTPS|IMAPS|IMAPv4|LDAP|LDAPS|MYSQL|POP3|POP3S|SMTP|TCP|TCP_CLIENT_FIRST|UDP|UDP_STREAM|SFTP}
	state=${6:#present|absent}
	timeout=${7:30}
	type=${8:#PUBLIC|SERVICENET}
	vip_id=${9:# Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol}
	wait=${10:no}
	wait_timeout=${11:300}
	api_key=${12:# Rackspace API key, overrides I(credentials).}
	credentials=${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${15:DFW}
	username=${16:# Rackspace username, overrides I(credentials).}
	validate_certs=${17:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${18:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${19:rackspace}
	tenant_id=${20:# The tenant ID used for authentication.}
	tenant_name=${21:# The tenant name used for authentication.}

endsnippet

snippet rax_mon_entity "Create or delete a Rackspace Cloud Monitoring entity" b
rax_mon_entity: >
	label=${1:# Defines a name for this entity. Must be a non-empty string between 1 and 255 characters long.}

	state=${2:present|absent}
	agent_id=${3:# Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect C(agent.) rax_mon_checks against this entity.}
	named_ip_addresses=${4:# Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses.}
	metadata=${5:# Hash of arbitrary C(name), C(value) pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long.}
	api_key=${6:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${7:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${10:rackspace}
	region=${11:DFW}
	tenant_id=${12:# The tenant ID used for authentication.}
	tenant_name=${13:# The tenant name used for authentication.}
	username=${14:# Rackspace username, overrides I(credentials).}
	validate_certs=${15:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax "create / delete an instance in Rackspace Public Cloud" b
rax: >
	auto_increment=${1:yes}
	boot_from_volume=${2:no}
	boot_volume=${3:# Cloud Block Storage ID or Name to use as the boot volume of the instance}
	boot_volume_size=${4:100}
	boot_volume_terminate=${5:no}
	config_drive=${6:no}
	count=${7:1}
	count_offset=${8:1}
	disk_config=${9:#auto|manual}
	exact_count=${10:no}
	extra_client_args=${11:# A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution.}
	extra_create_args=${12:# A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution.}
	files=${13:# Files to insert into the instance. remotefilename:localcontent}
	flavor=${14:# flavor to use for the instance}
	group=${15:# host group to assign to server, is also used for idempotent operations to ensure a specific number of instances}
	image=${16:# image to use for the instance. Can be an C(id), C(human_id) or C(name). With I(boot_from_volume), a Cloud Block Storage volume will be created with this image}
	instance_ids=${17:# list of instance ids, currently only used when state='absent' to remove instances}
	key_name=${18:# key pair to use on the instance}
	meta=${19:# A hash of metadata to associate with the instance}
	name=${20:# Name to give the instance}
	networks=${21:['public', 'private']}
	state=${22:#present|absent}
	user_data=${23:# Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string}
	wait=${24:no}
	wait_timeout=${25:300}
	api_key=${26:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${27:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${28:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${29:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${30:rackspace}
	region=${31:DFW}
	tenant_id=${32:# The tenant ID used for authentication.}
	tenant_name=${33:# The tenant name used for authentication.}
	username=${34:# Rackspace username, overrides I(credentials).}
	validate_certs=${35:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_keypair "Create a keypair for use with Rackspace Cloud Servers" b
rax_keypair: >
	name=${1:# Name of keypair}

	public_key=${2:# Public Key string to upload. Can be a file path or string}
	state=${3:#present|absent}
	api_key=${4:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${5:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${6:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${7:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${8:rackspace}
	region=${9:DFW}
	tenant_id=${10:# The tenant ID used for authentication.}
	tenant_name=${11:# The tenant name used for authentication.}
	username=${12:# Rackspace username, overrides I(credentials).}
	validate_certs=${13:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_cdb_database "create / delete a database in the Cloud Databases" b
rax_cdb_database: >
	cdb_id=${1:# The databases server UUID}
	name=${2:# Name to give to the database}
	character_set=${3:utf8}
	collate=${4:utf8_general_ci}
	state=${5:#present|absent}
	api_key=${6:# Rackspace API key, overrides I(credentials).}
	credentials=${7:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${9:DFW}
	username=${10:# Rackspace username, overrides I(credentials).}
	validate_certs=${11:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${12:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${13:rackspace}
	tenant_id=${14:# The tenant ID used for authentication.}
	tenant_name=${15:# The tenant name used for authentication.}

endsnippet

snippet rax_dns "Manage domains on Rackspace Cloud DNS" b
rax_dns: >
	comment=${1:# Brief description of the domain. Maximum length of 160 characters}
	email=${2:# Email address of the domain administrator}
	name=${3:# Domain name to create}
	state=${4:#present|absent}
	ttl=${5:3600}
	api_key=${6:# Rackspace API key, overrides I(credentials).}
	credentials=${7:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${8:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${9:DFW}
	username=${10:# Rackspace username, overrides I(credentials).}
	validate_certs=${11:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${12:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${13:rackspace}
	tenant_id=${14:# The tenant ID used for authentication.}
	tenant_name=${15:# The tenant name used for authentication.}

endsnippet

snippet rax_clb_ssl "Manage SSL termination for a Rackspace Cloud Load Balancer." b
rax_clb_ssl: >
	loadbalancer=${1:# Name or ID of the load balancer on which to manage SSL termination.}

	state=${2:#present|absent}
	enabled=${3:yes}
	private_key=${4:# The private SSL key as a string in PEM format.}
	certificate=${5:# The public SSL certificates as a string in PEM format.}
	intermediate_certificate=${6:# One or more intermediate certificate authorities as a string in PEM}
	secure_port=${7:443}
	secure_traffic_only=${8:no}
	https_redirect=${9:# If "true", the load balancer will redirect HTTP traffic to HTTPS.}
	wait=${10:no}
	wait_timeout=${11:300}
	api_key=${12:# Rackspace API key, overrides I(credentials).}
	credentials=${13:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${14:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${15:DFW}
	username=${16:# Rackspace username, overrides I(credentials).}
	validate_certs=${17:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${18:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${19:rackspace}
	tenant_id=${20:# The tenant ID used for authentication.}
	tenant_name=${21:# The tenant name used for authentication.}

endsnippet

snippet rax_mon_check "Create or delete a Rackspace Cloud Monitoring check for an existing entity." b
rax_mon_check: >
	entity_id=${1:# ID of the rax_mon_entity to target with this check.}
	label=${2:# Defines a label for this check, between 1 and 64 characters long.}
	check_type=${3:remote.dns|remote.ftp-banner|remote.http|remote.imap-banner|remote.mssql-banner|remote.mysql-banner|remote.ping|remote.pop3-banner|remote.postgresql-banner|remote.smtp-banner|remote.smtp|remote.ssh|remote.tcp|remote.telnet-banner|agent.filesystem|agent.memory|agent.load_average|agent.cpu|agent.disk|agent.network|agent.plugin}

	state=${4:present|absent}
	monitoring_zones_poll=${5:# Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks.}
	target_hostname=${6:# One of `target_hostname` and `target_alias` is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN.}
	target_alias=${7:# One of `target_alias` and `target_hostname` is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's `ip_addresses` hash to resolve an IP address to target.}
	details=${8:# Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items.}
	disabled=${9:# If "yes", ensure the check is created, but don't actually use it yet.}
	metadata=${10:# Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long.}
	period=${11:# The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.}
	timeout=${12:# The number of seconds this check will wait when attempting to collect results. Must be less than the period.}
	api_key=${13:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${14:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${15:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${16:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${17:rackspace}
	region=${18:DFW}
	tenant_id=${19:# The tenant ID used for authentication.}
	tenant_name=${20:# The tenant name used for authentication.}
	username=${21:# Rackspace username, overrides I(credentials).}
	validate_certs=${22:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_identity "Load Rackspace Cloud Identity" b
rax_identity: >
	state=${1:#present|absent}
	api_key=${2:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${3:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${4:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${5:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${6:rackspace}
	region=${7:DFW}
	tenant_id=${8:# The tenant ID used for authentication.}
	tenant_name=${9:# The tenant name used for authentication.}
	username=${10:# Rackspace username, overrides I(credentials).}
	validate_certs=${11:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_cdb "create/delete or resize a Rackspace Cloud Databases instance" b
rax_cdb: >
	name=${1:# Name of the databases server instance}
	flavor=${2:1}
	volume=${3:2}
	cdb_type=${4:MySQL}
	cdb_version=${5:5.1|5.6|10}
	state=${6:#present|absent}
	wait=${7:no}
	wait_timeout=${8:300}
	api_key=${9:# Rackspace API key, overrides I(credentials).}
	credentials=${10:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${11:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${12:DFW}
	username=${13:# Rackspace username, overrides I(credentials).}
	validate_certs=${14:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${15:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${16:rackspace}
	tenant_id=${17:# The tenant ID used for authentication.}
	tenant_name=${18:# The tenant name used for authentication.}

endsnippet

snippet rax_cbs_attachments "Manipulate Rackspace Cloud Block Storage Volume Attachments" b
rax_cbs_attachments: >
	volume=${1:# Name or id of the volume to attach/detach}
	server=${2:# Name or id of the server to attach/detach}
	state=${3:#present|absent}

	device=${4:# The device path to attach the volume to, e.g. /dev/xvde.}
	wait=${5:no}
	wait_timeout=${6:300}
	api_key=${7:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${8:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${9:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${10:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${11:rackspace}
	region=${12:DFW}
	tenant_id=${13:# The tenant ID used for authentication.}
	tenant_name=${14:# The tenant name used for authentication.}
	username=${15:# Rackspace username, overrides I(credentials).}
	validate_certs=${16:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_mon_notification_plan "Create or delete a Rackspace Cloud Monitoring notification plan." b
rax_mon_notification_plan: >
	label=${1:# Defines a friendly name for this notification plan. String between 1 and 255 characters long.}

	state=${2:present|absent}
	critical_state=${3:# Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notification ids.}
	warning_state=${4:# Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notification ids.}
	ok_state=${5:# Notification list to use when the alarm state is OK. Must be an array of valid rax_mon_notification ids.}
	api_key=${6:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${7:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${8:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${9:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${10:rackspace}
	region=${11:DFW}
	tenant_id=${12:# The tenant ID used for authentication.}
	tenant_name=${13:# The tenant name used for authentication.}
	username=${14:# Rackspace username, overrides I(credentials).}
	validate_certs=${15:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet rax_scaling_group "Manipulate Rackspace Cloud Autoscale Groups" b
rax_scaling_group: >
	flavor=${1:# flavor to use for the instance}
	image=${2:# image to use for the instance. Can be an C(id), C(human_id) or C(name)}
	max_entities=${3:# The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
	min_entities=${4:# The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.}
	name=${5:# Name to give the scaling group}
	server_name=${6:# The base name for servers created by Autoscale}

	config_drive=${7:no}
	cooldown=${8:# The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).}
	disk_config=${9:#auto|manual}
	files=${10:# Files to insert into the instance. Hash of C(remotepath: localpath)}
	key_name=${11:# key pair to use on the instance}
	loadbalancers=${12:# List of load balancer C(id) and C(port) hashes}
	meta=${13:# A hash of metadata to associate with the instance}
	networks=${14:['public', 'private']}
	state=${15:#present|absent}
	user_data=${16:# Data to be uploaded to the servers config drive. This option implies I(config_drive). Can be a file path or a string}
	wait=${17:no}
	wait_timeout=${18:300}
	api_key=${19:# Rackspace API key, overrides I(credentials).}
	credentials=${20:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${21:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	region=${22:DFW}
	username=${23:# Rackspace username, overrides I(credentials).}
	validate_certs=${24:# Whether or not to require SSL validation of API endpoints.}
	auth_endpoint=${25:https://identity.api.rackspacecloud.com/v2.0/}
	identity_type=${26:rackspace}
	tenant_id=${27:# The tenant ID used for authentication.}
	tenant_name=${28:# The tenant name used for authentication.}

endsnippet

snippet rax_mon_alarm "Create or delete a Rackspace Cloud Monitoring alarm." b
rax_mon_alarm: >
	label=${1:# Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long.}
	entity_id=${2:# ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task.}
	check_id=${3:# ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task.}
	notification_plan_id=${4:# ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mon_notification_plan task.}

	state=${5:#present|absent}
	criteria=${6:# Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http://docs.rackspace.com/cm/api/v1.0/cm-devguide/content/alerts-language.html for a reference on the alerting language.}
	disabled=${7:# If yes, create this alarm, but leave it in an inactive state. Defaults to no.}
	metadata=${8:# Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long.}
	api_key=${9:# Rackspace API key, overrides I(credentials).}
	auth_endpoint=${10:https://identity.api.rackspacecloud.com/v2.0/}
	credentials=${11:# File to find the Rackspace credentials in. Ignored if I(api_key) and I(username) are provided.}
	env=${12:# Environment as configured in I(~/.pyrax.cfg), see U(https://github.com/rackspace/pyrax/blob/master/docs/getting_started.md#pyrax-configuration).}
	identity_type=${13:rackspace}
	region=${14:DFW}
	tenant_id=${15:# The tenant ID used for authentication.}
	tenant_name=${16:# The tenant name used for authentication.}
	username=${17:# Rackspace username, overrides I(credentials).}
	validate_certs=${18:# Whether or not to require SSL validation of API endpoints.}

endsnippet

snippet pubnub_blocks "PubNub blocks management module." b
pubnub_blocks: >
	application=${1:# Name of target PubNub application for which blocks configuration on specific C(keyset) will be done.}
	keyset=${2:# Name of application's keys set which is bound to managed blocks.}
	name=${3:# Name of managed block which will be later visible on admin.pubnub.com.}

	email=${4:# Email from account for which new session should be started.}
	password=${5:# Password which match to account to which specified C(email) belong.}
	cache=${6:{}}
	account=${7:# Name of PubNub account for from which C(application) will be used to manage blocks.}
	state=${8:#started|stopped|present|absent}
	description=${9:New block}
	event_handlers=${10:[]}
	changes=${11:{}}
	validate_certs=${12:yes}

endsnippet

snippet gcp_pubsub_topic_info "Gather info for GCP Topic" b
gcp_pubsub_topic_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcpubsub_info "List Topics/Subscriptions and Messages from Google PubSub." b
gcpubsub_info: >
	view=${1:# Choices are 'topics' or 'subscriptions'}

	topic=${2:# GCP pubsub topic name.  Only the name, not the full path, is required.}
	state=${3:# list is the only valid option.}

endsnippet

snippet gcp_compute_target_https_proxy_info "Gather info for GCP TargetHttpsProxy" b
gcp_compute_target_https_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_firewall_info "Gather info for GCP Firewall" b
gcp_compute_firewall_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_image_info "Gather info for GCP Image" b
gcp_compute_image_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_https_proxy_info "Gather info for GCP TargetHttpsProxy" b
gcp_compute_target_https_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_mlengine_model "Creates a GCP Model" b
gcp_mlengine_model: >
	name=${1:# The name specified for the model.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	description=${4:# The description specified for the model when it was created.}
	default_version=${5:# The default version of the model. This version will be used to handle prediction requests that do not specify a version.}
	regions=${6:# The list of regions where the model is going to be deployed.}
	online_prediction_logging=${7:# If true, online prediction access logs are sent to StackDriver Logging.}
	online_prediction_console_logging=${8:# If true, online prediction nodes send stderr and stdout streams to Stackdriver Logging.}
	labels=${9:# One or more labels that you can add, to organize your models.}
	project=${10:# The Google Cloud Platform project to use.}
	service_account_contents=${11:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${12:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${13:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${14:# Array of scopes to be used.}
	env_type=${15:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_bigquery_dataset "Creates a GCP Dataset" b
gcp_bigquery_dataset: >
	dataset_reference=${1:# A reference that identifies the dataset.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	name=${4:# Dataset name.}
	access=${5:# An array of objects that define dataset access for one or more entities.}
	default_table_expiration_ms=${6:# The default lifetime of all tables in the dataset, in milliseconds.}
	default_partition_expiration_ms=${7:# The default partition expiration for all partitioned tables in the dataset, in milliseconds.}
	description=${8:# A user-friendly description of the dataset.}
	friendly_name=${9:# A descriptive name for the dataset.}
	labels=${10:# The labels associated with this dataset. You can use these to organize and group your datasets .}
	location=${11:US}
	project=${12:# The Google Cloud Platform project to use.}
	service_account_contents=${13:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${14:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${15:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${16:# Array of scopes to be used.}
	env_type=${17:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_backend_service "Creates a GCP BackendService" b
gcp_compute_backend_service: >
	health_checks=${1:# The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health checking this BackendService. Currently at most one health check can be specified, and a health check is required.}
	name=${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	affinity_cookie_ttl_sec=${5:# Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value for TTL is one day.}
	backends=${6:# The set of backends that serve this BackendService.}
	cdn_policy=${7:# Cloud CDN configuration for this BackendService.}
	connection_draining=${8:# Settings for connection draining .}
	description=${9:# An optional description of this resource.}
	enable_cdn=${10:# If true, enable Cloud CDN for this BackendService.}
	iap=${11:# Settings for enabling Cloud Identity Aware Proxy.}
	load_balancing_scheme=${12:EXTERNAL}
	port_name=${13:# Name of backend port. The same name should appear in the instance groups referenced by this service. Required when the load balancing scheme is EXTERNAL.}
	protocol=${14:# The protocol this BackendService uses to communicate with backends.}
	security_policy=${15:# The security policy associated with this backend service.}
	session_affinity=${16:# Type of session affinity to use. The default is NONE.}
	timeout_sec=${17:# How many seconds to wait for the backend before considering it a failed request. Default is 30 seconds. Valid range is [1, 86400].}
	project=${18:# The Google Cloud Platform project to use.}
	service_account_contents=${19:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${20:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${21:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${22:# Array of scopes to be used.}
	env_type=${23:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_firewall_info "Gather info for GCP Firewall" b
gcp_compute_firewall_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_interconnect_attachment "Creates a GCP InterconnectAttachment" b
gcp_compute_interconnect_attachment: >
	router=${1:# URL of the cloud router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network & region within which the Cloud Router is configured.}
	name=${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	region=${3:# Region where the regional interconnect attachment resides.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	admin_enabled=${6:# Whether the VLAN attachment is enabled or disabled. When using PARTNER type this will Pre-Activate the interconnect attachment .}
	interconnect=${7:# URL of the underlying Interconnect object that this attachment's traffic will traverse through. Required if type is DEDICATED, must not be set if type is PARTNER.}
	description=${8:# An optional description of this resource.}
	bandwidth=${9:# Provisioned bandwidth capacity for the interconnect attachment.}
	edge_availability_domain=${10:# Desired availability domain for the attachment. Only available for type PARTNER, at creation time. For improved reliability, customers should configure a pair of attachments with one per availability domain. The selected availability domain will be provided to the Partner via the pairing key so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.}
	type=${11:# The type of InterconnectAttachment you wish to create. Defaults to DEDICATED.}
	candidate_subnets=${12:# Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment.}
	vlan_tag8021q=${13:# The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. When using PARTNER type this will be managed upstream.}
	project=${14:# The Google Cloud Platform project to use.}
	service_account_contents=${15:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${16:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${17:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${18:# Array of scopes to be used.}
	env_type=${19:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_database "Creates a GCP Database" b
gcp_sql_database: >
	name=${1:# The name of the database in the Cloud SQL instance.}
	instance=${2:# The name of the Cloud SQL instance. This does not include the project ID.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	charset=${5:# The charset value. See MySQL's [Supported Character Sets and Collations](U(https://dev.mysql.com/doc/refman/5.7/en/charset-charsets.html)) and Postgres' [Character Set Support](U(https://www.postgresql.org/docs/9.6/static/multibyte.html)) for more details and supported values. Postgres databases only support a value of `UTF8` at creation time.}
	collation=${6:# The collation value. See MySQL's [Supported Character Sets and Collations](U(https://dev.mysql.com/doc/refman/5.7/en/charset-charsets.html)) and Postgres' [Collation Support](U(https://www.postgresql.org/docs/9.6/static/collation.html)) for more details and supported values. Postgres databases only support a value of `en_US.UTF8` at creation time.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_dns_managed_zone_info "Gather info for GCP ManagedZone" b
gcp_dns_managed_zone_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	dns_name=${2:# Restricts the list to return only zones with this domain name.}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_iam_role_info "Gather info for GCP Role" b
gcp_iam_role_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_ssl_certificate "Creates a GCP SslCertificate" b
gcp_compute_ssl_certificate: >
	certificate=${1:# The certificate in PEM format.}
	private_key=${2:# The write-only private key in PEM format.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource.}
	name=${6:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_bigquery_table_info "Gather info for GCP Table" b
gcp_bigquery_table_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	dataset=${2:# Name of the dataset.}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_mlengine_version_info "Gather info for GCP Version" b
gcp_mlengine_version_info: >
	model=${1:# The model that this version belongs to.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_user "Creates a GCP User" b
gcp_sql_user: >
	host=${1:# The host name from which the user can connect. For insert operations, host defaults to an empty string. For update operations, host is specified as part of the request URL. The host name cannot be updated after insertion.}
	name=${2:# The name of the user in the Cloud SQL instance.}
	instance=${3:# The name of the Cloud SQL instance. This does not include the project ID.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	password=${6:# The password for the user.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_global_forwarding_rule "Creates a GCP GlobalForwardingRule" b
gcp_compute_global_forwarding_rule: >
	name=${1:# Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	target=${2:# The URL of the target resource to receive the matched traffic.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource. Provide this property when you create the resource.}
	ip_address=${6:# The IP address that this forwarding rule is serving on behalf of.}
	ip_protocol=${7:# The IP protocol to which this rule applies. Valid options are TCP, UDP, ESP, AH, SCTP or ICMP. When the load balancing scheme is INTERNAL_SELF_MANAGED, only TCP is valid.}
	ip_version=${8:# The IP Version that will be used by this global forwarding rule.}
	load_balancing_scheme=${9:EXTERNAL}
	network=${10:# This field is not used for external load balancing.}
	port_range=${11:# This field is used along with the target field for TargetHttpProxy, TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool, TargetInstance.}
	project=${12:# The Google Cloud Platform project to use.}
	service_account_contents=${13:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${14:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${15:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${16:# Array of scopes to be used.}
	env_type=${17:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_health_check_info "Gather info for GCP HealthCheck" b
gcp_compute_health_check_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_iam_role "Creates a GCP Role" b
gcp_iam_role: >
	name=${1:# The name of the role.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	title=${4:# A human-readable title for the role. Typically this is limited to 100 UTF-8 bytes.}
	description=${5:# Human-readable description for the role.}
	included_permissions=${6:# Names of permissions this role grants when bound in an IAM policy.}
	stage=${7:# The current launch stage of the role.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_global_forwarding_rule_info "Gather info for GCP GlobalForwardingRule" b
gcp_compute_global_forwarding_rule_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_kms_crypto_key "Creates a GCP CryptoKey" b
gcp_kms_crypto_key: >
	name=${1:# The resource name for the CryptoKey.}
	key_ring=${2:# The KeyRing that this key belongs to.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	labels=${5:# Labels with user-defined metadata to apply to this resource.}
	purpose=${6:ENCRYPT_DECRYPT}
	rotation_period=${7:# Every time this period passes, generate a new CryptoKeyVersion and set it as the primary.}
	version_template=${8:# A template describing settings for new crypto key versions.}
	project=${9:# The Google Cloud Platform project to use.}
	service_account_contents=${10:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${11:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${12:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${13:# Array of scopes to be used.}
	env_type=${14:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_url_map_info "Gather info for GCP UrlMap" b
gcp_compute_url_map_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_mig "Create, Update or Destroy a Managed Instance Group (MIG)." b
gce_mig: >
	name=${1:# Name of the Managed Instance Group.}
	zone=${2:# The GCE zone to use for this Managed Instance Group.}

	template=${3:# Instance Template to be used in creating the VMs.  See U(https://cloud.google.com/compute/docs/instance-templates) to learn more about Instance Templates.  Required for creating MIGs.}
	size=${4:# Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.}
	service_account_email=${5:# service account email}
	credentials_file=${6:# Path to the JSON file associated with the service account email}
	project_id=${7:# GCE project ID}
	state=${8:absent|#present}
	autoscaling=${9:# A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and policy.max_instances (int) are required fields if autoscaling is used. See U(https://cloud.google.com/compute/docs/reference/beta/autoscalers) for more information on Autoscaling.}
	named_ports=${10:# Define named ports that backend services can forward data to.  Format is a a list of name:port dictionaries.}

endsnippet

snippet gcp_iam_service_account_info "Gather info for GCP ServiceAccount" b
gcp_iam_service_account_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_container_node_pool "Creates a GCP NodePool" b
gcp_container_node_pool: >
	initial_node_count=${1:# The initial node count for the pool. You must ensure that your Compute Engine resource quota is sufficient for this number of instances. You must also have available firewall and routes quota.}
	cluster=${2:# The cluster this node pool belongs to.}
	location=${3:# The location where the node pool is deployed.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	name=${6:# The name of the node pool.}
	config=${7:# The node configuration of the pool.}
	version=${8:# The version of the Kubernetes of this node.}
	autoscaling=${9:# Autoscaler configuration for this NodePool. Autoscaler is enabled only if a valid configuration is present.}
	management=${10:# Management configuration for this NodePool.}
	max_pods_constraint=${11:# The constraint on the maximum number of pods that can be run simultaneously on a node in the node pool.}
	conditions=${12:# Which conditions caused the current node pool state.}
	project=${13:# The Google Cloud Platform project to use.}
	service_account_contents=${14:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${15:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${16:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${17:# Array of scopes to be used.}
	env_type=${18:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_group_manager_info "Gather info for GCP InstanceGroupManager" b
gcp_compute_instance_group_manager_info: >
	zone=${1:# The zone the managed instance group resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_tcp_proxy "Creates a GCP TargetTcpProxy" b
gcp_compute_target_tcp_proxy: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	service=${2:# A reference to the BackendService resource.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource.}
	proxy_header=${6:# Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_cloudbuild_trigger "Creates a GCP Trigger" b
gcp_cloudbuild_trigger: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	state=${2:#present|absent}
	id=${3:# The unique identifier for the trigger.}
	description=${4:# Human-readable description of the trigger.}
	disabled=${5:# Whether the trigger is disabled or not. If true, the trigger will never result in a build.}
	substitutions=${6:# Substitutions data for Build resource.}
	filename=${7:# Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.}
	ignored_files=${8:# ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support for `**`.}
	included_files=${9:# ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support for `**`.}
	trigger_template=${10:# Template describing the types of source changes to trigger a build.}
	build=${11:# Contents of the build template. Either a filename or build template must be provided.}
	project=${12:# The Google Cloud Platform project to use.}
	service_account_contents=${13:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${14:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${15:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${16:# Array of scopes to be used.}
	env_type=${17:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_group_manager "Creates a GCP InstanceGroupManager" b
gcp_compute_instance_group_manager: >
	base_instance_name=${1:# The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name.}
	instance_template=${2:# The instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group.}
	name=${3:# The name of the managed instance group. The name must be 1-63 characters long, and comply with RFC1035.}
	zone=${4:# The zone the managed instance group resides.}
	auth_kind=${5:application|machineaccount|serviceaccount}

	state=${6:#present|absent}
	description=${7:# An optional description of this resource. Provide this property when you create the resource.}
	named_ports=${8:# Named ports configured for the Instance Groups complementary to this Instance Group Manager.}
	target_pools=${9:# TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.}
	target_size=${10:# The target number of running instances for this managed instance group. Deleting or abandoning instances reduces this number. Resizing the group changes this number.}
	project=${11:# The Google Cloud Platform project to use.}
	service_account_contents=${12:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${13:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${14:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${15:# Array of scopes to be used.}
	env_type=${16:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_template_info "Gather info for GCP InstanceTemplate" b
gcp_compute_instance_template_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_pubsub_subscription_info "Gather info for GCP Subscription" b
gcp_pubsub_subscription_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_ssl_proxy_info "Gather info for GCP TargetSslProxy" b
gcp_compute_target_ssl_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_cloudscheduler_job_info "Gather info for GCP Job" b
gcp_cloudscheduler_job_info: >
	region=${1:# Region where the scheduler job resides .}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_global_address "Creates a GCP GlobalAddress" b
gcp_compute_global_address: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	address=${4:# The static external IP address represented by this resource.}
	description=${5:# An optional description of this resource.}
	ip_version=${6:# The IP Version that will be used by this address. Valid options are `IPV4` or `IPV6`. The default value is `IPV4`.}
	prefix_length=${7:# The prefix length of the IP range. If not present, it means the address field is a single IP address.}
	address_type=${8:EXTERNAL}
	purpose=${9:# The purpose of the resource. For global internal addresses it can be * VPC_PEERING - for peer networks This should only be set when using an Internal address.}
	network=${10:# The URL of the network in which to reserve the IP range. The IP range must be in RFC1918 space. The network cannot be deleted if there are any reserved IP ranges referring to it.}
	project=${11:# The Google Cloud Platform project to use.}
	service_account_contents=${12:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${13:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${14:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${15:# Array of scopes to be used.}
	env_type=${16:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_ssl_proxy "Creates a GCP TargetSslProxy" b
gcp_compute_target_ssl_proxy: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	service=${2:# A reference to the BackendService resource.}
	ssl_certificates=${3:# A list of SslCertificate resources that are used to authenticate connections between users and the load balancer. Currently, exactly one SSL certificate must be specified.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# An optional description of this resource.}
	proxy_header=${7:# Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.}
	ssl_policy=${8:# A reference to the SslPolicy resource that will be associated with the TargetSslProxy resource. If not set, the TargetSslProxy resource will not have any SSL policy configured.}
	project=${9:# The Google Cloud Platform project to use.}
	service_account_contents=${10:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${11:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${12:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${13:# Array of scopes to be used.}
	env_type=${14:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_autoscaler "Creates a GCP Autoscaler" b
gcp_compute_autoscaler: >
	name=${1:# Name of the resource. The name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	autoscaling_policy=${2:# The configuration parameters for the autoscaling algorithm. You can define one or more of the policies for an autoscaler: cpuUtilization, customMetricUtilizations, and loadBalancingUtilization.}
	target=${3:# URL of the managed instance group that this autoscaler will scale.}
	zone=${4:# URL of the zone where the instance group resides.}
	auth_kind=${5:application|machineaccount|serviceaccount}

	state=${6:#present|absent}
	description=${7:# An optional description of this resource.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_cloudfunctions_cloud_function_info "Gather info for GCP CloudFunction" b
gcp_cloudfunctions_cloud_function_info: >
	location=${1:# The location of this cloud function.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_cloudbuild_trigger_info "Gather info for GCP Trigger" b
gcp_cloudbuild_trigger_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_http_proxy_info "Gather info for GCP TargetHttpProxy" b
gcp_compute_target_http_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_https_health_check "Creates a GCP HttpsHealthCheck" b
gcp_compute_https_health_check: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	check_interval_sec=${4:# How often (in seconds) to send a health check. The default value is 5 seconds.}
	description=${5:# An optional description of this resource. Provide this property when you create the resource.}
	healthy_threshold=${6:# A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.}
	host=${7:# The value of the host header in the HTTPS health check request. If left empty (default value), the public IP on behalf of which this health check is performed will be used.}
	port=${8:# The TCP port number for the HTTPS health check request.}
	request_path=${9:# The request path of the HTTPS health check request.}
	timeout_sec=${10:# How long (in seconds) to wait before claiming failure.}
	unhealthy_threshold=${11:# A so-far healthy instance will be marked unhealthy after this many consecutive failures. The default value is 2.}
	project=${12:# The Google Cloud Platform project to use.}
	service_account_contents=${13:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${14:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${15:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${16:# Array of scopes to be used.}
	env_type=${17:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_route "Creates a GCP Route" b
gcp_compute_route: >
	dest_range=${1:# The destination range of outgoing packets that this route applies to.}
	name=${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	network=${3:# The network that this route applies to.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# An optional description of this resource. Provide this property when you create the resource.}
	priority=${7:# The priority of this route. Priority is used to break ties in cases where there is more than one matching route of equal prefix length.}
	tags=${8:# A list of instance tags to which this route applies.}
	next_hop_gateway=${9:# URL to a gateway that should handle matching packets.}
	next_hop_instance=${10:# URL to an instance that should handle matching packets.}
	next_hop_ip=${11:# Network IP address of an instance that should handle matching packets.}
	next_hop_vpn_tunnel=${12:# URL to a VpnTunnel that should handle matching packets.}
	project=${13:# The Google Cloud Platform project to use.}
	service_account_contents=${14:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${15:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${16:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${17:# Array of scopes to be used.}
	env_type=${18:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_info "Gather info for GCP Instance" b
gcp_compute_instance_info: >
	zone=${1:# A reference to the zone where the machine resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_http_proxy "Creates a GCP TargetHttpProxy" b
gcp_compute_target_http_proxy: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	url_map=${2:# A reference to the UrlMap resource that defines the mapping from URL to the BackendService.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource.}
	project=${6:# The Google Cloud Platform project to use.}
	service_account_contents=${7:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${8:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${9:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${10:# Array of scopes to be used.}
	env_type=${11:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_container_cluster_info "Gather info for GCP Cluster" b
gcp_container_cluster_info: >
	location=${1:# The location where the cluster is deployed.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_https_health_check_info "Gather info for GCP HttpsHealthCheck" b
gcp_compute_https_health_check_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_group_manager_info "Gather info for GCP InstanceGroupManager" b
gcp_compute_instance_group_manager_info: >
	zone=${1:# The zone the managed instance group resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_kms_key_ring "Creates a GCP KeyRing" b
gcp_kms_key_ring: >
	name=${1:# The resource name for the KeyRing.}
	location=${2:# The location for the KeyRing.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	project=${5:# The Google Cloud Platform project to use.}
	service_account_contents=${6:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${7:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${8:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${9:# Array of scopes to be used.}
	env_type=${10:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_container_node_pool_info "Gather info for GCP NodePool" b
gcp_container_node_pool_info: >
	location=${1:# The location where the node pool is deployed.}
	cluster=${2:# The cluster this node pool belongs to.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_backend_service_info "Gather info for GCP BackendService" b
gcp_compute_backend_service_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_address "Creates a GCP Address" b
gcp_compute_address: >
	name=${1:# Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	region=${2:# URL of the region where the regional address resides.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	address=${5:# The static external IP address represented by this resource. Only IPv4 is supported. An address may only be specified for INTERNAL address types. The IP address must be inside the specified subnetwork, if any.}
	address_type=${6:EXTERNAL}
	description=${7:# An optional description of this resource.}
	network_tier=${8:# The networking tier used for configuring this address. This field can take the following values: PREMIUM or STANDARD. If this field is not specified, it is assumed to be PREMIUM.}
	subnetwork=${9:# The URL of the subnetwork in which to reserve the address. If an IP address is specified, it must be within the subnetwork's IP range.}
	project=${10:# The Google Cloud Platform project to use.}
	service_account_contents=${11:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${12:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${13:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${14:# Array of scopes to be used.}
	env_type=${15:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_bigquery_dataset_info "Gather info for GCP Dataset" b
gcp_bigquery_dataset_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_router_info "Gather info for GCP Router" b
gcp_compute_router_info: >
	region=${1:# Region where the router resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_region_disk_info "Gather info for GCP RegionDisk" b
gcp_compute_region_disk_info: >
	region=${1:# A reference to the region where the disk resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_tpu_node "Creates a GCP Node" b
gcp_tpu_node: >
	name=${1:# The immutable name of the TPU.}
	accelerator_type=${2:# The type of hardware accelerators associated with this node.}
	tensorflow_version=${3:# The version of Tensorflow running in the Node.}
	cidr_block=${4:# The CIDR block that the TPU node will use when selecting an IP address. This CIDR block must be a /29 block; the Compute Engine networks API forbids a smaller block, and using a larger block would be wasteful (a node can only consume one IP address).}
	zone=${5:# The GCP location for the TPU.}
	auth_kind=${6:application|machineaccount|serviceaccount}

	state=${7:#present|absent}
	description=${8:# The user-supplied description of the TPU. Maximum of 512 characters.}
	network=${9:# The name of a network to peer the TPU node to. It must be a preexisting Compute Engine network inside of the project on which this API has been activated. If none is provided, "default" will be used.}
	scheduling_config=${10:# Sets the scheduling options for this TPU instance.}
	labels=${11:# Resource labels to represent user provided metadata.}
	project=${12:# The Google Cloud Platform project to use.}
	service_account_contents=${13:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${14:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${15:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${16:# Array of scopes to be used.}
	env_type=${17:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_template_info "Gather info for GCP InstanceTemplate" b
gcp_compute_instance_template_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_forwarding_rule "Creates a GCP ForwardingRule" b
gcp_compute_forwarding_rule: >
	name=${1:# Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	region=${2:# A reference to the region where the regional forwarding rule resides.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource. Provide this property when you create the resource.}
	ip_address=${6:# The IP address that this forwarding rule is serving on behalf of.}
	ip_protocol=${7:# The IP protocol to which this rule applies. Valid options are TCP, UDP, ESP, AH, SCTP or ICMP.}
	backend_service=${8:# A BackendService to receive the matched traffic. This is used only for INTERNAL load balancing.}
	ip_version=${9:# ipVersion is not a valid field for regional forwarding rules.}
	load_balancing_scheme=${10:# This signifies what the ForwardingRule will be used for and can only take the following values: INTERNAL, EXTERNAL The value of INTERNAL means that this will be used for Internal Network Load Balancing (TCP, UDP). The value of EXTERNAL means that this will be used for External Load Balancing (HTTP(S) LB, External TCP/UDP LB, SSL Proxy) .}
	network=${11:# For internal load balancing, this field identifies the network that the load balanced IP should belong to for this Forwarding Rule. If this field is not specified, the default network will be used.}
	port_range=${12:# This field is used along with the target field for TargetHttpProxy, TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway, TargetPool, TargetInstance.}
	ports=${13:# This field is used along with the backend_service field for internal load balancing.}
	subnetwork=${14:# The subnetwork that the load balanced IP should belong to for this Forwarding Rule. This field is only used for INTERNAL load balancing.}
	target=${15:# This field is only used for EXTERNAL load balancing.}
	all_ports=${16:# For internal TCP/UDP load balancing (i.e. load balancing scheme is INTERNAL and protocol is TCP/UDP), set this to true to allow packets addressed to any ports to be forwarded to the backends configured with this forwarding rule. Used with backend service. Cannot be set if port or portRange are set.}
	network_tier=${17:# The networking tier used for configuring this address. This field can take the following values: PREMIUM or STANDARD. If this field is not specified, it is assumed to be PREMIUM.}
	service_label=${18:# An optional prefix to the service name for this Forwarding Rule.}
	project=${19:# The Google Cloud Platform project to use.}
	service_account_contents=${20:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${21:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${22:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${23:# Array of scopes to be used.}
	env_type=${24:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance "Creates a GCP Instance" b
gcp_compute_instance: >
	zone=${1:# A reference to the zone where the machine resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	can_ip_forward=${4:# Allows this instance to send and receive packets with non-matching destination or source IPs. This is required if you plan to use this instance to forward routes.}
	deletion_protection=${5:# Whether the resource should be protected against deletion.}
	disks=${6:# An array of disks that are associated with the instances that are created from this template.}
	guest_accelerators=${7:# List of the type and count of accelerator cards attached to the instance .}
	hostname=${8:# The hostname of the instance to be created. The specified hostname must be RFC1035 compliant. If hostname is not specified, the default hostname is [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.}
	labels=${9:# Labels to apply to this instance. A list of key->value pairs.}
	metadata=${10:# The metadata key/value pairs to assign to instances that are created from this template. These pairs can consist of custom metadata or predefined keys.}
	machine_type=${11:# A reference to a machine type which defines VM kind.}
	min_cpu_platform=${12:# Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms .}
	name=${13:# The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	network_interfaces=${14:# An array of configurations for this interface. This specifies how this interface is configured to interact with other network services, such as connecting to the internet. Only one network interface is supported per instance.}
	scheduling=${15:# Sets the scheduling options for this instance.}
	service_accounts=${16:# A list of service accounts, with their specified scopes, authorized for this instance. Only one service account per VM instance is supported.}
	shielded_instance_config=${17:# Configuration for various parameters related to shielded instances.}
	status=${18:# The status of the instance. One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, and TERMINATED.}
	tags=${19:# A list of tags to apply to this instance. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during instance creation. The tags can be later modified by the setTags method. Each tag within the list must comply with RFC1035.}
	project=${20:# The Google Cloud Platform project to use.}
	service_account_contents=${21:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${22:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${23:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${24:# Array of scopes to be used.}
	env_type=${25:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_vpn_gateway_info "Gather info for GCP TargetVpnGateway" b
gcp_compute_target_vpn_gateway_info: >
	region=${1:# The region this gateway should sit in.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_spanner_instance_info "Gather info for GCP Instance" b
gcp_spanner_instance_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_redis_instance "Creates a GCP Instance" b
gcp_redis_instance: >
	name=${1:# The ID of the instance or a fully qualified identifier for the instance. .}
	memory_size_gb=${2:# Redis memory size in GiB.}
	region=${3:# The name of the Redis region of the instance.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	alternative_location_id=${6:# Only applicable to STANDARD_HA tier which protects the instance against zonal failures by provisioning it across two zones.}
	authorized_network=${7:# The full name of the Google Compute Engine network to which the instance is connected. If left unspecified, the default network will be used.}
	display_name=${8:# An arbitrary and optional user-provided name for the instance.}
	labels=${9:# Resource labels to represent user provided metadata.}
	redis_configs=${10:# Redis configuration parameters, according to U(http://redis.io/topics/config).}
	location_id=${11:# The zone where the instance will be provisioned. If not provided, the service will choose a zone for the instance. For STANDARD_HA tier, instances will be created across two zones for protection against zonal failures. If [alternativeLocationId] is also provided, it must be different from [locationId].}
	redis_version=${12:# The version of Redis software. If not provided, latest supported version will be used. Currently, the supported values are: - REDIS_4_0 for Redis 4.0 compatibility - REDIS_3_2 for Redis 3.2 compatibility .}
	reserved_ip_range=${13:# The CIDR range of internal addresses that are reserved for this instance. If not provided, the service will choose an unused /29 block, for example, 10.0.0.0/29 or 192.168.0.0/29. Ranges must be unique and non-overlapping with existing subnets in an authorized network.}
	tier=${14:BASIC}
	project=${15:# The Google Cloud Platform project to use.}
	service_account_contents=${16:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${17:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${18:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${19:# Array of scopes to be used.}
	env_type=${20:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_ssl_proxy_info "Gather info for GCP TargetSslProxy" b
gcp_compute_target_ssl_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_https_proxy "Creates a GCP TargetHttpsProxy" b
gcp_compute_target_https_proxy: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	ssl_certificates=${2:# A list of SslCertificate resources that are used to authenticate connections between users and the load balancer. Currently, exactly one SSL certificate must be specified.}
	url_map=${3:# A reference to the UrlMap resource that defines the mapping from URL to the BackendService.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# An optional description of this resource.}
	quic_override=${7:# Specifies the QUIC override policy for this resource. This determines whether the load balancer will attempt to negotiate QUIC with clients or not. Can specify one of NONE, ENABLE, or DISABLE. If NONE is specified, uses the QUIC policy with no user overrides, which is equivalent to DISABLE. Not specifying this field is equivalent to specifying NONE.}
	ssl_policy=${8:# A reference to the SslPolicy resource that will be associated with the TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource will not have any SSL policy configured.}
	project=${9:# The Google Cloud Platform project to use.}
	service_account_contents=${10:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${11:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${12:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${13:# Array of scopes to be used.}
	env_type=${14:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_route_info "Gather info for GCP Route" b
gcp_compute_route_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_spanner_database_info "Gather info for GCP Database" b
gcp_spanner_database_info: >
	instance=${1:# The instance to create the database on.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_instance "Creates a GCP Instance" b
gcp_sql_instance: >
	name=${1:# Name of the Cloud SQL instance. This does not include the project ID.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	backend_type=${4:# * FIRST_GEN: First Generation instance. MySQL only.}
	connection_name=${5:# Connection name of the Cloud SQL instance used in connection strings.}
	database_version=${6:# The database engine type and version. For First Generation instances, can be MYSQL_5_5, or MYSQL_5_6. For Second Generation instances, can be MYSQL_5_6 or MYSQL_5_7. Defaults to MYSQL_5_6.}
	failover_replica=${7:# The name and status of the failover replica. This property is applicable only to Second Generation instances.}
	instance_type=${8:# The instance type. This can be one of the following.}
	ipv6_address=${9:# The IPv6 address assigned to the instance. This property is applicable only to First Generation instances.}
	master_instance_name=${10:# The name of the instance which will act as master in the replication setup.}
	max_disk_size=${11:# The maximum disk size of the instance in bytes.}
	region=${12:# The geographical region. Defaults to us-central or us-central1 depending on the instance type (First Generation or Second Generation/PostgreSQL).}
	replica_configuration=${13:# Configuration specific to failover replicas and read replicas.}
	settings=${14:# The user settings.}
	project=${15:# The Google Cloud Platform project to use.}
	service_account_contents=${16:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${17:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${18:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${19:# Array of scopes to be used.}
	env_type=${20:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_forwarding_rule_info "Gather info for GCP ForwardingRule" b
gcp_compute_forwarding_rule_info: >
	region=${1:# A reference to the region where the regional forwarding rule resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_dns_resource_record_set "Creates a GCP ResourceRecordSet" b
gcp_dns_resource_record_set: >
	name=${1:# For example, U(www.example.com).}
	type=${2:# One of valid DNS resource types.}
	managed_zone=${3:# Identifies the managed zone addressed by this request. This must be a dictionary that contains both a 'name' key and a 'dnsName' key. You can pass in the results of the gcp_dns_managed_zone module, which will contain both.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	ttl=${6:# Number of seconds that this ResourceRecordSet can be cached by resolvers.}
	target=${7:# As defined in RFC 1035 (section 5) and RFC 1034 (section 3.6.1) .}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_group_info "Gather info for GCP InstanceGroup" b
gcp_compute_instance_group_info: >
	zone=${1:# A reference to the zone where the instance group resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_route_info "Gather info for GCP Route" b
gcp_compute_route_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_resourcemanager_project "Creates a GCP Project" b
gcp_resourcemanager_project: >
	id=${1:# The unique, user-assigned ID of the Project. It must be 6 to 30 lowercase letters, digits, or hyphens. It must start with a letter.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	name=${4:# The user-assigned display name of the Project. It must be 4 to 30 characters. Allowed characters are: lowercase and uppercase letters, numbers, hyphen, single-quote, double-quote, space, and exclamation point.}
	labels=${5:# The labels associated with this Project.}
	parent=${6:# A parent organization.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_redis_instance_info "Gather info for GCP Instance" b
gcp_redis_instance_info: >
	region=${1:# The name of the Redis region of the instance.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_net "create/destroy GCE networks and firewall rules" b
gce_net: >
	allowed=${1:# the protocol:ports to allow (I(tcp:80) or I(tcp:80,443) or I(tcp:80-800;udp:1-25)) this parameter is mandatory when creating or updating a firewall rule}
	ipv4_range=${2:# the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory}
	fwname=${3:# name of the firewall rule}
	name=${4:# name of the network}
	src_range=${5:[]}
	src_tags=${6:[]}
	target_tags=${7:[]}
	state=${8:active|#present|absent|deleted}
	service_account_email=${9:# service account email}
	pem_file=${10:# path to the pem file associated with the service account email This option is deprecated. Use C(credentials_file).}
	credentials_file=${11:# path to the JSON file associated with the service account email}
	project_id=${12:# your GCE project ID}
	mode=${13:#legacy|auto|custom}
	subnet_name=${14:# name of subnet to create}
	subnet_region=${15:# region of subnet to create}
	subnet_desc=${16:# description of subnet to create}

endsnippet

snippet gcp_iam_service_account "Creates a GCP ServiceAccount" b
gcp_iam_service_account: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	state=${2:#present|absent}
	name=${3:# The name of the service account.}
	display_name=${4:# User specified description of service account.}
	project=${5:# The Google Cloud Platform project to use.}
	service_account_contents=${6:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${7:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${8:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${9:# Array of scopes to be used.}
	env_type=${10:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcpubsub "Create and Delete Topics/Subscriptions, Publish and pull messages on PubSub" b
gcpubsub: >
	topic=${1:# GCP pubsub topic name.}

	subscription=${2:# Dictionary containing a subscription name associated with a topic (required), along with optional ack_deadline, push_endpoint and pull. For pulling from a subscription, message_ack (bool), max_messages (int) and return_immediate are available as subfields. See subfields name, push_endpoint and ack_deadline for more information.}
	name=${3:# S}
	ack_deadline=${4:# S}
	pull=${5:# Subfield of subscription. Not required. If specified, messages will be retrieved from topic via the provided subscription name. max_messages (int; default None; max number of messages to pull), message_ack (bool; default False; acknowledge the message) and return_immediately (bool; default True, don't wait for messages to appear). If the messages are acknowledged, changed is set to True, otherwise, changed is False.}
	push_endpoint=${6:# Subfield of subscription.  Not required.  If specified, message will be sent to an endpoint. See U(https://cloud.google.com/pubsub/docs/advanced#push_endpoints) for more information.}
	publish=${7:# List of dictionaries describing messages and attributes to be published.  Dictionary is in message(str):attributes(dict) format. Only message is required.}
	state=${8:absent|#present}

endsnippet

snippet gcp_mlengine_version "Creates a GCP Version" b
gcp_mlengine_version: >
	name=${1:# The name specified for the version when it was created.}
	deployment_uri=${2:# The Cloud Storage location of the trained model used to create the version.}
	model=${3:# The model that this version belongs to.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# The description specified for the version when it was created.}
	runtime_version=${7:# The AI Platform runtime version to use for this deployment.}
	machine_type=${8:# The type of machine on which to serve the model. Currently only applies to online prediction service.}
	labels=${9:# One or more labels that you can add, to organize your model versions.}
	framework=${10:# The machine learning framework AI Platform uses to train this version of the model.}
	python_version=${11:# The version of Python used in prediction. If not set, the default version is '2.7'. Python '3.5' is available when runtimeVersion is set to '1.4' and above. Python '2.7' works with all supported runtime versions.}
	service_account=${12:# Specifies the service account for resource access control.}
	auto_scaling=${13:# Automatically scale the number of nodes used to serve the model in response to increases and decreases in traffic. Care should be taken to ramp up traffic according to the model's ability to scale or you will start seeing increases in latency and 429 response codes.}
	manual_scaling=${14:# Manually select the number of nodes to use for serving the model. You should generally use autoScaling with an appropriate minNodes instead, but this option is available if you want more predictable billing. Beware that latency and error rates will increase if the traffic exceeds that capability of the system to serve it based on the selected number of nodes.}
	prediction_class=${15:# The fully qualified name (module_name.class_name) of a class that implements the Predictor interface described in this reference field. The module containing this class should be included in a package provided to the packageUris field.}
	is_default=${16:# If true, this version will be used to handle prediction requests that do not specify a version.}
	project=${17:# The Google Cloud Platform project to use.}
	service_account_contents=${18:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${19:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${20:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${21:# Array of scopes to be used.}
	env_type=${22:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_iam_service_account_info "Gather info for GCP ServiceAccount" b
gcp_iam_service_account_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_cloudtasks_queue "Creates a GCP Queue" b
gcp_cloudtasks_queue: >
	location=${1:# The location of the queue.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	name=${4:# The queue name.}
	app_engine_routing_override=${5:# Overrides for task-level appEngineRouting. These settings apply only to App Engine tasks in this queue .}
	rate_limits=${6:# Rate limits for task dispatches. The queue's actual dispatch rate is the result of: * Number of tasks in the queue * User-specified throttling: rateLimits, retryConfig, and the queue's state.}
	retry_config=${7:# Settings that determine the retry behavior.}
	status=${8:# The current state of the queue.}
	project=${9:# The Google Cloud Platform project to use.}
	service_account_contents=${10:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${11:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${12:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${13:# Array of scopes to be used.}
	env_type=${14:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_container_cluster_info "Gather info for GCP Cluster" b
gcp_container_cluster_info: >
	location=${1:# The location where the cluster is deployed.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_interconnect_attachment_info "Gather info for GCP InterconnectAttachment" b
gcp_compute_interconnect_attachment_info: >
	region=${1:# Region where the regional interconnect attachment resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_router "Creates a GCP Router" b
gcp_compute_router: >
	name=${1:# Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	network=${2:# A reference to the network to which this router belongs.}
	region=${3:# Region where the router resides.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# An optional description of this resource.}
	bgp=${7:# BGP information specific to this router.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_group "Creates a GCP InstanceGroup" b
gcp_compute_instance_group: >
	zone=${1:# A reference to the zone where the instance group resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	description=${4:# An optional description of this resource. Provide this property when you create the resource.}
	name=${5:# The name of the instance group.}
	named_ports=${6:# Assigns a name to a port number.}
	network=${7:# The network to which all instances in the instance group belong.}
	region=${8:# The region where the instance group is located (for regional resources).}
	subnetwork=${9:# The subnetwork to which all instances in the instance group belong.}
	instances=${10:# The list of instances associated with this InstanceGroup.}
	project=${11:# The Google Cloud Platform project to use.}
	service_account_contents=${12:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${13:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${14:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${15:# Array of scopes to be used.}
	env_type=${16:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sourcerepo_repository_info "Gather info for GCP Repository" b
gcp_sourcerepo_repository_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_ssl_certificate_info "Gather info for GCP SslCertificate" b
gcp_compute_ssl_certificate_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_storage_bucket "Creates a GCP Bucket" b
gcp_storage_bucket: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	state=${2:#present|absent}
	acl=${3:# Access controls on the bucket.}
	cors=${4:# The bucket's Cross-Origin Resource Sharing (CORS) configuration.}
	default_object_acl=${5:# Default access controls to apply to new objects when no ACL is provided.}
	lifecycle=${6:# The bucket's lifecycle configuration.}
	location=${7:# The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Defaults to US. See the developer's guide for the authoritative list.}
	logging=${8:# The bucket's logging configuration, which defines the destination bucket and optional name prefix for the current bucket's logs.}
	metageneration=${9:# The metadata generation of this bucket.}
	name=${10:# The name of the bucket.}
	owner=${11:# The owner of the bucket. This is always the project team's owner group.}
	storage_class=${12:# The bucket's default storage class, used whenever no storageClass is specified for a newly-created object. This defines how objects in the bucket are stored and determines the SLA and the cost of storage.}
	versioning=${13:# The bucket's versioning configuration.}
	website=${14:# The bucket's website configuration, controlling how the service behaves when accessing bucket contents as a web site. See the Static Website Examples for more information.}
	project=${15:# A valid API project identifier.}
	predefined_default_object_acl=${16:# Apply a predefined set of default object access controls to this bucket.}
	service_account_contents=${17:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${18:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${19:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${20:# Array of scopes to be used.}
	env_type=${21:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_kms_crypto_key_info "Gather info for GCP CryptoKey" b
gcp_kms_crypto_key_info: >
	key_ring=${1:# The KeyRing that this key belongs to.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_firewall "Creates a GCP Firewall" b
gcp_compute_firewall: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	allowed=${4:# The list of ALLOW rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a permitted connection.}
	denied=${5:# The list of DENY rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a denied connection.}
	description=${6:# An optional description of this resource. Provide this property when you create the resource.}
	destination_ranges=${7:# If destination ranges are specified, the firewall will apply only to traffic that has destination IP address in these ranges. These ranges must be expressed in CIDR format. Only IPv4 is supported.}
	direction=${8:# Direction of traffic to which this firewall applies; default is INGRESS. Note: For INGRESS traffic, it is NOT supported to specify destinationRanges; For EGRESS traffic, it is NOT supported to specify sourceRanges OR sourceTags.}
	disabled=${9:# Denotes whether the firewall rule is disabled, i.e not applied to the network it is associated with. When set to true, the firewall rule is not enforced and the network behaves as if it did not exist. If this is unspecified, the firewall rule will be enabled.}
	network=${10:{'selfLink': 'global/networks/default'}}
	priority=${11:1000}
	source_ranges=${12:# If source ranges are specified, the firewall will apply only to traffic that has source IP address in these ranges. These ranges must be expressed in CIDR format. One or both of sourceRanges and sourceTags may be set. If both properties are set, the firewall will apply to traffic that has source IP address within sourceRanges OR the source IP that belongs to a tag listed in the sourceTags property. The connection does not need to match both properties for the firewall to apply. Only IPv4 is supported.}
	source_service_accounts=${13:# If source service accounts are specified, the firewall will apply only to traffic originating from an instance with a service account in this list. Source service accounts cannot be used to control traffic to an instance's external IP address because service accounts are associated with an instance, not an IP address. sourceRanges can be set at the same time as sourceServiceAccounts. If both are set, the firewall will apply to traffic that has source IP address within sourceRanges OR the source IP belongs to an instance with service account listed in sourceServiceAccount. The connection does not need to match both properties for the firewall to apply. sourceServiceAccounts cannot be used at the same time as sourceTags or targetTags.}
	source_tags=${14:# If source tags are specified, the firewall will apply only to traffic with source IP that belongs to a tag listed in source tags. Source tags cannot be used to control traffic to an instance's external IP address. Because tags are associated with an instance, not an IP address. One or both of sourceRanges and sourceTags may be set. If both properties are set, the firewall will apply to traffic that has source IP address within sourceRanges OR the source IP that belongs to a tag listed in the sourceTags property. The connection does not need to match both properties for the firewall to apply.}
	target_service_accounts=${15:# A list of service accounts indicating sets of instances located in the network that may make network connections as specified in allowed[].}
	target_tags=${16:# A list of instance tags indicating sets of instances located in the network that may make network connections as specified in allowed[].}
	project=${17:# The Google Cloud Platform project to use.}
	service_account_contents=${18:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${19:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${20:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${21:# Array of scopes to be used.}
	env_type=${22:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_tpu_node_info "Gather info for GCP Node" b
gcp_tpu_node_info: >
	zone=${1:# The GCP location for the TPU.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_cloudbuild_trigger_info "Gather info for GCP Trigger" b
gcp_cloudbuild_trigger_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_storage_object "Creates a GCP Object" b
gcp_storage_object: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	state=${2:#present|absent}
	action=${3:# Upload or download from the bucket.}
	overwrite=${4:# 'Overwrite the file on the bucket/local machine. If overwrite is false and a difference exists between GCS + local, module will fail with error' .}
	src=${5:# Source location of file (may be local machine or cloud depending on action).}
	dest=${6:# Destination location of file (may be local machine or cloud depending on action).}
	bucket=${7:# The name of the bucket.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_https_health_check_info "Gather info for GCP HttpsHealthCheck" b
gcp_compute_https_health_check_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sourcerepo_repository "Creates a GCP Repository" b
gcp_sourcerepo_repository: >
	name=${1:# Resource name of the repository, of the form projects/{{project}}/repos/{{repo}}.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_pool "Creates a GCP TargetPool" b
gcp_compute_target_pool: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	region=${2:# The region where the target pool resides.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	backup_pool=${5:# This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool, and its failoverRatio field is properly set to a value between [0, 1].}
	description=${6:# An optional description of this resource.}
	failover_ratio=${7:# This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool (i.e., not as a backup pool to some other target pool). The value of the field must be in [0, 1].}
	health_check=${8:# A reference to a HttpHealthCheck resource.}
	instances=${9:# A list of virtual machine instances serving this pool.}
	session_affinity=${10:# Session affinity option. Must be one of these values: - NONE: Connections from the same client IP may go to any instance in the pool.}
	project=${11:# The Google Cloud Platform project to use.}
	service_account_contents=${12:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${13:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${14:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${15:# Array of scopes to be used.}
	env_type=${16:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_http_health_check_info "Gather info for GCP HttpHealthCheck" b
gcp_compute_http_health_check_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_global_address_info "Gather info for GCP GlobalAddress" b
gcp_compute_global_address_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_global_forwarding_rule_info "Gather info for GCP GlobalForwardingRule" b
gcp_compute_global_forwarding_rule_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_info "Gather info for GCP Instance" b
gcp_compute_instance_info: >
	zone=${1:# A reference to the zone where the machine resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_iam_service_account_key "Creates a GCP ServiceAccountKey" b
gcp_iam_service_account_key: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	state=${2:#present|absent}
	private_key_type=${3:# Output format for the service account key.}
	key_algorithm=${4:# Specifies the algorithm for the key.}
	service_account=${5:# The name of the serviceAccount.}
	path=${6:# The full name of the file that will hold the service account private key. The management of this file will depend on the value of sync_file parameter.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_global_address_info "Gather info for GCP GlobalAddress" b
gcp_compute_global_address_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_image "Creates a GCP Image" b
gcp_compute_image: >
	name=${1:# Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	description=${4:# An optional description of this resource. Provide this property when you create the resource.}
	disk_size_gb=${5:# Size of the image when restored onto a persistent disk (in GB).}
	family=${6:# The name of the image family to which this image belongs. You can create disks by specifying an image family instead of a specific image name. The image family always returns its latest image that is not deprecated. The name of the image family must comply with RFC1035.}
	guest_os_features=${7:# A list of features to enable on the guest OS. Applicable for bootable images only. Currently, only one feature can be enabled, VIRTIO_SCSI_MULTIQUEUE, which allows each virtual CPU to have its own queue. For Windows images, you can only enable VIRTIO_SCSI_MULTIQUEUE on images with driver version 1.2.0.1621 or higher. Linux images with kernel versions 3.17 and higher will support VIRTIO_SCSI_MULTIQUEUE.}
	image_encryption_key=${8:# Encrypts the image using a customer-supplied encryption key.}
	labels=${9:# Labels to apply to this Image.}
	licenses=${10:# Any applicable license URI.}
	raw_disk=${11:# The parameters of the raw disk image.}
	source_disk=${12:# The source disk to create this image based on.}
	source_disk_encryption_key=${13:# The customer-supplied encryption key of the source disk. Required if the source disk is protected by a customer-supplied encryption key.}
	source_disk_id=${14:# The ID value of the disk used to create this image. This value may be used to determine whether the image was taken from the current or a previous instance of a given disk name.}
	source_type=${15:# The type of the image used to create this disk. The default and only value is RAW .}
	project=${16:# The Google Cloud Platform project to use.}
	service_account_contents=${17:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${18:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${19:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${20:# Array of scopes to be used.}
	env_type=${21:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_img "utilize GCE image resources" b
gce_img: >
	name=${1:# the name of the image to create or delete}

	description=${2:# an optional description}
	family=${3:# an optional family name}
	source=${4:# the source disk or the Google Cloud Storage URI to create the image from}
	state=${5:#present|absent}
	zone=${6:us-central1-a}
	timeout=${7:180}
	service_account_email=${8:# service account email}
	pem_file=${9:# path to the pem file associated with the service account email}
	project_id=${10:# your GCE project ID}

endsnippet

snippet gcp_compute_forwarding_rule_info "Gather info for GCP ForwardingRule" b
gcp_compute_forwarding_rule_info: >
	region=${1:# A reference to the region where the regional forwarding rule resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_container_node_pool_info "Gather info for GCP NodePool" b
gcp_container_node_pool_info: >
	location=${1:# The location where the node pool is deployed.}
	cluster=${2:# The cluster this node pool belongs to.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_vpn_tunnel_info "Gather info for GCP VpnTunnel" b
gcp_compute_vpn_tunnel_info: >
	region=${1:# The region where the tunnel is located.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_subnetwork_info "Gather info for GCP Subnetwork" b
gcp_compute_subnetwork_info: >
	region=${1:# URL of the GCP region for this subnetwork.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_dns_managed_zone_info "Gather info for GCP ManagedZone" b
gcp_dns_managed_zone_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	dns_name=${2:# Restricts the list to return only zones with this domain name.}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_template "Creates a GCP InstanceTemplate" b
gcp_compute_instance_template: >
	name=${1:# Name of the resource. The name is 1-63 characters long and complies with RFC1035.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	description=${4:# An optional description of this resource. Provide this property when you create the resource.}
	properties=${5:# The instance properties for this instance template.}
	project=${6:# The Google Cloud Platform project to use.}
	service_account_contents=${7:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${8:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${9:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${10:# Array of scopes to be used.}
	env_type=${11:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_dns_resource_record_set_info "Gather info for GCP ResourceRecordSet" b
gcp_dns_resource_record_set_info: >
	managed_zone=${1:# Identifies the managed zone addressed by this request. This must be a dictionary that contains both a 'name' key and a 'dnsName' key. You can pass in the results of the gcp_dns_managed_zone module, which will contain both.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_lb "create/destroy GCE load-balancer resources" b
gce_lb: >
	httphealthcheck_name=${1:# the name identifier for the HTTP health check}
	httphealthcheck_port=${2:80}
	httphealthcheck_path=${3:/}
	httphealthcheck_interval=${4:5}
	httphealthcheck_timeout=${5:5}
	httphealthcheck_unhealthy_count=${6:2}
	httphealthcheck_healthy_count=${7:2}
	httphealthcheck_host=${8:# host header to pass through on HTTP check requests}
	name=${9:# name of the load-balancer resource}
	protocol=${10:#tcp|udp}
	region=${11:# the GCE region where the load-balancer is defined}
	external_ip=${12:# the external static IPv4 (or auto-assigned) address for the LB}
	port_range=${13:# the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports}
	members=${14:# a list of zone/nodename pairs, e.g ['us-central1-a/www-a', ...]}
	state=${15:active|#present|absent|deleted}
	service_account_email=${16:# service account email}
	pem_file=${17:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
	credentials_file=${18:# path to the JSON file associated with the service account email}
	project_id=${19:# your GCE project ID}

endsnippet

snippet gcp_compute_target_tcp_proxy_info "Gather info for GCP TargetTcpProxy" b
gcp_compute_target_tcp_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_backend_bucket_info "Gather info for GCP BackendBucket" b
gcp_compute_backend_bucket_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_ssl_policy_info "Gather info for GCP SslPolicy" b
gcp_compute_ssl_policy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gc_storage "This module manages objects/buckets in Google Cloud Storage." b
gc_storage: >
	bucket=${1:# Bucket name.}
	mode=${2:get|put|get_url|get_str|delete|create}
	gs_secret_key=${3:# GS secret key. If not set then the value of the GS_SECRET_ACCESS_KEY environment variable is used.}
	gs_access_key=${4:# GS access key. If not set then the value of the GS_ACCESS_KEY_ID environment variable is used.}

	object=${5:# Keyname of the object inside the bucket. Can be also be used to create "virtual directories" (see examples).}
	src=${6:# The source file path when performing a PUT operation.}
	dest=${7:# The destination file path when downloading an object/key with a GET operation.}
	force=${8:yes}
	permission=${9:private}
	headers=${10:{}}
	expiration=${11:# Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.}
	region=${12:US}
	versioning=${13:# Whether versioning is enabled or disabled (note that once versioning is enabled, it can only be suspended)}

endsnippet

snippet gcp_resourcemanager_project_info "Gather info for GCP Project" b
gcp_resourcemanager_project_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_network_info "Gather info for GCP Network" b
gcp_compute_network_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_appengine_firewall_rule "Creates a GCP FirewallRule" b
gcp_appengine_firewall_rule: >
	source_range=${1:# IP address or range, defined using CIDR notation, of requests that this rule applies to.}
	action=${2:# The action to take if this rule matches.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional string description of this rule.}
	priority=${6:# A positive integer that defines the order of rule evaluation.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_pd "utilize GCE persistent disk resources" b
gce_pd: >
	name=${1:# name of the disk}

	detach_only=${2:no}
	instance_name=${3:# instance name if you wish to attach or detach the disk}
	mode=${4:READ_WRITE|#READ_ONLY}
	size_gb=${5:10}
	image=${6:# the source image to use for the disk}
	snapshot=${7:# the source snapshot to use for the disk}
	state=${8:active|#present|absent|deleted}
	zone=${9:us-central1-b}
	service_account_email=${10:# service account email}
	pem_file=${11:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
	credentials_file=${12:# path to the JSON file associated with the service account email}
	project_id=${13:# your GCE project ID}
	disk_type=${14:#pd-standard|pd-ssd}
	delete_on_termination=${15:no}

endsnippet

snippet gcp_filestore_instance "Creates a GCP Instance" b
gcp_filestore_instance: >
	name=${1:# The resource name of the instance.}
	tier=${2:# The service tier of the instance.}
	file_shares=${3:# File system shares on the instance. For this version, only a single file share is supported.}
	networks=${4:# VPC networks to which the instance is connected. For this version, only a single network is supported.}
	zone=${5:# The name of the Filestore zone of the instance.}
	auth_kind=${6:application|machineaccount|serviceaccount}

	state=${7:#present|absent}
	description=${8:# A description of the instance.}
	labels=${9:# Resource labels to represent user-provided metadata.}
	project=${10:# The Google Cloud Platform project to use.}
	service_account_contents=${11:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${12:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${13:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${14:# Array of scopes to be used.}
	env_type=${15:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_instance_info "Gather info for GCP Instance" b
gcp_sql_instance_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_vpn_tunnel "Creates a GCP VpnTunnel" b
gcp_compute_vpn_tunnel: >
	name=${1:# Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	shared_secret=${2:# Shared secret used to set the secure session between the Cloud VPN gateway and the peer VPN gateway.}
	region=${3:# The region where the tunnel is located.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# An optional description of this resource.}
	target_vpn_gateway=${7:# URL of the Target VPN gateway with which this VPN tunnel is associated.}
	router=${8:# URL of router resource to be used for dynamic routing.}
	peer_ip=${9:# IP address of the peer VPN gateway. Only IPv4 is supported.}
	ike_version=${10:2}
	local_traffic_selector=${11:# Local traffic selector to use when establishing the VPN tunnel with peer VPN gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`. The ranges should be disjoint.}
	remote_traffic_selector=${12:# Remote traffic selector to use when establishing the VPN tunnel with peer VPN gateway. The value should be a CIDR formatted string, for example `192.168.0.0/16`. The ranges should be disjoint.}
	project=${13:# The Google Cloud Platform project to use.}
	service_account_contents=${14:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${15:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${16:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${17:# Array of scopes to be used.}
	env_type=${18:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_image_info "Gather info for GCP Image" b
gcp_compute_image_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_http_proxy_info "Gather info for GCP TargetHttpProxy" b
gcp_compute_target_http_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_snapshot_info "Gather info for GCP Snapshot" b
gcp_compute_snapshot_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_labels "Create, Update or Destroy GCE Labels." b
gce_labels: >
	labels=${1:# A list of labels (key/value pairs) to add or remove for the resource.}
	resource_url=${2:# The 'self_link' for the resource (instance, disk, snapshot, etc)}
	resource_type=${3:# The type of resource (instances, disks, snapshots, images)}
	resource_location=${4:# The location of resource (global, us-central1-f, etc.)}
	resource_name=${5:# The name of resource.}

endsnippet

snippet gcp_compute_subnetwork_info "Gather info for GCP Subnetwork" b
gcp_compute_subnetwork_info: >
	region=${1:# URL of the GCP region for this subnetwork.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_cloudscheduler_job "Creates a GCP Job" b
gcp_cloudscheduler_job: >
	name=${1:# The name of the job.}
	region=${2:# Region where the scheduler job resides .}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# A human-readable description for the job. This string must not contain more than 500 characters.}
	schedule=${6:# Describes the schedule on which the job will be executed.}
	time_zone=${7:Etc/UTC}
	retry_config=${8:# By default, if a job does not complete successfully, meaning that an acknowledgement is not received from the handler, then it will be retried with exponential backoff according to the settings .}
	pubsub_target=${9:# Pub/Sub target If the job providers a Pub/Sub target the cron will publish a message to the provided topic .}
	app_engine_http_target=${10:# App Engine HTTP target.}
	http_target=${11:# HTTP target.}
	project=${12:# The Google Cloud Platform project to use.}
	service_account_contents=${13:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${14:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${15:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${16:# Array of scopes to be used.}
	env_type=${17:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_region_disk "Creates a GCP RegionDisk" b
gcp_compute_region_disk: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	replica_zones=${2:# URLs of the zones where the disk should be replicated to.}
	region=${3:# A reference to the region where the disk resides.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# An optional description of this resource. Provide this property when you create the resource.}
	labels=${7:# Labels to apply to this disk. A list of key->value pairs.}
	licenses=${8:# Any applicable publicly visible licenses.}
	size_gb=${9:# Size of the persistent disk, specified in GB. You can specify this field when creating a persistent disk using the sourceImage or sourceSnapshot parameter, or specify it alone to create an empty persistent disk.}
	physical_block_size_bytes=${10:# Physical block size of the persistent disk, in bytes. If not present in a request, a default value is used. Currently supported sizes are 4096 and 16384, other sizes may be added in the future.}
	type=${11:# URL of the disk type resource describing which disk type to use to create the disk. Provide this when creating the disk.}
	disk_encryption_key=${12:# Encrypts the disk using a customer-supplied encryption key.}
	source_snapshot=${13:# The source snapshot used to create this disk. You can provide this as a partial or full URL to the resource.}
	source_snapshot_encryption_key=${14:# The customer-supplied encryption key of the source snapshot. Required if the source snapshot is protected by a customer-supplied encryption key.}
	project=${15:# The Google Cloud Platform project to use.}
	service_account_contents=${16:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${17:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${18:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${19:# Array of scopes to be used.}
	env_type=${20:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_spanner_instance "Creates a GCP Instance" b
gcp_spanner_instance: >
	name=${1:# A unique identifier for the instance, which cannot be changed after the instance is created. The name must be between 6 and 30 characters in length.}
	config=${2:# The name of the instance's configuration (similar but not quite the same as a region) which defines defines the geographic placement and replication of your databases in this instance. It determines where your data is stored. Values are typically of the form `regional-europe-west1` , `us-central` etc.}
	display_name=${3:# The descriptive name for this instance as it appears in UIs. Must be unique per project and between 4 and 30 characters in length.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	node_count=${6:1}
	labels=${7:# An object containing a list of "key": value pairs.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_bigquery_table_info "Gather info for GCP Table" b
gcp_bigquery_table_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	dataset=${2:# Name of the dataset.}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_router_info "Gather info for GCP Router" b
gcp_compute_router_info: >
	region=${1:# Region where the router resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_backend_bucket "Creates a GCP BackendBucket" b
gcp_compute_backend_bucket: >
	bucket_name=${1:# Cloud Storage bucket name.}
	name=${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	cdn_policy=${5:# Cloud CDN configuration for this Backend Bucket.}
	description=${6:# An optional textual description of the resource; provided by the client when the resource is created.}
	enable_cdn=${7:# If true, enable Cloud CDN for this BackendBucket.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcpubsub_info "List Topics/Subscriptions and Messages from Google PubSub." b
gcpubsub_info: >
	view=${1:# Choices are 'topics' or 'subscriptions'}

	topic=${2:# GCP pubsub topic name.  Only the name, not the full path, is required.}
	state=${3:# list is the only valid option.}

endsnippet

snippet gcp_compute_address_info "Gather info for GCP Address" b
gcp_compute_address_info: >
	region=${1:# URL of the region where the regional address resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_vpn_tunnel_info "Gather info for GCP VpnTunnel" b
gcp_compute_vpn_tunnel_info: >
	region=${1:# The region where the tunnel is located.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_health_check "Creates a GCP HealthCheck" b
gcp_compute_health_check: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	check_interval_sec=${4:5}
	description=${5:# An optional description of this resource. Provide this property when you create the resource.}
	healthy_threshold=${6:2}
	timeout_sec=${7:5}
	unhealthy_threshold=${8:2}
	type=${9:# Specifies the type of the healthCheck, either TCP, SSL, HTTP or HTTPS. If not specified, the default is TCP. Exactly one of the protocol-specific health check field must be specified, which must match type field.}
	http_health_check=${10:# A nested object resource.}
	https_health_check=${11:# A nested object resource.}
	tcp_health_check=${12:# A nested object resource.}
	ssl_health_check=${13:# A nested object resource.}
	project=${14:# The Google Cloud Platform project to use.}
	service_account_contents=${15:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${16:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${17:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${18:# Array of scopes to be used.}
	env_type=${19:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_snapshot "Create or destroy snapshots for GCE storage volumes" b
gce_snapshot: >
	instance_name=${1:# The GCE instance to snapshot}
	service_account_email=${2:# GCP service account email for the project where the instance resides}
	credentials_file=${3:# The path to the credentials file associated with the service account}
	project_id=${4:# The GCP project ID to use}

	snapshot_name=${5:# The name of the snapshot to manage}
	disks=${6:all}
	state=${7:#present|absent}

endsnippet

snippet gcp_appengine_firewall_rule_info "Gather info for GCP FirewallRule" b
gcp_appengine_firewall_rule_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_backend_bucket_info "Gather info for GCP BackendBucket" b
gcp_compute_backend_bucket_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_pubsub_topic_info "Gather info for GCP Topic" b
gcp_pubsub_topic_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_instance_template "create or destroy instance templates of Compute Engine of GCP." b
gce_instance_template: >
	state=${1:#present|absent}
	name=${2:# The name of the GCE instance template.}
	size=${3:f1-micro}
	source=${4:# A source disk to attach to the instance. Cannot specify both I(image) and I(source).}
	image=${5:# The image to use to create the instance. Cannot specify both both I(image) and I(source).}
	image_family=${6:# The image family to use to create the instance. If I(image) has been used I(image_family) is ignored. Cannot specify both I(image) and I(source).}
	disk_type=${7:pd-standard}
	disk_auto_delete=${8:yes}
	network=${9:default}
	subnetwork=${10:# The Subnetwork resource name for this instance.}
	can_ip_forward=${11:no}
	external_ip=${12:ephemeral}
	service_account_email=${13:# service account email}
	service_account_permissions=${14:bigquery|cloud-platform|compute-ro|compute-rw|useraccounts-ro|useraccounts-rw|datastore|logging-write|monitoring|sql-admin|storage-full|storage-ro|storage-rw|taskqueue|userinfo-email}
	automatic_restart=${15:# Defines whether the instance should be automatically restarted when it is terminated by Compute Engine.}
	preemptible=${16:# Defines whether the instance is preemptible.}
	tags=${17:# a comma-separated list of tags to associate with the instance}
	metadata=${18:# a hash/dictionary of custom data for the instance; '{"key":"value", ...}'}
	description=${19:# description of instance template}
	disks=${20:# a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).}
	nic_gce_struct=${21:# Support passing in the GCE-specific formatted networkInterfaces[] structure.}
	disks_gce_struct=${22:# Support passing in the GCE-specific formatted formatted disks[] structure. Case sensitive. see U(https://cloud.google.com/compute/docs/reference/latest/instanceTemplates#resource) for detailed information}
	project_id=${23:# your GCE project ID}
	pem_file=${24:# path to the pem file associated with the service account email This option is deprecated. Use 'credentials_file'.}
	credentials_file=${25:# path to the JSON file associated with the service account email}
	subnetwork_region=${26:# Region that subnetwork resides in. (Required for subnetwork to successfully complete)}

endsnippet

snippet gcp_cloudfunctions_cloud_function "Creates a GCP CloudFunction" b
gcp_cloudfunctions_cloud_function: >
	name=${1:# A user-defined name of the function. Function names must be unique globally and match pattern `projects/*/locations/*/functions/*`.}
	location=${2:# The location of this cloud function.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# User-provided description of a function.}
	entry_point=${6:# The name of the function (as defined in source code) that will be executed.}
	runtime=${7:# The runtime in which the function is going to run. If empty, defaults to Node.js 6.}
	timeout=${8:# The function execution timeout. Execution is considered failed and can be terminated if the function is not completed at the end of the timeout period. Defaults to 60 seconds.}
	available_memory_mb=${9:# The amount of memory in MB available for a function.}
	labels=${10:# A set of key/value label pairs associated with this Cloud Function.}
	environment_variables=${11:# Environment variables that shall be available during function execution.}
	source_archive_url=${12:# The Google Cloud Storage URL, starting with gs://, pointing to the zip archive which contains the function.}
	source_upload_url=${13:# The Google Cloud Storage signed URL used for source uploading.}
	source_repository=${14:# The source repository where a function is hosted.}
	https_trigger=${15:# An HTTPS endpoint type of source that can be triggered via URL.}
	event_trigger=${16:# An HTTPS endpoint type of source that can be triggered via URL.}
	trigger_http=${17:# Use HTTP to trigger this function.}
	project=${18:# The Google Cloud Platform project to use.}
	service_account_contents=${19:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${20:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${21:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${22:# Array of scopes to be used.}
	env_type=${23:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_pool_info "Gather info for GCP TargetPool" b
gcp_compute_target_pool_info: >
	region=${1:# The region where the target pool resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_address_info "Gather info for GCP Address" b
gcp_compute_address_info: >
	region=${1:# URL of the region where the regional address resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_dns_resource_record_set_info "Gather info for GCP ResourceRecordSet" b
gcp_dns_resource_record_set_info: >
	managed_zone=${1:# Identifies the managed zone addressed by this request. This must be a dictionary that contains both a 'name' key and a 'dnsName' key. You can pass in the results of the gcp_dns_managed_zone module, which will contain both.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sourcerepo_repository_info "Gather info for GCP Repository" b
gcp_sourcerepo_repository_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_snapshot "Creates a GCP Snapshot" b
gcp_compute_snapshot: >
	name=${1:# Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	source_disk=${2:# A reference to the disk used to create this snapshot.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource.}
	labels=${6:# Labels to apply to this Snapshot.}
	zone=${7:# A reference to the zone where the disk is hosted.}
	snapshot_encryption_key=${8:# The customer-supplied encryption key of the snapshot. Required if the source snapshot is protected by a customer-supplied encryption key.}
	source_disk_encryption_key=${9:# The customer-supplied encryption key of the source snapshot. Required if the source snapshot is protected by a customer-supplied encryption key.}
	project=${10:# The Google Cloud Platform project to use.}
	service_account_contents=${11:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${12:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${13:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${14:# Array of scopes to be used.}
	env_type=${15:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_health_check_info "Gather info for GCP HealthCheck" b
gcp_compute_health_check_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_filestore_instance_info "Gather info for GCP Instance" b
gcp_filestore_instance_info: >
	zone=${1:# The name of the Filestore zone of the instance.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_spanner_database_info "Gather info for GCP Database" b
gcp_spanner_database_info: >
	instance=${1:# The instance to create the database on.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_instance_group_info "Gather info for GCP InstanceGroup" b
gcp_compute_instance_group_info: >
	zone=${1:# A reference to the zone where the instance group resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_url_map "Creates a GCP UrlMap" b
gcp_compute_url_map: >
	default_service=${1:# A reference to BackendService resource if none of the hostRules match.}
	name=${2:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource. Provide this property when you create the resource.}
	host_rules=${6:# The list of HostRules to use against the URL.}
	path_matchers=${7:# The list of named PathMatchers to use against the URL.}
	tests=${8:# The list of expected URL mappings. Requests to update this UrlMap will succeed only if all of the test cases pass.}
	project=${9:# The Google Cloud Platform project to use.}
	service_account_contents=${10:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${11:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${12:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${13:# Array of scopes to be used.}
	env_type=${14:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_database_info "Gather info for GCP Database" b
gcp_sql_database_info: >
	instance=${1:# The name of the Cloud SQL instance. This does not include the project ID.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_redis_instance_info "Gather info for GCP Instance" b
gcp_redis_instance_info: >
	region=${1:# The name of the Redis region of the instance.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_tcp_proxy_info "Gather info for GCP TargetTcpProxy" b
gcp_compute_target_tcp_proxy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_eip "Create or Destroy Global or Regional External IP addresses." b
gce_eip: >
	name=${1:# Name of Address.}
	region=${2:# Region to create the address in. Set to 'global' to create a global address.}

	state=${3:#present|absent}

endsnippet

snippet gcp_cloudtasks_queue_info "Gather info for GCP Queue" b
gcp_cloudtasks_queue_info: >
	location=${1:# The location of the queue.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_vpn_gateway "Creates a GCP TargetVpnGateway" b
gcp_compute_target_vpn_gateway: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	network=${2:# The network this VPN gateway is accepting traffic for.}
	region=${3:# The region this gateway should sit in.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	description=${6:# An optional description of this resource.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_autoscaler_info "Gather info for GCP Autoscaler" b
gcp_compute_autoscaler_info: >
	zone=${1:# URL of the zone where the instance group resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_network_info "Gather info for GCP Network" b
gcp_compute_network_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_http_health_check_info "Gather info for GCP HttpHealthCheck" b
gcp_compute_http_health_check_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_vpn_gateway_info "Gather info for GCP TargetVpnGateway" b
gcp_compute_target_vpn_gateway_info: >
	region=${1:# The region this gateway should sit in.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_tpu_node_info "Gather info for GCP Node" b
gcp_tpu_node_info: >
	zone=${1:# The GCP location for the TPU.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_disk_info "Gather info for GCP Disk" b
gcp_compute_disk_info: >
	zone=${1:# A reference to the zone where the disk resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_container_cluster "Creates a GCP Cluster" b
gcp_container_cluster: >
	location=${1:# The location where the cluster is deployed.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	name=${4:# The name of this cluster. The name must be unique within this project and location, and can be up to 40 characters. Must be Lowercase letters, numbers, and hyphens only. Must start with a letter. Must end with a number or a letter.}
	description=${5:# An optional description of this cluster.}
	initial_node_count=${6:# The number of nodes to create in this cluster. You must ensure that your Compute Engine resource quota is sufficient for this number of instances. You must also have available firewall and routes quota. For requests, this field should only be used in lieu of a "nodePool" object, since this configuration (along with the "nodeConfig") will be used to create a "NodePool" object with an auto-generated name. Do not use this and a nodePool at the same time.}
	node_config=${7:# Parameters used in creating the cluster's nodes.}
	master_auth=${8:# The authentication information for accessing the master endpoint.}
	logging_service=${9:# The logging service the cluster should use to write logs. Currently available options: logging.googleapis.com - the Google Cloud Logging service.}
	monitoring_service=${10:# The monitoring service the cluster should use to write metrics.}
	network=${11:# The name of the Google Compute Engine network to which the cluster is connected. If left unspecified, the default network will be used.}
	private_cluster_config=${12:# Configuration for a private cluster.}
	cluster_ipv4_cidr=${13:# The IP address range of the container pods in this cluster, in CIDR notation (e.g. 10.96.0.0/14). Leave blank to have one automatically chosen or specify a /14 block in 10.0.0.0/8.}
	addons_config=${14:# Configurations for the various addons available to run in the cluster.}
	subnetwork=${15:# The name of the Google Compute Engine subnetwork to which the cluster is connected.}
	locations=${16:# The list of Google Compute Engine zones in which the cluster's nodes should be located.}
	resource_labels=${17:# The resource labels for the cluster to use to annotate any related Google Compute Engine resources.}
	legacy_abac=${18:# Configuration for the legacy ABAC authorization mode.}
	network_policy=${19:# Configuration options for the NetworkPolicy feature.}
	default_max_pods_constraint=${20:# The default constraint on the maximum number of pods that can be run simultaneously on a node in the node pool of this cluster.}
	ip_allocation_policy=${21:# Configuration for controlling how IPs are allocated in the cluster.}
	enable_tpu=${22:# Enable the ability to use Cloud TPUs in this cluster.}
	tpu_ipv4_cidr_block=${23:# The IP address range of the Cloud TPUs in this cluster, in CIDR notation.}
	kubectl_path=${24:# The path that the kubectl config file will be written to.}
	kubectl_context=${25:# The name of the context for the kubectl config file. Will default to the cluster name.}
	project=${26:# The Google Cloud Platform project to use.}
	service_account_contents=${27:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${28:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${29:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${30:# Array of scopes to be used.}
	env_type=${31:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_storage_bucket_access_control "Creates a GCP BucketAccessControl" b
gcp_storage_bucket_access_control: >
	bucket=${1:# The name of the bucket.}
	entity=${2:# The entity holding the permission, in one of the following forms: user-userId user-email group-groupId group-email domain-domain project-team-projectId allUsers allAuthenticatedUsers Examples: The user liz@example.com would be user-liz@example.com.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	entity_id=${5:# The ID for the entity.}
	project_team=${6:# The project team associated with the entity.}
	role=${7:# The access permission for the entity.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_ssl_policy "Creates a GCP SslPolicy" b
gcp_compute_ssl_policy: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	description=${4:# An optional description of this resource.}
	profile=${5:# Profile specifies the set of SSL features that can be used by the load balancer when negotiating SSL with clients. This can be one of `COMPATIBLE`, `MODERN`, `RESTRICTED`, or `CUSTOM`. If using `CUSTOM`, the set of SSL features to enable must be specified in the `customFeatures` field.}
	min_tls_version=${6:# The minimum version of SSL protocol that can be used by the clients to establish a connection with the load balancer. This can be one of `TLS_1_0`, `TLS_1_1`, `TLS_1_2`.}
	custom_features=${7:# A list of features enabled when the selected profile is CUSTOM. The method returns the set of features that can be specified in this list. This field must be empty if the profile is not CUSTOM.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_user_info "Gather info for GCP User" b
gcp_sql_user_info: >
	instance=${1:# The name of the Cloud SQL instance. This does not include the project ID.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_backend_service_info "Gather info for GCP BackendService" b
gcp_compute_backend_service_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_kms_key_ring_info "Gather info for GCP KeyRing" b
gcp_kms_key_ring_info: >
	location=${1:# The location for the KeyRing.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_bigquery_dataset_info "Gather info for GCP Dataset" b
gcp_bigquery_dataset_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_disk_info "Gather info for GCP Disk" b
gcp_compute_disk_info: >
	zone=${1:# A reference to the zone where the disk resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_instance_info "Gather info for GCP Instance" b
gcp_sql_instance_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_region_disk_info "Gather info for GCP RegionDisk" b
gcp_compute_region_disk_info: >
	region=${1:# A reference to the region where the disk resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_ssl_policy_info "Gather info for GCP SslPolicy" b
gcp_compute_ssl_policy_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_bigquery_table "Creates a GCP Table" b
gcp_bigquery_table: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	state=${2:#present|absent}
	table_reference=${3:# Reference describing the ID of this table.}
	clustering=${4:# One or more fields on which data should be clustered. Only top-level, non-repeated, simple-type fields are supported. When you cluster a table using multiple columns, the order of columns you specify is important. The order of the specified columns determines the sort order of the data.}
	description=${5:# A user-friendly description of the dataset.}
	friendly_name=${6:# A descriptive name for this table.}
	labels=${7:# The labels associated with this dataset. You can use these to organize and group your datasets .}
	name=${8:# Name of the table.}
	num_rows=${9:# The number of rows of data in this table, excluding any data in the streaming buffer.}
	view=${10:# The view definition.}
	time_partitioning=${11:# If specified, configures time-based partitioning for this table.}
	schema=${12:# Describes the schema of this table.}
	encryption_configuration=${13:# Custom encryption configuration.}
	expiration_time=${14:# The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely.}
	external_data_configuration=${15:# Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.}
	dataset=${16:# Name of the dataset.}
	project=${17:# The Google Cloud Platform project to use.}
	service_account_contents=${18:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${19:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${20:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${21:# Array of scopes to be used.}
	env_type=${22:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_resourcemanager_project_info "Gather info for GCP Project" b
gcp_resourcemanager_project_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_spanner_instance_info "Gather info for GCP Instance" b
gcp_spanner_instance_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_url_map_info "Gather info for GCP UrlMap" b
gcp_compute_url_map_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_interconnect_attachment_info "Gather info for GCP InterconnectAttachment" b
gcp_compute_interconnect_attachment_info: >
	region=${1:# Region where the regional interconnect attachment resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_user_info "Gather info for GCP User" b
gcp_sql_user_info: >
	instance=${1:# The name of the Cloud SQL instance. This does not include the project ID.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_http_health_check "Creates a GCP HttpHealthCheck" b
gcp_compute_http_health_check: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	check_interval_sec=${4:5}
	description=${5:# An optional description of this resource. Provide this property when you create the resource.}
	healthy_threshold=${6:# A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.}
	host=${7:# The value of the host header in the HTTP health check request. If left empty (default value), the public IP on behalf of which this health check is performed will be used.}
	port=${8:# The TCP port number for the HTTP health check request.}
	request_path=${9:# The request path of the HTTP health check request.}
	timeout_sec=${10:# How long (in seconds) to wait before claiming failure.}
	unhealthy_threshold=${11:# A so-far healthy instance will be marked unhealthy after this many consecutive failures. The default value is 2.}
	project=${12:# The Google Cloud Platform project to use.}
	service_account_contents=${13:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${14:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${15:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${16:# Array of scopes to be used.}
	env_type=${17:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_disk "Creates a GCP Disk" b
gcp_compute_disk: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	zone=${2:# A reference to the zone where the disk resides.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	description=${5:# An optional description of this resource. Provide this property when you create the resource.}
	labels=${6:# Labels to apply to this disk. A list of key->value pairs.}
	licenses=${7:# Any applicable publicly visible licenses.}
	size_gb=${8:# Size of the persistent disk, specified in GB. You can specify this field when creating a persistent disk using the sourceImage or sourceSnapshot parameter, or specify it alone to create an empty persistent disk.}
	physical_block_size_bytes=${9:# Physical block size of the persistent disk, in bytes. If not present in a request, a default value is used. Currently supported sizes are 4096 and 16384, other sizes may be added in the future.}
	type=${10:# URL of the disk type resource describing which disk type to use to create the disk. Provide this when creating the disk.}
	source_image=${11:# The source image used to create this disk. If the source image is deleted, this field will not be set.}
	source_image_encryption_key=${12:# The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key.}
	disk_encryption_key=${13:# Encrypts the disk using a customer-supplied encryption key.}
	source_snapshot=${14:# The source snapshot used to create this disk. You can provide this as a partial or full URL to the resource.}
	source_snapshot_encryption_key=${15:# The customer-supplied encryption key of the source snapshot. Required if the source snapshot is protected by a customer-supplied encryption key.}
	project=${16:# The Google Cloud Platform project to use.}
	service_account_contents=${17:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${18:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${19:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${20:# Array of scopes to be used.}
	env_type=${21:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_iam_role_info "Gather info for GCP Role" b
gcp_iam_role_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_dns_managed_zone "Creates a GCP ManagedZone" b
gcp_dns_managed_zone: >
	description=${1:# A mutable string of at most 1024 characters associated with this resource for the user's convenience. Has no effect on the managed zone's function.}
	dns_name=${2:# The DNS name of this managed zone, for instance "example.com.".}
	name=${3:# User assigned name for this resource.}
	auth_kind=${4:application|machineaccount|serviceaccount}

	state=${5:#present|absent}
	dnssec_config=${6:# DNSSEC configuration.}
	name_server_set=${7:# Optionally specifies the NameServerSet for this ManagedZone. A NameServerSet is a set of DNS name servers that all host the same ManagedZones. Most users will leave this field unset.}
	labels=${8:# A set of key/value label pairs to assign to this ManagedZone.}
	visibility=${9:public}
	private_visibility_config=${10:# For privately visible zones, the set of Virtual Private Cloud resources that the zone is visible from.}
	project=${11:# The Google Cloud Platform project to use.}
	service_account_contents=${12:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${13:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${14:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${15:# Array of scopes to be used.}
	env_type=${16:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_subnetwork "Creates a GCP Subnetwork" b
gcp_compute_subnetwork: >
	ip_cidr_range=${1:# The range of internal addresses that are owned by this subnetwork.}
	name=${2:# The name of the resource, provided by the client when initially creating the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	network=${3:# The network this subnet belongs to.}
	region=${4:# URL of the GCP region for this subnetwork.}
	auth_kind=${5:application|machineaccount|serviceaccount}

	state=${6:#present|absent}
	description=${7:# An optional description of this resource. Provide this property when you create the resource. This field can be set only at resource creation time.}
	enable_flow_logs=${8:# Whether to enable flow logging for this subnetwork.}
	secondary_ip_ranges=${9:# An array of configurations for secondary IP ranges for VM instances contained in this subnetwork. The primary IP of such VM must belong to the primary ipCidrRange of the subnetwork. The alias IPs may belong to either primary or secondary ranges.}
	private_ip_google_access=${10:# When enabled, VMs in this subnetwork without external IP addresses can access Google APIs and services by using Private Google Access.}
	project=${11:# The Google Cloud Platform project to use.}
	service_account_contents=${12:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${13:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${14:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${15:# Array of scopes to be used.}
	env_type=${16:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gce_tag "add or remove tag(s) to/from GCE instances" b
gce_tag: >
	tags=${1:# Comma-separated list of tags to add or remove.}

	instance_name=${2:# The name of the GCE instance to add/remove tags.}
	instance_pattern=${3:# The pattern of GCE instance names to match for adding/removing tags.  Full-Python regex is supported. See U(https://docs.python.org/2/library/re.html) for details.}
	state=${4:absent|#present}
	zone=${5:us-central1-a}
	service_account_email=${6:# Service account email.}
	pem_file=${7:# Path to the PEM file associated with the service account email.}
	project_id=${8:# Your GCE project ID.}

endsnippet

snippet gcp_pubsub_subscription "Creates a GCP Subscription" b
gcp_pubsub_subscription: >
	name=${1:# Name of the subscription.}
	topic=${2:# A reference to a Topic resource.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	labels=${5:# A set of key/value label pairs to assign to this Subscription.}
	push_config=${6:# If push delivery is used with this subscription, this field is used to configure it. An empty pushConfig signifies that the subscriber will pull and ack messages using API methods.}
	ack_deadline_seconds=${7:# This value is the maximum time after a subscriber receives a message before the subscriber should acknowledge the message. After message delivery but before the ack deadline expires and before the message is acknowledged, it is an outstanding message and will not be delivered again during that time (on a best-effort basis).}
	message_retention_duration=${8:604800s}
	retain_acked_messages=${9:# Indicates whether to retain acknowledged messages. If `true`, then messages are not expunged from the subscription's backlog, even if they are acknowledged, until they fall out of the messageRetentionDuration window.}
	expiration_policy=${10:# A policy that specifies the conditions for this subscription's expiration.}
	project=${11:# The Google Cloud Platform project to use.}
	service_account_contents=${12:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${13:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${14:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${15:# Array of scopes to be used.}
	env_type=${16:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_target_pool_info "Gather info for GCP TargetPool" b
gcp_compute_target_pool_info: >
	region=${1:# The region where the target pool resides.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	filters=${3:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${4:# The Google Cloud Platform project to use.}
	service_account_contents=${5:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${6:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${7:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${8:# Array of scopes to be used.}
	env_type=${9:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_spanner_database "Creates a GCP Database" b
gcp_spanner_database: >
	name=${1:# A unique identifier for the database, which cannot be changed after the instance is created. Values are of the form [a-z][-a-z0-9]*[a-z0-9].}
	instance=${2:# The instance to create the database on.}
	auth_kind=${3:application|machineaccount|serviceaccount}

	state=${4:#present|absent}
	extra_statements=${5:# An optional list of DDL statements to run inside the newly created database. Statements can create tables, indexes, etc. These statements execute atomically with the creation of the database: if there is an error in any statement, the database is not created.}
	project=${6:# The Google Cloud Platform project to use.}
	service_account_contents=${7:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${8:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${9:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${10:# Array of scopes to be used.}
	env_type=${11:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_ssl_certificate_info "Gather info for GCP SslCertificate" b
gcp_compute_ssl_certificate_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	filters=${2:# A list of filter value pairs. Available filters are listed here U(https://cloud.google.com/sdk/gcloud/reference/topic/filters).}
	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_pubsub_subscription_info "Gather info for GCP Subscription" b
gcp_pubsub_subscription_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_mlengine_model_info "Gather info for GCP Model" b
gcp_mlengine_model_info: >
	auth_kind=${1:application|machineaccount|serviceaccount}

	project=${2:# The Google Cloud Platform project to use.}
	service_account_contents=${3:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${4:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${5:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${6:# Array of scopes to be used.}
	env_type=${7:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_sql_database_info "Gather info for GCP Database" b
gcp_sql_database_info: >
	instance=${1:# The name of the Cloud SQL instance. This does not include the project ID.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	project=${3:# The Google Cloud Platform project to use.}
	service_account_contents=${4:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${5:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${6:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${7:# Array of scopes to be used.}
	env_type=${8:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_compute_network "Creates a GCP Network" b
gcp_compute_network: >
	name=${1:# Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	description=${4:# An optional description of this resource. The resource must be recreated to modify this field.}
	ipv4_range=${5:# If this field is specified, a deprecated legacy network is created.}
	auto_create_subnetworks=${6:# When set to `true`, the network is created in "auto subnet mode" and it will create a subnet for each region automatically across the `10.128.0.0/9` address range.}
	routing_config=${7:# The network-level routing configuration for this network. Used by Cloud Router to determine what type of network-wide routing behavior to enforce.}
	project=${8:# The Google Cloud Platform project to use.}
	service_account_contents=${9:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${10:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${11:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${12:# Array of scopes to be used.}
	env_type=${13:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet gcp_pubsub_topic "Creates a GCP Topic" b
gcp_pubsub_topic: >
	name=${1:# Name of the topic.}
	auth_kind=${2:application|machineaccount|serviceaccount}

	state=${3:#present|absent}
	kms_key_name=${4:# The resource name of the Cloud KMS CryptoKey to be used to protect access to messages published on this topic. Your project's PubSub service account (`service-{{PROJECT_NUMBER}}@gcp-sa-pubsub.iam.gserviceaccount.com`) must have `roles/cloudkms.cryptoKeyEncrypterDecrypter` to use this feature.}
	labels=${5:# A set of key/value label pairs to assign to this Topic.}
	message_storage_policy=${6:# Policy constraining the set of Google Cloud Platform regions where messages published to the topic may be stored. If not present, then no constraints are in effect.}
	project=${7:# The Google Cloud Platform project to use.}
	service_account_contents=${8:# The contents of a Service Account JSON file, either in a dictionary or as a JSON string that represents it.}
	service_account_file=${9:# The path of a Service Account JSON file if serviceaccount is selected as type.}
	service_account_email=${10:# An optional service account email address if machineaccount is selected and the user does not wish to use the default email.}
	scopes=${11:# Array of scopes to be used.}
	env_type=${12:# Specifies which Ansible environment you're running this module within.}

endsnippet

snippet oci_vcn "Manage Virtual Cloud Networks(VCN) in OCI" b
oci_vcn: >
	cidr_block=${1:# T}
	compartment_id=${2:# T}
	display_name=${3:# A}
	dns_label=${4:# A}
	state=${5:#present|absent}
	vcn_id=${6:# T}
	config_file_location=${7:# Path to configuration file. If not set then the value of the OCI_CONFIG_FILE environment variable, if any, is used. Otherwise, defaults to ~/.oci/config.}
	config_profile_name=${8:DEFAULT}
	api_user=${9:# The OCID of the user, on whose behalf, OCI APIs are invoked. If not set, then the value of the OCI_USER_OCID environment variable, if any, is used. This option is required if the user is not specified through a configuration file (See C(config_file_location)). To get the user's OCID, please refer U(https://docs.us-phoenix-1.oraclecloud.com/Content/API/Concepts/apisigningkey.htm).}
	api_user_fingerprint=${10:# Fingerprint for the key pair being used. If not set, then the value of the OCI_USER_FINGERPRINT environment variable, if any, is used. This option is required if the key fingerprint is not specified through a configuration file (See C(config_file_location)). To get the key pair's fingerprint value please refer U(https://docs.us-phoenix-1.oraclecloud.com/Content/API/Concepts/apisigningkey.htm).}
	api_user_key_file=${11:# Full path and filename of the private key (in PEM format). If not set, then the value of the OCI_USER_KEY_FILE variable, if any, is used. This option is required if the private key is not specified through a configuration file (See C(config_file_location)). If the key is encrypted with a pass-phrase, the C(api_user_key_pass_phrase) option must also be provided.}
	api_user_key_pass_phrase=${12:# Passphrase used by the key referenced in C(api_user_key_file), if it is encrypted. If not set, then the value of the OCI_USER_KEY_PASS_PHRASE variable, if any, is used. This option is required if the key passphrase is not specified through a configuration file (See C(config_file_location)).}
	auth_type=${13:#api_key|instance_principal}
	tenancy=${14:# OCID of your tenancy. If not set, then the value of the OCI_TENANCY variable, if any, is used. This option is required if the tenancy OCID is not specified through a configuration file (See C(config_file_location)). To get the tenancy OCID, please refer U(https://docs.us-phoenix-1.oraclecloud.com/Content/API/Concepts/apisigningkey.htm)}
	region=${15:# The Oracle Cloud Infrastructure region to use for all OCI API requests. If not set, then the value of the OCI_REGION variable, if any, is used. This option is required if the region is not specified through a configuration file (See C(config_file_location)). Please refer to U(https://docs.us-phoenix-1.oraclecloud.com/Content/General/Concepts/regions.htm) for more information on OCI regions.}
	force_create=${16:no}
	key_by=${17:# T}
	wait=${18:yes}
	wait_timeout=${19:1200}
	wait_until=${20:# T}
	defined_tags=${21:# D}
	freeform_tags=${22:# F}

endsnippet

snippet cs_resourcelimit "Manages resource limits on Apache CloudStack based clouds." b
cs_resourcelimit: >
	resource_type=${1:instance|ip_address|volume|snapshot|template|network|vpc|cpu|memory|primary_storage|secondary_storage}

	limit=${2:-1}
	domain=${3:# Domain the resource is related to.}
	account=${4:# Account the resource is related to.}
	project=${5:# Name of the project the resource is related to.}
	api_key=${6:# API key of the CloudStack API.}
	api_secret=${7:# Secret key of the CloudStack API.}
	api_url=${8:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${9:get|post}
	api_timeout=${10:# HTTP timeout in seconds.}
	api_region=${11:cloudstack}

endsnippet

snippet cs_instance_nic_secondaryip "Manages secondary IPs of an instance on Apache CloudStack based clouds." b
cs_instance_nic_secondaryip: >
	vm=${1:# Name of instance.}

	network=${2:# Name of the network.}
	vm_guest_ip=${3:# Secondary IP address to be added to the instance nic.}
	vpc=${4:# Name of the VPC the I(vm) is related to.}
	domain=${5:# Domain the instance is related to.}
	account=${6:# Account the instance is related to.}
	project=${7:# Name of the project the instance is deployed in.}
	zone=${8:# Name of the zone in which the instance is deployed in.}
	state=${9:#present|absent}
	poll_async=${10:yes}
	api_key=${11:# API key of the CloudStack API.}
	api_secret=${12:# Secret key of the CloudStack API.}
	api_url=${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${14:get|post}
	api_timeout=${15:# HTTP timeout in seconds.}
	api_region=${16:cloudstack}

endsnippet

snippet cs_iso "Manages ISO images on Apache CloudStack based clouds." b
cs_iso: >
	name=${1:# Name of the ISO.}

	display_text=${2:# Display text of the ISO.}
	url=${3:# URL where the ISO can be downloaded from. Required if I(state) is present.}
	os_type=${4:# Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if I(state) is present.}
	is_ready=${5:no}
	is_public=${6:# Register the ISO to be publicly available to all users. Only used if I(state) is present.}
	is_featured=${7:# Register the ISO to be featured. Only used if I(state) is present.}
	is_dynamically_scalable=${8:# Register the ISO having XS/VMware tools installed inorder to support dynamic scaling of VM cpu/memory. Only used if I(state) is present.}
	checksum=${9:# The MD5 checksum value of this ISO. If set, we search by checksum instead of name.}
	bootable=${10:# Register the ISO to be bootable. Only used if I(state) is present.}
	domain=${11:# Domain the ISO is related to.}
	account=${12:# Account the ISO is related to.}
	project=${13:# Name of the project the ISO to be registered in.}
	zone=${14:# Name of the zone you wish the ISO to be registered or deleted from.}
	cross_zones=${15:no}
	iso_filter=${16:featured|#self|selfexecutable|sharedexecutable|executable|community}
	state=${17:#present|absent}
	poll_async=${18:yes}
	tags=${19:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	api_key=${20:# API key of the CloudStack API.}
	api_secret=${21:# Secret key of the CloudStack API.}
	api_url=${22:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${23:get|post}
	api_timeout=${24:# HTTP timeout in seconds.}
	api_region=${25:cloudstack}

endsnippet

snippet cs_vpc_offering "Manages vpc offerings on Apache CloudStack based clouds." b
cs_vpc_offering: >
	name=${1:# The name of the vpc offering}

	state=${2:enabled|#present|disabled|absent}
	display_text=${3:# Display text of the vpc offerings}
	service_capabilities=${4:# Desired service capabilities as part of vpc offering.}
	service_offering=${5:# The name or ID of the service offering for the VPC router appliance.}
	supported_services=${6:# Services supported by the vpc offering}
	service_providers=${7:# provider to service mapping. If not specified, the provider for the service will be mapped to the default provider on the physical network}
	poll_async=${8:yes}
	api_key=${9:# API key of the CloudStack API.}
	api_secret=${10:# Secret key of the CloudStack API.}
	api_url=${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${12:get|post}
	api_timeout=${13:# HTTP timeout in seconds.}
	api_region=${14:cloudstack}

endsnippet

snippet cs_vlan_ip_range "Manages VLAN IP ranges on Apache CloudStack based clouds." b
cs_vlan_ip_range: >
	start_ip=${1:# The beginning IPv4 address in the VLAN IP range.}

	network=${2:# The network name or id.}
	physical_network=${3:# The physical network name or id.}
	end_ip=${4:# The ending IPv4 address in the VLAN IP range.}
	gateway=${5:# The gateway of the VLAN IP range.}
	netmask=${6:# The netmask of the VLAN IP range.}
	start_ipv6=${7:# The beginning IPv6 address in the IPv6 network range.}
	end_ipv6=${8:# The ending IPv6 address in the IPv6 network range.}
	gateway_ipv6=${9:# The gateway of the IPv6 network.}
	cidr_ipv6=${10:# The CIDR of IPv6 network, must be at least /64.}
	vlan=${11:# The ID or VID of the network.}
	state=${12:#present|absent}
	zone=${13:# The Zone ID of the VLAN IP range.}
	domain=${14:# Domain of the account owning the VLAN.}
	account=${15:# Account who owns the VLAN.}
	project=${16:# Project who owns the VLAN.}
	for_virtual_network=${17:no}
	api_key=${18:# API key of the CloudStack API.}
	api_secret=${19:# Secret key of the CloudStack API.}
	api_url=${20:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${21:get|post}
	api_timeout=${22:# HTTP timeout in seconds.}
	api_region=${23:cloudstack}

endsnippet

snippet cs_region "Manages regions on Apache CloudStack based clouds." b
cs_region: >
	id=${1:# ID of the region.}

	name=${2:# Name of the region.}
	endpoint=${3:# Endpoint URL of the region.}
	state=${4:#present|absent}
	api_key=${5:# API key of the CloudStack API.}
	api_secret=${6:# Secret key of the CloudStack API.}
	api_url=${7:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${8:get|post}
	api_timeout=${9:# HTTP timeout in seconds.}
	api_region=${10:cloudstack}

endsnippet

snippet cs_zone "Manages zones on Apache CloudStack based clouds." b
cs_zone: >
	name=${1:# Name of the zone.}

	id=${2:# uuid of the existing zone.}
	state=${3:#present|enabled|disabled|absent}
	domain=${4:# Domain the zone is related to.}
	network_domain=${5:# Network domain for the zone.}
	network_type=${6:#Basic|Advanced}
	dns1=${7:# First DNS for the zone.}
	dns2=${8:# Second DNS for the zone.}
	internal_dns1=${9:# First internal DNS for the zone.}
	internal_dns2=${10:# Second internal DNS for the zone.}
	dns1_ipv6=${11:# First DNS for IPv6 for the zone.}
	dns2_ipv6=${12:# Second DNS for IPv6 for the zone.}
	guest_cidr_address=${13:# Guest CIDR address for the zone.}
	dhcp_provider=${14:# DHCP provider for the Zone.}
	local_storage_enabled=${15:# Whether to enable local storage for the zone or not..}
	securitygroups_enabled=${16:# Whether the zone is security group enabled or not.}
	api_key=${17:# API key of the CloudStack API.}
	api_secret=${18:# Secret key of the CloudStack API.}
	api_url=${19:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${20:get|post}
	api_timeout=${21:# HTTP timeout in seconds.}
	api_region=${22:cloudstack}

endsnippet

snippet cs_network_acl_rule "Manages network access control list (ACL) rules on Apache CloudStack based clouds." b
cs_network_acl_rule: >
	network_acl=${1:# Name of the network ACL.}
	rule_position=${2:# The position of the network ACL rule.}
	vpc=${3:# VPC the network ACL is related to.}

	cidrs=${4:['0.0.0.0/0']}
	protocol=${5:#tcp|udp|icmp|all|by_number}
	protocol_number=${6:# Protocol number from 1 to 256 required if I(protocol=by_number).}
	start_port=${7:# Start port for this rule.}
	end_port=${8:# End port for this rule.}
	icmp_type=${9:# Type of the icmp message being sent.}
	icmp_code=${10:# Error code for this icmp message.}
	traffic_type=${11:#ingress|egress}
	action_policy=${12:#allow|deny}
	tags=${13:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	domain=${14:# Domain the VPC is related to.}
	account=${15:# Account the VPC is related to.}
	project=${16:# Name of the project the VPC is related to.}
	zone=${17:# Name of the zone the VPC related to.}
	state=${18:#present|absent}
	poll_async=${19:yes}
	api_key=${20:# API key of the CloudStack API.}
	api_secret=${21:# Secret key of the CloudStack API.}
	api_url=${22:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${23:get|post}
	api_timeout=${24:# HTTP timeout in seconds.}
	api_region=${25:cloudstack}

endsnippet

snippet cs_securitygroup_rule "Manages security group rules on Apache CloudStack based clouds." b
cs_securitygroup_rule: >
	security_group=${1:# Name of the security group the rule is related to. The security group must be existing.}

	state=${2:#present|absent}
	protocol=${3:#tcp|udp|icmp|ah|esp|gre}
	type=${4:#ingress|egress}
	cidr=${5:0.0.0.0/0}
	user_security_group=${6:# Security group this rule is based of.}
	start_port=${7:# Start port for this rule. Required if I(protocol=tcp) or I(protocol=udp).}
	end_port=${8:# End port for this rule. Required if I(protocol=tcp) or I(protocol=udp), but I(start_port) will be used if not set.}
	icmp_type=${9:# Type of the icmp message being sent. Required if I(protocol=icmp).}
	icmp_code=${10:# Error code for this icmp message. Required if I(protocol=icmp).}
	project=${11:# Name of the project the security group to be created in.}
	poll_async=${12:yes}
	api_key=${13:# API key of the CloudStack API.}
	api_secret=${14:# Secret key of the CloudStack API.}
	api_url=${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${16:get|post}
	api_timeout=${17:# HTTP timeout in seconds.}
	api_region=${18:cloudstack}

endsnippet

snippet cs_loadbalancer_rule_member "Manages load balancer rule members on Apache CloudStack based clouds." b
cs_loadbalancer_rule_member: >
	name=${1:# The name of the load balancer rule.}
	vms=${2:# List of VMs to assign to or remove from the rule.}

	ip_address=${3:# Public IP address from where the network traffic will be load balanced from.}
	state=${4:#present|absent}
	project=${5:# Name of the project the firewall rule is related to.}
	domain=${6:# Domain the rule is related to.}
	account=${7:# Account the rule is related to.}
	zone=${8:# Name of the zone in which the rule should be located.}
	poll_async=${9:yes}
	api_key=${10:# API key of the CloudStack API.}
	api_secret=${11:# Secret key of the CloudStack API.}
	api_url=${12:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${13:get|post}
	api_timeout=${14:# HTTP timeout in seconds.}
	api_region=${15:cloudstack}

endsnippet

snippet cs_template "Manages templates on Apache CloudStack based clouds." b
cs_template: >
	name=${1:# Name of the template.}

	url=${2:# URL of where the template is hosted on I(state=present).}
	vm=${3:# VM name the template will be created from its volume or alternatively from a snapshot.}
	snapshot=${4:# Name of the snapshot, created from the VM ROOT volume, the template will be created from.}
	os_type=${5:# OS type that best represents the OS of this template.}
	checksum=${6:# The MD5 checksum value of this template.}
	is_ready=${7:# Note: this flag was not implemented and therefore marked as deprecated.}
	is_public=${8:# Register the template to be publicly available to all users.}
	is_featured=${9:# Register the template to be featured.}
	is_dynamically_scalable=${10:# Register the template having XS/VMware tools installed in order to support dynamic scaling of VM CPU/memory.}
	cross_zones=${11:no}
	mode=${12:#http_download|ftp_upload}
	domain=${13:# Domain the template, snapshot or VM is related to.}
	account=${14:# Account the template, snapshot or VM is related to.}
	project=${15:# Name of the project the template to be registered in.}
	zone=${16:# Name of the zone you wish the template to be registered or deleted from.}
	template_filter=${17:all|featured|#self|selfexecutable|sharedexecutable|executable|community}
	template_find_options=${18:['display_text', 'checksum', 'cross_zones'}
	hypervisor=${19:# Name the hypervisor to be used for creating the new template.}
	requires_hvm=${20:# Whether the template requires HVM or not.}
	password_enabled=${21:# Enable template password reset support.}
	template_tag=${22:# The tag for this template.}
	sshkey_enabled=${23:# True if the template supports the sshkey upload feature.}
	is_routing=${24:# Sets the template type to routing, i.e. if template is used to deploy routers.}
	format=${25:QCOW2|RAW|VHD|OVA}
	is_extractable=${26:# Allows the template or its derivatives to be extractable.}
	details=${27:# Template details in key/value pairs.}
	bits=${28:32|#64}
	display_text=${29:# Display text of the template.}
	state=${30:#present|absent|extracted}
	poll_async=${31:yes}
	tags=${32:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	api_key=${33:# API key of the CloudStack API.}
	api_secret=${34:# Secret key of the CloudStack API.}
	api_url=${35:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${36:get|post}
	api_timeout=${37:# HTTP timeout in seconds.}
	api_region=${38:cloudstack}

endsnippet

snippet cs_staticnat "Manages static NATs on Apache CloudStack based clouds." b
cs_staticnat: >
	ip_address=${1:# Public IP address the static NAT is assigned to.}

	vm=${2:# Name of virtual machine which we make the static NAT for.}
	vm_guest_ip=${3:# VM guest NIC secondary IP address for the static NAT.}
	network=${4:# Network the IP address is related to.}
	vpc=${5:# VPC the network related to.}
	state=${6:#present|absent}
	domain=${7:# Domain the static NAT is related to.}
	account=${8:# Account the static NAT is related to.}
	project=${9:# Name of the project the static NAT is related to.}
	zone=${10:# Name of the zone in which the virtual machine is in.}
	poll_async=${11:yes}
	api_key=${12:# API key of the CloudStack API.}
	api_secret=${13:# Secret key of the CloudStack API.}
	api_url=${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${15:get|post}
	api_timeout=${16:# HTTP timeout in seconds.}
	api_region=${17:cloudstack}

endsnippet

snippet cs_zone_info "Gathering information about zones from Apache CloudStack based clouds." b
cs_zone_info: >
	zone=${1:# Name of the zone.}
	api_key=${2:# API key of the CloudStack API.}
	api_secret=${3:# Secret key of the CloudStack API.}
	api_url=${4:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${5:get|post}
	api_timeout=${6:# HTTP timeout in seconds.}
	api_region=${7:cloudstack}

endsnippet

snippet cs_affinitygroup "Manages affinity groups on Apache CloudStack based clouds." b
cs_affinitygroup: >
	name=${1:# Name of the affinity group.}

	affinity_type=${2:# Type of the affinity group. If not specified, first found affinity type is used.}
	description=${3:# Description of the affinity group.}
	state=${4:#present|absent}
	domain=${5:# Domain the affinity group is related to.}
	account=${6:# Account the affinity group is related to.}
	project=${7:# Name of the project the affinity group is related to.}
	poll_async=${8:yes}
	api_key=${9:# API key of the CloudStack API.}
	api_secret=${10:# Secret key of the CloudStack API.}
	api_url=${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${12:get|post}
	api_timeout=${13:# HTTP timeout in seconds.}
	api_region=${14:cloudstack}

endsnippet

snippet cs_physical_network "Manages physical networks on Apache CloudStack based clouds." b
cs_physical_network: >
	name=${1:# Name of the physical network.}

	zone=${2:# Name of the zone in which the network belongs.}
	broadcast_domain_range=${3:POD|ZONE}
	domain=${4:# Domain the network is owned by.}
	isolation_method=${5:VLAN|GRE|L3}
	network_speed=${6:1G|10G}
	tags=${7:# A tag to identify this network.}
	vlan=${8:# The VLAN/VNI Ranges of the physical network.}
	nsps_enabled=${9:# List of Network Service Providers to enable.}
	nsps_disabled=${10:# List of Network Service Providers to disable.}
	state=${11:#present|absent|disabled|enabled}
	poll_async=${12:yes}
	api_key=${13:# API key of the CloudStack API.}
	api_secret=${14:# Secret key of the CloudStack API.}
	api_url=${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${16:get|post}
	api_timeout=${17:# HTTP timeout in seconds.}
	api_region=${18:cloudstack}

endsnippet

snippet cs_configuration "Manages configuration on Apache CloudStack based clouds." b
cs_configuration: >
	name=${1:# Name of the configuration.}
	value=${2:# Value of the configuration.}

	account=${3:# Ensure the value for corresponding account.}
	domain=${4:ROOT}
	zone=${5:# Ensure the value for corresponding zone.}
	storage=${6:# Ensure the value for corresponding storage pool.}
	cluster=${7:# Ensure the value for corresponding cluster.}
	api_key=${8:# API key of the CloudStack API.}
	api_secret=${9:# Secret key of the CloudStack API.}
	api_url=${10:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${11:get|post}
	api_timeout=${12:# HTTP timeout in seconds.}
	api_region=${13:cloudstack}

endsnippet

snippet cs_instance_info "Gathering information from the API of instances from Apache CloudStack based clouds." b
cs_instance_info: >
	name=${1:# Name or display name of the instance.}
	domain=${2:# Domain the instance is related to.}
	account=${3:# Account the instance is related to.}
	project=${4:# Project the instance is related to.}
	api_key=${5:# API key of the CloudStack API.}
	api_secret=${6:# Secret key of the CloudStack API.}
	api_url=${7:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${8:get|post}
	api_timeout=${9:# HTTP timeout in seconds.}
	api_region=${10:cloudstack}

endsnippet

snippet cs_network_offering "Manages network offerings on Apache CloudStack based clouds." b
cs_network_offering: >
	name=${1:# The name of the network offering.}

	state=${2:enabled|#present|disabled|absent}
	display_text=${3:# Display text of the network offerings.}
	guest_ip_type=${4:Shared|Isolated}
	supported_services=${5:Dns|PortForwarding|Dhcp|SourceNat|UserData|Firewall|StaticNat|Vpn|Lb}
	traffic_type=${6:Guest}
	availability=${7:# The availability of network offering. Default value is Optional}
	conserve_mode=${8:# Whether the network offering has IP conserve mode enabled.}
	details=${9:# Network offering details in key/value pairs.}
	egress_default_policy=${10:allow|deny}
	persistent=${11:# True if network offering supports persistent networks}
	keepalive_enabled=${12:# If true keepalive will be turned on in the loadbalancer.}
	max_connections=${13:# Maximum number of concurrent connections supported by the network offering.}
	network_rate=${14:# Data transfer rate in megabits per second allowed.}
	service_capabilities=${15:# Desired service capabilities as part of network offering.}
	service_offering=${16:# The service offering name or ID used by virtual router provider.}
	service_providers=${17:# Provider to service mapping.}
	specify_ip_ranges=${18:# Whether the network offering supports specifying IP ranges.}
	specify_vlan=${19:# Whether the network offering supports vlans or not.}
	for_vpc=${20:# Whether the offering is meant to be used for VPC or not.}
	api_key=${21:# API key of the CloudStack API.}
	api_secret=${22:# Secret key of the CloudStack API.}
	api_url=${23:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${24:get|post}
	api_timeout=${25:# HTTP timeout in seconds.}
	api_region=${26:cloudstack}

endsnippet

snippet cs_securitygroup "Manages security groups on Apache CloudStack based clouds." b
cs_securitygroup: >
	name=${1:# Name of the security group.}

	description=${2:# Description of the security group.}
	state=${3:#present|absent}
	domain=${4:# Domain the security group is related to.}
	account=${5:# Account the security group is related to.}
	project=${6:# Name of the project the security group to be created in.}
	api_key=${7:# API key of the CloudStack API.}
	api_secret=${8:# Secret key of the CloudStack API.}
	api_url=${9:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${10:get|post}
	api_timeout=${11:# HTTP timeout in seconds.}
	api_region=${12:cloudstack}

endsnippet

snippet cs_domain "Manages domains on Apache CloudStack based clouds." b
cs_domain: >
	path=${1:# Path of the domain.}

	network_domain=${2:# Network domain for networks in the domain.}
	clean_up=${3:no}
	state=${4:#present|absent}
	poll_async=${5:yes}
	api_key=${6:# API key of the CloudStack API.}
	api_secret=${7:# Secret key of the CloudStack API.}
	api_url=${8:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${9:get|post}
	api_timeout=${10:# HTTP timeout in seconds.}
	api_region=${11:cloudstack}

endsnippet

snippet cs_vpn_gateway "Manages site-to-site VPN gateways on Apache CloudStack based clouds." b
cs_vpn_gateway: >
	vpc=${1:# Name of the VPC.}

	state=${2:#present|absent}
	domain=${3:# Domain the VPN gateway is related to.}
	account=${4:# Account the VPN gateway is related to.}
	project=${5:# Name of the project the VPN gateway is related to.}
	zone=${6:# Name of the zone the VPC is related to.}
	poll_async=${7:yes}
	api_key=${8:# API key of the CloudStack API.}
	api_secret=${9:# Secret key of the CloudStack API.}
	api_url=${10:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${11:get|post}
	api_timeout=${12:# HTTP timeout in seconds.}
	api_region=${13:cloudstack}

endsnippet

snippet cs_traffic_type "Manages traffic types on CloudStack Physical Networks" b
cs_traffic_type: >
	physical_network=${1:# the name of the Physical Network}
	traffic_type=${2:Management|Guest|Public|Storage}

	zone=${3:# Name of the zone with the physical network.}
	state=${4:#present|absent}
	hyperv_networklabel=${5:# The network name label of the physical device dedicated to this traffic on a HyperV host.}
	isolation_method=${6:vlan|vxlan}
	kvm_networklabel=${7:# The network name label of the physical device dedicated to this traffic on a KVM host.}
	ovm3_networklabel=${8:# The network name of the physical device dedicated to this traffic on an OVM3 host.}
	vlan=${9:# The VLAN id to be used for Management traffic by VMware host.}
	vmware_networklabel=${10:# The network name label of the physical device dedicated to this traffic on a VMware host.}
	xen_networklabel=${11:# The network name label of the physical device dedicated to this traffic on a XenServer host.}
	poll_async=${12:yes}
	api_key=${13:# API key of the CloudStack API.}
	api_secret=${14:# Secret key of the CloudStack API.}
	api_url=${15:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${16:get|post}
	api_timeout=${17:# HTTP timeout in seconds.}
	api_region=${18:cloudstack}

endsnippet

snippet cs_router "Manages routers on Apache CloudStack based clouds." b
cs_router: >
	name=${1:# Name of the router.}

	service_offering=${2:# Name or id of the service offering of the router.}
	domain=${3:# Domain the router is related to.}
	account=${4:# Account the router is related to.}
	project=${5:# Name of the project the router is related to.}
	zone=${6:# Name of the zone the router is deployed in.}
	state=${7:#present|absent|started|stopped|restarted}
	poll_async=${8:yes}
	api_key=${9:# API key of the CloudStack API.}
	api_secret=${10:# Secret key of the CloudStack API.}
	api_url=${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${12:get|post}
	api_timeout=${13:# HTTP timeout in seconds.}
	api_region=${14:cloudstack}

endsnippet

snippet cs_network_acl "Manages network access control lists (ACL) on Apache CloudStack based clouds." b
cs_network_acl: >
	name=${1:# Name of the network ACL.}
	vpc=${2:# VPC the network ACL is related to.}

	description=${3:# Description of the network ACL.}
	state=${4:#present|absent}
	domain=${5:# Domain the network ACL rule is related to.}
	account=${6:# Account the network ACL rule is related to.}
	project=${7:# Name of the project the network ACL is related to.}
	zone=${8:# Name of the zone the VPC is related to.}
	poll_async=${9:yes}
	api_key=${10:# API key of the CloudStack API.}
	api_secret=${11:# Secret key of the CloudStack API.}
	api_url=${12:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${13:get|post}
	api_timeout=${14:# HTTP timeout in seconds.}
	api_region=${15:cloudstack}

endsnippet

snippet cs_vpn_connection "Manages site-to-site VPN connections on Apache CloudStack based clouds." b
cs_vpn_connection: >
	vpc=${1:# Name of the VPC the VPN connection is related to.}
	vpn_customer_gateway=${2:# Name of the VPN customer gateway.}

	passive=${3:no}
	force=${4:no}
	state=${5:#present|absent}
	zone=${6:# Name of the zone the VPC is related to.}
	domain=${7:# Domain the VPN connection is related to.}
	account=${8:# Account the VPN connection is related to.}
	project=${9:# Name of the project the VPN connection is related to.}
	poll_async=${10:yes}
	api_key=${11:# API key of the CloudStack API.}
	api_secret=${12:# Secret key of the CloudStack API.}
	api_url=${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${14:get|post}
	api_timeout=${15:# HTTP timeout in seconds.}
	api_region=${16:cloudstack}

endsnippet

snippet cs_portforward "Manages port forwarding rules on Apache CloudStack based clouds." b
cs_portforward: >
	ip_address=${1:# Public IP address the rule is assigned to.}
	public_port=${2:# Start public port for this rule.}
	private_port=${3:# Start private port for this rule.}

	vm=${4:# Name of virtual machine which we make the port forwarding rule for.}
	state=${5:#present|absent}
	protocol=${6:#tcp|udp}
	public_end_port=${7:# End public port for this rule.}
	private_end_port=${8:# End private port for this rule.}
	open_firewall=${9:no}
	vm_guest_ip=${10:# VM guest NIC secondary IP address for the port forwarding rule.}
	network=${11:# Name of the network.}
	vpc=${12:# Name of the VPC.}
	domain=${13:# Domain the I(vm) is related to.}
	account=${14:# Account the I(vm) is related to.}
	project=${15:# Name of the project the I(vm) is located in.}
	zone=${16:# Name of the zone in which the virtual machine is in.}
	poll_async=${17:yes}
	tags=${18:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	api_key=${19:# API key of the CloudStack API.}
	api_secret=${20:# Secret key of the CloudStack API.}
	api_url=${21:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${22:get|post}
	api_timeout=${23:# HTTP timeout in seconds.}
	api_region=${24:cloudstack}

endsnippet

snippet cs_user "Manages users on Apache CloudStack based clouds." b
cs_user: >
	username=${1:# Username of the user.}

	account=${2:# Account the user will be created under.}
	password=${3:# Password of the user to be created.}
	first_name=${4:# First name of the user.}
	last_name=${5:# Last name of the user.}
	email=${6:# Email of the user.}
	timezone=${7:# Timezone of the user.}
	keys_registered=${8:no}
	domain=${9:ROOT}
	state=${10:#present|absent|enabled|disabled|locked|unlocked}
	poll_async=${11:yes}
	api_key=${12:# API key of the CloudStack API.}
	api_secret=${13:# Secret key of the CloudStack API.}
	api_url=${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${15:get|post}
	api_timeout=${16:# HTTP timeout in seconds.}
	api_region=${17:cloudstack}

endsnippet

snippet cs_pod "Manages pods on Apache CloudStack based clouds." b
cs_pod: >
	name=${1:# Name of the pod.}

	id=${2:# uuid of the existing pod.}
	start_ip=${3:# Starting IP address for the Pod.}
	end_ip=${4:# Ending IP address for the Pod.}
	netmask=${5:# Netmask for the Pod.}
	gateway=${6:# Gateway for the Pod.}
	zone=${7:# Name of the zone in which the pod belongs to.}
	state=${8:#present|enabled|disabled|absent}
	api_key=${9:# API key of the CloudStack API.}
	api_secret=${10:# Secret key of the CloudStack API.}
	api_url=${11:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${12:get|post}
	api_timeout=${13:# HTTP timeout in seconds.}
	api_region=${14:cloudstack}

endsnippet

snippet cs_project "Manages projects on Apache CloudStack based clouds." b
cs_project: >
	name=${1:# Name of the project.}

	display_text=${2:# Display text of the project.}
	state=${3:#present|absent|active|suspended}
	domain=${4:# Domain the project is related to.}
	account=${5:# Account the project is related to.}
	tags=${6:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	poll_async=${7:yes}
	api_key=${8:# API key of the CloudStack API.}
	api_secret=${9:# Secret key of the CloudStack API.}
	api_url=${10:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${11:get|post}
	api_timeout=${12:# HTTP timeout in seconds.}
	api_region=${13:cloudstack}

endsnippet

snippet cs_storage_pool "Manages Primary Storage Pools on Apache CloudStack based clouds." b
cs_storage_pool: >
	name=${1:# Name of the storage pool.}

	zone=${2:# Name of the zone in which the host should be deployed.}
	storage_url=${3:# URL of the storage pool.}
	pod=${4:# Name of the pod.}
	cluster=${5:# Name of the cluster.}
	scope=${6:cluster|zone}
	managed=${7:# Whether the storage pool should be managed by CloudStack.}
	hypervisor=${8:# Required when creating a zone scoped pool.}
	storage_tags=${9:# Tags associated with this storage pool.}
	provider=${10:DefaultPrimary}
	capacity_bytes=${11:# Bytes CloudStack can provision from this storage pool.}
	capacity_iops=${12:# Bytes CloudStack can provision from this storage pool.}
	allocation_state=${13:enabled|disabled|maintenance}
	state=${14:#present|absent}
	api_key=${15:# API key of the CloudStack API.}
	api_secret=${16:# Secret key of the CloudStack API.}
	api_url=${17:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${18:get|post}
	api_timeout=${19:# HTTP timeout in seconds.}
	api_region=${20:cloudstack}

endsnippet

snippet cs_account "Manages accounts on Apache CloudStack based clouds." b
cs_account: >
	name=${1:# Name of account.}

	username=${2:# Username of the user to be created if account did not exist.}
	password=${3:# Password of the user to be created if account did not exist.}
	first_name=${4:# First name of the user to be created if account did not exist.}
	last_name=${5:# Last name of the user to be created if account did not exist.}
	email=${6:# Email of the user to be created if account did not exist.}
	timezone=${7:# Timezone of the user to be created if account did not exist.}
	network_domain=${8:# Network domain of the account.}
	account_type=${9:#user|root_admin|domain_admin}
	domain=${10:ROOT}
	role=${11:# Creates the account under the specified role name or id.}
	ldap_domain=${12:# Name of the LDAP group or OU to bind.}
	ldap_type=${13:#GROUP|OU}
	state=${14:#present|absent|enabled|disabled|locked|unlocked}
	poll_async=${15:yes}
	api_key=${16:# API key of the CloudStack API.}
	api_secret=${17:# Secret key of the CloudStack API.}
	api_url=${18:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${19:get|post}
	api_timeout=${20:# HTTP timeout in seconds.}
	api_region=${21:cloudstack}

endsnippet

snippet cs_volume "Manages volumes on Apache CloudStack based clouds." b
cs_volume: >
	name=${1:# Name of the volume.}

	account=${2:# Account the volume is related to.}
	device_id=${3:# ID of the device on a VM the volume is attached to.}
	custom_id=${4:# Custom id to the resource.}
	disk_offering=${5:# Name of the disk offering to be used.}
	display_volume=${6:# Whether to display the volume to the end user or not.}
	domain=${7:# Name of the domain the volume to be deployed in.}
	max_iops=${8:# Max iops}
	min_iops=${9:# Min iops}
	project=${10:# Name of the project the volume to be deployed in.}
	size=${11:# Size of disk in GB}
	snapshot=${12:# The snapshot name for the disk volume.}
	force=${13:no}
	shrink_ok=${14:no}
	vm=${15:# Name of the virtual machine to attach the volume to.}
	zone=${16:# Name of the zone in which the volume should be deployed.}
	state=${17:#present|absent|attached|detached|extracted|uploaded}
	poll_async=${18:yes}
	tags=${19:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	url=${20:# URL to which the volume would be extracted on I(state=extracted)}
	mode=${21:#http_download|ftp_upload}
	format=${22:QCOW2|RAW|VHD|VHDX|OVA}
	api_key=${23:# API key of the CloudStack API.}
	api_secret=${24:# Secret key of the CloudStack API.}
	api_url=${25:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${26:get|post}
	api_timeout=${27:# HTTP timeout in seconds.}
	api_region=${28:cloudstack}

endsnippet

snippet cs_firewall "Manages firewall rules on Apache CloudStack based clouds." b
cs_firewall: >
	ip_address=${1:# Public IP address the ingress rule is assigned to.}
	network=${2:# Network the egress rule is related to.}
	state=${3:#present|absent}
	type=${4:#ingress|egress}
	protocol=${5:#tcp|udp|icmp|all}
	cidrs=${6:0.0.0.0/0}
	start_port=${7:# Start port for this rule.}
	end_port=${8:# End port for this rule. Considered if I(protocol=tcp) or I(protocol=udp).}
	icmp_type=${9:# Type of the icmp message being sent.}
	icmp_code=${10:# Error code for this icmp message.}
	domain=${11:# Domain the firewall rule is related to.}
	account=${12:# Account the firewall rule is related to.}
	project=${13:# Name of the project the firewall rule is related to.}
	zone=${14:# Name of the zone in which the virtual machine is in.}
	poll_async=${15:yes}
	tags=${16:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	api_key=${17:# API key of the CloudStack API.}
	api_secret=${18:# Secret key of the CloudStack API.}
	api_url=${19:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${20:get|post}
	api_timeout=${21:# HTTP timeout in seconds.}
	api_region=${22:cloudstack}

endsnippet

snippet cs_facts "Gather facts on instances of Apache CloudStack based clouds." b
cs_facts: >
	filter=${1:cloudstack_service_offering|cloudstack_availability_zone|cloudstack_public_hostname|cloudstack_public_ipv4|cloudstack_local_hostname|cloudstack_local_ipv4|cloudstack_instance_id|cloudstack_user_data}
	meta_data_host=${2:# Host or IP of the meta data API service.}

endsnippet

snippet cs_role_permission "Manages role permissions on Apache CloudStack based clouds." b
cs_role_permission: >
	name=${1:# The API name of the permission.}
	role=${2:# Name or ID of the role.}

	permission=${3:allow|#deny}
	state=${4:#present|absent}
	description=${5:# The description of the role permission.}
	parent=${6:# The parent role permission uuid. use 0 to move this rule at the top of the list.}
	api_key=${7:# API key of the CloudStack API.}
	api_secret=${8:# Secret key of the CloudStack API.}
	api_url=${9:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${10:get|post}
	api_timeout=${11:# HTTP timeout in seconds.}
	api_region=${12:cloudstack}

endsnippet

snippet cs_vpn_customer_gateway "Manages site-to-site VPN customer gateway configurations on Apache CloudStack based clouds." b
cs_vpn_customer_gateway: >
	name=${1:# Name of the gateway.}

	cidrs=${2:# List of guest CIDRs behind the gateway.}
	gateway=${3:# Public IP address of the gateway.}
	esp_policy=${4:# ESP policy in the format e.g. C(aes256-sha1;modp1536).}
	ike_policy=${5:# IKE policy in the format e.g. C(aes256-sha1;modp1536).}
	ipsec_psk=${6:# IPsec Preshared-Key.}
	ike_lifetime=${7:# Lifetime in seconds of phase 1 VPN connection.}
	esp_lifetime=${8:# Lifetime in seconds of phase 2 VPN connection.}
	dpd=${9:# Enable Dead Peer Detection.}
	force_encap=${10:# Force encapsulation for NAT traversal.}
	state=${11:#present|absent}
	domain=${12:# Domain the VPN customer gateway is related to.}
	account=${13:# Account the VPN customer gateway is related to.}
	project=${14:# Name of the project the VPN gateway is related to.}
	poll_async=${15:yes}
	api_key=${16:# API key of the CloudStack API.}
	api_secret=${17:# Secret key of the CloudStack API.}
	api_url=${18:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${19:get|post}
	api_timeout=${20:# HTTP timeout in seconds.}
	api_region=${21:cloudstack}

endsnippet

snippet cs_disk_offering "Manages disk offerings on Apache CloudStack based clouds." b
cs_disk_offering: >
	name=${1:# Name of the disk offering.}

	disk_size=${2:# Size of the disk offering in GB (1GB = 1,073,741,824 bytes).}
	bytes_read_rate=${3:# Bytes read rate of the disk offering.}
	bytes_write_rate=${4:# Bytes write rate of the disk offering.}
	display_text=${5:# Display text of the disk offering.}
	domain=${6:# Domain the disk offering is related to.}
	hypervisor_snapshot_reserve=${7:# Hypervisor snapshot reserve space as a percent of a volume.}
	customized=${8:no}
	iops_read_rate=${9:# IO requests read rate of the disk offering.}
	iops_write_rate=${10:# IO requests write rate of the disk offering.}
	iops_max=${11:# Max. iops of the disk offering.}
	iops_min=${12:# Min. iops of the disk offering.}
	provisioning_type=${13:thin|sparse|fat}
	state=${14:#present|absent}
	storage_type=${15:local|shared}
	storage_tags=${16:# The storage tags for this disk offering.}
	display_offering=${17:# An optional field, whether to display the offering to the end user or not.}
	api_key=${18:# API key of the CloudStack API.}
	api_secret=${19:# Secret key of the CloudStack API.}
	api_url=${20:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${21:get|post}
	api_timeout=${22:# HTTP timeout in seconds.}
	api_region=${23:cloudstack}

endsnippet

snippet cs_role "Manages user roles on Apache CloudStack based clouds." b
cs_role: >
	name=${1:# Name of the role.}

	id=${2:# ID of the role.}
	role_type=${3:#User|DomainAdmin|ResourceAdmin|Admin}
	description=${4:# Description of the role.}
	state=${5:#present|absent}
	api_key=${6:# API key of the CloudStack API.}
	api_secret=${7:# Secret key of the CloudStack API.}
	api_url=${8:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${9:get|post}
	api_timeout=${10:# HTTP timeout in seconds.}
	api_region=${11:cloudstack}

endsnippet

snippet cs_cluster "Manages host clusters on Apache CloudStack based clouds." b
cs_cluster: >
	name=${1:# name of the cluster.}

	zone=${2:# Name of the zone in which the cluster belongs to.}
	pod=${3:# Name of the pod in which the cluster belongs to.}
	cluster_type=${4:CloudManaged|ExternalManaged}
	hypervisor=${5:# Name the hypervisor to be used.}
	url=${6:# URL for the cluster}
	username=${7:# Username for the cluster.}
	password=${8:# Password for the cluster.}
	guest_vswitch_name=${9:# Name of virtual switch used for guest traffic in the cluster.}
	guest_vswitch_type=${10:vmwaresvs|vmwaredvs}
	public_vswitch_name=${11:# Name of virtual switch used for public traffic in the cluster.}
	public_vswitch_type=${12:vmwaresvs|vmwaredvs}
	vms_ip_address=${13:# IP address of the VSM associated with this cluster.}
	vms_username=${14:# Username for the VSM associated with this cluster.}
	vms_password=${15:# Password for the VSM associated with this cluster.}
	ovm3_cluster=${16:# Ovm3 native OCFS2 clustering enabled for cluster.}
	ovm3_pool=${17:# Ovm3 native pooling enabled for cluster.}
	ovm3_vip=${18:# Ovm3 vip to use for pool (and cluster).}
	state=${19:#present|absent|disabled|enabled}
	api_key=${20:# API key of the CloudStack API.}
	api_secret=${21:# Secret key of the CloudStack API.}
	api_url=${22:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${23:get|post}
	api_timeout=${24:# HTTP timeout in seconds.}
	api_region=${25:cloudstack}

endsnippet

snippet cs_instance_password_reset "Allows resetting VM the default passwords on Apache CloudStack based clouds." b
cs_instance_password_reset: >
	vm=${1:# Name of the virtual machine to reset the password on.}

	domain=${2:# Name of the domain the virtual machine belongs to.}
	account=${3:# Account the virtual machine belongs to.}
	project=${4:# Name of the project the virtual machine belongs to.}
	zone=${5:# Name of the zone in which the instance is deployed.}
	poll_async=${6:yes}
	api_key=${7:# API key of the CloudStack API.}
	api_secret=${8:# Secret key of the CloudStack API.}
	api_url=${9:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${10:get|post}
	api_timeout=${11:# HTTP timeout in seconds.}
	api_region=${12:cloudstack}

endsnippet

snippet cs_vpc "Manages VPCs on Apache CloudStack based clouds." b
cs_vpc: >
	name=${1:# Name of the VPC.}

	display_text=${2:# Display text of the VPC.}
	cidr=${3:# CIDR of the VPC, e.g. 10.1.0.0/16}
	network_domain=${4:# Network domain for the VPC.}
	vpc_offering=${5:# Name of the VPC offering.}
	clean_up=${6:# Whether to redeploy a VPC router or not when I(state=restarted)}
	state=${7:#present|absent|stopped|restarted}
	domain=${8:# Domain the VPC is related to.}
	account=${9:# Account the VPC is related to.}
	project=${10:# Name of the project the VPC is related to.}
	zone=${11:# Name of the zone.}
	tags=${12:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	poll_async=${13:yes}
	api_key=${14:# API key of the CloudStack API.}
	api_secret=${15:# Secret key of the CloudStack API.}
	api_url=${16:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${17:get|post}
	api_timeout=${18:# HTTP timeout in seconds.}
	api_region=${19:cloudstack}

endsnippet

snippet cs_sshkeypair "Manages SSH keys on Apache CloudStack based clouds." b
cs_sshkeypair: >
	name=${1:# Name of public key.}

	domain=${2:# Domain the public key is related to.}
	account=${3:# Account the public key is related to.}
	project=${4:# Name of the project the public key to be registered in.}
	state=${5:#present|absent}
	public_key=${6:# String of the public key.}
	api_key=${7:# API key of the CloudStack API.}
	api_secret=${8:# Secret key of the CloudStack API.}
	api_url=${9:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${10:get|post}
	api_timeout=${11:# HTTP timeout in seconds.}
	api_region=${12:cloudstack}

endsnippet

snippet cs_image_store "Manages CloudStack Image Stores." b
cs_image_store: >
	name=${1:# The ID of the Image Store. Required when deleting a Image Store.}
	zone=${2:# The Zone name for the Image Store.}

	url=${3:# The URL for the Image Store.}
	state=${4:#present|absent}
	provider=${5:# The image store provider name. Required when creating a new Image Store}
	force_recreate=${6:no}
	api_key=${7:# API key of the CloudStack API.}
	api_secret=${8:# Secret key of the CloudStack API.}
	api_url=${9:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${10:get|post}
	api_timeout=${11:# HTTP timeout in seconds.}
	api_region=${12:cloudstack}

endsnippet

snippet cs_host "Manages hosts on Apache CloudStack based clouds." b
cs_host: >
	name=${1:# Name of the host.}

	url=${2:# Url of the host used to create a host.}
	username=${3:# Username for the host.}
	password=${4:# Password for the host.}
	pod=${5:# Name of the pod.}
	cluster=${6:# Name of the cluster.}
	hypervisor=${7:# Name of the cluster.}
	allocation_state=${8:enabled|disabled|maintenance}
	host_tags=${9:# Tags of the host.}
	state=${10:#present|absent}
	zone=${11:# Name of the zone in which the host should be deployed.}
	api_key=${12:# API key of the CloudStack API.}
	api_secret=${13:# Secret key of the CloudStack API.}
	api_url=${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${15:get|post}
	api_timeout=${16:# HTTP timeout in seconds.}
	api_region=${17:cloudstack}

endsnippet

snippet cs_instancegroup "Manages instance groups on Apache CloudStack based clouds." b
cs_instancegroup: >
	name=${1:# Name of the instance group.}

	domain=${2:# Domain the instance group is related to.}
	account=${3:# Account the instance group is related to.}
	project=${4:# Project the instance group is related to.}
	state=${5:#present|absent}
	api_key=${6:# API key of the CloudStack API.}
	api_secret=${7:# Secret key of the CloudStack API.}
	api_url=${8:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${9:get|post}
	api_timeout=${10:# HTTP timeout in seconds.}
	api_region=${11:cloudstack}

endsnippet

snippet cs_loadbalancer_rule "Manages load balancer rules on Apache CloudStack based clouds." b
cs_loadbalancer_rule: >
	name=${1:# The name of the load balancer rule.}
	public_port=${2:# The public port from where the network traffic will be load balanced from.}
	ip_address=${3:# Public IP address from where the network traffic will be load balanced from.}

	description=${4:# The description of the load balancer rule.}
	algorithm=${5:#source|roundrobin|leastconn}
	private_port=${6:# The private port of the private ip address/virtual machine where the network traffic will be load balanced to.}
	open_firewall=${7:no}
	cidr=${8:# CIDR (full notation) to be used for firewall rule if required.}
	protocol=${9:# The protocol to be used on the load balancer}
	project=${10:# Name of the project the load balancer IP address is related to.}
	state=${11:#present|absent}
	domain=${12:# Domain the rule is related to.}
	account=${13:# Account the rule is related to.}
	zone=${14:# Name of the zone in which the rule should be created.}
	poll_async=${15:yes}
	tags=${16:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	network=${17:# Name of the network.}
	vpc=${18:# Name of the VPC.}
	api_key=${19:# API key of the CloudStack API.}
	api_secret=${20:# Secret key of the CloudStack API.}
	api_url=${21:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${22:get|post}
	api_timeout=${23:# HTTP timeout in seconds.}
	api_region=${24:cloudstack}

endsnippet

snippet cs_service_offering "Manages service offerings on Apache CloudStack based clouds." b
cs_service_offering: >
	name=${1:# Name of the service offering.}

	disk_bytes_read_rate=${2:# Bytes read rate of the disk offering.}
	disk_bytes_write_rate=${3:# Bytes write rate of the disk offering.}
	cpu_number=${4:# The number of CPUs of the service offering.}
	cpu_speed=${5:# The CPU speed of the service offering in MHz.}
	limit_cpu_usage=${6:# Restrict the CPU usage to committed service offering.}
	deployment_planner=${7:# The deployment planner heuristics used to deploy a VM of this offering.}
	display_text=${8:# Display text of the service offering.}
	domain=${9:# Domain the service offering is related to.}
	host_tags=${10:# The host tags for this service offering.}
	hypervisor_snapshot_reserve=${11:# Hypervisor snapshot reserve space as a percent of a volume.}
	is_iops_customized=${12:# Whether compute offering iops is custom or not.}
	disk_iops_read_rate=${13:# IO requests read rate of the disk offering.}
	disk_iops_write_rate=${14:# IO requests write rate of the disk offering.}
	disk_iops_max=${15:# Max. iops of the compute offering.}
	disk_iops_min=${16:# Min. iops of the compute offering.}
	is_system=${17:no}
	is_volatile=${18:# Whether the virtual machine needs to be volatile or not.}
	memory=${19:# The total memory of the service offering in MB.}
	network_rate=${20:# Data transfer rate in Mb/s allowed.}
	offer_ha=${21:no}
	provisioning_type=${22:thin|sparse|fat}
	service_offering_details=${23:# Details for planner, used to store specific parameters.}
	state=${24:#present|absent}
	storage_type=${25:local|shared}
	system_vm_type=${26:domainrouter|consoleproxy|secondarystoragevm}
	storage_tags=${27:# The storage tags for this service offering.}
	is_customized=${28:# Whether the offering is customizable or not.}
	api_key=${29:# API key of the CloudStack API.}
	api_secret=${30:# Secret key of the CloudStack API.}
	api_url=${31:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${32:get|post}
	api_timeout=${33:# HTTP timeout in seconds.}
	api_region=${34:cloudstack}

endsnippet

snippet cs_snapshot_policy "Manages volume snapshot policies on Apache CloudStack based clouds." b
cs_snapshot_policy: >
	volume=${1:# Name of the volume.}
	volume_type=${2:DATADISK|ROOT}
	vm=${3:# Name of the instance to select the volume from.}
	device_id=${4:# ID of the device on a VM the volume is attached to.}
	vpc=${5:# Name of the vpc the instance is deployed in.}
	interval_type=${6:hourly|#daily|weekly|monthly}
	max_snaps=${7:8}
	schedule=${8:# Time the snapshot is scheduled. Required if I(state=present).}
	time_zone=${9:UTC}
	state=${10:#present|absent}
	domain=${11:# Domain the volume is related to.}
	account=${12:# Account the volume is related to.}
	project=${13:# Name of the project the volume is related to.}
	api_key=${14:# API key of the CloudStack API.}
	api_secret=${15:# Secret key of the CloudStack API.}
	api_url=${16:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${17:get|post}
	api_timeout=${18:# HTTP timeout in seconds.}
	api_region=${19:cloudstack}

endsnippet

snippet cs_network "Manages networks on Apache CloudStack based clouds." b
cs_network: >
	name=${1:# Name (case sensitive) of the network.}

	display_text=${2:# Display text of the network.}
	network_offering=${3:# Name of the offering for the network.}
	start_ip=${4:# The beginning IPv4 address of the network belongs to.}
	end_ip=${5:# The ending IPv4 address of the network belongs to.}
	gateway=${6:# The gateway of the network.}
	netmask=${7:# The netmask of the network.}
	start_ipv6=${8:# The beginning IPv6 address of the network belongs to.}
	end_ipv6=${9:# The ending IPv6 address of the network belongs to.}
	cidr_ipv6=${10:# CIDR of IPv6 network, must be at least /64.}
	gateway_ipv6=${11:# The gateway of the IPv6 network.}
	vlan=${12:# The ID or VID of the network.}
	vpc=${13:# Name of the VPC of the network.}
	isolated_pvlan=${14:# The isolated private VLAN for this network.}
	clean_up=${15:no}
	acl_type=${16:account|domain}
	acl=${17:# The name of the access control list for the VPC network tier.}
	subdomain_access=${18:# Defines whether to allow subdomains to use networks dedicated to their parent domain(s).}
	network_domain=${19:# The network domain.}
	state=${20:#present|absent|restarted}
	zone=${21:# Name of the zone in which the network should be deployed.}
	project=${22:# Name of the project the network to be deployed in.}
	domain=${23:# Domain the network is related to.}
	account=${24:# Account the network is related to.}
	poll_async=${25:yes}
	tags=${26:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	api_key=${27:# API key of the CloudStack API.}
	api_secret=${28:# Secret key of the CloudStack API.}
	api_url=${29:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${30:get|post}
	api_timeout=${31:# HTTP timeout in seconds.}
	api_region=${32:cloudstack}

endsnippet

snippet cs_ip_address "Manages public IP address associations on Apache CloudStack based clouds." b
cs_ip_address: >
	ip_address=${1:# Public IP address.}
	domain=${2:# Domain the IP address is related to.}
	network=${3:# Network the IP address is related to.}
	vpc=${4:# VPC the IP address is related to.}
	account=${5:# Account the IP address is related to.}
	project=${6:# Name of the project the IP address is related to.}
	zone=${7:# Name of the zone in which the IP address is in.}
	state=${8:#present|absent}
	tags=${9:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	poll_async=${10:yes}
	api_key=${11:# API key of the CloudStack API.}
	api_secret=${12:# Secret key of the CloudStack API.}
	api_url=${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${14:get|post}
	api_timeout=${15:# HTTP timeout in seconds.}
	api_region=${16:cloudstack}

endsnippet

snippet cs_instance_nic "Manages NICs of an instance on Apache CloudStack based clouds." b
cs_instance_nic: >
	vm=${1:# Name of instance.}
	network=${2:# Name of the network.}

	ip_address=${3:# IP address to be used for the nic.}
	vpc=${4:# Name of the VPC the I(vm) is related to.}
	domain=${5:# Domain the instance is related to.}
	account=${6:# Account the instance is related to.}
	project=${7:# Name of the project the instance is deployed in.}
	zone=${8:# Name of the zone in which the instance is deployed in.}
	state=${9:#present|absent}
	poll_async=${10:yes}
	api_key=${11:# API key of the CloudStack API.}
	api_secret=${12:# Secret key of the CloudStack API.}
	api_url=${13:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${14:get|post}
	api_timeout=${15:# HTTP timeout in seconds.}
	api_region=${16:cloudstack}

endsnippet

snippet cs_vmsnapshot "Manages VM snapshots on Apache CloudStack based clouds." b
cs_vmsnapshot: >
	name=${1:# Unique Name of the snapshot. In CloudStack terms display name.}
	vm=${2:# Name of the virtual machine.}

	description=${3:# Description of the snapshot.}
	snapshot_memory=${4:no}
	zone=${5:# Name of the zone in which the VM is in. If not set, default zone is used.}
	project=${6:# Name of the project the VM is assigned to.}
	state=${7:#present|absent|revert}
	domain=${8:# Domain the VM snapshot is related to.}
	account=${9:# Account the VM snapshot is related to.}
	poll_async=${10:yes}
	tags=${11:# List of tags. Tags are a list of dictionaries having keys I(key) and I(value).}
	api_key=${12:# API key of the CloudStack API.}
	api_secret=${13:# Secret key of the CloudStack API.}
	api_url=${14:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${15:get|post}
	api_timeout=${16:# HTTP timeout in seconds.}
	api_region=${17:cloudstack}

endsnippet

snippet cs_instance "Manages instances and virtual machines on Apache CloudStack based clouds." b
cs_instance: >
	name=${1:# Host name of the instance. C(name) can only contain ASCII letters.}
	display_name=${2:# Custom display name of the instances.}
	group=${3:# Group in where the new instance should be in.}
	state=${4:deployed|started|stopped|restarted|restored|destroyed|expunged|#present|absent}
	service_offering=${5:# Name or id of the service offering of the new instance.}
	cpu=${6:# The number of CPUs to allocate to the instance, used with custom service offerings}
	cpu_speed=${7:# The clock speed/shares allocated to the instance, used with custom service offerings}
	memory=${8:# The memory allocated to the instance, used with custom service offerings}
	template=${9:# Name, display text or id of the template to be used for creating the new instance.}
	iso=${10:# Name or id of the ISO to be used for creating the new instance.}
	template_filter=${11:all|featured|self|selfexecutable|sharedexecutable|#executable|community}
	hypervisor=${12:# Name the hypervisor to be used for creating the new instance.}
	keyboard=${13:de|de-ch|es|fi|fr|fr-be|fr-ch|is|it|jp|nl-be|no|pt|uk|us}
	networks=${14:# List of networks to use for the new instance.}
	ip_address=${15:# IPv4 address for default instance's network during creation.}
	ip6_address=${16:# IPv6 address for default instance's network.}
	ip_to_networks=${17:# List of mappings in the form I({'network': NetworkName, 'ip': 1.2.3.4})}
	disk_offering=${18:# Name of the disk offering to be used.}
	disk_size=${19:# Disk size in GByte required if deploying instance from ISO.}
	root_disk_size=${20:# Root disk size in GByte required if deploying instance with KVM hypervisor and want resize the root disk size at startup (need CloudStack >= 4.4, cloud-initramfs-growroot installed and enabled in the template)}
	security_groups=${21:# List of security groups the instance to be applied to.}
	host=${22:# Host on which an instance should be deployed or started on.}
	domain=${23:# Domain the instance is related to.}
	account=${24:# Account the instance is related to.}
	project=${25:# Name of the project the instance to be deployed in.}
	zone=${26:# Name of the zone in which the instance should be deployed.}
	ssh_key=${27:# Name of the SSH key to be deployed on the new instance.}
	affinity_groups=${28:# Affinity groups names to be applied to the new instance.}
	user_data=${29:# Optional data (ASCII) that can be sent to the instance upon a successful deployment.}
	force=${30:no}
	allow_root_disk_shrink=${31:no}
	tags=${32:# List of tags. Tags are a list of dictionaries having keys C(key) and C(value).}
	poll_async=${33:yes}
	details=${34:# Map to specify custom parameters.}
	api_key=${35:# API key of the CloudStack API.}
	api_secret=${36:# Secret key of the CloudStack API.}
	api_url=${37:# URL of the CloudStack API e.g. https://cloud.example.com/client/api.}
	api_http_method=${38:get|post}
	api_timeout=${39:# HTTP timeout in seconds.}
	api_region=${40:cloudstack}

endsnippet

snippet clc_group "Create/delete Server Groups at Centurylink Cloud" b
clc_group: >
	name=${1:# The name of the Server Group}

	description=${2:# A description of the Server Group}
	parent=${3:# The parent group of the server group. If parent is not provided, it creates the group at top level.}
	location=${4:# Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account}
	state=${5:#present|absent}
	wait=${6:yes}

endsnippet

snippet clc_firewall_policy "Create/delete/update firewall policies" b
clc_firewall_policy: >
	location=${1:# Target datacenter for the firewall policy}
	source_account_alias=${2:# CLC alias for the source account}

	state=${3:#present|absent}
	source=${4:# The list  of source addresses for traffic on the originating firewall. This is required when state is 'present'}
	destination=${5:# The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'}
	ports=${6:any|icmp|TCP/123|UDP/123|TCP/123-456|UDP/123-456}
	firewall_policy_id=${7:# Id of the firewall policy. This is required to update or delete an existing firewall policy}
	destination_account_alias=${8:# CLC alias for the destination account}
	wait=${9:yes}
	enabled=${10:True|False}

endsnippet

snippet clc_loadbalancer "Create, Delete shared loadbalancers in CenturyLink Cloud." b
clc_loadbalancer: >
	name=${1:# The name of the loadbalancer}
	alias=${2:# The alias of your CLC Account}
	location=${3:# The location of the datacenter where the load balancer resides in}

	description=${4:# A description for the loadbalancer}
	method=${5:leastConnection|roundRobin}
	persistence=${6:standard|sticky}
	port=${7:80|443}
	nodes=${8:[]}
	status=${9:#enabled|disabled}
	state=${10:#present|absent|port_absent|nodes_present|nodes_absent}

endsnippet

snippet clc_server "Create, Delete, Start and Stop servers in CenturyLink Cloud." b
clc_server: >
	additional_disks=${1:[]}
	add_public_ip=${2:no}
	alias=${3:# The account alias to provision the servers under.}
	anti_affinity_policy_id=${4:# The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_name'.}
	anti_affinity_policy_name=${5:# The anti-affinity policy to assign to the server. This is mutually exclusive with 'anti_affinity_policy_id'.}
	alert_policy_id=${6:# The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_name'.}
	alert_policy_name=${7:# The alert policy to assign to the server. This is mutually exclusive with 'alert_policy_id'.}
	count=${8:1}
	count_group=${9:# Required when exact_count is specified.  The Server Group use to determine how many servers to deploy.}
	cpu=${10:1}
	cpu_autoscale_policy_id=${11:# The autoscale policy to assign to the server.}
	custom_fields=${12:[]}
	description=${13:# The description to set for the server.}
	exact_count=${14:# Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count.  Requires count_group to be set.}
	group=${15:Default Group}
	ip_address=${16:# The IP Address for the server. One is assigned if not provided.}
	location=${17:# The Datacenter to create servers in.}
	managed_os=${18:no}
	memory=${19:1}
	name=${20:# A 1 to 6 character identifier to use for the server. This is required when state is 'present'}
	network_id=${21:# The network UUID on which to create servers.}
	packages=${22:[]}
	password=${23:# Password for the administrator / root user}
	primary_dns=${24:# Primary DNS used by the server.}
	public_ip_protocol=${25:#TCP|UDP|ICMP}
	public_ip_ports=${26:[]}
	secondary_dns=${27:# Secondary DNS used by the server.}
	server_ids=${28:[]}
	source_server_password=${29:# The password for the source server if a clone is specified.}
	state=${30:#present|absent|started|stopped}
	storage_type=${31:#standard|hyperscale}
	template=${32:# The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'}
	ttl=${33:# The time to live for the server in seconds.  The server will be deleted when this time expires.}
	type=${34:#standard|hyperscale|bareMetal}
	configuration_id=${35:# Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.}
	os_type=${36:redHat6_64Bit|centOS6_64Bit|windows2012R2Standard_64Bit|ubuntu14_64Bit}
	wait=${37:yes}

endsnippet

snippet clc_aa_policy "Create or Delete Anti Affinity Policies at CenturyLink Cloud." b
clc_aa_policy: >
	name=${1:# The name of the Anti Affinity Policy.}
	location=${2:# Datacenter in which the policy lives/should live.}

	state=${3:#present|absent}
	wait=${4:yes}

endsnippet

snippet clc_publicip "Add and Delete public ips on servers in CenturyLink Cloud." b
clc_publicip: >
	server_ids=${1:# A list of servers to create public ips on.}

	protocol=${2:#TCP|UDP|ICMP}
	ports=${3:# A list of ports to expose. This is required when state is 'present'}
	state=${4:#present|absent}
	wait=${5:yes}

endsnippet

snippet clc_server_snapshot "Create, Delete and Restore server snapshots in CenturyLink Cloud." b
clc_server_snapshot: >
	server_ids=${1:# The list of CLC server Ids.}

	expiration_days=${2:7}
	state=${3:#present|absent|restore}
	wait=${4:yes}

endsnippet

snippet clc_modify_server "modify servers in CenturyLink Cloud." b
clc_modify_server: >
	server_ids=${1:# A list of server Ids to modify.}

	cpu=${2:# How many CPUs to update on the server}
	memory=${3:# Memory (in GB) to set to the server.}
	anti_affinity_policy_id=${4:# The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_name'}
	anti_affinity_policy_name=${5:# The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'anti_affinity_policy_id'}
	alert_policy_id=${6:# The alert policy id to be associated to the server. This is mutually exclusive with 'alert_policy_name'}
	alert_policy_name=${7:# The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'}
	state=${8:#present|absent}
	wait=${9:yes}

endsnippet

snippet clc_blueprint_package "deploys a blue print package on a set of servers in CenturyLink Cloud." b
clc_blueprint_package: >
	server_ids=${1:# A list of server Ids to deploy the blue print package.}
	package_id=${2:# The package id of the blue print.}

	package_params=${3:{}}
	state=${4:#present}
	wait=${5:yes}

endsnippet

snippet clc_alert_policy "Create or Delete Alert Policies at CenturyLink Cloud." b
clc_alert_policy: >
	alias=${1:# The alias of your CLC Account}

	name=${2:# The name of the alert policy. This is mutually exclusive with id}
	id=${3:# The alert policy id. This is mutually exclusive with name}
	alert_recipients=${4:# A list of recipient email ids to notify the alert. This is required for state 'present'}
	metric=${5:cpu|memory|disk}
	duration=${6:# The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'}
	threshold=${7:# The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0}
	state=${8:#present|absent}

endsnippet

snippet atomic_image "Manage the container images on the atomic host platform" b
atomic_image: >
	name=${1:# Name of the container image.}

	backend=${2:docker|ostree}
	state=${3:absent|#latest|present}
	started=${4:yes}

endsnippet

snippet atomic_container "Manage the containers on the atomic host platform" b
atomic_container: >
	backend=${1:docker|ostree}
	name=${2:# Name of the container}
	image=${3:# The image to use to install the container}
	state=${4:#latest|present|absent|rollback}
	mode=${5:user|system}

	rootfs=${6:# Define the rootfs of the image}
	values=${7:# Values for the installation of the container.  This option is permitted only with mode 'user' or 'system'. The values specified here will be used at installation time as --set arguments for atomic install.}

endsnippet

snippet atomic_host "Manage the atomic host platform" b
atomic_host: >
	revision=${1:latest}

endsnippet

snippet digital_ocean_snapshot_info "Gather information about DigitalOcean Snapshot" b
digital_ocean_snapshot_info: >
	snapshot_type=${1:#all|droplet|volume|by_id}
	snapshot_id=${2:# To retrieve information about a snapshot, please specify this as a snapshot id.}
	oauth_token=${3:# DigitalOcean OAuth token.}
	timeout=${4:30}
	validate_certs=${5:yes}

endsnippet

snippet digital_ocean_region_info "Gather information about DigitalOcean regions" b
digital_ocean_region_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_sshkey_info "Gather information about DigitalOcean SSH keys" b
digital_ocean_sshkey_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_tag_info "Gather information about DigitalOcean tags" b
digital_ocean_tag_info: >
	tag_name=${1:# Tag name that can be used to identify and reference a tag.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_tag "Create and remove tag(s) to DigitalOcean resource." b
digital_ocean_tag: >
	name=${1:# The name of the tag. The supported characters for names include alphanumeric characters, dashes, and underscores.}

	resource_id=${2:# The ID of the resource to operate on.}
	resource_type=${3:#droplet}
	state=${4:#present|absent}
	oauth_token=${5:# DigitalOcean OAuth token.}
	timeout=${6:30}
	validate_certs=${7:yes}

endsnippet

snippet digital_ocean_domain_info "Gather information about DigitalOcean Domains" b
digital_ocean_domain_info: >
	domain_name=${1:# Name of the domain to gather information for.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_firewall_info "Gather information about DigitalOcean firewalls" b
digital_ocean_firewall_info: >
	name=${1:# Firewall rule name that can be used to identify and reference a specific firewall rule.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_block_storage "Create/destroy or attach/detach Block Storage volumes in DigitalOcean" b
digital_ocean_block_storage: >
	command=${1:create|attach}
	state=${2:present|absent}
	volume_name=${3:# The name of the Block Storage volume.}
	region=${4:# The slug of the region where your Block Storage volume should be located in. If snapshot_id is included, this will be ignored.}

	block_size=${5:# The size of the Block Storage volume in gigabytes. Required when command=create and state=present. If snapshot_id is included, this will be ignored.}
	description=${6:# Description of the Block Storage volume.}
	snapshot_id=${7:# The snapshot id you would like the Block Storage volume created with. If included, region and block_size will be ignored and changed to null.}
	droplet_id=${8:# The droplet id you want to operate on. Required when command=attach.}
	oauth_token=${9:# DigitalOcean OAuth token.}
	timeout=${10:30}
	validate_certs=${11:yes}

endsnippet

snippet digital_ocean_droplet "Create and delete a DigitalOcean droplet" b
digital_ocean_droplet: >
	oauth_token=${1:# DigitalOcean OAuth token. Can be specified in C(DO_API_KEY), C(DO_API_TOKEN), or C(DO_OAUTH_TOKEN) environment variables}

	state=${2:#present|absent}
	id=${3:# Numeric, the droplet id you want to operate on.}
	name=${4:# String, this is the name of the droplet - must be formatted by hostname rules.}
	unique_name=${5:no}
	size=${6:# This is the slug of the size you would like the droplet created with.}
	image=${7:# This is the slug of the image you would like the droplet created with.}
	region=${8:# This is the slug of the region you would like your server to be created in.}
	ssh_keys=${9:# array of SSH key (numeric) ID that you would like to be added to the server.}
	private_networking=${10:no}
	user_data=${11:# opaque blob of data which is made available to the droplet}
	ipv6=${12:no}
	wait=${13:yes}
	wait_timeout=${14:120}
	backups=${15:no}
	monitoring=${16:no}
	tags=${17:# List, A list of tag names as strings to apply to the Droplet after it is created. Tag names can either be existing or new tags.}
	volumes=${18:# List, A list including the unique string identifier for each Block Storage volume to be attached to the Droplet.}

endsnippet

snippet digital_ocean_load_balancer_info "Gather information about DigitalOcean load balancers" b
digital_ocean_load_balancer_info: >
	load_balancer_id=${1:# Load balancer ID that can be used to identify and reference a load_balancer.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_sshkey "Manage DigitalOcean SSH keys" b
digital_ocean_sshkey: >
	oauth_token=${1:# DigitalOcean OAuth token.}

	state=${2:#present|absent}
	fingerprint=${3:# This is a unique identifier for the SSH key used to delete a key}
	name=${4:# The name for the SSH key}
	ssh_pub_key=${5:# The Public SSH key to add.}

endsnippet

snippet digital_ocean_load_balancer_info "Gather information about DigitalOcean load balancers" b
digital_ocean_load_balancer_info: >
	load_balancer_id=${1:# Load balancer ID that can be used to identify and reference a load_balancer.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_certificate "Manage certificates in DigitalOcean." b
digital_ocean_certificate: >
	name=${1:# The name of the certificate.}

	private_key=${2:# A PEM-formatted private key content of SSL Certificate.}
	leaf_certificate=${3:# A PEM-formatted public SSL Certificate.}
	certificate_chain=${4:# The full PEM-formatted trust chain between the certificate authority's certificate and your domain's SSL certificate.}
	state=${5:#present|absent}
	oauth_token=${6:# DigitalOcean OAuth token.}
	timeout=${7:30}
	validate_certs=${8:yes}

endsnippet

snippet digital_ocean_snapshot_info "Gather information about DigitalOcean Snapshot" b
digital_ocean_snapshot_info: >
	snapshot_type=${1:#all|droplet|volume|by_id}
	snapshot_id=${2:# To retrieve information about a snapshot, please specify this as a snapshot id.}
	oauth_token=${3:# DigitalOcean OAuth token.}
	timeout=${4:30}
	validate_certs=${5:yes}

endsnippet

snippet digital_ocean_account_info "Gather information about DigitalOcean User account" b
digital_ocean_account_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_volume_info "Gather information about DigitalOcean volumes" b
digital_ocean_volume_info: >
	region_name=${1:# Name of region to restrict results to volumes available in a specific region.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_floating_ip "Manage DigitalOcean Floating IPs" b
digital_ocean_floating_ip: >
	oauth_token=${1:# DigitalOcean OAuth token.}

	state=${2:#present|absent}
	ip=${3:# Public IP address of the Floating IP. Used to remove an IP}
	region=${4:# The region that the Floating IP is reserved to.}
	droplet_id=${5:# The Droplet that the Floating IP has been assigned to.}

endsnippet

snippet digital_ocean_floating_ip_info "DigitalOcean Floating IPs information" b
digital_ocean_floating_ip_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_size_info "Gather information about DigitalOcean Droplet sizes" b
digital_ocean_size_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_size_info "Gather information about DigitalOcean Droplet sizes" b
digital_ocean_size_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_region_info "Gather information about DigitalOcean regions" b
digital_ocean_region_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_image_info "Gather information about DigitalOcean images" b
digital_ocean_image_info: >
	image_type=${1:#all|application|distribution|private}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_volume_info "Gather information about DigitalOcean volumes" b
digital_ocean_volume_info: >
	region_name=${1:# Name of region to restrict results to volumes available in a specific region.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_certificate_info "Gather information about DigitalOcean certificates" b
digital_ocean_certificate_info: >
	certificate_id=${1:# Certificate ID that can be used to identify and reference a certificate.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_image_info "Gather information about DigitalOcean images" b
digital_ocean_image_info: >
	image_type=${1:#all|application|distribution|private}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_account_info "Gather information about DigitalOcean User account" b
digital_ocean_account_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_domain_info "Gather information about DigitalOcean Domains" b
digital_ocean_domain_info: >
	domain_name=${1:# Name of the domain to gather information for.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_firewall_info "Gather information about DigitalOcean firewalls" b
digital_ocean_firewall_info: >
	name=${1:# Firewall rule name that can be used to identify and reference a specific firewall rule.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_certificate_info "Gather information about DigitalOcean certificates" b
digital_ocean_certificate_info: >
	certificate_id=${1:# Certificate ID that can be used to identify and reference a certificate.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet digital_ocean_floating_ip_info "DigitalOcean Floating IPs information" b
digital_ocean_floating_ip_info: >
	oauth_token=${1:# DigitalOcean OAuth token.}
	timeout=${2:30}
	validate_certs=${3:yes}

endsnippet

snippet digital_ocean_domain "Create/delete a DNS domain in DigitalOcean" b
digital_ocean_domain: >
	state=${1:#present|absent}
	id=${2:# Numeric, the droplet id you want to operate on.}
	name=${3:# String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key, or the name of a domain.}
	ip=${4:# An 'A' record for '@' ($ORIGIN) will be created with the value 'ip'.  'ip' is an IP version 4 address.}
	oauth_token=${5:# DigitalOcean OAuth token.}
	timeout=${6:30}
	validate_certs=${7:yes}

endsnippet

snippet digital_ocean_tag_info "Gather information about DigitalOcean tags" b
digital_ocean_tag_info: >
	tag_name=${1:# Tag name that can be used to identify and reference a tag.}
	oauth_token=${2:# DigitalOcean OAuth token.}
	timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet cloudscale_server_group "Manages server groups on the cloudscale.ch IaaS service" b
cloudscale_server_group: >
	name=${1:# Name of the server group.}
	uuid=${2:# UUID of the server group.}
	type=${3:anti-affinity}
	state=${4:#present|absent}
	tags=${5:# Tags assosiated with the server groups. Set this to C({}) to clear any tags.}
	api_token=${6:# cloudscale.ch API token.}
	api_timeout=${7:30}

endsnippet

snippet cloudscale_volume "Manages volumes on the cloudscale.ch IaaS service." b
cloudscale_volume: >
	state=${1:#present|absent}
	name=${2:# Name of the volume. Either name or UUID must be present to change an existing volume.}
	uuid=${3:# UUID of the volume. Either name or UUID must be present to change an existing volume.}
	size_gb=${4:# Size of the volume in GB.}
	type=${5:ssd|bulk}
	server_uuids=${6:# UUIDs of the servers this volume is attached to. Set this to C([]) to detach the volume. Currently a volume can only be attached to a single server.}
	tags=${7:# Tags associated with the volume. Set this to C({}) to clear any tags.}
	api_token=${8:# cloudscale.ch API token.}
	api_timeout=${9:30}

endsnippet

snippet cloudscale_server "Manages servers on the cloudscale.ch IaaS service" b
cloudscale_server: >
	state=${1:#running|stopped|absent}
	name=${2:# Name of the Server.}
	uuid=${3:# UUID of the server.}
	flavor=${4:# Flavor of the server.}
	image=${5:# Image used to create the server.}
	volume_size_gb=${6:10}
	bulk_volume_size_gb=${7:# Size of the bulk storage volume in GB.}
	ssh_keys=${8:# List of SSH public keys.}
	password=${9:# Password for the server.}
	use_public_network=${10:yes}
	use_private_network=${11:no}
	use_ipv6=${12:yes}
	anti_affinity_with=${13:# UUID of another server to create an anti-affinity group with.}
	server_groups=${14:# List of UUID or names of server groups.}
	user_data=${15:# Cloud-init configuration (cloud-config) data to use for the server.}
	api_timeout=${16:30}
	force=${17:no}
	tags=${18:# Tags assosiated with the servers. Set this to C({}) to clear any tags.}
	api_token=${19:# cloudscale.ch API token.}

endsnippet

snippet cloudscale_floating_ip "Manages floating IPs on the cloudscale.ch IaaS service" b
cloudscale_floating_ip: >
	state=${1:#present|absent}
	ip=${2:# Floating IP address to change.}
	ip_version=${3:4|6}
	server=${4:# UUID of the server assigned to this floating IP.}
	prefix_length=${5:56}
	reverse_ptr=${6:# Reverse PTR entry for this address.}
	api_token=${7:# cloudscale.ch API token.}
	api_timeout=${8:30}

endsnippet

snippet oneandone_public_ip "Configure 1&1 public IPs." b
oneandone_public_ip: >
	auth_token=${1:# Authenticating API token provided by 1&1.}
	public_ip_id=${2:# The ID of the public IP used with update and delete states.}

	state=${3:#present|absent|update}
	api_url=${4:# Custom API URL. Overrides the ONEANDONE_API_URL environement variable.}
	reverse_dns=${5:# Reverse DNS name. maxLength=256}
	datacenter=${6:# ID of the datacenter where the IP will be created (only for unassigned IPs).}
	type=${7:#IPV4|IPV6}
	wait=${8:yes}
	wait_timeout=${9:600}
	wait_interval=${10:5}

endsnippet

snippet oneandone_monitoring_policy "Configure 1&1 monitoring policy." b
oneandone_monitoring_policy: >
	auth_token=${1:# Authenticating API token provided by 1&1.}
	name=${2:# Monitoring policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
	monitoring_policy=${3:# The identifier (id or name) of the monitoring policy used with update state.}
	agent=${4:# Set true for using agent.}
	email=${5:# User's email. maxLength=128}
	thresholds=${6:# Monitoring policy thresholds. Each of the suboptions have warning and critical, which both have alert and value suboptions. Warning is used to set limits for warning alerts, critical is used to set critical alerts. alert enables alert, and value is used to advise when the value is exceeded.}
	ports=${7:# Array of ports that will be monitoring.}
	processes=${8:# Array of processes that will be monitoring.}

	state=${9:#present|absent|update}
	api_url=${10:# Custom API URL. Overrides the ONEANDONE_API_URL environement variable.}
	description=${11:# Monitoring policy description. maxLength=256}
	add_ports=${12:# Ports to add to the monitoring policy.}
	add_processes=${13:# Processes to add to the monitoring policy.}
	add_servers=${14:# Servers to add to the monitoring policy.}
	remove_ports=${15:# Ports to remove from the monitoring policy.}
	remove_processes=${16:# Processes to remove from the monitoring policy.}
	remove_servers=${17:# Servers to remove from the monitoring policy.}
	update_ports=${18:# Ports to be updated on the monitoring policy.}
	update_processes=${19:# Processes to be updated on the monitoring policy.}
	wait=${20:yes}
	wait_timeout=${21:600}
	wait_interval=${22:5}

endsnippet

snippet oneandone_firewall_policy "Configure 1&1 firewall policy." b
oneandone_firewall_policy: >
	auth_token=${1:# Authenticating API token provided by 1&1.}
	name=${2:# Firewall policy name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
	firewall_policy=${3:# The identifier (id or name) of the firewall policy used with update state.}

	state=${4:#present|absent|update}
	api_url=${5:# Custom API URL. Overrides the ONEANDONE_API_URL environment variable.}
	rules=${6:# A list of rules that will be set for the firewall policy. Each rule must contain protocol parameter, in addition to three optional parameters (port_from, port_to, and source)}
	add_server_ips=${7:# A list of server identifiers (id or name) to be assigned to a firewall policy. Used in combination with update state.}
	remove_server_ips=${8:# A list of server IP ids to be unassigned from a firewall policy. Used in combination with update state.}
	add_rules=${9:# A list of rules that will be added to an existing firewall policy. It is syntax is the same as the one used for rules parameter. Used in combination with update state.}
	remove_rules=${10:# A list of rule ids that will be removed from an existing firewall policy. Used in combination with update state.}
	description=${11:# Firewall policy description. maxLength=256}
	wait=${12:yes}
	wait_timeout=${13:600}
	wait_interval=${14:5}

endsnippet

snippet oneandone_server "Create, destroy, start, stop, and reboot a 1&1 Host server." b
oneandone_server: >
	auth_token=${1:# Authenticating API token provided by 1&1. Overrides the ONEANDONE_AUTH_TOKEN environement variable.}
	fixed_instance_size=${2:S|M|L|XL|XXL|3XL|4XL|5XL}

	state=${3:#present|absent|running|stopped}
	api_url=${4:# Custom API URL. Overrides the ONEANDONE_API_URL environement variable.}
	datacenter=${5:#US|ES|DE|GB}
	hostname=${6:# The hostname or ID of the server. Only used when state is 'present'.}
	description=${7:# The description of the server.}
	appliance=${8:# The operating system name or ID for the server. It is required only for 'present' state.}
	vcore=${9:# The total number of processors. It must be provided with cores_per_processor, ram, and hdds parameters.}
	cores_per_processor=${10:# The number of cores per processor. It must be provided with vcore, ram, and hdds parameters.}
	ram=${11:# The amount of RAM memory. It must be provided with with vcore, cores_per_processor, and hdds parameters.}
	hdds=${12:# A list of hard disks with nested "size" and "is_main" properties. It must be provided with vcore, cores_per_processor, and ram parameters.}
	private_network=${13:# The private network name or ID.}
	firewall_policy=${14:# The firewall policy name or ID.}
	load_balancer=${15:# The load balancer name or ID.}
	monitoring_policy=${16:# The monitoring policy name or ID.}
	server=${17:# Server identifier (ID or hostname). It is required for all states except 'running' and 'present'.}
	count=${18:1}
	ssh_key=${19:# User's public SSH key (contents, not path).}
	server_type=${20:#cloud|baremetal|k8s_node}
	wait=${21:yes}
	wait_timeout=${22:600}
	wait_interval=${23:5}
	auto_increment=${24:yes}

endsnippet

snippet oneandone_private_network "Configure 1&1 private networking." b
oneandone_private_network: >
	auth_token=${1:# Authenticating API token provided by 1&1.}
	private_network=${2:# The identifier (id or name) of the network used with update state.}
	name=${3:# Private network name used with present state. Used as identifier (id or name) when used with absent state.}

	state=${4:#present|absent|update}
	api_url=${5:# Custom API URL. Overrides the ONEANDONE_API_URL environement variable.}
	description=${6:# Set a description for the network.}
	datacenter=${7:# The identifier of the datacenter where the private network will be created}
	network_address=${8:# Set a private network space, i.e. 192.168.1.0}
	subnet_mask=${9:# Set the netmask for the private network, i.e. 255.255.255.0}
	add_members=${10:# List of server identifiers (name or id) to be added to the private network.}
	remove_members=${11:# List of server identifiers (name or id) to be removed from the private network.}
	wait=${12:yes}
	wait_timeout=${13:600}
	wait_interval=${14:5}

endsnippet

snippet oneandone_load_balancer "Configure 1&1 load balancer." b
oneandone_load_balancer: >
	auth_token=${1:# Authenticating API token provided by 1&1.}
	load_balancer=${2:# The identifier (id or name) of the load balancer used with update state.}
	name=${3:# Load balancer name used with present state. Used as identifier (id or name) when used with absent state. maxLength=128}
	health_check_test=${4:NONE|TCP|HTTP|ICMP}
	health_check_interval=${5:# Health check period in seconds. minimum=5, maximum=300, multipleOf=1}
	persistence=${6:# Persistence.}
	persistence_time=${7:# Persistence time in seconds. Required if persistence is enabled. minimum=30, maximum=1200, multipleOf=1}
	method=${8:ROUND_ROBIN|LEAST_CONNECTIONS}
	rules=${9:# A list of rule objects that will be set for the load balancer. Each rule must contain protocol, port_balancer, and port_server parameters, in addition to source parameter, which is optional.}

	state=${10:#present|absent|update}
	api_url=${11:# Custom API URL. Overrides the ONEANDONE_API_URL environement variable.}
	health_check_path=${12:# Url to call for checking. Required for HTTP health check. maxLength=1000}
	health_check_parse=${13:# Regular expression to check. Required for HTTP health check. maxLength=64}
	datacenter=${14:#US|ES|DE|GB}
	description=${15:# Description of the load balancer. maxLength=256}
	add_server_ips=${16:# A list of server identifiers (id or name) to be assigned to a load balancer. Used in combination with update state.}
	remove_server_ips=${17:# A list of server IP ids to be unassigned from a load balancer. Used in combination with update state.}
	add_rules=${18:# A list of rules that will be added to an existing load balancer. It is syntax is the same as the one used for rules parameter. Used in combination with update state.}
	remove_rules=${19:# A list of rule ids that will be removed from an existing load balancer. Used in combination with update state.}
	wait=${20:yes}
	wait_timeout=${21:600}
	wait_interval=${22:5}

endsnippet

snippet lxc_container "Manage LXC Containers" b
lxc_container: >
	name=${1:# Name of a container.}

	backing_store=${2:#dir|lvm|loop|btrfs|overlayfs|zfs}
	template=${3:ubuntu}
	template_options=${4:# Template options when building the container.}
	config=${5:# Path to the LXC configuration file.}
	lv_name=${6:$CONTAINER_NAME}
	vg_name=${7:lxc}
	thinpool=${8:# Use LVM thin pool called TP.}
	fs_type=${9:ext4}
	fs_size=${10:5G}
	directory=${11:# Place rootfs directory under DIR.}
	zfs_root=${12:# Create zfs under given zfsroot.}
	container_command=${13:# Run a command within a container.}
	lxc_path=${14:# Place container under PATH}
	container_log=${15:True|False}
	container_log_level=${16:#INFO|ERROR|DEBUG}
	clone_name=${17:# Name of the new cloned server. This is only used when state is clone.}
	clone_snapshot=${18:True|False}
	archive=${19:True|False}
	archive_path=${20:# Path the save the archived container. If the path does not exist the archive method will attempt to create it.}
	archive_compression=${21:#gzip|bzip2|none}
	state=${22:#started|stopped|restarted|absent|frozen}
	container_config=${23:# list of 'key=value' options to use when configuring a container.}

endsnippet

snippet lxd_container "Manage LXD Containers" b
lxd_container: >
	name=${1:# Name of a container.}

	architecture=${2:# The architecture for the container (e.g. "x86_64" or "i686"). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
	config=${3:# The config for the container (e.g. {"limits.cpu": "2"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
	devices=${4:# The devices for the container (e.g. { "rootfs": { "path": "/dev/kvm", "type": "unix-char" }). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
	ephemeral=${5:# Whether or not the container is ephemeral (e.g. true or false). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1)}
	source=${6:# The source for the container (e.g. { "type": "image", "mode": "pull", "server": "https://images.linuxcontainers.org", "protocol": "lxd", "alias": "ubuntu/xenial/amd64" }).}
	state=${7:#started|stopped|restarted|absent|frozen}
	timeout=${8:30}
	wait_for_ipv4_addresses=${9:no}
	force_stop=${10:no}
	url=${11:unix:/var/lib/lxd/unix.socket}
	snap_url=${12:unix:/var/snap/lxd/common/lxd/unix.socket}
	client_key=${13:"{}/.config/lxc/client.key" .format(os.environ["HOME"])}
	client_cert=${14:"{}/.config/lxc/client.crt" .format(os.environ["HOME"])}
	trust_password=${15:# The client trusted password.}

endsnippet

snippet lxd_profile "Manage LXD profiles" b
lxd_profile: >
	name=${1:# Name of a profile.}

	description=${2:# Description of the profile.}
	config=${3:# The config for the container (e.g. {"limits.memory": "4GB"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)}
	devices=${4:# The devices for the profile (e.g. {"rootfs": {"path": "/dev/kvm", "type": "unix-char"}). See U(https://github.com/lxc/lxd/blob/master/doc/rest-api.md#patch-3)}
	new_name=${5:# A new name of a profile.}
	state=${6:#present|absent}
	url=${7:unix:/var/lib/lxd/unix.socket}
	snap_url=${8:unix:/var/snap/lxd/common/lxd/unix.socket}
	client_key=${9:"{}/.config/lxc/client.key" .format(os.environ["HOME"])}
	client_cert=${10:"{}/.config/lxc/client.crt" .format(os.environ["HOME"])}
	trust_password=${11:# The client trusted password.}

endsnippet

snippet spotinst_aws_elastigroup "Create, update or delete Spotinst AWS Elastigroups" b
spotinst_aws_elastigroup: >
	availability_vs_cost=${1:availabilityOriented|costOriented|balanced}
	availability_zones=${2:# (List of Objects) a list of hash/dictionaries of Availability Zones that are configured in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are name (String), subnet_id (String), placement_group_name (String),}
	image_id=${3:# (String) The image Id used to launch the instance.; In case of conflict between Instance type and image type, an error will be returned}
	key_pair=${4:# (String) Specify a Key Pair to attach to the instances}
	max_size=${5:# (Integer) The upper limit number of instances that you can scale up to}
	min_size=${6:# (Integer) The lower limit number of instances that you can scale down to}
	monitoring=${7:# (Boolean) Describes whether instance Enhanced Monitoring is enabled}
	name=${8:# (String) Unique name for elastigroup to be created, updated or deleted}
	on_demand_instance_type=${9:# (String) On-demand instance type that will be provisioned}
	product=${10:Linux/UNIX|SUSE Linux|Windows|Linux/UNIX (Amazon VPC)|SUSE Linux (Amazon VPC)|Windows}
	security_group_ids=${11:# (List of Strings) One or more security group IDs. ; In case of update it will override the existing Security Group with the new given array}
	spot_instance_types=${12:# (List of Strings) Spot instance type that will be provisioned.}
	target=${13:# (Integer) The number of instances to launch}
	unit=${14:instance|weight}

	credentials_path=${15:# (String) Optional parameter that allows to set a non-default credentials path. Default is ~/.spotinst/credentials}
	account_id=${16:# (String) Optional parameter that allows to set an account-id inside the module configuration By default this is retrieved from the credentials path}
	block_device_mappings=${17:# (List of Objects) a list of hash/dictionaries of Block Device Mappings for elastigroup instances; You can specify virtual devices and EBS volumes.; '[{"key":"value", "key":"value"}]'; keys allowed are device_name (List of Strings), virtual_name (String), no_device (String), ebs (Object, expects the following keys- delete_on_termination(Boolean), encrypted(Boolean), iops (Integer), snapshot_id(Integer), volume_type(String), volume_size(Integer))}
	chef=${18:# (Object) The Chef integration configuration.; Expects the following keys - chef_server (String), organization (String), user (String), pem_key (String), chef_version (String)}
	draining_timeout=${19:# (Integer) Time for instance to be drained from incoming requests and deregistered from ELB before termination.}
	ebs_optimized=${20:# (Boolean) Enable EBS optimization for supported instances which are not enabled by default.; Note - additional charges will be applied.}
	ebs_volume_pool=${21:# (List of Objects) a list of hash/dictionaries of EBS devices to reattach to the elastigroup when available; '[{"key":"value", "key":"value"}]'; keys allowed are - volume_ids (List of Strings), device_name (String)}
	ecs=${22:# (Object) The ECS integration configuration.; Expects the following key - cluster_name (String)}
	elastic_ips=${23:# (List of Strings) List of ElasticIps Allocation Ids (Example C(eipalloc-9d4e16f8)) to associate to the group instances}
	fallback_to_od=${24:# (Boolean) In case of no spots available, Elastigroup will launch an On-demand instance instead}
	health_check_grace_period=${25:300}
	health_check_unhealthy_duration_before_replacement=${26:# (Integer) Minimal mount of time instance should be unhealthy for us to consider it unhealthy.}
	health_check_type=${27:ELB|HCS|TARGET_GROUP|MLB|EC2}
	iam_role_name=${28:# (String) The instance profile iamRole name}
	iam_role_arn=${29:# (String) The instance profile iamRole arn}
	id=${30:# (String) The group id if it already exists and you want to update, or delete it. This will not work unless the uniqueness_by field is set to id. When this is set, and the uniqueness_by field is set, the group will either be updated or deleted, but not created.}
	ignore_changes=${31:image_id|target}
	kubernetes=${32:# (Object) The Kubernetes integration configuration. Expects the following keys - api_server (String), token (String)}
	lifetime_period=${33:# (String) lifetime period}
	load_balancers=${34:# (List of Strings) List of classic ELB names}
	mesosphere=${35:# (Object) The Mesosphere integration configuration. Expects the following key - api_server (String)}
	network_interfaces=${36:# (List of Objects) a list of hash/dictionaries of network interfaces to add to the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - description (String), device_index (Integer), secondary_private_ip_address_count (Integer), associate_public_ip_address (Boolean), delete_on_termination (Boolean), groups (List of Strings), network_interface_id (String), private_ip_address (String), subnet_id (String), associate_ipv6_address (Boolean), private_ip_addresses (List of Objects, Keys are privateIpAddress (String, required) and primary (Boolean))}
	on_demand_count=${37:# (Integer) Required if risk is not set}
	opsworks=${38:# (Object) The elastigroup OpsWorks integration configration.; Expects the following key - layer_id (String)}
	persistence=${39:# (Object) The Stateful elastigroup configration.; Accepts the following keys - should_persist_root_device (Boolean), should_persist_block_devices (Boolean), should_persist_private_ip (Boolean)}
	rancher=${40:# (Object) The Rancher integration configuration.; Expects the following keys - version (String), access_key (String), secret_key (String), master_host (String)}
	right_scale=${41:# (Object) The Rightscale integration configuration.; Expects the following keys - account_id (String), refresh_token (String)}
	risk=${42:# (Integer) required if on demand is not set. The percentage of Spot instances to launch (0 - 100).}
	roll_config=${43:# (Object) Roll configuration.; If you would like the group to roll after updating, please use this feature. Accepts the following keys - batch_size_percentage(Integer, Required), grace_period - (Integer, Required), health_check_type(String, Optional)}
	scheduled_tasks=${44:# (List of Objects) a list of hash/dictionaries of scheduled tasks to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - adjustment (Integer), scale_target_capacity (Integer), scale_min_capacity (Integer), scale_max_capacity (Integer), adjustment_percentage (Integer), batch_size_percentage (Integer), cron_expression (String), frequency (String), grace_period (Integer), task_type (String, required), is_enabled (Boolean)}
	shutdown_script=${45:# (String) The Base64-encoded shutdown script that executes prior to instance termination. Encode before setting.}
	signals=${46:# (List of Objects) a list of hash/dictionaries of signals to configure in the elastigroup; keys allowed are - name (String, required), timeout (Integer)}
	spin_up_time=${47:# (Integer) spin up time, in seconds, for the instance}
	state=${48:present|absent}
	tags=${49:# (List of tagKey:tagValue paris) a list of tags to configure in the elastigroup. Please specify list of keys and values (key colon value);}
	target_group_arns=${50:# (List of Strings) List of target group arns instances should be registered to}
	tenancy=${51:default|dedicated}
	terminate_at_end_of_billing_hour=${52:# (Boolean) terminate at the end of billing hour}
	up_scaling_policies=${53:# (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions (List of Objects, Keys allowed are name (String, required) and value (String)), statistic (String, required) evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), min_target_capacity (String), target (String), maximum (String), minimum (String)}
	down_scaling_policies=${54:# (List of Objects) a list of hash/dictionaries of scaling policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), metric_name (String, required), dimensions ((List of Objects), Keys allowed are name (String, required) and value (String)), statistic (String, required), evaluation_periods (String, required), period (String, required), threshold (String, required), cooldown (String, required), unit (String, required), operator (String, required), action_type (String, required), adjustment (String), max_target_capacity (String), target (String), maximum (String), minimum (String)}
	target_tracking_policies=${55:# (List of Objects) a list of hash/dictionaries of target tracking policies to configure in the elastigroup; '[{"key":"value", "key":"value"}]'; keys allowed are - policy_name (String, required), namespace (String, required), source (String, required), metric_name (String, required), statistic (String, required), unit (String, required), cooldown (String, required), target (String, required)}
	uniqueness_by=${56:id|name}
	user_data=${57:# (String) Base64-encoded MIME user data. Encode before setting the value.}
	utilize_reserved_instances=${58:# (Boolean) In case of any available Reserved Instances, Elastigroup will utilize your reservations before purchasing Spot instances.}
	wait_for_instances=${59:# (Boolean) Whether or not the elastigroup creation / update actions should wait for the instances to spin}
	wait_timeout=${60:# (Integer) How long the module should wait for instances before failing the action.; Only works if wait_for_instances is True.}

endsnippet

snippet imgadm "Manage SmartOS images" b
imgadm: >
	state=${1:present|absent|deleted|imported|updated|vacuumed}

	force=${2:# Force a given operation (where supported by imgadm(1M)).}
	pool=${3:zones}
	source=${4:# URI for the image source.}
	type=${5:#imgapi|docker|dsapi}
	uuid=${6:# Image UUID. Can either be a full UUID or C(*) for all images.}

endsnippet

snippet nictagadm "Manage nic tags on SmartOS systems" b
nictagadm: >
	name=${1:# Name of the nic tag.}

	mac=${2:# Specifies the I(mac) address to attach the nic tag to when not creating an I(etherstub).}
	etherstub=${3:no}
	mtu=${4:# Specifies the size of the I(mtu) of the desired nic tag.}
	force=${5:no}
	state=${6:absent|#present}

endsnippet

snippet smartos_image_info "Get SmartOS image details." b
smartos_image_info: >
	filters=${1:# Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More information can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.}

endsnippet

snippet smartos_image_info "Get SmartOS image details." b
smartos_image_info: >
	filters=${1:# Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More information can be found at U(https://smartos.org/man/1m/imgadm) under 'imgadm list'.}

endsnippet

snippet vmadm "Manage SmartOS virtual machines and zones." b
vmadm: >
	brand=${1:#joyent|joyent-minimal|kvm|lx}
	state=${2:present|absent|stopped|restarted}

	archive_on_delete=${3:# When enabled, the zone dataset will be mounted on C(/zones/archive) upon removal.}
	autoboot=${4:# Whether or not a VM is booted when the system is rebooted.}
	boot=${5:# Set the boot order for KVM VMs.}
	cpu_cap=${6:# Sets a limit on the amount of CPU time that can be used by a VM. Use C(0) for no cap.}
	cpu_shares=${7:# Sets a limit on the number of fair share scheduler (FSS) CPU shares for a VM. This limit is relative to all other VMs on the system.}
	cpu_type=${8:#qemu64|host}
	customer_metadata=${9:# Metadata to be set and associated with this VM, this contain customer modifiable keys.}
	delegate_dataset=${10:# Whether to delegate a ZFS dataset to an OS VM.}
	disk_driver=${11:# Default value for a virtual disk model for KVM guests.}
	disks=${12:# A list of disks to add, valid properties are documented in vmadm(1M).}
	dns_domain=${13:# Domain value for C(/etc/hosts).}
	docker=${14:# Docker images need this flag enabled along with the I(brand) set to C(lx).}
	filesystems=${15:# Mount additional filesystems into an OS VM.}
	firewall_enabled=${16:# Enables the firewall, allowing fwadm(1M) rules to be applied.}
	force=${17:# Force a particular action (i.e. stop or delete a VM).}
	fs_allowed=${18:# Comma separated list of filesystem types this zone is allowed to mount.}
	hostname=${19:# Zone/VM hostname.}
	image_uuid=${20:# Image UUID.}
	indestructible_delegated=${21:# Adds an C(@indestructible) snapshot to delegated datasets.}
	indestructible_zoneroot=${22:# Adds an C(@indestructible) snapshot to zoneroot.}
	internal_metadata=${23:# Metadata to be set and associated with this VM, this contains operator generated keys.}
	internal_metadata_namespace=${24:# List of namespaces to be set as I(internal_metadata-only); these namespaces will come from I(internal_metadata) rather than I(customer_metadata).}
	kernel_version=${25:# Kernel version to emulate for LX VMs.}
	limit_priv=${26:# Set (comma separated) list of privileges the zone is allowed to use.}
	maintain_resolvers=${27:# Resolvers in C(/etc/resolv.conf) will be updated when updating the I(resolvers) property.}
	max_locked_memory=${28:# Total amount of memory (in MiBs) on the host that can be locked by this VM.}
	max_lwps=${29:# Maximum number of lightweight processes this VM is allowed to have running.}
	max_physical_memory=${30:# Maximum amount of memory (in MiBs) on the host that the VM is allowed to use.}
	max_swap=${31:# Maximum amount of virtual memory (in MiBs) the VM is allowed to use.}
	mdata_exec_timeout=${32:# Timeout in seconds (or 0 to disable) for the C(svc:/smartdc/mdata:execute) service that runs user-scripts in the zone.}
	name=${33:# Name of the VM. vmadm(1M) uses this as an optional name.}
	nic_driver=${34:# Default value for a virtual NIC model for KVM guests.}
	nics=${35:# A list of nics to add, valid properties are documented in vmadm(1M).}
	nowait=${36:# Consider the provisioning complete when the VM first starts, rather than when the VM has rebooted.}
	qemu_opts=${37:# Additional qemu arguments for KVM guests. This overwrites the default arguments provided by vmadm(1M) and should only be used for debugging.}
	qemu_extra_opts=${38:# Additional qemu cmdline arguments for KVM guests.}
	quota=${39:# Quota on zone filesystems (in MiBs).}
	ram=${40:# Amount of virtual RAM for a KVM guest (in MiBs).}
	resolvers=${41:# List of resolvers to be put into C(/etc/resolv.conf).}
	routes=${42:# Dictionary that maps destinations to gateways, these will be set as static routes in the VM.}
	spice_opts=${43:# Addition options for SPICE-enabled KVM VMs.}
	spice_password=${44:# Password required to connect to SPICE. By default no password is set. Please note this can be read from the Global Zone.}
	tmpfs=${45:# Amount of memory (in MiBs) that will be available in the VM for the C(/tmp) filesystem.}
	uuid=${46:# UUID of the VM. Can either be a full UUID or C(*) for all VMs.}
	vcpus=${47:# Number of virtual CPUs for a KVM guest.}
	vga=${48:# Specify VGA emulation used by KVM VMs.}
	virtio_txburst=${49:# Number of packets that can be sent in a single flush of the tx queue of virtio NICs.}
	virtio_txtimer=${50:# Timeout (in nanoseconds) for the TX timer of virtio NICs.}
	vnc_password=${51:# Password required to connect to VNC. By default no password is set. Please note this can be read from the Global Zone.}
	vnc_port=${52:# TCP port to listen of the VNC server. Or set C(0) for random, or C(-1) to disable.}
	zfs_data_compression=${53:# Specifies compression algorithm used for this VMs data dataset. This option only has effect on delegated datasets.}
	zfs_data_recsize=${54:# Suggested block size (power of 2) for files in the delegated dataset's filesystem.}
	zfs_filesystem_limit=${55:# Maximum number of filesystems the VM can have.}
	zfs_io_priority=${56:# IO throttle priority value relative to other VMs.}
	zfs_root_compression=${57:# Specifies compression algorithm used for this VMs root dataset. This option only has effect on the zoneroot dataset.}
	zfs_root_recsize=${58:# Suggested block size (power of 2) for files in the zoneroot dataset's filesystem.}
	zfs_snapshot_limit=${59:# Number of snapshots the VM can have.}
	zpool=${60:# ZFS pool the VM's zone dataset will be created in.}

endsnippet

snippet kubevirt_preset "Manage KubeVirt virtual machine presets" b
kubevirt_preset: >
	name=${1:# Name of the virtual machine preset.}
	namespace=${2:# Namespace where the virtual machine preset exists.}

	state=${3:#present|absent}
	selector=${4:# Selector is a label query over a set of virtual machine preset.}
	host=${5:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${6:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${7:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${8:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${9:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${10:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${11:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${12:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${13:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${14:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${15:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}
	disks=${16:# List of dictionaries which specify disks of the virtual machine.}
	labels=${17:# Labels are key/value pairs that are attached to virtual machines. Labels are intended to be used to specify identifying attributes of virtual machines that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of virtual machines. Labels can be attached to virtual machines at creation time and subsequently added and modified at any time.}
	interfaces=${18:# An interface defines a virtual network interface of a virtual machine (also called a frontend).}
	cloud_init_nocloud=${19:# Represents a cloud-init NoCloud user-data source. The NoCloud data will be added as a disk to the virtual machine. A proper cloud-init installation is required inside the guest. More information U(https://kubevirt.io/api-reference/master/definitions.html#_v1_cloudinitnocloudsource)}
	affinity=${20:# Describes node affinity scheduling rules for the vm.}
	node_affinity=${21:# Describes vm affinity scheduling rules e.g. co-locate this vm in the same node, zone, etc. as some other vms}
	anti_affinity=${22:# Describes vm anti-affinity scheduling rules e.g. avoid putting this vm in the same node, zone, etc. as some other vms.}
	resource_definition=${23:# A partial YAML definition of the object being created/updated. Here you can define Kubernetes resource parameters not covered by this module's parameters.}
	wait=${24:yes}
	force=${25:no}
	wait_timeout=${26:120}
	wait_sleep=${27:5}
	memory=${28:# The amount of memory to be requested by virtual machine.}
	memory_limit=${29:# The maximum memory to be used by virtual machine.}
	machine_type=${30:# QEMU machine type is the actual chipset of the virtual machine.}
	merge_type=${31:json|merge|strategic-merge}
	cpu_shares=${32:# Specify CPU shares.}
	cpu_limit=${33:# Is converted to its millicore value and multiplied by 100. The resulting value is the total amount of CPU time that a container can use every 100ms. A virtual machine cannot use more than its share of CPU time during this interval.}
	cpu_cores=${34:# Number of CPU cores.}
	cpu_model=${35:# CPU model.}
	bootloader=${36:# Specify the bootloader of the virtual machine.}
	smbios_uuid=${37:# In order to provide a consistent view on the virtualized hardware for the guest OS, the SMBIOS UUID can be set.}
	cpu_features=${38:# List of dictionary to fine-tune features provided by the selected CPU model.}
	headless=${39:# Specify if the virtual machine should have attached a  minimal Video and Graphics device configuration.}
	hugepage_size=${40:# Specify huge page size.}
	tablets=${41:# Specify tablets to be used as input devices}
	hostname=${42:# Specifies the hostname of the virtual machine. The hostname will be set either by dhcp, cloud-init if configured or virtual machine name will be used.}
	subdomain=${43:# If specified, the fully qualified virtual machine hostname will be hostname.subdomain.namespace.svc.cluster_domain. If not specified, the virtual machine will not have a domain name at all. The DNS entry will resolve to the virtual machine, no matter if the virtual machine itself can pick up a hostname.}

endsnippet

snippet kubevirt_vm "Manage KubeVirt virtual machine" b
kubevirt_vm: >
	name=${1:# Name of the virtual machine.}
	namespace=${2:# Namespace where the virtual machine exists.}

	state=${3:#present|absent|running|stopped}
	ephemeral=${4:no}
	datavolumes=${5:# DataVolumes are a way to automate importing virtual machine disks onto pvcs during the virtual machine's launch flow. Without using a DataVolume, users have to prepare a pvc with a disk image before assigning it to a VM or VMI manifest. With a DataVolume, both the pvc creation and import is automated on behalf of the user.}
	template=${6:# Name of Template to be used in creation of a virtual machine.}
	template_parameters=${7:# New values of parameters from Template.}
	host=${8:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${9:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${10:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${11:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${12:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${13:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${14:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${15:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${16:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${17:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${18:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}
	disks=${19:# List of dictionaries which specify disks of the virtual machine.}
	labels=${20:# Labels are key/value pairs that are attached to virtual machines. Labels are intended to be used to specify identifying attributes of virtual machines that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of virtual machines. Labels can be attached to virtual machines at creation time and subsequently added and modified at any time.}
	interfaces=${21:# An interface defines a virtual network interface of a virtual machine (also called a frontend).}
	cloud_init_nocloud=${22:# Represents a cloud-init NoCloud user-data source. The NoCloud data will be added as a disk to the virtual machine. A proper cloud-init installation is required inside the guest. More information U(https://kubevirt.io/api-reference/master/definitions.html#_v1_cloudinitnocloudsource)}
	affinity=${23:# Describes node affinity scheduling rules for the vm.}
	node_affinity=${24:# Describes vm affinity scheduling rules e.g. co-locate this vm in the same node, zone, etc. as some other vms}
	anti_affinity=${25:# Describes vm anti-affinity scheduling rules e.g. avoid putting this vm in the same node, zone, etc. as some other vms.}
	resource_definition=${26:# A partial YAML definition of the object being created/updated. Here you can define Kubernetes resource parameters not covered by this module's parameters.}
	wait=${27:yes}
	force=${28:no}
	wait_timeout=${29:120}
	wait_sleep=${30:5}
	memory=${31:# The amount of memory to be requested by virtual machine.}
	memory_limit=${32:# The maximum memory to be used by virtual machine.}
	machine_type=${33:# QEMU machine type is the actual chipset of the virtual machine.}
	merge_type=${34:json|merge|strategic-merge}
	cpu_shares=${35:# Specify CPU shares.}
	cpu_limit=${36:# Is converted to its millicore value and multiplied by 100. The resulting value is the total amount of CPU time that a container can use every 100ms. A virtual machine cannot use more than its share of CPU time during this interval.}
	cpu_cores=${37:# Number of CPU cores.}
	cpu_model=${38:# CPU model.}
	bootloader=${39:# Specify the bootloader of the virtual machine.}
	smbios_uuid=${40:# In order to provide a consistent view on the virtualized hardware for the guest OS, the SMBIOS UUID can be set.}
	cpu_features=${41:# List of dictionary to fine-tune features provided by the selected CPU model.}
	headless=${42:# Specify if the virtual machine should have attached a  minimal Video and Graphics device configuration.}
	hugepage_size=${43:# Specify huge page size.}
	tablets=${44:# Specify tablets to be used as input devices}
	hostname=${45:# Specifies the hostname of the virtual machine. The hostname will be set either by dhcp, cloud-init if configured or virtual machine name will be used.}
	subdomain=${46:# If specified, the fully qualified virtual machine hostname will be hostname.subdomain.namespace.svc.cluster_domain. If not specified, the virtual machine will not have a domain name at all. The DNS entry will resolve to the virtual machine, no matter if the virtual machine itself can pick up a hostname.}

endsnippet

snippet kubevirt_template "Manage KubeVirt templates" b
kubevirt_template: >
	name=${1:# Name of the Template object.}
	namespace=${2:# Namespace where the Template object exists.}

	objects=${3:# List of any valid API objects, such as a I(DeploymentConfig), I(Service), etc. The object will be created exactly as defined here, with any parameter values substituted in prior to creation. The definition of these objects can reference parameters defined earlier.}
	merge_type=${4:json|merge|strategic-merge}
	display_name=${5:# A brief, user-friendly name, which can be employed by user interfaces.}
	description=${6:# A description of the template.}
	long_description=${7:# Additional template description. This may be displayed by the service catalog, for example.}
	provider_display_name=${8:# The name of the person or organization providing the template.}
	documentation_url=${9:# A URL referencing further documentation for the template.}
	support_url=${10:# A URL where support can be obtained for the template.}
	editable=${11:# Extension for hinting at which elements should be considered editable. List of jsonpath selectors. The jsonpath root is the objects: element of the template.}
	default_disk=${12:# The goal of default disk is to define what kind of disk is supported by the OS mainly in terms of bus (ide, scsi, sata, virtio, ...)}
	default_volume=${13:# The goal of default volume is to be able to configure mostly performance parameters like caches if those are exposed by the underlying volume implementation.}
	default_nic=${14:# The goal of default network is similar to I(default_disk) and should be used as a template to ensure OS compatibility and performance.}
	default_network=${15:# The goal of default network is similar to I(default_volume) and should be used as a template that specifies performance and connection parameters (L2 bridge for example)}
	icon_class=${16:# An icon to be displayed with your template in the web console. Choose from our existing logo icons when possible. You can also use icons from FontAwesome. Alternatively, provide icons through CSS customizations that can be added to an OpenShift Container Platform cluster that uses your template. You must specify an icon class that exists, or it will prevent falling back to the generic icon.}
	parameters=${17:# Parameters allow a value to be supplied by the user or generated when the template is instantiated. Then, that value is substituted wherever the parameter is referenced. References can be defined in any field in the objects list field. This is useful for generating random passwords or allowing the user to supply a host name or other user-specific value that is required to customize the template.}
	version=${18:# Template structure version.}
	host=${19:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${20:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${21:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${22:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${23:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${24:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${25:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${26:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${27:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${28:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${29:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}
	state=${30:absent|#present}
	force=${31:no}

endsnippet

snippet kubevirt_pvc "Manage PVCs on Kubernetes" b
kubevirt_pvc: >
	name=${1:# Use to specify a PVC object name.}
	namespace=${2:# Use to specify a PVC object namespace.}

	resource_definition=${3:# A partial YAML definition of the PVC object being created/updated. Here you can define Kubernetes PVC Resource parameters not covered by this module's parameters.}
	state=${4:#present|absent}
	force=${5:no}
	merge_type=${6:json|merge|strategic-merge}
	annotations=${7:# Annotations attached to this object.}
	labels=${8:# Labels attached to this object.}
	selector=${9:# A label query over volumes to consider for binding.}
	access_modes=${10:# Contains the desired access modes the volume should have.}
	size=${11:# How much storage to allocate to the PVC.}
	storage_class_name=${12:# Name of the StorageClass required by the claim.}
	volume_mode=${13:# This defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is an alpha feature of kubernetes and may change in the future.}
	volume_name=${14:# This is the binding reference to the PersistentVolume backing this claim.}
	cdi_source=${15:# If data is to be copied onto the PVC using the Containerized Data Importer you can specify the source of the data (along with any additional configuration) as well as it's format.}
	wait=${16:no}
	wait_timeout=${17:300}
	host=${18:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${19:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${20:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${21:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${22:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${23:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${24:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${25:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${26:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${27:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${28:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet kubevirt_rs "Manage KubeVirt virtual machine replica sets" b
kubevirt_rs: >
	name=${1:# Name of the virtual machine replica set.}
	namespace=${2:# Namespace where the virtual machine replica set exists.}
	selector=${3:# Selector is a label query over a set of virtual machine.}

	state=${4:#present|absent}
	replicas=${5:# Number of desired pods. This is a pointer to distinguish between explicit zero and not specified.}
	host=${6:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${7:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${8:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${9:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${10:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${11:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${12:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${13:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${14:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${15:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${16:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}
	disks=${17:# List of dictionaries which specify disks of the virtual machine.}
	labels=${18:# Labels are key/value pairs that are attached to virtual machines. Labels are intended to be used to specify identifying attributes of virtual machines that are meaningful and relevant to users, but do not directly imply semantics to the core system. Labels can be used to organize and to select subsets of virtual machines. Labels can be attached to virtual machines at creation time and subsequently added and modified at any time.}
	interfaces=${19:# An interface defines a virtual network interface of a virtual machine (also called a frontend).}
	cloud_init_nocloud=${20:# Represents a cloud-init NoCloud user-data source. The NoCloud data will be added as a disk to the virtual machine. A proper cloud-init installation is required inside the guest. More information U(https://kubevirt.io/api-reference/master/definitions.html#_v1_cloudinitnocloudsource)}
	affinity=${21:# Describes node affinity scheduling rules for the vm.}
	node_affinity=${22:# Describes vm affinity scheduling rules e.g. co-locate this vm in the same node, zone, etc. as some other vms}
	anti_affinity=${23:# Describes vm anti-affinity scheduling rules e.g. avoid putting this vm in the same node, zone, etc. as some other vms.}
	resource_definition=${24:# A partial YAML definition of the object being created/updated. Here you can define Kubernetes resource parameters not covered by this module's parameters.}
	wait=${25:yes}
	force=${26:no}
	wait_timeout=${27:120}
	wait_sleep=${28:5}
	memory=${29:# The amount of memory to be requested by virtual machine.}
	memory_limit=${30:# The maximum memory to be used by virtual machine.}
	machine_type=${31:# QEMU machine type is the actual chipset of the virtual machine.}
	merge_type=${32:json|merge|strategic-merge}
	cpu_shares=${33:# Specify CPU shares.}
	cpu_limit=${34:# Is converted to its millicore value and multiplied by 100. The resulting value is the total amount of CPU time that a container can use every 100ms. A virtual machine cannot use more than its share of CPU time during this interval.}
	cpu_cores=${35:# Number of CPU cores.}
	cpu_model=${36:# CPU model.}
	bootloader=${37:# Specify the bootloader of the virtual machine.}
	smbios_uuid=${38:# In order to provide a consistent view on the virtualized hardware for the guest OS, the SMBIOS UUID can be set.}
	cpu_features=${39:# List of dictionary to fine-tune features provided by the selected CPU model.}
	headless=${40:# Specify if the virtual machine should have attached a  minimal Video and Graphics device configuration.}
	hugepage_size=${41:# Specify huge page size.}
	tablets=${42:# Specify tablets to be used as input devices}
	hostname=${43:# Specifies the hostname of the virtual machine. The hostname will be set either by dhcp, cloud-init if configured or virtual machine name will be used.}
	subdomain=${44:# If specified, the fully qualified virtual machine hostname will be hostname.subdomain.namespace.svc.cluster_domain. If not specified, the virtual machine will not have a domain name at all. The DNS entry will resolve to the virtual machine, no matter if the virtual machine itself can pick up a hostname.}

endsnippet

snippet kubevirt_cdi_upload "Upload local VM images to CDI Upload Proxy." b
kubevirt_cdi_upload: >
	pvc_name=${1:# Use to specify the name of the target PersistentVolumeClaim.}
	pvc_namespace=${2:# Use to specify the namespace of the target PersistentVolumeClaim.}

	upload_host=${3:# URL containing the host and port on which the CDI Upload Proxy is available.}
	upload_host_validate_certs=${4:yes}
	path=${5:# Path of local image file to transfer.}
	merge_type=${6:json|merge|strategic-merge}
	host=${7:# Provide a URL for accessing the API. Can also be specified via K8S_AUTH_HOST environment variable.}
	api_key=${8:# Token used to authenticate with the API. Can also be specified via K8S_AUTH_API_KEY environment variable.}
	kubeconfig=${9:# Path to an existing Kubernetes config file. If not provided, and no other connection options are provided, the openshift client will attempt to load the default configuration file from I(~/.kube/config.json). Can also be specified via K8S_AUTH_KUBECONFIG environment variable.}
	context=${10:# The name of a context found in the config file. Can also be specified via K8S_AUTH_CONTEXT environment variable.}
	username=${11:# Provide a username for authenticating with the API. Can also be specified via K8S_AUTH_USERNAME environment variable.}
	password=${12:# Provide a password for authenticating with the API. Can also be specified via K8S_AUTH_PASSWORD environment variable.}
	client_cert=${13:# Path to a certificate used to authenticate with the API. Can also be specified via K8S_AUTH_CERT_FILE environment variable.}
	client_key=${14:# Path to a key file used to authenticate with the API. Can also be specified via K8S_AUTH_KEY_FILE environment variable.}
	ca_cert=${15:# Path to a CA certificate used to authenticate with the API. The full certificate chain must be provided to avoid certificate validation errors. Can also be specified via K8S_AUTH_SSL_CA_CERT environment variable.}
	validate_certs=${16:# Whether or not to verify the API server's SSL certificates. Can also be specified via K8S_AUTH_VERIFY_SSL environment variable.}
	proxy=${17:# The URL of an HTTP proxy to use for the connection. Can also be specified via K8S_AUTH_PROXY environment variable.}

endsnippet

snippet scaleway_compute "Scaleway compute management module" b
scaleway_compute: >
	image=${1:# Image identifier used to start the instance with}
	organization=${2:# Organization identifier}
	region=${3:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}
	commercial_type=${4:# Commercial name of the compute node}

	public_ip=${5:absent}
	enable_ipv6=${6:no}
	name=${7:# Name of the instance}
	state=${8:#present|absent|running|restarted|stopped}
	tags=${9:[]}
	wait=${10:no}
	wait_timeout=${11:300}
	wait_sleep_time=${12:3}
	security_group=${13:# Security group unique identifier}
	api_token=${14:# Scaleway OAuth token.}
	api_url=${15:https://api.scaleway.com}
	api_timeout=${16:30}
	query_parameters=${17:{}}
	validate_certs=${18:yes}

endsnippet

snippet scaleway_volume "Scaleway volumes management module" b
scaleway_volume: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}
	name=${2:# Name used to identify the volume.}

	state=${3:#present|absent}
	organization=${4:# ScaleWay organization ID to which volume belongs.}
	size=${5:# Size of the volume in bytes.}
	volume_type=${6:# Type of the volume (for example 'l_ssd').}
	api_token=${7:# Scaleway OAuth token.}
	api_url=${8:https://api.scaleway.com}
	api_timeout=${9:30}
	query_parameters=${10:{}}
	validate_certs=${11:yes}

endsnippet

snippet scaleway_sshkey "Scaleway SSH keys management module" b
scaleway_sshkey: >
	ssh_pub_key=${1:# The public SSH key as a string to add.}

	state=${2:#present|absent}
	api_url=${3:https://account.scaleway.com}
	api_token=${4:# Scaleway OAuth token.}
	api_timeout=${5:30}
	query_parameters=${6:{}}
	validate_certs=${7:yes}

endsnippet

snippet scaleway_organization_info "Gather information about the Scaleway organizations available." b
scaleway_organization_info: >
	api_url=${1:https://account.scaleway.com}
	api_token=${2:# Scaleway OAuth token.}
	api_timeout=${3:30}
	query_parameters=${4:{}}
	validate_certs=${5:yes}

endsnippet

snippet scaleway_server_info "Gather information about the Scaleway servers available." b
scaleway_server_info: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	api_token=${2:# Scaleway OAuth token.}
	api_url=${3:https://api.scaleway.com}
	api_timeout=${4:30}
	query_parameters=${5:{}}
	validate_certs=${6:yes}

endsnippet

snippet scaleway_image_info "Gather information about the Scaleway images available." b
scaleway_image_info: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	api_token=${2:# Scaleway OAuth token.}
	api_url=${3:https://api.scaleway.com}
	api_timeout=${4:30}
	query_parameters=${5:{}}
	validate_certs=${6:yes}

endsnippet

snippet scaleway_ip "Scaleway IP management module" b
scaleway_ip: >
	organization=${1:# Scaleway organization identifier}
	region=${2:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	state=${3:#present|absent}
	id=${4:# id of the Scaleway IP (UUID)}
	server=${5:# id of the server you want to attach an IP to.}
	reverse=${6:# Reverse to assign to the IP}
	api_token=${7:# Scaleway OAuth token.}
	api_url=${8:https://api.scaleway.com}
	api_timeout=${9:30}
	query_parameters=${10:{}}
	validate_certs=${11:yes}

endsnippet

snippet scaleway_security_group "Scaleway Security Group management module" b
scaleway_security_group: >
	organization=${1:# Organization identifier.}
	region=${2:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}
	name=${3:# Name of the Security Group.}
	stateful=${4:# Create a stateful security group which allows established connections in and out.}

	state=${5:absent|#present}
	description=${6:# Description of the Security Group.}
	inbound_default_policy=${7:accept|drop}
	outbound_default_policy=${8:accept|drop}
	organization_default=${9:# Create security group to be the default one.}
	api_token=${10:# Scaleway OAuth token.}
	api_url=${11:https://api.scaleway.com}
	api_timeout=${12:30}
	query_parameters=${13:{}}
	validate_certs=${14:yes}

endsnippet

snippet scaleway_security_group_info "Gather information about the Scaleway security groups available." b
scaleway_security_group_info: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	api_token=${2:# Scaleway OAuth token.}
	api_url=${3:https://api.scaleway.com}
	api_timeout=${4:30}
	query_parameters=${5:{}}
	validate_certs=${6:yes}

endsnippet

snippet scaleway_user_data "Scaleway user_data management module" b
scaleway_user_data: >
	server_id=${1:# Scaleway Compute instance ID of the server}
	region=${2:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	user_data=${3:# User defined data. Typically used with `cloud-init`.}
	api_token=${4:# Scaleway OAuth token.}
	api_url=${5:https://api.scaleway.com}
	api_timeout=${6:30}
	query_parameters=${7:{}}
	validate_certs=${8:yes}

endsnippet

snippet scaleway_volume_info "Gather information about the Scaleway volumes available." b
scaleway_volume_info: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	api_token=${2:# Scaleway OAuth token.}
	api_url=${3:https://api.scaleway.com}
	api_timeout=${4:30}
	query_parameters=${5:{}}
	validate_certs=${6:yes}

endsnippet

snippet scaleway_ip_info "Gather information about the Scaleway ips available." b
scaleway_ip_info: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	api_token=${2:# Scaleway OAuth token.}
	api_url=${3:https://api.scaleway.com}
	api_timeout=${4:30}
	query_parameters=${5:{}}
	validate_certs=${6:yes}

endsnippet

snippet scaleway_security_group_rule "Scaleway Security Group Rule management module" b
scaleway_security_group_rule: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}
	protocol=${2:TCP|UDP|ICMP}
	port=${3:# Port related to the rule, null value for all the ports}
	direction=${4:inbound|outbound}
	action=${5:accept|drop}
	security_group=${6:# Security Group unique identifier}

	state=${7:#present|absent}
	ip_range=${8:0.0.0.0/0}
	api_token=${9:# Scaleway OAuth token.}
	api_url=${10:https://api.scaleway.com}
	api_timeout=${11:30}
	query_parameters=${12:{}}
	validate_certs=${13:yes}

endsnippet

snippet scaleway_snapshot_info "Gather information about the Scaleway snapshots available." b
scaleway_snapshot_info: >
	region=${1:ams1|EMEA-NL-EVS|par1|EMEA-FR-PAR1}

	api_token=${2:# Scaleway OAuth token.}
	api_url=${3:https://api.scaleway.com}
	api_timeout=${4:30}
	query_parameters=${5:{}}
	validate_certs=${6:yes}

endsnippet

snippet scaleway_lb "Scaleway load-balancer management module" b
scaleway_lb: >
	name=${1:# Name of the load-balancer}
	description=${2:# Description of the load-balancer}
	organization_id=${3:# Organization identifier}
	region=${4:nl-ams|fr-par}

	state=${5:#present|absent}
	tags=${6:# List of tags to apply to the load-balancer}
	wait=${7:no}
	wait_timeout=${8:300}
	wait_sleep_time=${9:3}
	api_token=${10:# Scaleway OAuth token.}
	api_url=${11:https://api.scaleway.com}
	api_timeout=${12:30}
	query_parameters=${13:{}}
	validate_certs=${14:yes}

endsnippet

snippet vultr_firewall_rule "Manages firewall rules on Vultr." b
vultr_firewall_rule: >
	group=${1:# Name of the firewall group.}

	ip_version=${2:#v4|v6}
	protocol=${3:icmp|#tcp|udp|gre}
	cidr=${4:# Network in CIDR format}
	start_port=${5:# Start port for the firewall rule.}
	end_port=${6:# End port for the firewall rule.}
	state=${7:#present|absent}
	api_key=${8:# API key of the Vultr API.}
	api_timeout=${9:# HTTP timeout to Vultr API.}
	api_retries=${10:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${11:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${12:default}
	api_endpoint=${13:# URL to API endpint (without trailing slash).}
	validate_certs=${14:yes}

endsnippet

snippet vultr_dns_domain "Manages DNS domains on Vultr." b
vultr_dns_domain: >
	name=${1:# The domain name.}

	server_ip=${2:# The default server IP.}
	state=${3:#present|absent}
	api_key=${4:# API key of the Vultr API.}
	api_timeout=${5:# HTTP timeout to Vultr API.}
	api_retries=${6:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${7:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${8:default}
	api_endpoint=${9:# URL to API endpint (without trailing slash).}
	validate_certs=${10:yes}

endsnippet

snippet vultr_user "Manages users on Vultr." b
vultr_user: >
	name=${1:# Name of the user}

	email=${2:# Email of the user.}
	password=${3:# Password of the user.}
	force=${4:no}
	api_enabled=${5:yes}
	acls=${6:manage_users|subscriptions|provisioning|billing|support|abuse|dns|upgrade}
	state=${7:#present|absent}
	api_key=${8:# API key of the Vultr API.}
	api_timeout=${9:# HTTP timeout to Vultr API.}
	api_retries=${10:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${11:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${12:default}
	api_endpoint=${13:# URL to API endpint (without trailing slash).}
	validate_certs=${14:yes}

endsnippet

snippet vultr_block_storage_info "Get information about the Vultr block storage volumes available." b
vultr_block_storage_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_network "Manages networks on Vultr." b
vultr_network: >
	name=${1:# Name of the network.}

	cidr=${2:# The CIDR IPv4 network block to be used when attaching servers to this network. Required if I(state=present).}
	region=${3:# Region the network is deployed into. Required if I(state=present).}
	state=${4:#present|absent}
	api_key=${5:# API key of the Vultr API.}
	api_timeout=${6:# HTTP timeout to Vultr API.}
	api_retries=${7:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${8:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${9:default}
	api_endpoint=${10:# URL to API endpint (without trailing slash).}
	validate_certs=${11:yes}

endsnippet

snippet vultr_user_info "Get information about the Vultr user available." b
vultr_user_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_startup_script "Manages startup scripts on Vultr." b
vultr_startup_script: >
	name=${1:# The script name.}

	script_type=${2:#boot|pxe}
	script=${3:# The script source code.}
	state=${4:#present|absent}
	api_key=${5:# API key of the Vultr API.}
	api_timeout=${6:# HTTP timeout to Vultr API.}
	api_retries=${7:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${8:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${9:default}
	api_endpoint=${10:# URL to API endpint (without trailing slash).}
	validate_certs=${11:yes}

endsnippet

snippet vultr_dns_domain_info "Gather information about the Vultr DNS domains available." b
vultr_dns_domain_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_dns_record "Manages DNS records on Vultr." b
vultr_dns_record: >
	domain=${1:# The domain the record is related to.}

	name=${2:}
	record_type=${3:#A|AAAA|CNAME|MX|SRV|CAA|TXT|NS|SSHFP}
	data=${4:# Data of the record.}
	ttl=${5:300}
	multiple=${6:no}
	priority=${7:0}
	state=${8:#present|absent}
	api_key=${9:# API key of the Vultr API.}
	api_timeout=${10:# HTTP timeout to Vultr API.}
	api_retries=${11:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${12:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${13:default}
	api_endpoint=${14:# URL to API endpint (without trailing slash).}
	validate_certs=${15:yes}

endsnippet

snippet vultr_firewall_rule "Manages firewall rules on Vultr." b
vultr_firewall_rule: >
	group=${1:# Name of the firewall group.}

	ip_version=${2:#v4|v6}
	protocol=${3:icmp|#tcp|udp|gre}
	cidr=${4:# Network in CIDR format}
	start_port=${5:# Start port for the firewall rule.}
	end_port=${6:# End port for the firewall rule.}
	state=${7:#present|absent}
	api_key=${8:# API key of the Vultr API.}
	api_timeout=${9:# HTTP timeout to Vultr API.}
	api_retries=${10:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${11:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${12:default}
	api_endpoint=${13:# URL to API endpint (without trailing slash).}
	validate_certs=${14:yes}

endsnippet

snippet vultr_server "Manages virtual servers on Vultr." b
vultr_server: >
	name=${1:# Name of the server.}

	hostname=${2:# The hostname to assign to this server.}
	os=${3:# The operating system name or ID.}
	snapshot=${4:# Name or ID of the snapshot to restore the server from.}
	firewall_group=${5:# The firewall group description or ID to assign this server to.}
	plan=${6:# Plan name or ID to use for the server.}
	force=${7:no}
	notify_activate=${8:# Whether to send an activation email when the server is ready or not.}
	private_network_enabled=${9:# Whether to enable private networking or not.}
	auto_backup_enabled=${10:# Whether to enable automatic backups or not.}
	ipv6_enabled=${11:# Whether to enable IPv6 or not.}
	tag=${12:# Tag for the server.}
	user_data=${13:# User data to be passed to the server.}
	startup_script=${14:# Name or ID of the startup script to execute on boot.}
	ssh_keys=${15:# List of SSH key names or IDs passed to the server on creation.}
	reserved_ip_v4=${16:# IP address of the floating IP to use as the main IP of this server.}
	region=${17:# Region name or ID the server is deployed into.}
	state=${18:#present|absent|restarted|reinstalled|started|stopped}
	api_key=${19:# API key of the Vultr API.}
	api_timeout=${20:# HTTP timeout to Vultr API.}
	api_retries=${21:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${22:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${23:default}
	api_endpoint=${24:# URL to API endpint (without trailing slash).}
	validate_certs=${25:yes}

endsnippet

snippet vultr_firewall_group "Manages firewall groups on Vultr." b
vultr_firewall_group: >
	name=${1:# Name of the firewall group.}

	state=${2:#present|absent}
	api_key=${3:# API key of the Vultr API.}
	api_timeout=${4:# HTTP timeout to Vultr API.}
	api_retries=${5:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${6:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${7:default}
	api_endpoint=${8:# URL to API endpint (without trailing slash).}
	validate_certs=${9:yes}

endsnippet

snippet vultr_network_info "Gather information about the Vultr networks available." b
vultr_network_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_region_info "Gather information about the Vultr regions available." b
vultr_region_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_os_info "Get information about the Vultr OSes available." b
vultr_os_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_server "Manages virtual servers on Vultr." b
vultr_server: >
	name=${1:# Name of the server.}

	hostname=${2:# The hostname to assign to this server.}
	os=${3:# The operating system name or ID.}
	snapshot=${4:# Name or ID of the snapshot to restore the server from.}
	firewall_group=${5:# The firewall group description or ID to assign this server to.}
	plan=${6:# Plan name or ID to use for the server.}
	force=${7:no}
	notify_activate=${8:# Whether to send an activation email when the server is ready or not.}
	private_network_enabled=${9:# Whether to enable private networking or not.}
	auto_backup_enabled=${10:# Whether to enable automatic backups or not.}
	ipv6_enabled=${11:# Whether to enable IPv6 or not.}
	tag=${12:# Tag for the server.}
	user_data=${13:# User data to be passed to the server.}
	startup_script=${14:# Name or ID of the startup script to execute on boot.}
	ssh_keys=${15:# List of SSH key names or IDs passed to the server on creation.}
	reserved_ip_v4=${16:# IP address of the floating IP to use as the main IP of this server.}
	region=${17:# Region name or ID the server is deployed into.}
	state=${18:#present|absent|restarted|reinstalled|started|stopped}
	api_key=${19:# API key of the Vultr API.}
	api_timeout=${20:# HTTP timeout to Vultr API.}
	api_retries=${21:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${22:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${23:default}
	api_endpoint=${24:# URL to API endpint (without trailing slash).}
	validate_certs=${25:yes}

endsnippet

snippet vultr_ssh_key "Manages ssh keys on Vultr." b
vultr_ssh_key: >
	name=${1:# Name of the ssh key.}

	ssh_key=${2:# SSH public key.}
	state=${3:#present|absent}
	api_key=${4:# API key of the Vultr API.}
	api_timeout=${5:# HTTP timeout to Vultr API.}
	api_retries=${6:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${7:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${8:default}
	api_endpoint=${9:# URL to API endpint (without trailing slash).}
	validate_certs=${10:yes}

endsnippet

snippet vultr_startup_script "Manages startup scripts on Vultr." b
vultr_startup_script: >
	name=${1:# The script name.}

	script_type=${2:#boot|pxe}
	script=${3:# The script source code.}
	state=${4:#present|absent}
	api_key=${5:# API key of the Vultr API.}
	api_timeout=${6:# HTTP timeout to Vultr API.}
	api_retries=${7:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${8:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${9:default}
	api_endpoint=${10:# URL to API endpint (without trailing slash).}
	validate_certs=${11:yes}

endsnippet

snippet vultr_dns_record "Manages DNS records on Vultr." b
vultr_dns_record: >
	domain=${1:# The domain the record is related to.}

	name=${2:}
	record_type=${3:#A|AAAA|CNAME|MX|SRV|CAA|TXT|NS|SSHFP}
	data=${4:# Data of the record.}
	ttl=${5:300}
	multiple=${6:no}
	priority=${7:0}
	state=${8:#present|absent}
	api_key=${9:# API key of the Vultr API.}
	api_timeout=${10:# HTTP timeout to Vultr API.}
	api_retries=${11:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${12:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${13:default}
	api_endpoint=${14:# URL to API endpint (without trailing slash).}
	validate_certs=${15:yes}

endsnippet

snippet vultr_firewall_group "Manages firewall groups on Vultr." b
vultr_firewall_group: >
	name=${1:# Name of the firewall group.}

	state=${2:#present|absent}
	api_key=${3:# API key of the Vultr API.}
	api_timeout=${4:# HTTP timeout to Vultr API.}
	api_retries=${5:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${6:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${7:default}
	api_endpoint=${8:# URL to API endpint (without trailing slash).}
	validate_certs=${9:yes}

endsnippet

snippet vultr_startup_script_info "Gather information about the Vultr startup scripts available." b
vultr_startup_script_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_user "Manages users on Vultr." b
vultr_user: >
	name=${1:# Name of the user}

	email=${2:# Email of the user.}
	password=${3:# Password of the user.}
	force=${4:no}
	api_enabled=${5:yes}
	acls=${6:manage_users|subscriptions|provisioning|billing|support|abuse|dns|upgrade}
	state=${7:#present|absent}
	api_key=${8:# API key of the Vultr API.}
	api_timeout=${9:# HTTP timeout to Vultr API.}
	api_retries=${10:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${11:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${12:default}
	api_endpoint=${13:# URL to API endpint (without trailing slash).}
	validate_certs=${14:yes}

endsnippet

snippet vultr_plan_info "Gather information about the Vultr plans available." b
vultr_plan_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_dns_domain "Manages DNS domains on Vultr." b
vultr_dns_domain: >
	name=${1:# The domain name.}

	server_ip=${2:# The default server IP.}
	state=${3:#present|absent}
	api_key=${4:# API key of the Vultr API.}
	api_timeout=${5:# HTTP timeout to Vultr API.}
	api_retries=${6:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${7:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${8:default}
	api_endpoint=${9:# URL to API endpint (without trailing slash).}
	validate_certs=${10:yes}

endsnippet

snippet vultr_ssh_key_info "Get information about the Vultr SSH keys available." b
vultr_ssh_key_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_firewall_group_info "Gather information about the Vultr firewall groups available." b
vultr_firewall_group_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_ssh_key "Manages ssh keys on Vultr." b
vultr_ssh_key: >
	name=${1:# Name of the ssh key.}

	ssh_key=${2:# SSH public key.}
	state=${3:#present|absent}
	api_key=${4:# API key of the Vultr API.}
	api_timeout=${5:# HTTP timeout to Vultr API.}
	api_retries=${6:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${7:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${8:default}
	api_endpoint=${9:# URL to API endpint (without trailing slash).}
	validate_certs=${10:yes}

endsnippet

snippet vultr_server_info "Gather information about the Vultr servers available." b
vultr_server_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet vultr_block_storage "Manages block storage volumes on Vultr." b
vultr_block_storage: >
	name=${1:# Name of the block storage volume.}
	size=${2:# Size of the block storage volume in GB.}
	region=${3:# Region the block storage volume is deployed into.}

	state=${4:#present|absent}
	api_key=${5:# API key of the Vultr API.}
	api_timeout=${6:# HTTP timeout to Vultr API.}
	api_retries=${7:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${8:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${9:default}
	api_endpoint=${10:# URL to API endpint (without trailing slash).}
	validate_certs=${11:yes}

endsnippet

snippet vultr_account_info "Get information about the Vultr account." b
vultr_account_info: >
	api_key=${1:# API key of the Vultr API.}
	api_timeout=${2:# HTTP timeout to Vultr API.}
	api_retries=${3:# Amount of retries in case of the Vultr API retuns an HTTP 503 code.}
	api_retry_max_delay=${4:# Retry backoff delay in seconds is exponential up to this max. value, in seconds.}
	api_account=${5:default}
	api_endpoint=${6:# URL to API endpint (without trailing slash).}
	validate_certs=${7:yes}

endsnippet

snippet xenserver_guest "Manages virtual machines running on Citrix Hypervisor/XenServer host or pool" b
xenserver_guest: >
	name=${1:# Name of the VM to work with.}

	state=${2:#present|absent|poweredon}
	name_desc=${3:# VM description.}
	uuid=${4:# UUID of the VM to manage if known. This is XenServer's unique identifier.}
	template=${5:# Name of a template, an existing VM (must be shut down) or a snapshot that should be used to create VM.}
	template_uuid=${6:# UUID of a template, an existing VM or a snapshot that should be used to create VM.}
	is_template=${7:no}
	folder=${8:# Destination folder for VM.}
	hardware=${9:# Manage VM's hardware parameters. VM needs to be shut down to reconfigure these parameters.}
	disks=${10:# A list of disks to add to VM.}
	cdrom=${11:# A CD-ROM configuration for the VM.}
	networks=${12:# A list of networks (in the order of the NICs).}
	home_server=${13:# Name of a XenServer host that will be a Home Server for the VM.}
	custom_params=${14:# Define a list of custom VM params to set on VM.}
	wait_for_ip_address=${15:no}
	state_change_timeout=${16:0}
	linked_clone=${17:no}
	force=${18:no}
	hostname=${19:localhost}
	username=${20:root}
	password=${21:# The password to use for connecting to XenServer.}
	validate_certs=${22:yes}

endsnippet

snippet xenserver_guest_powerstate "Manages power states of virtual machines running on Citrix Hypervisor/XenServer host or pool" b
xenserver_guest_powerstate: >
	name=${1:# Name of the VM to manage.}

	state=${2:powered-on|powered-off|restarted|shutdown-guest|reboot-guest|suspended|#present}
	uuid=${3:# UUID of the VM to manage if known. This is XenServer's unique identifier.}
	wait_for_ip_address=${4:no}
	state_change_timeout=${5:0}
	hostname=${6:localhost}
	username=${7:root}
	password=${8:# The password to use for connecting to XenServer.}
	validate_certs=${9:yes}

endsnippet

snippet xenserver_guest_info "Gathers information for virtual machines running on Citrix Hypervisor/XenServer host or pool" b
xenserver_guest_info: >
	name=${1:# Name of the VM to gather facts from.}

	uuid=${2:# UUID of the VM to gather fact of. This is XenServer's unique identifier.}
	hostname=${3:localhost}
	username=${4:root}
	password=${5:# The password to use for connecting to XenServer.}
	validate_certs=${6:yes}

endsnippet

snippet xenserver_guest_info "Gathers information for virtual machines running on Citrix Hypervisor/XenServer host or pool" b
xenserver_guest_info: >
	name=${1:# Name of the VM to gather facts from.}

	uuid=${2:# UUID of the VM to gather fact of. This is XenServer's unique identifier.}
	hostname=${3:localhost}
	username=${4:root}
	password=${5:# The password to use for connecting to XenServer.}
	validate_certs=${6:yes}

endsnippet

snippet online_server_info "Gather information about Online servers." b
online_server_info: >
	api_token=${1:# Online OAuth token.}
	api_url=${2:https://api.online.net}
	api_timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet online_user_info "Gather information about Online user." b
online_user_info: >
	api_token=${1:# Online OAuth token.}
	api_url=${2:https://api.online.net}
	api_timeout=${3:30}
	validate_certs=${4:yes}

endsnippet

snippet dimensiondata_network "Create, update, and delete MCP 1.0 & 2.0 networks" b
dimensiondata_network: >
	name=${1:# The name of the network domain to create.}
	location=${2:# The target datacenter.}

	description=${3:# Additional description of the network domain.}
	service_plan=${4:#ESSENTIALS|ADVANCED}
	state=${5:#present|absent}
	region=${6:Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.}
	mcp_user=${7:# The username used to authenticate to the CloudControl API.}
	mcp_password=${8:# The password used to authenticate to the CloudControl API.}
	validate_certs=${9:yes}
	wait=${10:no}
	wait_time=${11:600}
	wait_poll_interval=${12:2}

endsnippet

snippet dimensiondata_vlan "Manage a VLAN in a Cloud Control network domain." b
dimensiondata_vlan: >
	network_domain=${1:# The Id or name of the target network domain.}
	location=${2:# The target datacenter.}

	name=${3:# The name of the target VLAN.}
	description=${4:# A description of the VLAN.}
	private_ipv4_base_address=${5:# The base address for the VLAN's IPv4 network (e.g. 192.168.1.0).}
	private_ipv4_prefix_size=${6:# The size of the IPv4 address space, e.g 24.}
	state=${7:#present|absent|readonly}
	allow_expand=${8:no}
	region=${9:Regions are defined in Apache libcloud project [libcloud/common/dimensiondata.py]|They are also listed in U(https://libcloud.readthedocs.io/en/latest/compute/drivers/dimensiondata.html)|Note that the default value "na" stands for "North America".|The module prepends 'dd-' to the region choice.}
	mcp_user=${10:# The username used to authenticate to the CloudControl API.}
	mcp_password=${11:# The password used to authenticate to the CloudControl API.}
	validate_certs=${12:yes}
	wait=${13:no}
	wait_time=${14:600}
	wait_poll_interval=${15:2}

endsnippet

snippet ovirt_disk_info "Retrieve information about one or more oVirt/RHV disks" b
ovirt_disk_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_vm_info "Retrieve information about one or more oVirt/RHV virtual machines" b
ovirt_vm_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	all_content=${3:# If I(true) all the attributes of the virtual machines should be included in the response.}
	case_sensitive=${4:yes}
	max=${5:# The maximum number of results to return.}
	next_run=${6:# Indicates if the returned result describes the virtual machine as it is currently running or if describes the virtual machine with the modifications that have already been performed but that will only come into effect when the virtual machine is restarted. By default the value is set by engine.}
	fetch_nested=${7:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${8:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_affinity_label_info "Retrieve information about one or more oVirt/RHV affinity labels" b
ovirt_affinity_label_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the affinity labels which should be listed.}
	vm=${3:# Name of the VM, which affinity labels should be listed.}
	host=${4:# Name of the host, which affinity labels should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_storage_domain "Module to manage storage domains in oVirt/RHV" b
ovirt_storage_domain: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${2:# Id of the storage domain to be imported.}
	name=${3:# Name of the storage domain to manage. (Not required when state is I(imported))}
	state=${4:#present|absent|maintenance|unattached|imported|update_ovf_store}
	description=${5:# Description of the storage domain.}
	comment=${6:# Comment of the storage domain.}
	data_center=${7:# Data center name where storage domain should be attached.}
	domain_function=${8:#data|iso|export}
	host=${9:# Host to be used to mount storage.}
	localfs=${10:# Dictionary with values for localfs storage type:}
	nfs=${11:# Dictionary with values for NFS storage type:}
	iscsi=${12:# Dictionary with values for iSCSI storage type:}
	posixfs=${13:# Dictionary with values for PosixFS storage type:}
	glusterfs=${14:# Dictionary with values for GlusterFS storage type:}
	managed_block_storage=${15:# Dictionary with values for managed block storage type}
	fcp=${16:# Dictionary with values for fibre channel storage type:}
	wipe_after_delete=${17:# Boolean flag which indicates whether the storage domain should wipe the data after delete.}
	backup=${18:# Boolean flag which indicates whether the storage domain is configured as backup or not.}
	critical_space_action_blocker=${19:# Indicates the minimal free space the storage domain should contain in percentages.}
	warning_low_space=${20:# Indicates the minimum percentage of a free space in a storage domain to present a warning.}
	destroy=${21:# Logical remove of the storage domain. If I(true) retains the storage domain's data for import.}
	format=${22:# If I(True) storage domain will be formatted after removing it from oVirt/RHV.}
	discard_after_delete=${23:# If I(True) storage domain blocks will be discarded upon deletion. Enabled by default.}
	wait=${24:yes}
	fetch_nested=${25:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${26:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${27:180}
	poll_interval=${28:3}

endsnippet

snippet ovirt_snapshot "Module to manage Virtual Machine Snapshots in oVirt/RHV" b
ovirt_snapshot: >
	vm_name=${1:# Name of the Virtual Machine to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	snapshot_id=${3:# ID of the snapshot to manage.}
	state=${4:restore|#present|absent}
	description=${5:# Description of the snapshot.}
	disk_id=${6:# Disk id which you want to upload or download}
	disk_name=${7:# Disk name which you want to upload or download}
	download_image_path=${8:# Path on a file system where snapshot should be downloaded.}
	upload_image_path=${9:# Path to disk image, which should be uploaded.}
	use_memory=${10:# If I(true) and C(state) is I(present) save memory of the Virtual Machine if it's running.}
	keep_days_old=${11:# Number of days after which should snapshot be deleted.}
	wait=${12:yes}
	fetch_nested=${13:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${14:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${15:180}
	poll_interval=${16:3}

endsnippet

snippet ovirt_permission_info "Retrieve information about one or more oVirt/RHV permissions" b
ovirt_permission_info: >
	authz_name=${1:# Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	user_name=${3:# Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
	group_name=${4:# Name of the group to manage.}
	namespace=${5:# Namespace of the authorization provider, where user/group resides.}
	fetch_nested=${6:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${7:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_nic_info "Retrieve information about one or more oVirt/RHV virtual machine network interfaces" b
ovirt_nic_info: >
	vm=${1:# Name of the VM where NIC is attached.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the NIC, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_scheduling_policy_info "Retrieve information about one or more oVirt scheduling policies" b
ovirt_scheduling_policy_info: >
	id=${1:# ID of the scheduling policy.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the scheduling policy, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_instance_type "Module to manage Instance Types in oVirt/RHV" b
ovirt_instance_type: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the Instance Type to manage.}
	id=${3:# ID of the Instance Type to manage.}
	state=${4:absent|#present}
	memory=${5:# Amount of memory of the Instance Type. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	memory_guaranteed=${6:# Amount of minimal guaranteed memory of the Instance Type. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	nics=${7:# List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary.}
	memory_max=${8:# Upper bound of instance type memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	cpu_cores=${9:# Number of virtual CPUs cores of the Instance Type.}
	cpu_sockets=${10:# Number of virtual CPUs sockets of the Instance Type.}
	cpu_threads=${11:# Number of virtual CPUs sockets of the Instance Type.}
	operating_system=${12:# Operating system of the Instance Type.}
	boot_devices=${13:cdrom|hd|network}
	serial_console=${14:# I(True) enable VirtIO serial console, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	usb_support=${15:# I(True) enable USB support, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	high_availability=${16:# If I(yes) Instance Type will be set as highly available.}
	high_availability_priority=${17:# Indicates the priority of the instance type inside the run and migration queues. Instance Type with higher priorities will be started and migrated before instance types with lower priorities. The value is an integer between 0 and 100. The higher the value, the higher the priority.}
	watchdog=${18:# Assign watchdog device for the instance type.}
	host=${19:# Specify host where Instance Type should be running. By default the host is chosen by engine scheduler.}
	graphical_console=${20:# Assign graphical console to the instance type.}
	description=${21:# Description of the instance type.}
	cpu_mode=${22:# CPU mode of the instance type. It can be some of the following: I(host_passthrough), I(host_model) or I(custom).}
	rng_device=${23:# Random number generator (RNG). You can choose of one the following devices I(urandom), I(random) or I(hwrng).}
	rng_bytes=${24:# Number of bytes allowed to consume per period.}
	rng_period=${25:# Duration of one period in milliseconds.}
	placement_policy=${26:# The configuration of the instance type's placement policy.}
	cpu_pinning=${27:# CPU Pinning topology to map instance type CPU to host CPU.}
	soundcard_enabled=${28:# If I(true), the sound card is added to the instance type.}
	smartcard_enabled=${29:# If I(true), use smart card authentication.}
	virtio_scsi=${30:# If I(true), virtio scsi will be enabled.}
	io_threads=${31:# Number of IO threads used by instance type. I(0) means IO threading disabled.}
	ballooning_enabled=${32:# If I(true), use memory ballooning.}
	wait=${33:yes}
	fetch_nested=${34:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${35:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${36:180}
	poll_interval=${37:3}

endsnippet

snippet ovirt_group "Module to manage groups in oVirt/RHV" b
ovirt_group: >
	name=${1:# Name of the group to manage.}
	authz_name=${2:# Authorization provider of the group. In previous versions of oVirt/RHV known as domain.}
	auth=${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${4:#present|absent}
	namespace=${5:# Namespace of the authorization provider, where group resides.}
	wait=${6:yes}
	fetch_nested=${7:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${8:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${9:180}
	poll_interval=${10:3}

endsnippet

snippet ovirt_vmpool_info "Retrieve information about one or more oVirt/RHV vmpools" b
ovirt_vmpool_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_host_info "Retrieve information about one or more oVirt/RHV hosts" b
ovirt_host_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	all_content=${3:no}
	cluster_version=${4:# Filter the hosts based on the cluster version.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_job "Module to manage jobs in oVirt/RHV" b
ovirt_job: >
	description=${1:# Description of the job.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${3:#present|absent|started|finished|failed}
	steps=${4:# The steps of the job.}
	wait=${5:yes}
	fetch_nested=${6:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${7:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${8:180}
	poll_interval=${9:3}

endsnippet

snippet ovirt_mac_pool "Module to manage MAC pools in oVirt/RHV" b
ovirt_mac_pool: >
	name=${1:# Name of the MAC pool to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the mac pool to manage.}
	description=${4:# Description of the MAC pool.}
	state=${5:#present|absent}
	allow_duplicates=${6:# If I(true) allow a MAC address to be used multiple times in a pool.}
	ranges=${7:# List of MAC ranges. The from and to should be split by comma.}
	wait=${8:yes}
	fetch_nested=${9:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${10:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${11:180}
	poll_interval=${12:3}

endsnippet

snippet ovirt_affinity_label_info "Retrieve information about one or more oVirt/RHV affinity labels" b
ovirt_affinity_label_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the affinity labels which should be listed.}
	vm=${3:# Name of the VM, which affinity labels should be listed.}
	host=${4:# Name of the host, which affinity labels should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_user_info "Retrieve information about one or more oVirt/RHV users" b
ovirt_user_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_template_info "Retrieve information about one or more oVirt/RHV templates" b
ovirt_template_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_storage_template_info "Retrieve information about one or more oVirt/RHV templates relate to a storage domain." b
ovirt_storage_template_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	unregistered=${2:no}
	max=${3:# Sets the maximum number of templates to return. If not specified all the templates are returned.}
	storage_domain=${4:# The storage domain name where the templates should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_event_info "This module can be used to retrieve information about one or more oVirt/RHV events" b
ovirt_event_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	case_sensitive=${2:yes}
	from_=${3:# Indicates the event index after which events should be returned. The indexes of events are strictly increasing, so when this parameter is used only the events with greater indexes will be returned.}
	max=${4:# Sets the maximum number of events to return. If not specified all the events are returned.}
	search=${5:# Search term which is accepted by the oVirt/RHV API.}
	headers=${6:# Additional HTTP headers.}
	query=${7:# Additional URL query parameters.}
	wait=${8:yes}
	fetch_nested=${9:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${10:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_vmpool "Module to manage VM pools in oVirt/RHV" b
ovirt_vmpool: >
	name=${1:# Name of the VM pool to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the vmpool to manage.}
	comment=${4:# Comment of the Virtual Machine pool.}
	state=${5:#present|absent}
	template=${6:# Name of the template, which will be used to create VM pool.}
	description=${7:# Description of the VM pool.}
	cluster=${8:# Name of the cluster, where VM pool should be created.}
	type=${9:manual|automatic}
	vm_per_user=${10:# Maximum number of VMs a single user can attach to from this pool.}
	prestarted=${11:# Number of pre-started VMs defines the number of VMs in run state, that are waiting to be attached to Users.}
	vm_count=${12:# Number of VMs in the pool.}
	vm=${13:# For creating vm pool without editing template.}
	wait=${14:yes}
	fetch_nested=${15:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${16:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${17:180}
	poll_interval=${18:3}

endsnippet

snippet ovirt_api_info "Retrieve information about the oVirt/RHV API" b
ovirt_api_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	fetch_nested=${2:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${3:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_storage_connection "Module to manage storage connections in oVirt" b
ovirt_storage_connection: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${2:# Id of the storage connection to manage.}
	state=${3:#present|absent}
	storage=${4:# Name of the storage domain to be used with storage connection.}
	address=${5:# Address of the storage server. E.g.: myserver.mydomain.com}
	path=${6:# Path of the mount point of the storage. E.g.: /path/to/my/data}
	nfs_version=${7:# NFS version. One of: I(auto), I(v3), I(v4) or I(v4_1).}
	nfs_timeout=${8:# The time in tenths of a second to wait for a response before retrying NFS requests. Range 0 to 65535.}
	nfs_retrans=${9:# The number of times to retry a request before attempting further recovery actions. Range 0 to 65535.}
	mount_options=${10:# Option which will be passed when mounting storage.}
	password=${11:# A CHAP password for logging into a target.}
	username=${12:# A CHAP username for logging into a target.}
	port=${13:# Port of the iSCSI storage server.}
	target=${14:# The target IQN for the storage device.}
	type=${15:# Storage type. For example: I(nfs), I(iscsi), etc.}
	vfs_type=${16:# Virtual File System type.}
	force=${17:# This parameter is relevant only when updating a connection.}
	wait=${18:yes}
	fetch_nested=${19:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${20:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${21:180}
	poll_interval=${22:3}

endsnippet

snippet ovirt_group_info "Retrieve information about one or more oVirt/RHV groups" b
ovirt_group_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_group_info "Retrieve information about one or more oVirt/RHV groups" b
ovirt_group_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_vm_info "Retrieve information about one or more oVirt/RHV virtual machines" b
ovirt_vm_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	all_content=${3:# If I(true) all the attributes of the virtual machines should be included in the response.}
	case_sensitive=${4:yes}
	max=${5:# The maximum number of results to return.}
	next_run=${6:# Indicates if the returned result describes the virtual machine as it is currently running or if describes the virtual machine with the modifications that have already been performed but that will only come into effect when the virtual machine is restarted. By default the value is set by engine.}
	fetch_nested=${7:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${8:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_template "Module to manage virtual machine templates in oVirt/RHV" b
ovirt_template: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the template to manage.}
	id=${3:# ID of the template to be registered.}
	state=${4:#present|absent|exported|imported|registered}
	vm=${5:# Name of the VM, which will be used to create template.}
	description=${6:# Description of the template.}
	cpu_profile=${7:# CPU profile to be set to template.}
	cluster=${8:# Name of the cluster, where template should be created/imported.}
	allow_partial_import=${9:# Boolean indication whether to allow partial registration of a template when C(state) is registered.}
	vnic_profile_mappings=${10:# Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:}
	cluster_mappings=${11:# Mapper which maps cluster name between Template's OVF and the destination cluster this Template should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:}
	role_mappings=${12:# Mapper which maps role name between Template's OVF and the destination role this Template should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:}
	domain_mappings=${13:# Mapper which maps aaa domain name between Template's OVF and the destination aaa domain this Template should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:}
	exclusive=${14:# When C(state) is I(exported) this parameter indicates if the existing templates with the same name should be overwritten.}
	export_domain=${15:# When C(state) is I(exported) or I(imported) this parameter specifies the name of the export storage domain.}
	image_provider=${16:# When C(state) is I(imported) this parameter specifies the name of the image provider to be used.}
	image_disk=${17:# When C(state) is I(imported) and C(image_provider) is used this parameter specifies the name of disk to be imported as template.}
	io_threads=${18:# Number of IO threads used by virtual machine. I(0) means IO threading disabled.}
	template_image_disk_name=${19:# When C(state) is I(imported) and C(image_provider) is used this parameter specifies the new name for imported disk, if omitted then I(image_disk) name is used by default. This parameter is used only in case of importing disk image from Glance domain.}
	storage_domain=${20:# When C(state) is I(imported) this parameter specifies the name of the destination data storage domain. When C(state) is I(registered) this parameter specifies the name of the data storage domain of the unregistered template.}
	clone_permissions=${21:no}
	seal=${22:no}
	operating_system=${23:# Operating system of the template.}
	memory=${24:# Amount of memory of the template. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	memory_guaranteed=${25:# Amount of minimal guaranteed memory of the template. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	memory_max=${26:# Upper bound of template memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	version=${27:# C(name) - The name of this version.}
	clone_name=${28:# Name for importing Template from storage domain.}
	usb_support=${29:# I(True) enable USB support, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	timezone=${30:# Sets time zone offset of the guest hardware clock.}
	sso=${31:# I(True) enable Single Sign On by Guest Agent, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	soundcard_enabled=${32:# If I(true), the sound card is added to the virtual machine.}
	smartcard_enabled=${33:# If I(true), use smart card authentication.}
	cloud_init=${34:# Dictionary with values for Unix-like Virtual Machine initialization using cloud init.}
	cloud_init_nics=${35:# List of dictionaries representing network interfaces to be setup by cloud init.}
	ballooning_enabled=${36:# If I(true), use memory ballooning.}
	nics=${37:# List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary.}
	sysprep=${38:# Dictionary with values for Windows Virtual Machine initialization using sysprep.}
	wait=${39:yes}
	fetch_nested=${40:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${41:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${42:180}
	poll_interval=${43:3}

endsnippet

snippet ovirt_event_info "This module can be used to retrieve information about one or more oVirt/RHV events" b
ovirt_event_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	case_sensitive=${2:yes}
	from_=${3:# Indicates the event index after which events should be returned. The indexes of events are strictly increasing, so when this parameter is used only the events with greater indexes will be returned.}
	max=${4:# Sets the maximum number of events to return. If not specified all the events are returned.}
	search=${5:# Search term which is accepted by the oVirt/RHV API.}
	headers=${6:# Additional HTTP headers.}
	query=${7:# Additional URL query parameters.}
	wait=${8:yes}
	fetch_nested=${9:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${10:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_vnic_profile "Module to manage vNIC profile of network in oVirt/RHV" b
ovirt_vnic_profile: >
	name=${1:# A human-readable name in plain text.}
	data_center=${2:# Datacenter name where network reside.}
	network=${3:# Name of network to which is vNIC attached.}
	auth=${4:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${5:absent|#present}
	description=${6:# A human-readable description in plain text.}
	network_filter=${7:# The network filter enables to filter packets send to/from the VM's nic according to defined rules.}
	custom_properties=${8:# Custom properties applied to the vNIC profile.}
	qos=${9:# Quality of Service attributes regulate inbound and outbound network traffic of the NIC.}
	port_mirroring=${10:# Enables port mirroring.}
	pass_through=${11:disabled|enabled}
	migratable=${12:# Marks whether pass_through NIC is migratable or not.}
	wait=${13:yes}
	fetch_nested=${14:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${15:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${16:180}
	poll_interval=${17:3}

endsnippet

snippet ovirt_storage_vm_info "Retrieve information about one or more oVirt/RHV virtual machines relate to a storage domain." b
ovirt_storage_vm_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	unregistered=${2:no}
	max=${3:# Sets the maximum number of virtual machines to return. If not specified all the virtual machines are returned.}
	storage_domain=${4:# The storage domain name where the virtual machines should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_nic_info "Retrieve information about one or more oVirt/RHV virtual machine network interfaces" b
ovirt_nic_info: >
	vm=${1:# Name of the VM where NIC is attached.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the NIC, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_auth "Module to manage authentication to oVirt/RHV" b
ovirt_auth: >
	state=${1:#present|absent}
	username=${2:# The name of the user. For example: I(admin@internal) Default value is set by I(OVIRT_USERNAME) environment variable.}
	password=${3:# The password of the user. Default value is set by I(OVIRT_PASSWORD) environment variable.}
	token=${4:# SSO token to be used instead of login with username/password. Default value is set by I(OVIRT_TOKEN) environment variable.}
	url=${5:# A string containing the API URL of the server. For example: I(https://server.example.com/ovirt-engine/api). Default value is set by I(OVIRT_URL) environment variable.}
	hostname=${6:# A string containing the hostname of the server. For example: I(server.example.com). Default value is set by I(OVIRT_HOSTNAME) environment variable.}
	insecure=${7:# A boolean flag that indicates if the server TLS certificate and host name should be checked.}
	ca_file=${8:# A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If C(ca_file) parameter is not set, system wide CA certificate store is used. Default value is set by I(OVIRT_CAFILE) environment variable.}
	timeout=${9:# The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.}
	compress=${10:# A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is I(True). Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to I(True).}
	kerberos=${11:# A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.}
	headers=${12:# A dictionary of HTTP headers to be added to each API call.}

endsnippet

snippet ovirt_cluster_info "Retrieve information about one or more oVirt/RHV clusters" b
ovirt_cluster_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_datacenter_info "Retrieve information about one or more oVirt/RHV datacenters" b
ovirt_datacenter_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_host_network "Module to manage host networks in oVirt/RHV" b
ovirt_host_network: >
	name=${1:# Name of the host to manage networks for.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${3:#present|absent}
	bond=${4:# Dictionary describing network bond:}
	interface=${5:# Name of the network interface where logical network should be attached.}
	networks=${6:# List of dictionary describing networks to be attached to interface or bond:}
	labels=${7:# List of names of the network label to be assigned to bond or interface.}
	check=${8:# If I(true) verify connectivity between host and engine.}
	save=${9:yes}
	sync_networks=${10:no}
	wait=${11:yes}
	fetch_nested=${12:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${13:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${14:180}
	poll_interval=${15:3}

endsnippet

snippet ovirt_vm "Module to manage Virtual Machines in oVirt/RHV" b
ovirt_vm: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the Virtual Machine to manage.}
	id=${3:# ID of the Virtual Machine to manage.}
	state=${4:absent|next_run|#present|registered|running|stopped|suspended|exported}
	cluster=${5:# Name of the cluster, where Virtual Machine should be created.}
	allow_partial_import=${6:# Boolean indication whether to allow partial registration of Virtual Machine when C(state) is registered.}
	vnic_profile_mappings=${7:# Mapper which maps an external virtual NIC profile to one that exists in the engine when C(state) is registered. vnic_profile is described by the following dictionary:}
	cluster_mappings=${8:# Mapper which maps cluster name between VM's OVF and the destination cluster this VM should be registered to, relevant when C(state) is registered. Cluster mapping is described by the following dictionary:}
	role_mappings=${9:# Mapper which maps role name between VM's OVF and the destination role this VM should be registered to, relevant when C(state) is registered. Role mapping is described by the following dictionary:}
	domain_mappings=${10:# Mapper which maps aaa domain name between VM's OVF and the destination aaa domain this VM should be registered to, relevant when C(state) is registered. The aaa domain mapping is described by the following dictionary:}
	affinity_group_mappings=${11:# Mapper which maps affinity name between VM's OVF and the destination affinity this VM should be registered to, relevant when C(state) is registered.}
	affinity_label_mappings=${12:# Mapper which maps affinity label name between VM's OVF and the destination label this VM should be registered to, relevant when C(state) is registered.}
	lun_mappings=${13:# Mapper which maps lun between VM's OVF and the destination lun this VM should contain, relevant when C(state) is registered. lun_mappings is described by the following dictionary: - C(logical_unit_id): The logical unit number to identify a logical unit, - C(logical_unit_port): The port being used to connect with the LUN disk. - C(logical_unit_portal): The portal being used to connect with the LUN disk. - C(logical_unit_address): The address of the block storage host. - C(logical_unit_target): The iSCSI specification located on an iSCSI server - C(logical_unit_username): Username to be used to connect to the block storage host. - C(logical_unit_password): Password to be used to connect to the block storage host. - C(storage_type): The storage type which the LUN reside on (iscsi or fcp)}
	reassign_bad_macs=${14:# Boolean indication whether to reassign bad macs when C(state) is registered.}
	template=${15:# Name of the template, which should be used to create Virtual Machine.}
	template_version=${16:# Version number of the template to be used for VM.}
	use_latest_template_version=${17:# Specify if latest template version should be used, when running a stateless VM.}
	storage_domain=${18:# Name of the storage domain where all template disks should be created.}
	disk_format=${19:#cow|raw}
	memory=${20:# Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	memory_guaranteed=${21:# Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	memory_max=${22:# Upper bound of virtual machine memory up to which memory hot-plug can be performed. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB).}
	cpu_shares=${23:# Set a CPU shares for this Virtual Machine.}
	cpu_cores=${24:# Number of virtual CPUs cores of the Virtual Machine.}
	cpu_sockets=${25:# Number of virtual CPUs sockets of the Virtual Machine.}
	cpu_threads=${26:# Number of threads per core of the Virtual Machine.}
	type=${27:desktop|server|high_performance}
	quota_id=${28:# Virtual Machine quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.}
	operating_system=${29:# Operating system of the Virtual Machine.}
	boot_devices=${30:cdrom|hd|network}
	boot_menu=${31:# I(True) enable menu to select boot device, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	usb_support=${32:# I(True) enable USB support, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	serial_console=${33:# I(True) enable VirtIO serial console, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	sso=${34:# I(True) enable Single Sign On by Guest Agent, I(False) to disable it. By default is chosen by oVirt/RHV engine.}
	host=${35:# Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler.}
	high_availability=${36:# If I(yes) Virtual Machine will be set as highly available.}
	high_availability_priority=${37:# Indicates the priority of the virtual machine inside the run and migration queues. Virtual machines with higher priorities will be started and migrated before virtual machines with lower priorities. The value is an integer between 0 and 100. The higher the value, the higher the priority.}
	lease=${38:# Name of the storage domain this virtual machine lease reside on. Pass an empty string to remove the lease.}
	custom_compatibility_version=${39:# Enables a virtual machine to be customized to its own compatibility version. If 'C(custom_compatibility_version)' is set, it overrides the cluster's compatibility version for this particular virtual machine.}
	host_devices=${40:# Single Root I/O Virtualization - technology that allows single device to expose multiple endpoints that can be passed to VMs}
	delete_protected=${41:# If I(yes) Virtual Machine will be set as delete protected.}
	stateless=${42:# If I(yes) Virtual Machine will be set as stateless.}
	clone=${43:no}
	clone_permissions=${44:no}
	cd_iso=${45:# ISO file from ISO storage domain which should be attached to Virtual Machine.}
	force=${46:no}
	nics=${47:# List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary.}
	disks=${48:# List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary.}
	sysprep=${49:# Dictionary with values for Windows Virtual Machine initialization using sysprep.}
	cloud_init=${50:# Dictionary with values for Unix-like Virtual Machine initialization using cloud init.}
	cloud_init_nics=${51:# List of dictionaries representing network interfaces to be setup by cloud init.}
	cloud_init_persist=${52:no}
	kernel_params_persist=${53:# If I(true) C(kernel_params), C(initrd_path) and C(kernel_path) will persist in virtual machine configuration, if I(False) it will be used for run once.}
	kernel_path=${54:# Path to a kernel image used to boot the virtual machine.}
	initrd_path=${55:# Path to an initial ramdisk to be used with the kernel specified by C(kernel_path) option.}
	kernel_params=${56:# Kernel command line parameters (formatted as string) to be used with the kernel specified by C(kernel_path) option.}
	instance_type=${57:# Name of virtual machine's hardware configuration.}
	description=${58:# Description of the Virtual Machine.}
	comment=${59:# Comment of the Virtual Machine.}
	timezone=${60:# Sets time zone offset of the guest hardware clock.}
	serial_policy=${61:vm|host|custom}
	serial_policy_value=${62:# Allows you to specify a custom serial number.}
	vmware=${63:# Dictionary of values to be used to connect to VMware and import a virtual machine to oVirt.}
	xen=${64:# Dictionary of values to be used to connect to XEN and import a virtual machine to oVirt.}
	kvm=${65:# Dictionary of values to be used to connect to kvm and import a virtual machine to oVirt.}
	cpu_mode=${66:# CPU mode of the virtual machine. It can be some of the following: I(host_passthrough), I(host_model) or I(custom).}
	placement_policy=${67:# The configuration of the virtual machine's placement policy.}
	ticket=${68:# If I(true), in addition return I(remote_vv_file) inside I(vm) dictionary, which contains compatible content for remote-viewer application. Works only C(state) is I(running).}
	cpu_pinning=${69:# CPU Pinning topology to map virtual machine CPU to host CPU.}
	soundcard_enabled=${70:# If I(true), the sound card is added to the virtual machine.}
	smartcard_enabled=${71:# If I(true), use smart card authentication.}
	io_threads=${72:# Number of IO threads used by virtual machine. I(0) means IO threading disabled.}
	ballooning_enabled=${73:# If I(true), use memory ballooning.}
	numa_tune_mode=${74:interleave|preferred|strict}
	numa_nodes=${75:# List of vNUMA Nodes to set for this VM and pin them to assigned host's physical NUMA node.}
	rng_device=${76:# Random number generator (RNG). You can choose of one the following devices I(urandom), I(random) or I(hwrng).}
	custom_properties=${77:# Properties sent to VDSM to configure various hooks.}
	watchdog=${78:# Assign watchdog device for the virtual machine.}
	graphical_console=${79:# Assign graphical console to the virtual machine.}
	exclusive=${80:# When C(state) is I(exported) this parameter indicates if the existing VM with the same name should be overwritten.}
	export_domain=${81:# When C(state) is I(exported)this parameter specifies the name of the export storage domain.}
	export_ova=${82:# Dictionary of values to be used to export VM as OVA.}
	force_migrate=${83:# If I(true), the VM will migrate when I(placement_policy=user-migratable) but not when I(placement_policy=pinned).}
	migrate=${84:# If I(true), the VM will migrate to any available host.}
	next_run=${85:# If I(true), the update will not be applied to the VM immediately and will be only applied when virtual machine is restarted.}
	snapshot_name=${86:# Snapshot to clone VM from.}
	snapshot_vm=${87:# Source VM to clone VM from.}
	wait=${88:yes}
	fetch_nested=${89:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${90:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${91:180}
	poll_interval=${92:3}

endsnippet

snippet ovirt_disk_info "Retrieve information about one or more oVirt/RHV disks" b
ovirt_disk_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_snapshot_info "Retrieve information about one or more oVirt/RHV virtual machine snapshots" b
ovirt_snapshot_info: >
	vm=${1:# Name of the VM with snapshot.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	description=${3:# Description of the snapshot, can be used as glob expression.}
	snapshot_id=${4:# Id of the snapshot we want to retrieve information about.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_vmpool_info "Retrieve information about one or more oVirt/RHV vmpools" b
ovirt_vmpool_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_external_provider_info "Retrieve information about one or more oVirt/RHV external providers" b
ovirt_external_provider_info: >
	type=${1:os_image|os_network|os_volume|foreman}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the external provider, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_user "Module to manage users in oVirt/RHV" b
ovirt_user: >
	name=${1:# Name of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
	authz_name=${2:# Authorization provider of the user. In previous versions of oVirt/RHV known as domain.}
	auth=${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${4:#present|absent}
	namespace=${5:# Namespace where the user resides. When using the authorization provider that stores users in the LDAP server, this attribute equals the naming context of the LDAP server.}
	wait=${6:yes}
	fetch_nested=${7:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${8:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${9:180}
	poll_interval=${10:3}

endsnippet

snippet ovirt_quota_info "Retrieve information about one or more oVirt/RHV quotas" b
ovirt_quota_info: >
	data_center=${1:# Name of the datacenter where quota resides.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the quota, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_cluster_info "Retrieve information about one or more oVirt/RHV clusters" b
ovirt_cluster_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_datacenter_info "Retrieve information about one or more oVirt/RHV datacenters" b
ovirt_datacenter_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_disk "Module to manage Virtual Machine and floating disks in oVirt/RHV" b
ovirt_disk: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${2:# ID of the disk to manage. Either C(id) or C(name) is required.}
	name=${3:# Name of the disk to manage. Either C(id) or C(name)/C(alias) is required.}
	description=${4:# Description of the disk image to manage.}
	vm_name=${5:# Name of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
	vm_id=${6:# ID of the Virtual Machine to manage. Either C(vm_id) or C(vm_name) is required if C(state) is I(attached) or I(detached).}
	state=${7:#present|absent|attached|detached|exported}
	download_image_path=${8:# Path on a file system where disk should be downloaded.}
	upload_image_path=${9:# Path to disk image, which should be uploaded.}
	size=${10:# Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.}
	interface=${11:#virtio|ide|virtio_scsi}
	format=${12:raw|cow}
	content_type=${13:#data|iso|hosted_engine|hosted_engine_sanlock|hosted_engine_metadata|hosted_engine_configuration}
	sparse=${14:# I(True) if the disk should be sparse (also known as I(thin provision)). If the parameter is omitted, cow disks will be created as sparse and raw disks as I(preallocated)}
	storage_domain=${15:# Storage domain name where disk should be created. By default storage is chosen by oVirt/RHV engine.}
	storage_domains=${16:# Storage domain names where disk should be copied.}
	force=${17:# Please take a look at C(image_path) documentation to see the correct usage of this parameter.}
	profile=${18:# Disk profile name to be attached to disk. By default profile is chosen by oVirt/RHV engine.}
	quota_id=${19:# Disk quota ID to be used for disk. By default quota is chosen by oVirt/RHV engine.}
	bootable=${20:no}
	shareable=${21:# I(True) if the disk should be shareable. By default when disk is created it isn't shareable.}
	logical_unit=${22:# Dictionary which describes LUN to be directly attached to VM:}
	sparsify=${23:# I(True) if the disk should be sparsified.}
	openstack_volume_type=${24:# Name of the openstack volume type. This is valid when working with cinder.}
	image_provider=${25:# When C(state) is I(exported) disk is exported to given Glance image provider.}
	host=${26:# When the hypervisor name is specified the newly created disk or an existing disk will refresh its information about the underlying storage( Disk size, Serial, Product ID, Vendor ID ...) The specified host will be used for gathering the storage related information. This option is only valid for passthrough disks. This option requires at least the logical_unit.id to be specified}
	wipe_after_delete=${27:# If the disk's Wipe After Delete is enabled, then the disk is first wiped.}
	activate=${28:# I(True) if the disk should be activated.}
	wait=${29:yes}
	fetch_nested=${30:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${31:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${32:180}
	poll_interval=${33:3}

endsnippet

snippet ovirt_snapshot_info "Retrieve information about one or more oVirt/RHV virtual machine snapshots" b
ovirt_snapshot_info: >
	vm=${1:# Name of the VM with snapshot.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	description=${3:# Description of the snapshot, can be used as glob expression.}
	snapshot_id=${4:# Id of the snapshot we want to retrieve information about.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_affinity_group "Module to manage affinity groups in oVirt/RHV" b
ovirt_affinity_group: >
	name=${1:# Name of the affinity group to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${3:absent|#present}
	cluster=${4:# Name of the cluster of the affinity group.}
	description=${5:# Description of the affinity group.}
	host_enforcing=${6:# If I(yes) VM cannot start on host if it does not satisfy the C(host_rule).}
	host_rule=${7:negative|positive}
	vm_enforcing=${8:# If I(yes) VM cannot start if it does not satisfy the C(vm_rule).}
	vm_rule=${9:disabled|negative|positive}
	vms=${10:# List of the VMs names, which should have assigned this affinity group.}
	hosts=${11:# List of the hosts names, which should have assigned this affinity group.}
	wait=${12:yes}
	fetch_nested=${13:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${14:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${15:180}
	poll_interval=${16:3}

endsnippet

snippet ovirt_storage_domain_info "Retrieve information about one or more oVirt/RHV storage domains" b
ovirt_storage_domain_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_quota "Module to manage datacenter quotas in oVirt/RHV" b
ovirt_quota: >
	name=${1:# Name of the quota to manage.}
	data_center=${2:# Name of the datacenter where quota should be managed.}
	auth=${3:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${4:# ID of the quota to manage.}
	state=${5:#present|absent}
	description=${6:# Description of the quota to manage.}
	cluster_threshold=${7:# Cluster threshold(soft limit) defined in percentage (0-100).}
	cluster_grace=${8:# Cluster grace(hard limit) defined in percentage (1-100).}
	storage_threshold=${9:# Storage threshold(soft limit) defined in percentage (0-100).}
	storage_grace=${10:# Storage grace(hard limit) defined in percentage (1-100).}
	clusters=${11:# List of dictionary of cluster limits, which is valid to specific cluster.}
	storages=${12:# List of dictionary of storage limits, which is valid to specific storage.}
	wait=${13:yes}
	fetch_nested=${14:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${15:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${16:180}
	poll_interval=${17:3}

endsnippet

snippet ovirt_api_info "Retrieve information about the oVirt/RHV API" b
ovirt_api_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	fetch_nested=${2:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${3:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_storage_domain_info "Retrieve information about one or more oVirt/RHV storage domains" b
ovirt_storage_domain_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_datacenter "Module to manage data centers in oVirt/RHV" b
ovirt_datacenter: >
	name=${1:# Name of the data center to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the datacenter to manage.}
	state=${4:#present|absent}
	description=${5:# Description of the data center.}
	comment=${6:# Comment of the data center.}
	local=${7:# I(True) if the data center should be local, I(False) if should be shared.}
	compatibility_version=${8:# Compatibility version of the data center.}
	quota_mode=${9:disabled|audit|enabled}
	mac_pool=${10:# MAC pool to be used by this datacenter.}
	force=${11:no}
	wait=${12:yes}
	fetch_nested=${13:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${14:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${15:180}
	poll_interval=${16:3}

endsnippet

snippet ovirt_affinity_label "Module to manage affinity labels in oVirt/RHV" b
ovirt_affinity_label: >
	name=${1:# Name of the affinity label to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${3:#present|absent}
	cluster=${4:# Name of the cluster where vms and hosts resides.}
	vms=${5:# List of the VMs names, which should have assigned this affinity label.}
	hosts=${6:# List of the hosts names, which should have assigned this affinity label.}
	wait=${7:yes}
	fetch_nested=${8:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${9:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${10:180}
	poll_interval=${11:3}

endsnippet

snippet ovirt_user_info "Retrieve information about one or more oVirt/RHV users" b
ovirt_user_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_scheduling_policy_info "Retrieve information about one or more oVirt scheduling policies" b
ovirt_scheduling_policy_info: >
	id=${1:# ID of the scheduling policy.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the scheduling policy, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_permission "Module to manage permissions of users/groups in oVirt/RHV" b
ovirt_permission: >
	authz_name=${1:# Authorization provider of the user/group.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	role=${3:UserRole}
	state=${4:absent|#present}
	object_id=${5:# ID of the object where the permissions should be managed.}
	object_name=${6:# Name of the object where the permissions should be managed.}
	object_type=${7:cluster|cpu_profile|data_center|disk|disk_profile|host|network|storage_domain|system|template|#vm|vm_pool|vnic_profile}
	user_name=${8:# Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
	group_name=${9:# Name of the group to manage.}
	namespace=${10:# Namespace of the authorization provider, where user/group resides.}
	quota_name=${11:# Name of the quota to assign permission. Works only with C(object_type) I(data_center).}
	wait=${12:yes}
	fetch_nested=${13:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${14:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${15:180}
	poll_interval=${16:3}

endsnippet

snippet ovirt_external_provider "Module to manage external providers in oVirt/RHV" b
ovirt_external_provider: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the external provider to manage.}
	state=${3:#present|absent}
	description=${4:# Description of the external provider.}
	type=${5:os_image|network|os_volume|foreman}
	url=${6:# URL where external provider is hosted.}
	username=${7:# Username to be used for login to external provider.}
	password=${8:# Password of the user specified in C(username) parameter.}
	tenant_name=${9:# Name of the tenant.}
	authentication_url=${10:# Keystone authentication URL of the openstack provider.}
	data_center=${11:# Name of the data center where provider should be attached.}
	read_only=${12:# Specify if the network should be read only.}
	network_type=${13:[#'external', 'neutron'}
	authentication_keys=${14:[]}
	wait=${15:yes}
	fetch_nested=${16:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${17:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${18:180}
	poll_interval=${19:3}

endsnippet

snippet ovirt_quota_info "Retrieve information about one or more oVirt/RHV quotas" b
ovirt_quota_info: >
	data_center=${1:# Name of the datacenter where quota resides.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the quota, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_tag_info "Retrieve information about one or more oVirt/RHV tags" b
ovirt_tag_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the tag which should be listed.}
	vm=${3:# Name of the VM, which tags should be listed.}
	host=${4:# Name of the host, which tags should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_cluster "Module to manage clusters in oVirt/RHV" b
ovirt_cluster: >
	name=${1:# Name of the cluster to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the cluster to manage.}
	state=${4:#present|absent}
	data_center=${5:# Datacenter name where cluster reside.}
	description=${6:# Description of the cluster.}
	comment=${7:# Comment of the cluster.}
	network=${8:# Management network of cluster to access cluster hosts.}
	ballooning=${9:# If I(True) enable memory balloon optimization. Memory balloon is used to re-distribute / reclaim the host memory based on VM needs in a dynamic way.}
	virt=${10:# If I(True), hosts in this cluster will be used to run virtual machines.}
	gluster=${11:# If I(True), hosts in this cluster will be used as Gluster Storage server nodes, and not for running virtual machines.}
	threads_as_cores=${12:# If I(True) the exposed host threads would be treated as cores which can be utilized by virtual machines.}
	ksm=${13:# I I(True) MoM enables to run Kernel Same-page Merging I(KSM) when necessary and when it can yield a memory saving benefit that outweighs its CPU cost.}
	ksm_numa=${14:# If I(True) enables KSM C(ksm) for best performance inside NUMA nodes.}
	ha_reservation=${15:# If I(True) enables the oVirt/RHV to monitor cluster capacity for highly available virtual machines.}
	trusted_service=${16:# If I(True) enables integration with an OpenAttestation server.}
	vm_reason=${17:# If I(True) enables an optional reason field when a virtual machine is shut down from the Manager, allowing the administrator to provide an explanation for the maintenance.}
	host_reason=${18:# If I(True) enables an optional reason field when a host is placed into maintenance mode from the Manager, allowing the administrator to provide an explanation for the maintenance.}
	memory_policy=${19:disabled|server|desktop}
	rng_sources=${20:# List that specify the random number generator devices that all hosts in the cluster will use.}
	spice_proxy=${21:# The proxy by which the SPICE client will connect to virtual machines.}
	fence_enabled=${22:# If I(True) enables fencing on the cluster.}
	fence_skip_if_gluster_bricks_up=${23:# A flag indicating if fencing should be skipped if Gluster bricks are up and running in the host being fenced.}
	fence_skip_if_gluster_quorum_not_met=${24:# A flag indicating if fencing should be skipped if Gluster bricks are up and running and Gluster quorum will not be met without those bricks.}
	fence_skip_if_sd_active=${25:# If I(True) any hosts in the cluster that are Non Responsive and still connected to storage will not be fenced.}
	fence_skip_if_connectivity_broken=${26:# If I(True) fencing will be temporarily disabled if the percentage of hosts in the cluster that are experiencing connectivity issues is greater than or equal to the defined threshold.}
	fence_connectivity_threshold=${27:# The threshold used by C(fence_skip_if_connectivity_broken).}
	resilience_policy=${28:do_not_migrate|migrate|migrate_highly_available}
	migration_bandwidth=${29:auto|hypervisor_default|custom}
	migration_bandwidth_limit=${30:# Set the I(custom) migration bandwidth limit.}
	migration_auto_converge=${31:true|false|inherit}
	migration_compressed=${32:true|false|inherit}
	migration_policy=${33:legacy|minimal_downtime|suspend_workload|post_copy}
	serial_policy=${34:# Specify a serial number policy for the virtual machines in the cluster.}
	serial_policy_value=${35:# Allows you to specify a custom serial number.}
	scheduling_policy=${36:# Name of the scheduling policy to be used for cluster.}
	scheduling_policy_properties=${37:# Custom scheduling policy properties of the cluster.}
	cpu_arch=${38:x86_64|ppc64|undefined}
	cpu_type=${39:# CPU codename. For example I(Intel SandyBridge Family).}
	switch_type=${40:legacy|ovs}
	compatibility_version=${41:# The compatibility version of the cluster. All hosts in this cluster must support at least this compatibility version.}
	mac_pool=${42:# MAC pool to be used by this cluster.}
	external_network_providers=${43:# List of references to the external network providers available in the cluster. If the automatic deployment of the external network provider is supported, the networks of the referenced network provider are available on every host in the cluster.}
	firewall_type=${44:firewalld|iptables}
	gluster_tuned_profile=${45:# The name of the U(https://fedorahosted.org/tuned) to set on all the hosts in the cluster. This is not mandatory and relevant only for clusters with Gluster service.}
	wait=${46:yes}
	fetch_nested=${47:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${48:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${49:180}
	poll_interval=${50:3}

endsnippet

snippet ovirt_storage_template_info "Retrieve information about one or more oVirt/RHV templates relate to a storage domain." b
ovirt_storage_template_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	unregistered=${2:no}
	max=${3:# Sets the maximum number of templates to return. If not specified all the templates are returned.}
	storage_domain=${4:# The storage domain name where the templates should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_tag_info "Retrieve information about one or more oVirt/RHV tags" b
ovirt_tag_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the tag which should be listed.}
	vm=${3:# Name of the VM, which tags should be listed.}
	host=${4:# Name of the host, which tags should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_host "Module to manage hosts in oVirt/RHV" b
ovirt_host: >
	name=${1:# Name of the host to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the host to manage.}
	state=${4:#present|absent|maintenance|upgraded|started|restarted|stopped|reinstalled|iscsidiscover|iscsilogin}
	comment=${5:# Description of the host.}
	timeout=${6:600}
	cluster=${7:# Name of the cluster, where host should be created.}
	address=${8:# Host address. It can be either FQDN (preferred) or IP address.}
	password=${9:# Password of the root. It's required in case C(public_key) is set to I(False).}
	public_key=${10:no}
	kdump_integration=${11:enabled|disabled}
	spm_priority=${12:# SPM priority of the host. Integer value from 1 to 10, where higher number means higher priority.}
	override_iptables=${13:# If True host iptables will be overridden by host deploy script.}
	force=${14:no}
	override_display=${15:# Override the display address of all VMs on this host with specified address.}
	kernel_params=${16:# List of kernel boot parameters.}
	hosted_engine=${17:deploy|undeploy}
	power_management_enabled=${18:# Enable or disable power management of the host.}
	activate=${19:yes}
	iscsi=${20:# If C(state) is I(iscsidiscover) it means that the iscsi attribute is being used to discover targets}
	check_upgrade=${21:yes}
	reboot_after_upgrade=${22:yes}
	vgpu_placement=${23:consolidated|separated}
	wait=${24:yes}
	fetch_nested=${25:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${26:# Specifies list of the attributes which should be fetched from the API.}
	poll_interval=${27:3}

endsnippet

snippet ovirt_host_pm "Module to manage power management of hosts in oVirt/RHV" b
ovirt_host_pm: >
	name=${1:# Name of the host to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${3:#present|absent}
	address=${4:# Address of the power management interface.}
	username=${5:# Username to be used to connect to power management interface.}
	password=${6:# Password of the user specified in C(username) parameter.}
	type=${7:# Type of the power management. oVirt/RHV predefined values are I(drac5), I(ipmilan), I(rsa), I(bladecenter), I(alom), I(apc), I(apc_snmp), I(eps), I(wti), I(rsb), I(cisco_ucs), I(drac7), I(hpblade), I(ilo), I(ilo2), I(ilo3), I(ilo4), I(ilo_ssh), but user can have defined custom type.}
	port=${8:# Power management interface port.}
	options=${9:# Dictionary of additional fence agent options (including Power Management slot).}
	encrypt_options=${10:# If I(true) options will be encrypted when send to agent.}
	order=${11:# Integer value specifying, by default it's added at the end.}
	wait=${12:yes}
	fetch_nested=${13:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${14:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${15:180}
	poll_interval=${16:3}

endsnippet

snippet ovirt_host_storage_info "Retrieve information about one or more oVirt/RHV HostStorages (applicable only for block storage)" b
ovirt_host_storage_info: >
	host=${1:# Host to get device list from.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	iscsi=${3:# Dictionary with values for iSCSI storage type:}
	fcp=${4:# Dictionary with values for fibre channel storage type:}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_host_info "Retrieve information about one or more oVirt/RHV hosts" b
ovirt_host_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	all_content=${3:no}
	cluster_version=${4:# Filter the hosts based on the cluster version.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_host_storage_info "Retrieve information about one or more oVirt/RHV HostStorages (applicable only for block storage)" b
ovirt_host_storage_info: >
	host=${1:# Host to get device list from.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	iscsi=${3:# Dictionary with values for iSCSI storage type:}
	fcp=${4:# Dictionary with values for fibre channel storage type:}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_nic "Module to manage network interfaces of Virtual Machines in oVirt/RHV" b
ovirt_nic: >
	name=${1:# Name of the network interface to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the nic to manage.}
	vm=${4:# Name of the Virtual Machine to manage.}
	template=${5:# Name of the template to manage.}
	state=${6:absent|plugged|#present|unplugged}
	network=${7:# Logical network to which the VM network interface should use, by default Empty network is used if network is not specified.}
	profile=${8:# Virtual network interface profile to be attached to VM network interface.}
	interface=${9:# Type of the network interface. For example e1000, pci_passthrough, rtl8139, rtl8139_virtio, spapr_vlan or virtio.}
	mac_address=${10:# Custom MAC address of the network interface, by default it's obtained from MAC pool.}
	linked=${11:# Defines if the NIC is linked to the virtual machine.}
	wait=${12:yes}
	fetch_nested=${13:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${14:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${15:180}
	poll_interval=${16:3}

endsnippet

snippet ovirt_storage_vm_info "Retrieve information about one or more oVirt/RHV virtual machines relate to a storage domain." b
ovirt_storage_vm_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	unregistered=${2:no}
	max=${3:# Sets the maximum number of virtual machines to return. If not specified all the virtual machines are returned.}
	storage_domain=${4:# The storage domain name where the virtual machines should be listed.}
	fetch_nested=${5:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${6:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_network_info "Retrieve information about one or more oVirt/RHV networks" b
ovirt_network_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_network "Module to manage logical networks in oVirt/RHV" b
ovirt_network: >
	name=${1:# Name of the network to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the network to manage.}
	state=${4:#present|absent}
	data_center=${5:# Datacenter name where network reside.}
	description=${6:# Description of the network.}
	comment=${7:# Comment of the network.}
	vlan_tag=${8:# Specify VLAN tag.}
	external_provider=${9:# Name of external network provider.}
	vm_network=${10:# If I(True) network will be marked as network for VM.}
	mtu=${11:# Maximum transmission unit (MTU) of the network.}
	clusters=${12:# List of dictionaries describing how the network is managed in specific cluster.}
	label=${13:# Name of the label to assign to the network.}
	wait=${14:yes}
	fetch_nested=${15:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${16:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${17:180}
	poll_interval=${18:3}

endsnippet

snippet ovirt_network_info "Retrieve information about one or more oVirt/RHV networks" b
ovirt_network_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_external_provider_info "Retrieve information about one or more oVirt/RHV external providers" b
ovirt_external_provider_info: >
	type=${1:os_image|os_network|os_volume|foreman}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${3:# Name of the external provider, can be used as glob expression.}
	fetch_nested=${4:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${5:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_template_info "Retrieve information about one or more oVirt/RHV templates" b
ovirt_template_info: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	pattern=${2:# Search term which is accepted by oVirt/RHV search backend.}
	fetch_nested=${3:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${4:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_event "Create or delete an event in oVirt/RHV" b
ovirt_event: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	state=${2:#present|absent}
	description=${3:# Message for the event.}
	severity=${4:error|#normal|warning}
	origin=${5:# Originator of the event.}
	custom_id=${6:# Custom ID for the event. This ID must be unique for each event.}
	id=${7:# The event ID in the oVirt/RHV audit_log table. This ID is not the same as custom_id and is only used when state is absent.}
	cluster=${8:# The id of the cluster associated with this event.}
	data_center=${9:# The id of the data center associated with this event.}
	host=${10:# The id of the host associated with this event.}
	storage_domain=${11:# The id of the storage domain associated with this event.}
	template=${12:# The id of the template associated with this event.}
	user=${13:# The id of the user associated with this event.}
	vm=${14:# The id of the VM associated with this event.}
	wait=${15:yes}
	fetch_nested=${16:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${17:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${18:180}
	poll_interval=${19:3}

endsnippet

snippet ovirt_permission_info "Retrieve information about one or more oVirt/RHV permissions" b
ovirt_permission_info: >
	authz_name=${1:# Authorization provider of the user/group. In previous versions of oVirt/RHV known as domain.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	user_name=${3:# Username of the user to manage. In most LDAPs it's I(uid) of the user, but in Active Directory you must specify I(UPN) of the user.}
	group_name=${4:# Name of the group to manage.}
	namespace=${5:# Namespace of the authorization provider, where user/group resides.}
	fetch_nested=${6:# If I(yes) the module will fetch additional data from the API.}
	nested_attributes=${7:# Specifies list of the attributes which should be fetched from the API.}

endsnippet

snippet ovirt_tag "Module to manage tags in oVirt/RHV" b
ovirt_tag: >
	name=${1:# Name of the tag to manage.}
	auth=${2:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	id=${3:# ID of the tag to manage.}
	state=${4:#present|absent|attached|detached}
	description=${5:# Description of the tag to manage.}
	parent=${6:# Name of the parent tag.}
	vms=${7:# List of the VMs names, which should have assigned this tag.}
	hosts=${8:# List of the hosts names, which should have assigned this tag.}
	wait=${9:yes}
	fetch_nested=${10:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${11:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${12:180}
	poll_interval=${13:3}

endsnippet

snippet ovirt_role "Module to manage roles in oVirt/RHV" b
ovirt_role: >
	auth=${1:# Dictionary with values needed to create HTTP/HTTPS connection to oVirt:}

	name=${2:# Name of the role to manage.}
	id=${3:# ID of the role to manage.}
	description=${4:# Description of the role.}
	state=${5:#present|absent}
	administrative=${6:# Defines the role as administrative-only or not.}
	permits=${7:# List of permits which role will have}
	wait=${8:yes}
	fetch_nested=${9:# If I(True) the module will fetch additional data from the API.}
	nested_attributes=${10:# Specifies list of the attributes which should be fetched from the API.}
	timeout=${11:180}
	poll_interval=${12:3}

endsnippet

snippet hcloud_ssh_key_info "Gather infos about your Hetzner Cloud ssh_keys." b
hcloud_ssh_key_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the ssh key you want to get.}
	name=${3:# The name of the ssh key you want to get.}
	fingerprint=${4:# The fingerprint of the ssh key you want to get.}
	label_selector=${5:# The label selector for the ssh key you want to get.}
	endpoint=${6:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_server_type_info "Gather infos about the Hetzner Cloud server types." b
hcloud_server_type_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the server type you want to get.}
	name=${3:# The name of the server type you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_server_type_info "Gather infos about the Hetzner Cloud server types." b
hcloud_server_type_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the server type you want to get.}
	name=${3:# The name of the server type you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_subnetwork "Manage cloud subnetworks on the Hetzner Cloud." b
hcloud_subnetwork: >
	network=${1:# The ID or Name  of the Hetzner Cloud Networks.}
	ip_range=${2:# IP range of the subnetwork.}
	type=${3:# Type of subnetwork.}
	network_zone=${4:# Name of network zone.}
	api_token=${5:# This is the API Token for the Hetzner Cloud.}

	state=${6:absent|#present}
	endpoint=${7:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_network_info "Gather info about your Hetzner Cloud networks." b
hcloud_network_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the network you want to get.}
	name=${3:# The name of the network you want to get.}
	label_selector=${4:# The label selector for the network you want to get.}
	endpoint=${5:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_server "Create and manage cloud servers on the Hetzner Cloud." b
hcloud_server: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the Hetzner Cloud server to manage.}
	name=${3:# The Name of the Hetzner Cloud server to manage.}
	server_type=${4:# The Server Type of the Hetzner Cloud server to manage.}
	ssh_keys=${5:# List of SSH key names}
	volumes=${6:# List of Volumes IDs that should be attached to the server on server creation.}
	image=${7:# Image the server should be created from.}
	location=${8:# Location of Server.}
	datacenter=${9:# Datacenter of Server.}
	backups=${10:no}
	upgrade_disk=${11:no}
	force_upgrade=${12:no}
	user_data=${13:# User Data to be passed to the server on creation.}
	rescue_mode=${14:# Add the Hetzner rescue system type you want the server to be booted into.}
	labels=${15:# User-defined labels (key-value pairs).}
	state=${16:absent|#present|restarted|started|stopped|rebuild}
	endpoint=${17:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_volume_info "Gather infos about your Hetzner Cloud volumes." b
hcloud_volume_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the volume you want to get.}
	name=${3:# The name of the volume you want to get.}
	label_selector=${4:# The label selector for the volume you want to get.}
	endpoint=${5:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_image_info "Gather infos about your Hetzner Cloud images." b
hcloud_image_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the image you want to get.}
	name=${3:# The name of the image you want to get.}
	label_selector=${4:# The label selector for the images you want to get.}
	type=${5:#system|snapshot|backup}
	endpoint=${6:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_floating_ip_info "Gather infos about the Hetzner Cloud Floating IPs." b
hcloud_floating_ip_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the Floating IP you want to get.}
	label_selector=${3:# The label selector for the Floating IP you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_network "Create and manage cloud Networks on the Hetzner Cloud." b
hcloud_network: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the Hetzner Cloud Networks to manage.}
	name=${3:# The Name of the Hetzner Cloud Network to manage.}
	ip_range=${4:# IP range of the Network.}
	labels=${5:# User-defined labels (key-value pairs).}
	state=${6:absent|#present}
	endpoint=${7:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_datacenter_info "Gather info about the Hetzner Cloud datacenters." b
hcloud_datacenter_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the datacenter you want to get.}
	name=${3:# The name of the datacenter you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_server_network "Manage the relationship between Hetzner Cloud Networks and servers" b
hcloud_server_network: >
	network=${1:# The name of the Hetzner Cloud Networks.}
	server=${2:# The name of the Hetzner Cloud server.}
	api_token=${3:# This is the API Token for the Hetzner Cloud.}

	ip=${4:# The IP the server should have.}
	alias_ips=${5:# Alias IPs the server has.}
	state=${6:absent|#present}
	endpoint=${7:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_volume_info "Gather infos about your Hetzner Cloud volumes." b
hcloud_volume_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the volume you want to get.}
	name=${3:# The name of the volume you want to get.}
	label_selector=${4:# The label selector for the volume you want to get.}
	endpoint=${5:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_rdns "Create and manage reverse DNS entries on the Hetzner Cloud." b
hcloud_rdns: >
	server=${1:# The name of the Hetzner Cloud server you want to add the reverse DNS entry to.}
	ip_address=${2:# The IP address that should point to I(dns_ptr).}
	api_token=${3:# This is the API Token for the Hetzner Cloud.}

	dns_ptr=${4:# The DNS address the I(ip_address) should resolve to.}
	state=${5:absent|#present}
	endpoint=${6:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_location_info "Gather infos about your Hetzner Cloud locations." b
hcloud_location_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the location you want to get.}
	name=${3:# The name of the location you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_datacenter_info "Gather info about the Hetzner Cloud datacenters." b
hcloud_datacenter_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the datacenter you want to get.}
	name=${3:# The name of the datacenter you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_ssh_key_info "Gather infos about your Hetzner Cloud ssh_keys." b
hcloud_ssh_key_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the ssh key you want to get.}
	name=${3:# The name of the ssh key you want to get.}
	fingerprint=${4:# The fingerprint of the ssh key you want to get.}
	label_selector=${5:# The label selector for the ssh key you want to get.}
	endpoint=${6:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_route "Create and delete cloud routes on the Hetzner Cloud." b
hcloud_route: >
	network=${1:# The name of the Hetzner Cloud Network.}
	destination=${2:# Destination network or host of this route.}
	gateway=${3:# Gateway for the route.}
	api_token=${4:# This is the API Token for the Hetzner Cloud.}

	state=${5:absent|#present}
	endpoint=${6:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_location_info "Gather infos about your Hetzner Cloud locations." b
hcloud_location_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the location you want to get.}
	name=${3:# The name of the location you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_volume "Create and manage block volumes on the Hetzner Cloud." b
hcloud_volume: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the Hetzner Cloud Block Volume to manage.}
	name=${3:# The Name of the Hetzner Cloud Block Volume to manage.}
	size=${4:# The size of the Block Volume in GB.}
	automount=${5:# Automatically mount the Volume.}
	format=${6:xfs|ext4}
	location=${7:# Location of the Hetzner Cloud Volume.}
	server=${8:# Server Name the Volume should be assigned to.}
	labels=${9:# User-defined key-value pairs.}
	state=${10:absent|#present}
	endpoint=${11:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_floating_ip_info "Gather infos about the Hetzner Cloud Floating IPs." b
hcloud_floating_ip_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the Floating IP you want to get.}
	label_selector=${3:# The label selector for the Floating IP you want to get.}
	endpoint=${4:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_server_info "Gather infos about your Hetzner Cloud servers." b
hcloud_server_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the server you want to get.}
	name=${3:# The name of the server you want to get.}
	label_selector=${4:# The label selector for the server you want to get.}
	endpoint=${5:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_ssh_key "Create and manage ssh keys on the Hetzner Cloud." b
hcloud_ssh_key: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the Hetzner Cloud ssh_key to manage.}
	name=${3:# The Name of the Hetzner Cloud ssh_key to manage.}
	fingerprint=${4:# The Fingerprint of the Hetzner Cloud ssh_key to manage.}
	labels=${5:# User-defined labels (key-value pairs)}
	public_key=${6:# The Public Key to add.}
	state=${7:absent|#present}
	endpoint=${8:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_server_info "Gather infos about your Hetzner Cloud servers." b
hcloud_server_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the server you want to get.}
	name=${3:# The name of the server you want to get.}
	label_selector=${4:# The label selector for the server you want to get.}
	endpoint=${5:https://api.hetzner.cloud/v1}

endsnippet

snippet hcloud_image_info "Gather infos about your Hetzner Cloud images." b
hcloud_image_info: >
	api_token=${1:# This is the API Token for the Hetzner Cloud.}

	id=${2:# The ID of the image you want to get.}
	name=${3:# The name of the image you want to get.}
	label_selector=${4:# The label selector for the images you want to get.}
	type=${5:#system|snapshot|backup}
	endpoint=${6:https://api.hetzner.cloud/v1}

endsnippet

snippet packet_device "Manage a bare metal server in the Packet Host." b
packet_device: >
	project_id=${1:# ID of project of the device.}

	auth_token=${2:# Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).}
	count=${3:1}
	count_offset=${4:1}
	device_ids=${5:# List of device IDs on which to operate.}
	facility=${6:# Facility slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/facilities/).}
	features=${7:# Dict with "features" for device creation. See Packet API docs for details.}
	hostnames=${8:# A hostname of a device, or a list of hostnames.}
	locked=${9:no}
	operating_system=${10:# OS slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/operatingsystems/).}
	plan=${11:# Plan slug for device creation. See Packet API for current list - U(https://www.packet.net/developers/api/plans/).}
	state=${12:#present|absent|active|inactive|rebooted}
	user_data=${13:# Userdata blob made available to the machine}
	wait_for_public_IPv=${14:4|6}
	wait_timeout=${15:900}
	ipxe_script_url=${16:# URL of custom iPXE script for provisioning.}
	always_pxe=${17:no}

endsnippet

snippet packet_sshkey "Create/delete an SSH key in Packet host." b
packet_sshkey: >
	state=${1:#present|absent}
	auth_token=${2:# Packet api token. You can also supply it in env var C(PACKET_API_TOKEN).}
	label=${3:# Label for the key. If you keep it empty, it will be read from key string.}
	id=${4:# UUID of the key which you want to remove.}
	fingerprint=${5:# Fingerprint of the key which you want to remove.}
	key=${6:# Public Key string ({type} {base64 encoded key} {description}).}
	key_file=${7:# File with the public key.}

endsnippet

snippet udm_user "Manage posix users on a univention corporate server" b
udm_user: >
	username=${1:# User name}

	state=${2:#present|absent}
	firstname=${3:# First name. Required if C(state=present).}
	lastname=${4:# Last name. Required if C(state=present).}
	password=${5:# Password. Required if C(state=present).}
	birthday=${6:# Birthday}
	city=${7:# City of users business address.}
	country=${8:# Country of users business address.}
	department_number=${9:# Department number of users business address.}
	description=${10:# Description (not gecos)}
	display_name=${11:# Display name (not gecos)}
	email=${12:[]}
	employee_number=${13:# Employee number}
	employee_type=${14:# Employee type}
	gecos=${15:# GECOS}
	groups=${16:[]}
	home_share=${17:# Home NFS share. Must be a LDAP DN, e.g. C(cn=home,cn=shares,ou=school,dc=example,dc=com).}
	home_share_path=${18:# Path to home NFS share, inside the homeShare.}
	home_telephone_number=${19:[]}
	homedrive=${20:# Windows home drive, e.g. C("H:").}
	mail_alternative_address=${21:[]}
	mail_home_server=${22:# FQDN of mail server}
	mail_primary_address=${23:# Primary e-mail address}
	mobile_telephone_number=${24:[]}
	organisation=${25:# Organisation}
	override_pw_history=${26:no}
	override_pw_length=${27:no}
	pager_telephonenumber=${28:[]}
	phone=${29:# List of telephone numbers.}
	postcode=${30:# Postal code of users business address.}
	primary_group=${31:cn=Domain Users,cn=groups,$LDAP_BASE_DN}
	profilepath=${32:# Windows profile directory}
	pwd_change_next_login=${33:0|1}
	room_number=${34:# Room number of users business address.}
	samba_privileges=${35:# Samba privilege, like allow printer administration, do domain join.}
	samba_user_workstations=${36:# Allow the authentication only on this Microsoft Windows host.}
	sambahome=${37:# Windows home path, e.g. C('\\$FQDN\$USERNAME').}
	scriptpath=${38:# Windows logon script.}
	secretary=${39:[]}
	serviceprovider=${40:[]}
	shell=${41:/bin/bash}
	street=${42:# Street of users business address.}
	title=${43:# Title, e.g. C(Prof.).}
	unixhome=${44:/home/$USERNAME}
	userexpiry=${45:Today + 1 year}
	position=${46:}
	update_password=${47:always}
	ou=${48:}
	subpath=${49:cn=users}

endsnippet

snippet udm_share "Manage samba shares on a univention corporate server" b
udm_share: >
	name=${1:# Name}
	ou=${2:# Organisational unit, inside the LDAP Base DN.}

	state=${3:#present|absent}
	host=${4:# Host FQDN (server which provides the share), e.g. C({{ ansible_fqdn }}). Required if C(state=present).}
	path=${5:# Directory on the providing server, e.g. C(/home). Required if C(state=present).}
	samba_name=${6:# Windows name. Required if C(state=present).}
	owner=${7:0}
	group=${8:0}
	directorymode=${9:00755}
	root_squash=${10:0|#1}
	subtree_checking=${11:0|#1}
	sync=${12:sync}
	writeable=${13:0|#1}
	samba_block_size=${14:# Blocking size.}
	samba_blocking_locks=${15:0|#1}
	samba_browseable=${16:0|#1}
	samba_create_mode=${17:0744}
	samba_csc_policy=${18:manual}
	samba_custom_settings=${19:[]}
	samba_directory_mode=${20:0755}
	samba_directory_security_mode=${21:0777}
	samba_dos_filemode=${22:#0|1}
	samba_fake_oplocks=${23:#0|1}
	samba_force_create_mode=${24:#0|1}
	samba_force_directory_mode=${25:#0|1}
	samba_force_directory_security_mode=${26:#0|1}
	samba_force_group=${27:# Force group.}
	samba_force_security_mode=${28:#0|1}
	samba_force_user=${29:# Force user.}
	samba_hide_files=${30:# Hide files.}
	samba_hide_unreadable=${31:#0|1}
	samba_hosts_allow=${32:[]}
	samba_hosts_deny=${33:[]}
	samba_inherit_acls=${34:0|#1}
	samba_inherit_owner=${35:#0|1}
	samba_inherit_permissions=${36:#0|1}
	samba_invalid_users=${37:# Invalid users or groups.}
	samba_level_2_oplocks=${38:0|#1}
	samba_locking=${39:0|#1}
	samba_msdfs_root=${40:#0|1}
	samba_nt_acl_support=${41:0|#1}
	samba_oplocks=${42:0|#1}
	samba_postexec=${43:# Postexec script.}
	samba_preexec=${44:# Preexec script.}
	samba_public=${45:#0|1}
	samba_security_mode=${46:0777}
	samba_strict_locking=${47:Auto}
	samba_vfs_objects=${48:# VFS objects.}
	samba_valid_users=${49:# Valid users or groups.}
	samba_write_list=${50:# Restrict write access to these users/groups.}
	samba_writeable=${51:0|#1}
	nfs_hosts=${52:[]}
	nfs_custom_settings=${53:[]}

endsnippet

snippet udm_group "Manage of the posix group" b
udm_group: >
	name=${1:# Name of the posix group.}

	state=${2:#present|absent}
	description=${3:# Group description.}
	position=${4:# define the whole ldap position of the group, e.g. C(cn=g123m-1A,cn=classes,cn=schueler,cn=groups,ou=schule,dc=example,dc=com).}
	ou=${5:# LDAP OU, e.g. school for LDAP OU C(ou=school,dc=example,dc=com).}
	subpath=${6:# Subpath inside the OU, e.g. C(cn=classes,cn=students,cn=groups).}

endsnippet

snippet udm_dns_record "Manage dns entries on a univention corporate server" b
udm_dns_record: >
	name=${1:# Name of the record, this is also the DNS record. E.g. www for www.example.com.}
	zone=${2:# Corresponding DNS zone for this record, e.g. example.com.}
	type=${3:host_record|alias|ptr_record|srv_record|txt_record}

	state=${4:#present|absent}
	data=${5:[]}

endsnippet

snippet udm_dns_zone "Manage dns zones on a univention corporate server" b
udm_dns_zone: >
	type=${1:forward_zone|reverse_zone}
	zone=${2:# DNS zone name, e.g. C(example.com).}

	state=${3:#present|absent}
	nameserver=${4:# List of appropriate name servers. Required if C(state=present).}
	interfaces=${5:# List of interface IP addresses, on which the server should response this zone. Required if C(state=present).}
	refresh=${6:3600}
	retry=${7:1800}
	expire=${8:604800}
	ttl=${9:600}
	contact=${10:}
	mx=${11:[]}

endsnippet

snippet one_image "Manages OpenNebula images" b
one_image: >
	api_url=${1:# URL of the OpenNebula RPC server.}
	api_username=${2:# Name of the user to login into the OpenNebula RPC server. If not set}
	api_password=${3:# Password of the user to login into OpenNebula RPC server. If not set}
	id=${4:# A C(id) of the image you would like to manage.}
	name=${5:# A C(name) of the image you would like to manage.}
	state=${6:#present|absent|cloned|renamed}
	enabled=${7:# Whether the image should be enabled or disabled.}
	new_name=${8:# A name that will be assigned to the existing or new image.}

endsnippet

snippet one_image_info "Gather information on OpenNebula images" b
one_image_info: >
	api_url=${1:# URL of the OpenNebula RPC server.}
	api_username=${2:# Name of the user to login into the OpenNebula RPC server. If not set}
	api_password=${3:# Password of the user to login into OpenNebula RPC server. If not set}
	ids=${4:# A list of images ids whose facts you want to gather.}
	name=${5:# A C(name) of the image whose facts will be gathered.}

endsnippet

snippet one_image_info "Gather information on OpenNebula images" b
one_image_info: >
	api_url=${1:# URL of the OpenNebula RPC server.}
	api_username=${2:# Name of the user to login into the OpenNebula RPC server. If not set}
	api_password=${3:# Password of the user to login into OpenNebula RPC server. If not set}
	ids=${4:# A list of images ids whose facts you want to gather.}
	name=${5:# A C(name) of the image whose facts will be gathered.}

endsnippet

snippet one_vm "Creates or terminates OpenNebula instances" b
one_vm: >
	api_url=${1:# URL of the OpenNebula RPC server.}
	api_username=${2:# Name of the user to login into the OpenNebula RPC server. If not set}
	api_password=${3:# Password of the user to login into OpenNebula RPC server. If not set}
	template_name=${4:# Name of VM template to use to create a new instace}
	template_id=${5:# ID of a VM template to use to create a new instance}
	vm_start_on_hold=${6:no}
	instance_ids=${7:# A list of instance ids used for states':' C(absent), C(running), C(rebooted), C(poweredoff)}
	state=${8:#present|absent|running|rebooted|poweredoff}
	hard=${9:no}
	wait=${10:yes}
	wait_timeout=${11:300}
	attributes=${12:{}}
	labels=${13:[]}
	count_attributes=${14:# A dictionary of key/value attributes that can only be used with}
	count_labels=${15:# A list of labels that can only be used with C(exact_count) to determine}
	count=${16:1}
	exact_count=${17:# Indicates how many instances that match C(count_attributes) and}
	mode=${18:# Set permission mode of the instance in octet format, e.g. C(600) to give owner C(use) and C(manage) and nothing to group and others.}
	owner_id=${19:# ID of the user which will be set as the owner of the instance}
	group_id=${20:# ID of the group which will be set as the group of the instance}
	memory=${21:# The size of the memory for new instances (in MB, GB, ...)}
	disk_size=${22:# The size of the disk created for new instances (in MB, GB, TB,...).}
	cpu=${23:# Percentage of CPU divided by 100 required for the new instance. Half a}
	vcpu=${24:# Number of CPUs (cores) new VM will have.}
	networks=${25:[]}
	disk_saveas=${26:# Creates an image from a VM disk.}

endsnippet

snippet one_service "Deploy and manage OpenNebula services" b
one_service: >
	api_url=${1:# URL of the OpenNebula OneFlow API server.}
	api_username=${2:# Name of the user to login into the OpenNebula OneFlow API server. If not set then the value of the C(ONEFLOW_USERNAME) environment variable is used.}
	api_password=${3:# Password of the user to login into OpenNebula OneFlow API server. If not set then the value of the C(ONEFLOW_PASSWORD) environment variable is used.}
	template_name=${4:# Name of service template to use to create a new instance of a service}
	template_id=${5:# ID of a service template to use to create a new instance of a service}
	service_id=${6:# ID of a service instance that you would like to manage}
	service_name=${7:# Name of a service instance that you would like to manage}
	unique=${8:no}
	state=${9:#present|absent}
	mode=${10:# Set permission mode of a service instance in octet format, e.g. C(600) to give owner C(use) and C(manage) and nothing to group and others.}
	owner_id=${11:# ID of the user which will be set as the owner of the service}
	group_id=${12:# ID of the group which will be set as the group of the service}
	wait=${13:no}
	wait_timeout=${14:300}
	custom_attrs=${15:{}}
	role=${16:# Name of the role whose cardinality should be changed}
	cardinality=${17:# Number of VMs for the specified role}
	force=${18:no}

endsnippet

snippet one_host "Manages OpenNebula Hosts" b
one_host: >
	name=${1:# Hostname of the machine to manage.}

	state=${2:absent|#present|enabled|disabled|offline}
	im_mad_name=${3:kvm}
	vmm_mad_name=${4:kvm}
	cluster_id=${5:0}
	cluster_name=${6:# The cluster specified by name.}
	labels=${7:# The labels for this host.}
	template=${8:# The template or attribute changes to merge into the host template.}
	api_url=${9:# The ENDPOINT URL of the XMLRPC server.}
	api_username=${10:# The name of the user for XMLRPC authentication.}
	api_password=${11:# The password or token for XMLRPC authentication.}
	validate_certs=${12:yes}
	wait_timeout=${13:300}

endsnippet

snippet vmware_guest_powerstate "Manages power states of virtual machines in vCenter" b
vmware_guest_powerstate: >
	state=${1:powered-off|powered-on|reboot-guest|restarted|shutdown-guest|suspended|#present}
	name=${2:# Name of the virtual machine to work with.}
	name_match=${3:#first|last}
	uuid=${4:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	moid=${5:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${6:no}
	folder=${7:# Destination folder, absolute or relative path to find an existing guest.}
	scheduled_at=${8:# Date and time in string format at which specified task needs to be performed.}
	schedule_task_name=${9:# Name of schedule task.}
	schedule_task_description=${10:# Description of schedule task.}
	schedule_task_enabled=${11:yes}
	force=${12:no}
	state_change_timeout=${13:0}
	hostname=${14:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${15:# The username of the vSphere vCenter or ESXi server.}
	password=${16:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${17:yes}
	port=${18:443}
	proxy_host=${19:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${20:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_tag_info "Manage VMware tag info" b
vmware_tag_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter server.}
	username=${2:# The username of the vSphere vCenter server.}
	password=${3:# The password of the vSphere vCenter server.}
	validate_certs=${4:yes}
	protocol=${5:http|#https}

endsnippet

snippet vmware_cluster_ha "Manage High Availability (HA) on VMware vSphere clusters" b
vmware_cluster_ha: >
	cluster_name=${1:# The name of the cluster to be managed.}
	datacenter=${2:# The name of the datacenter.}

	enable_ha=${3:no}
	ha_host_monitoring=${4:#enabled|disabled}
	ha_vm_monitoring=${5:vmAndAppMonitoring|vmMonitoringOnly|#vmMonitoringDisabled}
	host_isolation_response=${6:#none|powerOff|shutdown}
	slot_based_admission_control=${7:# Configure slot based admission control policy.}
	reservation_based_admission_control=${8:# Configure reservation based admission control policy.}
	failover_host_admission_control=${9:# Configure dedicated failover hosts.}
	ha_vm_failure_interval=${10:30}
	ha_vm_min_up_time=${11:120}
	ha_vm_max_failures=${12:3}
	ha_vm_max_failure_window=${13:-1}
	ha_restart_priority=${14:disabled|high|low|#medium}
	hostname=${15:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${16:# The username of the vSphere vCenter or ESXi server.}
	password=${17:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${18:yes}
	port=${19:443}
	proxy_host=${20:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${21:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_snapshot_info "Gather info about virtual machine's snapshots in vCenter" b
vmware_guest_snapshot_info: >
	datacenter=${1:# Name of the datacenter.}

	name=${2:# Name of the VM to work with.}
	uuid=${3:# UUID of the instance to manage if known, this is VMware's BIOS UUID by default.}
	moid=${4:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${5:no}
	folder=${6:# Destination folder, absolute or relative path to find an existing guest.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_content_deploy_template "Deploy Virtual Machine from template stored in content library." b
vmware_content_deploy_template: >
	template=${1:# The name of template from which VM to be deployed.}
	name=${2:# The name of the VM to be deployed.}
	datacenter=${3:# Name of the datacenter, where VM to be deployed.}
	datastore=${4:# Name of the datastore to store deployed VM and disk.}
	folder=${5:# Name of the folder in datacenter in which to place deployed VM.}
	host=${6:# Name of the ESX Host in datacenter in which to place deployed VM.}

	resource_pool=${7:# Name of the resourcepool in datacenter in which to place deployed VM.}
	cluster=${8:# Name of the cluster in datacenter in which to place deployed VM.}
	state=${9:#present|poweredon}
	hostname=${10:# The hostname or IP address of the vSphere vCenter server.}
	username=${11:# The username of the vSphere vCenter server.}
	password=${12:# The password of the vSphere vCenter server.}
	validate_certs=${13:yes}
	protocol=${14:http|#https}

endsnippet

snippet vmware_host_vmnic_info "Gathers info about vmnics available on the given ESXi host" b
vmware_host_vmnic_info: >
	capabilities=${1:no}
	directpath_io=${2:no}
	sriov=${3:no}
	esxi_hostname=${4:# Name of the host system to work with.}
	cluster_name=${5:# Name of the cluster from which all host systems will be used.}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vca_fw "add remove firewall rules in a gateway  in a vca" b
vca_fw: >
	fw_rules=${1:no}

	username=${2:# The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.}
	password=${3:# The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.}
	org=${4:# The org to login to for creating vapp.}
	instance_id=${5:# The instance ID in a vchs environment to be used for creating the vapp.}
	host=${6:# The authentication host to be used when service type is vcd.}
	api_version=${7:5.7}
	service_type=${8:#vca|vcd|vchs}
	state=${9:absent|#present}
	validate_certs=${10:yes}
	vdc_name=${11:# The name of the vdc where the gateway is located.}
	gateway_name=${12:gateway}

endsnippet

snippet vmware_vcenter_statistics "Configures statistics on a vCenter server" b
vmware_vcenter_statistics: >
	interval_past_day=${1:# Settings for vCenter server past day statistic collection.}
	interval_past_week=${2:# Settings for vCenter server past week statistic collection.}
	interval_past_month=${3:# Settings for vCenter server past month statistic collection.}
	interval_past_year=${4:# Settings for vCenter server past month statistic collection.}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_datastore_maintenancemode "Place a datastore into maintenance mode" b
vmware_datastore_maintenancemode: >
	datastore=${1:# Name of datastore to manage.}
	datastore_cluster=${2:# Name of the datastore cluster from all child datastores to be managed.}
	cluster_name=${3:# Name of the cluster where datastore is connected to.}
	state=${4:#present|absent}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_custom_attribute_defs "Manage custom attributes definitions for virtual machine from VMware" b
vmware_guest_custom_attribute_defs: >
	state=${1:#present|absent}

	attribute_key=${2:# Name of the custom attribute definition.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_boot_manager "Manage boot options for the given virtual machine" b
vmware_guest_boot_manager: >
	name=${1:# Name of the VM to work with.}
	uuid=${2:# UUID of the instance to manage if known, this is VMware's BIOS UUID by default.}
	moid=${3:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${4:no}
	boot_order=${5:[]}
	name_match=${6:#first|last}
	boot_delay=${7:0}
	enter_bios_setup=${8:no}
	boot_retry_enabled=${9:no}
	boot_retry_delay=${10:0}
	boot_firmware=${11:bios|efi}
	secure_boot_enabled=${12:no}
	hostname=${13:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${14:# The username of the vSphere vCenter or ESXi server.}
	password=${15:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${16:yes}
	port=${17:443}
	proxy_host=${18:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${19:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_datastore_info "Gather info about datastores available in given vCenter" b
vmware_datastore_info: >
	name=${1:# Name of the datastore to match.}
	datacenter=${2:# Datacenter to search for datastores.}
	cluster=${3:# Cluster to search for datastores.}
	gather_nfs_mount_info=${4:no}
	gather_vmfs_mount_info=${5:no}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_object_role_permission "Manage local roles on an ESXi host" b
vmware_object_role_permission: >
	role=${1:# The role to be assigned permission.}
	object_name=${2:# The object name to assigned permission.}

	principal=${3:# The user to be assigned permission.}
	group=${4:# The group to be assigned permission.}
	object_type=${5:#Folder|VirtualMachine|Datacenter|ResourcePool|Datastore|Network|HostSystem|ComputeResource|ClusterComputeResource|DistributedVirtualSwitch}
	recursive=${6:yes}
	state=${7:#present|absent}
	hostname=${8:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${9:# The username of the vSphere vCenter or ESXi server.}
	password=${10:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${11:yes}
	port=${12:443}
	proxy_host=${13:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${14:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_snapshot_info "Gather info about virtual machine's snapshots in vCenter" b
vmware_guest_snapshot_info: >
	datacenter=${1:# Name of the datacenter.}

	name=${2:# Name of the VM to work with.}
	uuid=${3:# UUID of the instance to manage if known, this is VMware's BIOS UUID by default.}
	moid=${4:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${5:no}
	folder=${6:# Destination folder, absolute or relative path to find an existing guest.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_ssl_info "Gather info of ESXi host system about SSL" b
vmware_host_ssl_info: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_sendkey "Send USB HID codes to the Virtual Machine's keyboard." b
vmware_guest_sendkey: >
	name=${1:# Name of the virtual machine.}
	uuid=${2:# UUID of the instance to gather facts if known, this is VMware's unique identifier.}
	moid=${3:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${4:# Destination folder, absolute or relative path to find an existing guest.}
	cluster=${5:# The name of cluster where the virtual machine is running.}
	esxi_hostname=${6:# The ESXi hostname where the virtual machine is running.}
	datacenter=${7:# The datacenter name to which virtual machine belongs to.}
	string_send=${8:# The string will be sent to the virtual machine.}
	keys_send=${9:# The list of the keys will be sent to the virtual machine.}
	hostname=${10:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${11:# The username of the vSphere vCenter or ESXi server.}
	password=${12:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${13:yes}
	port=${14:443}
	proxy_host=${15:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${16:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_screenshot "Create a screenshot of the Virtual Machine console." b
vmware_guest_screenshot: >
	name=${1:# Name of the virtual machine.}
	uuid=${2:# UUID of the instance to gather facts if known, this is VMware's unique identifier.}
	moid=${3:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${4:# Destination folder, absolute or relative path to find an existing guest.}
	cluster=${5:# The name of cluster where the virtual machine is running.}
	esxi_hostname=${6:# The ESXi hostname where the virtual machine is running.}
	datacenter=${7:# The datacenter name to which virtual machine belongs to.}
	local_path=${8:# If C(local_path) is not set, the created screenshot file will be kept in the directory of the virtual machine on ESXi host. If C(local_path) is set to a valid path on local machine, then the screenshot file will be downloaded from ESXi host to the local directory.}
	hostname=${9:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${10:# The username of the vSphere vCenter or ESXi server.}
	password=${11:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${12:yes}
	port=${13:443}
	proxy_host=${14:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${15:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_tag_manager "Manage association of VMware tags with VMware objects" b
vmware_tag_manager: >
	tag_names=${1:# List of tag(s) to be managed.}
	object_type=${2:VirtualMachine|Datacenter|ClusterComputeResource|HostSystem|DistributedVirtualSwitch|DistributedVirtualPortgroup}
	object_name=${3:# Name of the object to work with.}

	state=${4:present|absent|#add|remove|set}
	hostname=${5:# The hostname or IP address of the vSphere vCenter server.}
	username=${6:# The username of the vSphere vCenter server.}
	password=${7:# The password of the vSphere vCenter server.}
	validate_certs=${8:yes}
	protocol=${9:http|#https}

endsnippet

snippet vmware_guest_vnc "Manages VNC remote display on virtual machines in vCenter" b
vmware_guest_vnc: >
	datacenter=${1:ha-datacenter}
	state=${2:#present|absent}
	name=${3:# Name of the virtual machine to work with.}
	name_match=${4:#first|last}
	uuid=${5:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	moid=${6:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${7:# Destination folder, absolute or relative path to find an existing guest.}
	vnc_ip=${8:0.0.0.0}
	vnc_port=${9:0}
	vnc_password=${10:}
	hostname=${11:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${12:# The username of the vSphere vCenter or ESXi server.}
	password=${13:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${14:yes}
	port=${15:443}
	proxy_host=${16:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${17:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_powerstate "Manages power states of host systems in vCenter" b
vmware_host_powerstate: >
	state=${1:power-down-to-standby|power-up-from-standby|#shutdown-host|reboot-host}
	esxi_hostname=${2:# Name of the host system to work with.}
	cluster_name=${3:# Name of the cluster from which all host systems will be used.}
	force=${4:no}
	timeout=${5:600}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_drs_group_info "Gathers info about DRS VM/Host groups on the given cluster" b
vmware_drs_group_info: >
	datacenter=${1:# Datacenter to search for DRS VM/Host groups.}

	cluster_name=${2:# Cluster to search for VM/Host groups.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vcenter_extension_info "Gather info vCenter extensions" b
vcenter_extension_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${2:# The username of the vSphere vCenter or ESXi server.}
	password=${3:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${4:yes}
	port=${5:443}
	proxy_host=${6:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${7:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vmotion "Move a virtual machine using vMotion, and/or its vmdks using storage vMotion." b
vmware_vmotion: >
	vm_name=${1:# Name of the VM to perform a vMotion on.}
	vm_uuid=${2:# UUID of the virtual machine to perform a vMotion operation on.}
	moid=${3:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${4:no}
	destination_host=${5:# Name of the destination host the virtual machine should be running on.}
	destination_datastore=${6:# Name of the destination datastore the virtual machine's vmdk should be moved on.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vswitch_info "Gathers info about an ESXi host's vswitch configurations" b
vmware_vswitch_info: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname to gather information from.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_vmhba_info "Gathers info about vmhbas available on the given ESXi host" b
vmware_host_vmhba_info: >
	esxi_hostname=${1:# Name of the host system to work with.}
	cluster_name=${2:# Name of the cluster from which all host systems will be used.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vsphere_copy "Copy a file to a VMware datastore" b
vsphere_copy: >
	src=${1:# The file to push to vCenter.}
	datastore=${2:# The datastore to push files to.}
	path=${3:# The file to push to the datastore.}

	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	port=${5:443}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	datacenter=${7:# The datacenter on the vCenter server that holds the datastore.}
	timeout=${8:10}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_about_info "Provides information about VMware server to which user is connecting to" b
vmware_about_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${2:# The username of the vSphere vCenter or ESXi server.}
	password=${3:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${4:yes}
	port=${5:443}
	proxy_host=${6:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${7:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_tools_wait "Wait for VMware tools to become available" b
vmware_guest_tools_wait: >
	name=${1:# Name of the VM for which to wait until the tools become available.}
	name_match=${2:#first|last}
	folder=${3:# Destination folder, absolute or relative path to find an existing guest.}
	uuid=${4:# UUID of the VM  for which to wait until the tools become available, if known. This is VMware's unique identifier.}
	moid=${5:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${6:no}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_firewall_manager "Manage firewall configurations about an ESXi host" b
vmware_host_firewall_manager: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	rules=${3:[]}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_facts "Gathers facts about remote ESXi hostsystem" b
vmware_host_facts: >
	esxi_hostname=${1:# ESXi hostname.}
	show_tag=${2:no}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_cluster_drs "Manage Distributed Resource Scheduler (DRS) on VMware vSphere clusters" b
vmware_cluster_drs: >
	cluster_name=${1:# The name of the cluster to be managed.}
	datacenter=${2:# The name of the datacenter.}

	enable_drs=${3:no}
	drs_enable_vm_behavior_overrides=${4:yes}
	drs_default_vm_behavior=${5:#fullyAutomated|manual|partiallyAutomated}
	drs_vmotion_rate=${6:1|2|#3|4|5}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvs_portgroup "Create or remove a Distributed vSwitch portgroup." b
vmware_dvs_portgroup: >
	portgroup_name=${1:# The name of the portgroup that is to be created or deleted.}
	switch_name=${2:# The name of the distributed vSwitch the port group should be created on.}
	vlan_id=${3:# The VLAN ID that should be configured with the portgroup, use 0 for no VLAN.}
	num_ports=${4:# The number of ports the portgroup should contain.}
	portgroup_type=${5:earlyBinding|lateBinding|ephemeral}
	state=${6:present|absent}

	vlan_trunk=${7:no}
	network_policy=${8:{'promiscuous': False, 'forged_transmits': False, 'mac_changes': False}}
	teaming_policy=${9:{'notify_switches': True, 'load_balance_policy': 'loadbalance_srcid', 'inbound_policy': False, 'rolling_order': False}}
	port_policy=${10:{'traffic_filter_override': False, 'network_rp_override': False, 'live_port_move': False, 'security_override': False, 'vendor_config_override': False, 'port_config_reset_at_disconnect': True, 'uplink_teaming_override': False, 'block_override': True, 'shaping_override': False, 'vlan_override': False, 'ipfix_override': False}}
	hostname=${11:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${12:# The username of the vSphere vCenter or ESXi server.}
	password=${13:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${14:yes}
	port=${15:443}
	proxy_host=${16:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${17:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_disk "Manage disks related to virtual machine in given vCenter infrastructure" b
vmware_guest_disk: >
	datacenter=${1:# The datacenter name to which virtual machine belongs to.}

	name=${2:# Name of the virtual machine.}
	uuid=${3:# UUID of the instance to gather facts if known, this is VMware's unique identifier.}
	moid=${4:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${5:# Destination folder, absolute or relative path to find an existing guest.}
	use_instance_uuid=${6:no}
	disk=${7:[]}
	hostname=${8:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${9:# The username of the vSphere vCenter or ESXi server.}
	password=${10:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${11:yes}
	port=${12:443}
	proxy_host=${13:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${14:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_local_user_info "Gather info about users on the given ESXi host" b
vmware_local_user_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${2:# The username of the vSphere vCenter or ESXi server.}
	password=${3:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${4:yes}
	port=${5:443}
	proxy_host=${6:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${7:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_tag "Manage VMware tags" b
vmware_tag: >
	tag_name=${1:# The name of tag to manage.}

	tag_description=${2:}
	category_id=${3:# The unique ID generated by vCenter should be used to.}
	state=${4:#present|absent}
	hostname=${5:# The hostname or IP address of the vSphere vCenter server.}
	username=${6:# The username of the vSphere vCenter server.}
	password=${7:# The password of the vSphere vCenter server.}
	validate_certs=${8:yes}
	protocol=${9:http|#https}

endsnippet

snippet vmware_local_role_info "Gather info about local roles on an ESXi host" b
vmware_local_role_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${2:# The username of the vSphere vCenter or ESXi server.}
	password=${3:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${4:yes}
	port=${5:443}
	proxy_host=${6:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${7:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_cluster "Manage VMware vSphere clusters" b
vmware_cluster: >
	cluster_name=${1:# The name of the cluster to be managed.}
	datacenter=${2:# The name of the datacenter.}

	ignore_drs=${3:no}
	ignore_ha=${4:no}
	ignore_vsan=${5:no}
	enable_drs=${6:no}
	drs_enable_vm_behavior_overrides=${7:yes}
	drs_default_vm_behavior=${8:#fullyAutomated|manual|partiallyAutomated}
	drs_vmotion_rate=${9:1|2|#3|4|5}
	enable_ha=${10:no}
	ha_host_monitoring=${11:#enabled|disabled}
	ha_vm_monitoring=${12:vmAndAppMonitoring|vmMonitoringOnly|#vmMonitoringDisabled}
	ha_failover_level=${13:2}
	ha_admission_control_enabled=${14:yes}
	ha_vm_failure_interval=${15:30}
	ha_vm_min_up_time=${16:120}
	ha_vm_max_failures=${17:3}
	ha_vm_max_failure_window=${18:-1}
	ha_restart_priority=${19:disabled|high|low|#medium}
	enable_vsan=${20:no}
	vsan_auto_claim_storage=${21:no}
	state=${22:absent|#present}
	hostname=${23:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${24:# The username of the vSphere vCenter or ESXi server.}
	password=${25:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${26:yes}
	port=${27:443}
	proxy_host=${28:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${29:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_firewall_info "Gathers info about an ESXi host's firewall configuration information" b
vmware_host_firewall_info: >
	cluster_name=${1:# Name of the cluster from which the ESXi host belong to.}
	esxi_hostname=${2:# ESXi hostname to gather information from.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_snapshot "Manages virtual machines snapshots in vCenter" b
vmware_guest_snapshot: >
	state=${1:#present|absent|revert|remove_all}
	datacenter=${2:# Destination datacenter for the deploy operation.}

	name=${3:# Name of the virtual machine to work with.}
	name_match=${4:#first|last}
	uuid=${5:# UUID of the instance to manage if known, this is VMware's BIOS UUID by default.}
	moid=${6:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${7:no}
	folder=${8:# Destination folder, absolute or relative path to find an existing guest.}
	snapshot_name=${9:# Sets the snapshot name to manage.}
	description=${10:}
	quiesce=${11:no}
	memory_dump=${12:no}
	remove_children=${13:no}
	new_snapshot_name=${14:# Value to rename the existing snapshot to.}
	new_description=${15:# Value to change the description of an existing snapshot to.}
	hostname=${16:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${17:# The username of the vSphere vCenter or ESXi server.}
	password=${18:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${19:yes}
	port=${20:443}
	proxy_host=${21:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${22:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest "Manages virtual machines in vCenter" b
vmware_guest: >
	name=${1:# Name of the virtual machine to work with.}

	state=${2:#present|absent|poweredon|poweredoff|restarted|suspended|shutdownguest|rebootguest}
	name_match=${3:#first|last}
	uuid=${4:# UUID of the virtual machine to manage if known, this is VMware's unique identifier.}
	use_instance_uuid=${5:no}
	template=${6:# Template or existing virtual machine used to create new virtual machine.}
	is_template=${7:no}
	folder=${8:# Destination folder, absolute path to find an existing guest or create the new guest.}
	hardware=${9:# Manage virtual machine's hardware attributes.}
	guest_id=${10:# Set the guest ID.}
	disk=${11:# A list of disks to add.}
	cdrom=${12:# A CD-ROM configuration for the virtual machine.}
	resource_pool=${13:# Use the given resource pool for virtual machine operation.}
	wait_for_ip_address=${14:no}
	wait_for_customization=${15:no}
	state_change_timeout=${16:0}
	snapshot_src=${17:# Name of the existing snapshot to use to create a clone of a virtual machine.}
	linked_clone=${18:no}
	force=${19:no}
	datacenter=${20:ha-datacenter}
	cluster=${21:# The cluster name where the virtual machine will run.}
	esxi_hostname=${22:# The ESXi hostname where the virtual machine will run.}
	annotation=${23:# A note or annotation to include in the virtual machine.}
	customvalues=${24:# Define a list of custom values to set on virtual machine.}
	networks=${25:# A list of networks (in the order of the NICs).}
	customization=${26:# Parameters for OS customization when cloning from the template or the virtual machine, or apply to the existing virtual machine directly.}
	vapp_properties=${27:# A list of vApp properties}
	customization_spec=${28:# Unique name identifying the requested customization specification.}
	datastore=${29:# Specify datastore or datastore cluster to provision virtual machine.}
	convert=${30:thin|thick|eagerzeroedthick}
	hostname=${31:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${32:# The username of the vSphere vCenter or ESXi server.}
	password=${33:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${34:yes}
	port=${35:443}
	proxy_host=${36:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${37:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_dns_info "Gathers info about an ESXi host's DNS configuration information" b
vmware_host_dns_info: >
	cluster_name=${1:# Name of the cluster from which the ESXi host belong to.}
	esxi_hostname=${2:# ESXi hostname to gather information from.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_cluster_vsan "Manages virtual storage area network (vSAN) configuration on VMware vSphere clusters" b
vmware_cluster_vsan: >
	cluster_name=${1:# The name of the cluster to be managed.}
	datacenter=${2:# The name of the datacenter.}

	enable_vsan=${3:no}
	vsan_auto_claim_storage=${4:no}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vcenter_folder "Manage folders on given datacenter" b
vcenter_folder: >
	datacenter=${1:# Name of the datacenter.}
	folder_name=${2:# Name of folder to be managed.}

	parent_folder=${3:# Name of the parent folder under which new folder needs to be created.}
	folder_type=${4:datastore|host|network|#vm}
	state=${5:#present|absent}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_scanhba "Rescan host HBA's and optionally refresh the storage system" b
vmware_host_scanhba: >
	esxi_hostname=${1:# ESXi hostname to Rescan the storage subsystem on.}
	cluster_name=${2:# Cluster name to Rescan the storage subsystem on (this will run the rescan task on each host in the cluster).}
	refresh_storage=${3:no}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vm_host_drs_rule "Creates vm/host group in a given cluster" b
vmware_vm_host_drs_rule: >
	cluster_name=${1:# Cluster to create VM-Host rule.}
	drs_rule_name=${2:# Name of rule to create or remove.}
	host_group_name=${3:# Name of Host group to use with rule.}
	state=${4:#present|absent}
	vm_group_name=${5:# Name of VM group to use with rule.}

	affinity_rule=${6:yes}
	datacenter=${7:# Datacenter to search for given cluster. If not set, we use first cluster we encounter with C(cluster_name).}
	enabled=${8:no}
	mandatory=${9:no}
	hostname=${10:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${11:# The username of the vSphere vCenter or ESXi server.}
	password=${12:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${13:yes}
	port=${14:443}
	proxy_host=${15:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${16:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_cfg_backup "Backup / Restore / Reset ESXi host configuration" b
vmware_cfg_backup: >
	esxi_hostname=${1:# Name of ESXi server. This is required only if authentication against a vCenter is done.}
	dest=${2:# The destination where the ESXi configuration bundle will be saved. The I(dest) can be a folder or a file.}
	src=${3:# The file containing the ESXi configuration that will be restored.}
	state=${4:saved|absent|loaded}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_capability_info "Gathers info about an ESXi host's capability information" b
vmware_host_capability_info: >
	cluster_name=${1:# Name of the cluster from all host systems to be used for information gathering.}
	esxi_hostname=${2:# ESXi hostname to gather information from.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vm_vss_dvs_migrate "Migrates a virtual machine from a standard vswitch to distributed" b
vmware_vm_vss_dvs_migrate: >
	vm_name=${1:# Name of the virtual machine to migrate to a dvSwitch}
	dvportgroup_name=${2:# Name of the portgroup to migrate to the virtual machine to}

	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vspan_session "Create or remove a Port Mirroring session." b
vmware_vspan_session: >
	switch=${1:# The name of the distributed vSwitch on which to add or remove the mirroring session.}
	name=${2:# Name of the session.}
	state=${3:present|absent}

	session_type=${4:encapsulatedRemoteMirrorSource|remoteMirrorDest|remoteMirrorSource|#dvPortMirror}
	enabled=${5:yes}
	description=${6:# The description for the session.}
	source_port_transmitted=${7:# Source port for which transmitted packets are mirrored.}
	source_port_received=${8:# Source port for which received packets are mirrored.}
	destination_port=${9:# Destination port that received the mirrored packets. Also any port designated in the value of this property can not match the source port in any of the Distributed Port Mirroring session.}
	encapsulation_vlan_id=${10:# VLAN ID used to encapsulate the mirrored traffic.}
	strip_original_vlan=${11:# Whether to strip the original VLAN tag. if false, the original VLAN tag will be preserved on the mirrored traffic. If encapsulationVlanId has been set and this property is false, the frames will be double tagged with the original VLAN ID as the inner tag.}
	mirrored_packet_length=${12:# An integer that describes how much of each frame to mirror. If unset, all of the frame would be mirrored. Setting this property to a smaller value is useful when the consumer will look only at the headers. The value cannot be less than 60.}
	normal_traffic_allowed=${13:# Whether or not destination ports can send and receive "normal" traffic. Setting this to false will make mirror ports be used solely for mirroring and not double as normal access ports.}
	sampling_rate=${14:# Sampling rate of the session. If its value is n, one of every n packets is mirrored. Valid values are between 1 to 65535, and default value is 1.}
	source_vm_transmitted=${15:# With this parameter it is possible, to add a NIC of a VM to a port mirroring session.}
	source_vm_received=${16:# With this parameter it is possible, to add a NIC of a VM to a port mirroring session.}
	destination_vm=${17:# With this parameter it is possible, to add a NIC of a VM to a port mirroring session.}
	hostname=${18:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${19:# The username of the vSphere vCenter or ESXi server.}
	password=${20:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${21:yes}
	port=${22:443}
	proxy_host=${23:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${24:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vm_storage_policy_info "Gather information about vSphere storage profile defined storage policy information." b
vmware_vm_storage_policy_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${2:# The username of the vSphere vCenter or ESXi server.}
	password=${3:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${4:yes}
	port=${5:443}
	proxy_host=${6:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${7:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvswitch "Create or remove a Distributed Switch" b
vmware_dvswitch: >
	switch_name=${1:# The name of the distribute vSwitch to create or remove.}

	datacenter_name=${2:# The name of the datacenter that will contain the Distributed Switch.}
	switch_version=${3:5.0.0|5.1.0|5.5.0|6.0.0|6.5.0|6.6.0}
	mtu=${4:1500}
	multicast_filtering_mode=${5:#basic|snooping}
	uplink_quantity=${6:# Quantity of uplink per ESXi host added to the Distributed Switch.}
	uplink_prefix=${7:Uplink }
	discovery_proto=${8:#cdp|lldp|disabled}
	discovery_operation=${9:both|advertise|#listen}
	contact=${10:# Dictionary which configures administrator contact name and description for the Distributed Switch.}
	description=${11:# Description of the Distributed Switch.}
	health_check=${12:{'vlan_mtu': False, 'teaming_failover': False, 'vlan_mtu_interval': 0, 'teaming_failover_interval': 0}}
	state=${13:#present|absent}
	folder=${14:# Destination folder, absolute path to place dvswitch in.}
	hostname=${15:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${16:# The username of the vSphere vCenter or ESXi server.}
	password=${17:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${18:yes}
	port=${19:443}
	proxy_host=${20:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${21:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_package_info "Gathers info about available packages on an ESXi host" b
vmware_host_package_info: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_custom_attributes "Manage custom attributes from VMware for the given virtual machine" b
vmware_guest_custom_attributes: >
	name=${1:# Name of the virtual machine to work with.}
	datacenter=${2:# Datacenter name where the virtual machine is located in.}

	state=${3:#present|absent}
	uuid=${4:# UUID of the virtual machine to manage if known. This is VMware's unique identifier.}
	moid=${5:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${6:no}
	folder=${7:# Absolute path to find an existing guest.}
	attributes=${8:[]}
	hostname=${9:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${10:# The username of the vSphere vCenter or ESXi server.}
	password=${11:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${12:yes}
	port=${13:443}
	proxy_host=${14:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${15:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vcenter_settings "Configures general settings on a vCenter server" b
vmware_vcenter_settings: >
	database=${1:{'max_connections': 50, 'task_cleanup': True, 'task_retention': 30, 'event_cleanup': True, 'event_retention': 30}}
	runtime_settings=${2:# The unique runtime settings for vCenter server.}
	user_directory=${3:{'timeout': 60, 'query_limit': True, 'query_limit_size': 5000, 'validation': True, 'validation_period': 1440}}
	mail=${4:# The settings vCenter server uses to send email alerts.}
	snmp_receivers=${5:{'snmp_receiver_1_url': 'localhost', 'snmp_receiver_1_enabled': True, 'snmp_receiver_1_port': 162, 'snmp_receiver_1_community': 'public', 'snmp_receiver_2_url': '', 'snmp_receiver_2_enabled': False, 'snmp_receiver_2_port': 162, 'snmp_receiver_2_community': '', 'snmp_receiver_3_url': '', 'snmp_receiver_3_enabled': False, 'snmp_receiver_3_port': 162, 'snmp_receiver_3_community': '', 'snmp_receiver_4_url': '', 'snmp_receiver_4_enabled': False, 'snmp_receiver_4_port': 162, 'snmp_receiver_4_community': ''}}
	timeout_settings=${6:{'normal_operations': 30, 'long_operations': 120}}
	logging_options=${7:none|error|warning|#info|verbose|trivia}
	hostname=${8:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${9:# The username of the vSphere vCenter or ESXi server.}
	password=${10:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${11:yes}
	port=${12:443}
	proxy_host=${13:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${14:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_resource_pool_info "Gathers info about resource pool information" b
vmware_resource_pool_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${2:# The username of the vSphere vCenter or ESXi server.}
	password=${3:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${4:yes}
	port=${5:443}
	proxy_host=${6:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${7:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_deploy_ovf "Deploys a VMware virtual machine from an OVF or OVA file" b
vmware_deploy_ovf: >
	allow_duplicates=${1:yes}
	datacenter=${2:ha-datacenter}
	cluster=${3:# Cluster to deploy to.}
	datastore=${4:datastore1}
	deployment_option=${5:# The key of the chosen deployment option.}
	disk_provisioning=${6:flat|eagerZeroedThick|monolithicSparse|twoGbMaxExtentSparse|twoGbMaxExtentFlat|#thin|sparse|thick|seSparse|monolithicFlat}
	fail_on_spec_warnings=${7:no}
	folder=${8:# Absolute path of folder to place the virtual machine.}
	inject_ovf_env=${9:# Force the given properties to be inserted into an OVF Environment and injected through VMware Tools.}
	name=${10:# Name of the VM to work with.}
	networks=${11:{'VM Network': 'VM Network'}}
	ovf=${12:# Path to OVF or OVA file to deploy.}
	power_on=${13:yes}
	properties=${14:# The assignment of values to the properties found in the OVF as key value pairs.}
	resource_pool=${15:Resources}
	wait=${16:yes}
	wait_for_ip_address=${17:no}
	hostname=${18:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${19:# The username of the vSphere vCenter or ESXi server.}
	password=${20:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${21:yes}
	port=${22:443}
	proxy_host=${23:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${24:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_service_manager "Manage services on a given ESXi host" b
vmware_host_service_manager: >
	service_name=${1:# Name of Service to be managed. This is a brief identifier for the service, for example, ntpd, vxsyslogd etc.}

	cluster_name=${2:# Name of the cluster.}
	esxi_hostname=${3:# ESXi hostname.}
	state=${4:absent|present|restart|#start|stop}
	service_policy=${5:automatic|off|on}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_content_library_manager "Create, update and delete VMware content library" b
vmware_content_library_manager: >
	library_name=${1:# The name of VMware content library to manage.}

	library_description=${2:}
	library_type=${3:#local|subscribed}
	datastore_name=${4:# Name of the datastore on which backing content library is created.}
	state=${5:#present|absent}
	hostname=${6:# The hostname or IP address of the vSphere vCenter server.}
	username=${7:# The username of the vSphere vCenter server.}
	password=${8:# The password of the vSphere vCenter server.}
	validate_certs=${9:yes}
	protocol=${10:http|#https}

endsnippet

snippet vmware_guest_network "Manage network adapters of specified virtual machine in given vCenter infrastructure" b
vmware_guest_network: >
	name=${1:# Name of the virtual machine.}
	uuid=${2:# UUID of the instance to gather info if known, this is VMware's unique identifier.}
	moid=${3:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${4:# Destination folder, absolute or relative path to find an existing guest.}
	cluster=${5:# The name of cluster where the virtual machine will run.}
	esxi_hostname=${6:# The ESXi hostname where the virtual machine will run.}
	datacenter=${7:ha-datacenter}
	gather_network_info=${8:no}
	networks=${9:# A list of network adapters.}
	hostname=${10:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${11:# The username of the vSphere vCenter or ESXi server.}
	password=${12:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${13:yes}
	port=${14:443}
	proxy_host=${15:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${16:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvs_portgroup_info "Gathers info DVS portgroup configurations" b
vmware_dvs_portgroup_info: >
	datacenter=${1:# Name of the datacenter.}

	dvswitch=${2:# Name of a dvswitch to look for.}
	show_network_policy=${3:yes}
	show_port_policy=${4:yes}
	show_teaming_policy=${5:yes}
	show_vlan_info=${6:no}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_powermgmt_policy "Manages the Power Management Policy of an ESXI host system" b
vmware_host_powermgmt_policy: >
	policy=${1:high-performance|#balanced|low-power|custom}
	esxi_hostname=${2:# Name of the host system to work with.}
	cluster_name=${3:# Name of the cluster from which all host systems will be used.}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_target_canonical_info "Return canonical (NAA) from an ESXi host system" b
vmware_target_canonical_info: >
	target_id=${1:# The target id based on order of scsi device.}
	cluster_name=${2:# Name of the cluster.}
	esxi_hostname=${3:# Name of the ESXi host system.}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_local_role_manager "Manage local roles on an ESXi host" b
vmware_local_role_manager: >
	local_role_name=${1:# The local role name to be managed.}

	local_privilege_ids=${2:[]}
	state=${3:#present|absent}
	force_remove=${4:no}
	action=${5:add|remove|#set}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_portgroup_info "Gathers info about an ESXi host's Port Group configuration" b
vmware_portgroup_info: >
	policies=${1:no}
	cluster_name=${2:# Name of the cluster.}
	esxi_hostname=${3:# ESXi hostname to gather information from.}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_ntp "Manage NTP server configuration of an ESXi host" b
vmware_host_ntp: >
	ntp_servers=${1:# IP or FQDN of NTP server(s).}

	esxi_hostname=${2:# Name of the host system to work with.}
	cluster_name=${3:# Name of the cluster from which all host systems will be used.}
	state=${4:present|absent}
	verbose=${5:no}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_acceptance "Manage the host acceptance level of an ESXi host" b
vmware_host_acceptance: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	state=${3:#list|present}
	acceptance_level=${4:community|partner|vmware_accepted|vmware_certified}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvswitch_uplink_pg "Manage uplink portproup configuration of a Distributed Switch" b
vmware_dvswitch_uplink_pg: >
	switch=${1:# The name of the Distributed Switch.}

	name=${2:# The name of the uplink portgroup.}
	description=${3:# The description of the uplink portgroup.}
	advanced=${4:{'port_config_reset_at_disconnect': True, 'block_override': True, 'vendor_config_override': False, 'vlan_override': False, 'netflow_override': False, 'traffic_filter_override': False}}
	vlan_trunk_range=${5:['0-4094']}
	lacp=${6:{'status': 'disabled', 'mode': 'passive'}}
	netflow_enabled=${7:no}
	block_all_ports=${8:no}
	hostname=${9:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${10:# The username of the vSphere vCenter or ESXi server.}
	password=${11:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${12:yes}
	port=${13:443}
	proxy_host=${14:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${15:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_feature_info "Gathers info about an ESXi host's feature capability information" b
vmware_host_feature_info: >
	cluster_name=${1:# Name of the cluster from all host systems to be used for information gathering.}
	esxi_hostname=${2:# ESXi hostname to gather information from.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_info "Gather info about a single VM" b
vmware_guest_info: >
	datacenter=${1:# Destination datacenter for the deploy operation}

	name=${2:# Name of the VM to work with}
	name_match=${3:#first|last}
	uuid=${4:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	use_instance_uuid=${5:no}
	moid=${6:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${7:# Destination folder, absolute or relative path to find an existing guest.}
	tags=${8:no}
	schema=${9:#summary|vsphere}
	properties=${10:# Specify the properties to retrieve.}
	hostname=${11:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${12:# The username of the vSphere vCenter or ESXi server.}
	password=${13:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${14:yes}
	port=${15:443}
	proxy_host=${16:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${17:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_ipv6 "Enables/Disables IPv6 support for an ESXi host system" b
vmware_host_ipv6: >
	state=${1:#enabled|disabled}
	esxi_hostname=${2:# Name of the host system to work with.}
	cluster_name=${3:# Name of the cluster from which all host systems will be used.}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_lockdown "Manage administrator permission for the local administrative account for the ESXi host" b
vmware_host_lockdown: >
	cluster_name=${1:# Name of cluster.}
	esxi_hostname=${2:# List of ESXi hostname to manage lockdown.}
	state=${3:#present|absent}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vm_vm_drs_rule "Configure VMware DRS Affinity rule for virtual machine in given cluster" b
vmware_vm_vm_drs_rule: >
	cluster_name=${1:# Desired cluster name where virtual machines are present for the DRS rule.}
	drs_rule_name=${2:# The name of the DRS rule to manage.}

	vms=${3:# List of virtual machines name for which DRS rule needs to be applied.}
	enabled=${4:no}
	mandatory=${5:no}
	affinity_rule=${6:yes}
	state=${7:#present|absent}
	hostname=${8:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${9:# The username of the vSphere vCenter or ESXi server.}
	password=${10:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${11:yes}
	port=${12:443}
	proxy_host=${13:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${14:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_resource_pool "Add/remove resource pools to/from vCenter" b
vmware_resource_pool: >
	datacenter=${1:# Name of the datacenter to add the host.}
	cluster=${2:# Name of the cluster to add the host.}
	resource_pool=${3:# Resource pool name to manage.}

	cpu_expandable_reservations=${4:yes}
	cpu_reservation=${5:0}
	cpu_limit=${6:-1}
	cpu_shares=${7:high|custom|low|#normal}
	mem_expandable_reservations=${8:yes}
	mem_reservation=${9:0}
	mem_limit=${10:-1}
	mem_shares=${11:high|custom|low|#normal}
	state=${12:#present|absent}
	hostname=${13:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${14:# The username of the vSphere vCenter or ESXi server.}
	password=${15:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${16:yes}
	port=${17:443}
	proxy_host=${18:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${19:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_kernel_manager "Manage kernel module options on ESXi hosts" b
vmware_host_kernel_manager: >
	kernel_module_name=${1:# Name of the kernel module to be configured.}
	kernel_module_option=${2:# Specified configurations will be applied to the given module.}

	esxi_hostname=${3:# Name of the ESXi host to work on.}
	cluster_name=${4:# Name of the VMware cluster to work on.}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_maintenancemode "Place a host into maintenance mode" b
vmware_maintenancemode: >
	esxi_hostname=${1:# Name of the host as defined in vCenter.}

	vsan=${2:ensureObjectAccessibility|evacuateAllData|noAction}
	evacuate=${3:no}
	timeout=${4:0}
	state=${5:#present|absent}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vmkernel "Manages a VMware VMkernel Adapter of an ESXi host." b
vmware_vmkernel: >
	portgroup_name=${1:# The name of the port group for the VMKernel interface.}
	esxi_hostname=${2:# Name of ESXi host to which VMKernel is to be managed.}

	vswitch_name=${3:# The name of the vSwitch where to add the VMKernel interface.}
	dvswitch_name=${4:# The name of the vSphere Distributed Switch (vDS) where to add the VMKernel interface.}
	network=${5:{'type': 'static', 'tcpip_stack': 'default'}}
	ip_address=${6:# The IP Address for the VMKernel interface.}
	subnet_mask=${7:# The Subnet Mask for the VMKernel interface.}
	mtu=${8:1500}
	device=${9:# Search VMkernel adapter by device name.}
	enable_vsan=${10:# Enable VSAN traffic on the VMKernel adapter.}
	enable_vmotion=${11:# Enable vMotion traffic on the VMKernel adapter.}
	enable_mgmt=${12:# Enable Management traffic on the VMKernel adapter.}
	enable_ft=${13:# Enable Fault Tolerance traffic on the VMKernel adapter.}
	enable_provisioning=${14:# Enable Provisioning traffic on the VMKernel adapter.}
	enable_replication=${15:# Enable vSphere Replication traffic on the VMKernel adapter.}
	enable_replication_nfc=${16:# Enable vSphere Replication NFC traffic on the VMKernel adapter.}
	state=${17:#present|absent}
	hostname=${18:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${19:# The username of the vSphere vCenter or ESXi server.}
	password=${20:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${21:yes}
	port=${22:443}
	proxy_host=${23:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${24:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vmkernel_info "Gathers VMKernel info about an ESXi host" b
vmware_vmkernel_info: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_evc_mode "Enable/Disable EVC mode on vCenter" b
vmware_evc_mode: >
	datacenter_name=${1:# The name of the datacenter the cluster belongs to that you want to enable or disable EVC mode on.}
	cluster_name=${2:# The name of the cluster to enable or disable EVC mode on.}
	evc_mode=${3:# Required for C(state=present).}

	state=${4:absent|#present}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_customization_info "Gather info about VM customization specifications" b
vmware_guest_customization_info: >
	spec_name=${1:# Name of customization specification to find.}
	hostname=${2:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${3:# The username of the vSphere vCenter or ESXi server.}
	password=${4:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${5:yes}
	port=${6:443}
	proxy_host=${7:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${8:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_service_info "Gathers info about an ESXi host's services" b
vmware_host_service_info: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_ntp_info "Gathers info about NTP configuration on an ESXi host" b
vmware_host_ntp_info: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_video "Modify video card configurations of specified virtual machine in given vCenter infrastructure" b
vmware_guest_video: >
	name=${1:# Name of the virtual machine.}
	uuid=${2:# UUID of the instance to gather facts if known, this is VMware's unique identifier.}
	moid=${3:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${4:# Destination folder, absolute or relative path to find an existing guest.}
	datacenter=${5:ha-datacenter}
	gather_video_facts=${6:no}
	use_auto_detect=${7:# If set to True, applies common video settings to the guest operating system, attributes C(display_number) and C(video_memory_mb) are ignored.}
	display_number=${8:# The number of display. Valid value from 1 to 10. The maximum display number is 4 on vCenter 6.0, 6.5 web UI.}
	video_memory_mb=${9:# Valid total MB of video memory range of virtual machine is from 1.172 MB to 256 MB on ESXi 6.7U1, from 1.172 MB to 128 MB on ESXi 6.7 and previous versions.}
	enable_3D=${10:# Enable 3D for guest operating systems on which VMware supports 3D.}
	renderer_3D=${11:automatic|software|hardware}
	memory_3D_mb=${12:# The value of 3D Memory must be power of 2 and valid value is from 32 MB to 2048 MB.}
	hostname=${13:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${14:# The username of the vSphere vCenter or ESXi server.}
	password=${15:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${16:yes}
	port=${17:443}
	proxy_host=${18:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${19:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vswitch "Manage a VMware Standard Switch to an ESXi host." b
vmware_vswitch: >
	switch=${1:# vSwitch name to add.}

	nics=${2:[]}
	number_of_ports=${3:128}
	mtu=${4:1500}
	state=${5:absent|#present}
	esxi_hostname=${6:# Manage the vSwitch using this ESXi host system.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_tools_upgrade "Module to upgrade VMTools" b
vmware_guest_tools_upgrade: >
	datacenter=${1:# Destination datacenter where the virtual machine exists.}

	name=${2:# Name of the virtual machine to work with.}
	name_match=${3:#first|last}
	uuid=${4:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	moid=${5:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${6:# Destination folder, absolute or relative path to find an existing guest.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vsan_cluster "Configure VSAN clustering on an ESXi host" b
vmware_vsan_cluster: >
	cluster_uuid=${1:# Desired cluster UUID}
	hostname=${2:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${3:# The username of the vSphere vCenter or ESXi server.}
	password=${4:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${5:yes}
	port=${6:443}
	proxy_host=${7:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${8:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_active_directory "Joins an ESXi host system to an Active Directory domain or leaves it" b
vmware_host_active_directory: >
	ad_domain=${1:# AD Domain to join.}
	ad_user=${2:# Username for AD domain join.}
	ad_password=${3:# Password for AD domain join.}
	ad_state=${4:present|#absent}
	esxi_hostname=${5:# Name of the host system to work with.}
	cluster_name=${6:# Name of the cluster from which all host systems will be used.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vca_vapp "Manages vCloud Air vApp instances." b
vca_vapp: >
	vapp_name=${1:# The name of the vCloud Air vApp instance}

	template_name=${2:# The name of the vApp template to use to create the vApp instance.  If the I(state) is not `absent` then the I(template_name) value must be provided.  The I(template_name) must be previously uploaded to the catalog specified by I(catalog_name)}
	network_name=${3:# The name of the network that should be attached to the virtual machine in the vApp.  The virtual network specified must already be created in the vCloud Air VDC.  If the I(state) is not 'absent' then the I(network_name) argument must be provided.}
	network_mode=${4:#pool|dhcp|static}
	vm_name=${5:# The name of the virtual machine instance in the vApp to manage.}
	vm_cpus=${6:# The number of vCPUs to configure for the VM in the vApp.   If the I(vm_name) argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp.}
	vm_memory=${7:# The amount of memory in MB to allocate to VMs in the vApp.  If the I(vm_name) argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp.}
	operation=${8:#noop|poweron|poweroff|suspend|shutdown|reboot|reset}
	state=${9:#present|absent|deployed|undeployed}
	username=${10:# The vCloud Air username to use during authentication}
	password=${11:# The vCloud Air password to use during authentication}
	org=${12:# The org to login to for creating vapp, mostly set when the service_type is vdc.}
	instance_id=${13:# The instance id in a vchs environment to be used for creating the vapp}
	host=${14:# The authentication host to be used when service type  is vcd.}
	api_version=${15:5.7}
	service_type=${16:#vca|vchs|vcd}
	vdc_name=${17:# The name of the virtual data center (VDC) where the vm should be created or contains the vAPP.}
	validate_certs=${18:yes}
	gateway_name=${19:gateway}

endsnippet

snippet vsphere_file "Manage files on a vCenter datastore" b
vsphere_file: >
	host=${1:# The vCenter server on which the datastore is available.}
	username=${2:# The user name to authenticate on the vCenter server.}
	password=${3:# The password to authenticate on the vCenter server.}
	datacenter=${4:# The datacenter on the vCenter server that holds the datastore.}
	datastore=${5:# The datastore on the vCenter server to push files to.}
	path=${6:# The file or directory on the datastore on the vCenter server.}

	validate_certs=${7:yes}
	timeout=${8:10}
	state=${9:absent|directory|#file|touch}

endsnippet

snippet vmware_guest_info "Gather info about a single VM" b
vmware_guest_info: >
	datacenter=${1:# Destination datacenter for the deploy operation}

	name=${2:# Name of the VM to work with}
	name_match=${3:#first|last}
	uuid=${4:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	use_instance_uuid=${5:no}
	moid=${6:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	folder=${7:# Destination folder, absolute or relative path to find an existing guest.}
	tags=${8:no}
	schema=${9:#summary|vsphere}
	properties=${10:# Specify the properties to retrieve.}
	hostname=${11:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${12:# The username of the vSphere vCenter or ESXi server.}
	password=${13:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${14:yes}
	port=${15:443}
	proxy_host=${16:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${17:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vm_shell "Run commands in a VMware guest operating system" b
vmware_vm_shell: >
	vm_id=${1:# Name of the virtual machine to work with.}
	vm_username=${2:# The user to login-in to the virtual machine.}
	vm_password=${3:# The password used to login-in to the virtual machine.}
	vm_shell=${4:# The absolute path to the program to start.}

	datacenter=${5:# The datacenter hosting the virtual machine.}
	cluster=${6:# The cluster hosting the virtual machine.}
	folder=${7:# Destination folder, absolute or relative path to find an existing guest or create the new guest.}
	vm_id_type=${8:uuid|instance_uuid|dns_name|inventory_path|#vm_name}
	vm_shell_args=${9: }
	vm_shell_env=${10:# Comma separated list of environment variable, specified in the guest OS notation.}
	vm_shell_cwd=${11:# The current working directory of the application from which it will be run.}
	wait_for_process=${12:no}
	timeout=${13:3600}
	hostname=${14:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${15:# The username of the vSphere vCenter or ESXi server.}
	password=${16:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${17:yes}
	port=${18:443}
	proxy_host=${19:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${20:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_folder_info "Provides information about folders in a datacenter" b
vmware_folder_info: >
	datacenter=${1:# Name of the datacenter.}

	hostname=${2:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${3:# The username of the vSphere vCenter or ESXi server.}
	password=${4:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${5:yes}
	port=${6:443}
	proxy_host=${7:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${8:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vcenter_extension "Register/deregister vCenter Extensions" b
vcenter_extension: >
	extension_key=${1:# The extension key of the extension to install or uninstall.}
	version=${2:# The version of the extension you are installing or uninstalling.}

	name=${3:# Required for C(state=present). The name of the extension you are installing.}
	company=${4:# Required for C(state=present). The name of the company that makes the extension.}
	description=${5:# Required for C(state=present). A short description of the extension.}
	email=${6:# Required for C(state=present). Administrator email to use for extension.}
	url=${7:# Required for C(state=present). Link to server hosting extension zip file to install.}
	ssl_thumbprint=${8:# Required for C(state=present). SSL thumbprint of the extension hosting server.}
	server_type=${9:vsphere-client-serenity}
	client_type=${10:vsphere-client-serenity}
	visible=${11:yes}
	state=${12:absent|#present}
	hostname=${13:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${14:# The username of the vSphere vCenter or ESXi server.}
	password=${15:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${16:yes}
	port=${17:443}
	proxy_host=${18:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${19:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_portgroup "Create a VMware portgroup" b
vmware_portgroup: >
	switch=${1:# vSwitch to modify.}
	portgroup=${2:# Portgroup name to add.}

	vlan_id=${3:0}
	security=${4:# Network policy specifies layer 2 security settings for a portgroup such as promiscuous mode, where guest adapter listens to all the packets, MAC address changes and forged transmits.}
	teaming=${5:# Dictionary which configures the different teaming values for portgroup.}
	traffic_shaping=${6:# Dictionary which configures traffic shaping for the switch.}
	cluster_name=${7:# Name of cluster name for host membership.}
	hosts=${8:# List of name of host or hosts on which portgroup needs to be added.}
	state=${9:#present|absent}
	hostname=${10:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${11:# The username of the vSphere vCenter or ESXi server.}
	password=${12:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${13:yes}
	port=${14:443}
	proxy_host=${15:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${16:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_migrate_vmk "Migrate a VMK interface from VSS to VDS" b
vmware_migrate_vmk: >
	esxi_hostname=${1:# ESXi hostname to be managed}
	device=${2:# VMK interface name}
	current_switch_name=${3:# Switch VMK interface is currently on}
	current_portgroup_name=${4:# Portgroup name VMK interface is currently on}
	migrate_switch_name=${5:# Switch name to migrate VMK interface to}
	migrate_portgroup_name=${6:# Portgroup name to migrate VMK interface to}

	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_tag_info "Manage VMware tag info" b
vmware_tag_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter server.}
	username=${2:# The username of the vSphere vCenter server.}
	password=${3:# The password of the vSphere vCenter server.}
	validate_certs=${4:yes}
	protocol=${5:http|#https}

endsnippet

snippet vmware_category_info "Gather info about VMware tag categories" b
vmware_category_info: >
	hostname=${1:# The hostname or IP address of the vSphere vCenter server.}
	username=${2:# The username of the vSphere vCenter server.}
	password=${3:# The password of the vSphere vCenter server.}
	validate_certs=${4:yes}
	protocol=${5:http|#https}

endsnippet

snippet vmware_cluster_info "Gather info about clusters available in given vCenter" b
vmware_cluster_info: >
	datacenter=${1:# Datacenter to search for cluster/s.}
	cluster_name=${2:# Name of the cluster.}
	show_tag=${3:no}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_cluster_info "Gather info about clusters available in given vCenter" b
vmware_cluster_info: >
	datacenter=${1:# Datacenter to search for cluster/s.}
	cluster_name=${2:# Name of the cluster.}
	show_tag=${3:no}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvswitch_nioc "Manage distributed switch Network IO Control" b
vmware_dvswitch_nioc: >
	switch=${1:# The name of the distributed switch.}

	version=${2:version2|version3}
	state=${3:#present|absent}
	resources=${4:# List of dicts containing { name: Resource name is one of the following: "faultTolerance", "hbr", "iSCSI", "management", "nfs", "vdp", "virtualMachine", "vmotion", "vsan" limit: The maximum allowed usage for a traffic class belonging to this resource pool per host physical NIC. reservation: (Ignored if NIOC version is set to version2) Amount of bandwidth resource that is guaranteed available to the host infrastructure traffic class. If the utilization is less than the reservation, the extra bandwidth is used for other host infrastructure traffic class types. Reservation is not allowed to exceed the value of limit, if limit is set. Unit is Mbits/sec. shares_level: The allocation level ("low", "normal", "high", "custom"). The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for shares. shares: Ignored unless shares_level is "custom".  The number of shares allocated. reservation: Ignored unless version is "version3". Amount of bandwidth resource that is guaranteed available to the host infrastructure traffic class. }}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_boot_info "Gather info about boot options for the given virtual machine" b
vmware_guest_boot_info: >
	name=${1:# Name of the VM to work with.}
	uuid=${2:# UUID of the instance to manage if known, this is VMware's BIOS UUID by default.}
	moid=${3:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${4:no}
	name_match=${5:#first|last}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_datastore_info "Gather info about datastores available in given vCenter" b
vmware_datastore_info: >
	name=${1:# Name of the datastore to match.}
	datacenter=${2:# Datacenter to search for datastores.}
	cluster=${3:# Cluster to search for datastores.}
	gather_nfs_mount_info=${4:no}
	gather_vmfs_mount_info=${5:no}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvswitch_lacp "Manage LACP configuration on a Distributed Switch" b
vmware_dvswitch_lacp: >
	switch=${1:# The name of the Distributed Switch to manage.}

	support_mode=${2:#basic|enhanced}
	link_aggregation_groups=${3:# Can only be used if C(lacp_support) is set to C(enhanced).}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_export_ovf "Exports a VMware virtual machine to an OVF file, device files and a manifest file" b
vmware_export_ovf: >
	export_dir=${1:# Absolute path to place the exported files on the server running this task, must have write permission.}

	name=${2:# Name of the virtual machine to export.}
	uuid=${3:# Uuid of the virtual machine to export.}
	moid=${4:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	datacenter=${5:ha-datacenter}
	folder=${6:# Destination folder, absolute path to find the specified guest.}
	export_with_images=${7:no}
	download_timeout=${8:10}
	hostname=${9:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${10:# The username of the vSphere vCenter or ESXi server.}
	password=${11:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${12:yes}
	port=${13:443}
	proxy_host=${14:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${15:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_drs_group "Creates vm/host group in a given cluster." b
vmware_drs_group: >
	cluster_name=${1:# Cluster to create vm/host group.}
	group_name=${2:# The name of the group to create or remove.}
	state=${3:#present|absent}

	datacenter=${4:# Datacenter to search for given cluster. If not set, we use first cluster we encounter with C(cluster_name).}
	hosts=${5:# List of hosts to create in group.}
	vms=${6:# List of vms to create in group.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_content_library_info "Gather information about VMware Content Library" b
vmware_content_library_info: >
	library_id=${1:# content library id for which details needs to be fetched.}
	hostname=${2:# The hostname or IP address of the vSphere vCenter server.}
	username=${3:# The username of the vSphere vCenter server.}
	password=${4:# The password of the vSphere vCenter server.}
	validate_certs=${5:yes}
	protocol=${6:http|#https}

endsnippet

snippet vmware_dvs_host "Add or remove a host from distributed virtual switch" b
vmware_dvs_host: >
	esxi_hostname=${1:# The ESXi hostname.}
	switch_name=${2:# The name of the Distributed vSwitch.}
	vmnics=${3:# The ESXi hosts vmnics to use with the Distributed vSwitch.}
	state=${4:#present|absent}

	vendor_specific_config=${5:# List of key,value dictionaries for the Vendor Specific Configuration.}
	hostname=${6:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${7:# The username of the vSphere vCenter or ESXi server.}
	password=${8:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${9:yes}
	port=${10:443}
	proxy_host=${11:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${12:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dns_config "Manage VMware ESXi DNS Configuration" b
vmware_dns_config: >
	change_hostname_to=${1:# The hostname that an ESXi host should be changed to.}
	domainname=${2:# The domain the ESXi host should be apart of.}
	dns_servers=${3:# The DNS servers that the host should be configured to use.}

	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvswitch_pvlans "Manage Private VLAN configuration of a Distributed Switch" b
vmware_dvswitch_pvlans: >
	switch=${1:# The name of the Distributed Switch.}

	primary_pvlans=${2:[]}
	secondary_pvlans=${3:[]}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host "Add, remove, or move an ESXi host to, from, or within vCenter" b
vmware_host: >
	datacenter_name=${1:# Name of the datacenter to add the host.}
	esxi_hostname=${2:# ESXi hostname to manage.}

	cluster_name=${3:# Name of the cluster to add the host.}
	folder=${4:# Name of the folder under which host to add.}
	add_connected=${5:yes}
	esxi_username=${6:# ESXi username.}
	esxi_password=${7:# ESXi password.}
	state=${8:#present|absent|add_or_reconnect|reconnect}
	esxi_ssl_thumbprint=${9:}
	fetch_ssl_thumbprint=${10:yes}
	force_connection=${11:yes}
	reconnect_disconnected=${12:yes}
	hostname=${13:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${14:# The username of the vSphere vCenter or ESXi server.}
	password=${15:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${16:yes}
	port=${17:443}
	proxy_host=${18:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${19:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vm_info "Return basic info pertaining to a VMware machine guest" b
vmware_vm_info: >
	vm_type=${1:#all|vm|template}
	show_attribute=${2:no}
	folder=${3:# Specify a folder location of VMs to gather information from.}
	show_tag=${4:no}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_config_manager "Manage advanced system settings of an ESXi host" b
vmware_host_config_manager: >
	cluster_name=${1:# Name of the cluster.}
	esxi_hostname=${2:# ESXi hostname.}
	options=${3:{}}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_file_operation "Files operation in a VMware guest operating system without network" b
vmware_guest_file_operation: >
	vm_id=${1:# Name of the virtual machine to work with.}
	vm_username=${2:# The user to login in to the virtual machine.}
	vm_password=${3:# The password used to login-in to the virtual machine.}

	datacenter=${4:# The datacenter hosting the virtual machine.}
	cluster=${5:# The cluster hosting the virtual machine.}
	folder=${6:# Destination folder, absolute path to find an existing guest or create the new guest.}
	vm_id_type=${7:uuid|instance_uuid|dns_name|inventory_path|#vm_name}
	directory=${8:# Create or delete a directory.}
	copy=${9:# Copy file to vm without requiring network.}
	fetch=${10:# Get file from virtual machine without requiring network.}
	hostname=${11:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${12:# The username of the vSphere vCenter or ESXi server.}
	password=${13:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${14:yes}
	port=${15:443}
	proxy_host=${16:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${17:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_hyperthreading "Enables/Disables Hyperthreading optimization for an ESXi host system" b
vmware_host_hyperthreading: >
	state=${1:#enabled|disabled}
	esxi_hostname=${2:# Name of the host system to work with.}
	cluster_name=${3:# Name of the cluster from which all host systems will be used.}
	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_dvs_portgroup_find "Find portgroup(s) in a VMware environment" b
vmware_dvs_portgroup_find: >
	dvswitch=${1:# Name of a distributed vSwitch to look for.}
	vlanid=${2:# VLAN id can be any number between 1 and 4094.}
	name=${3:# string to check inside the name of the portgroup.}
	show_uplink=${4:no}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_snmp "Configures SNMP on an ESXi host system" b
vmware_host_snmp: >
	state=${1:#disabled|enabled|reset}
	community=${2:# List of SNMP community strings.}
	snmp_port=${3:161}
	trap_targets=${4:[]}
	trap_filter=${5:# A list of trap oids for traps not to be sent by agent, e.g. [ 1.3.6.1.4.1.6876.4.1.1.0, 1.3.6.1.4.1.6876.4.1.1.1 ]}
	send_trap=${6:no}
	hw_source=${7:#indications|sensors}
	log_level=${8:debug|#info|warning|error}
	hostname=${9:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${10:# The username of the vSphere vCenter or ESXi server.}
	password=${11:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${12:yes}
	port=${13:443}
	proxy_host=${14:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${15:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_datacenter "Manage VMware vSphere Datacenters" b
vmware_datacenter: >
	datacenter_name=${1:# The name of the datacenter the cluster will be created in.}

	state=${2:#present|absent}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_datastore "Manage a datastore on ESXi host" b
vmware_host_datastore: >
	datastore_name=${1:# Name of the datastore to add/remove.}
	datastore_type=${2:nfs|nfs41|vmfs}

	datacenter_name=${3:# Name of the datacenter to add the datastore.}
	nfs_server=${4:# NFS host serving nfs datastore.}
	nfs_path=${5:# Resource path on NFS host.}
	nfs_ro=${6:no}
	vmfs_device_name=${7:# Name of the device to be used as VMFS datastore.}
	vmfs_version=${8:# VMFS version to use for datastore creation.}
	esxi_hostname=${9:# ESXi hostname to manage the datastore.}
	state=${10:#present|absent}
	hostname=${11:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${12:# The username of the vSphere vCenter or ESXi server.}
	password=${13:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${14:yes}
	port=${15:443}
	proxy_host=${16:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${17:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_local_user_manager "Manage local users on an ESXi host" b
vmware_local_user_manager: >
	local_user_name=${1:# The local user name to be changed.}

	local_user_password=${2:# The password to be set.}
	local_user_description=${3:# Description for the user.}
	state=${4:#present|absent}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vca_nat "add remove nat rules in a gateway  in a vca" b
vca_nat: >
	nat_rules=${1:no}

	purge_rules=${2:no}
	username=${3:# The vca username or email address, if not set the environment variable C(VCA_USER) is checked for the username.}
	password=${4:# The vca password, if not set the environment variable C(VCA_PASS) is checked for the password.}
	org=${5:# The org to login to for creating vapp.}
	instance_id=${6:# The instance ID in a vchs environment to be used for creating the vapp.}
	host=${7:# The authentication host to be used when service type is vcd.}
	api_version=${8:5.7}
	service_type=${9:#vca|vcd|vchs}
	state=${10:absent|#present}
	validate_certs=${11:yes}
	vdc_name=${12:# The name of the vdc where the gateway is located.}
	gateway_name=${13:gateway}

endsnippet

snippet vmware_guest_find "Find the folder path(s) for a virtual machine by name or UUID" b
vmware_guest_find: >
	name=${1:# Name of the VM to work with.}
	uuid=${2:# UUID of the instance to manage if known, this is VMware's BIOS UUID by default.}
	use_instance_uuid=${3:no}
	datacenter=${4:# Destination datacenter for the find operation.}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_drs_rule_info "Gathers info about DRS rule on the given cluster" b
vmware_drs_rule_info: >
	cluster_name=${1:# Name of the cluster.}
	datacenter=${2:# Name of the datacenter.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_disk_info "Gather info about disks of given virtual machine" b
vmware_guest_disk_info: >
	datacenter=${1:# The datacenter name to which virtual machine belongs to.}

	name=${2:# Name of the virtual machine.}
	uuid=${3:# UUID of the instance to gather information if known, this is VMware's unique identifier.}
	moid=${4:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${5:no}
	folder=${6:# Destination folder, absolute or relative path to find an existing guest.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${8:# The username of the vSphere vCenter or ESXi server.}
	password=${9:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vm_info "Return basic info pertaining to a VMware machine guest" b
vmware_vm_info: >
	vm_type=${1:#all|vm|template}
	show_attribute=${2:no}
	folder=${3:# Specify a folder location of VMs to gather information from.}
	show_tag=${4:no}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_datastore_cluster "Manage VMware vSphere datastore clusters" b
vmware_datastore_cluster: >
	datastore_cluster_name=${1:# The name of the datastore cluster.}

	datacenter_name=${2:# The name of the datacenter.}
	state=${3:#present|absent}
	folder=${4:# Destination folder, absolute path to place datastore cluster in.}
	hostname=${5:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${6:# The username of the vSphere vCenter or ESXi server.}
	password=${7:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${8:yes}
	port=${9:443}
	proxy_host=${10:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${11:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vcenter_license "Manage VMware vCenter license keys" b
vcenter_license: >
	license=${1:# The license key to manage in vSphere vCenter.}

	labels=${2:{'source': 'ansible'}}
	state=${3:absent|#present}
	esxi_hostname=${4:# The hostname of the ESXi server to which the specified license will be assigned.}
	datacenter=${5:# The datacenter name to use for the operation.}
	cluster_name=${6:# Name of the cluster to apply vSAN license.}
	hostname=${7:# The hostname or IP address of the vSphere vCenter server.}
	username=${8:# The username of the vSphere vCenter server.}
	password=${9:# The password of the vSphere vCenter server.}
	validate_certs=${10:yes}
	port=${11:443}
	proxy_host=${12:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${13:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_vmkernel_ip_config "Configure the VMkernel IP Address" b
vmware_vmkernel_ip_config: >
	vmk_name=${1:# VMkernel interface name}
	ip_address=${2:# IP address to assign to VMkernel interface}
	subnet_mask=${3:# Subnet Mask to assign to VMkernel interface}

	hostname=${4:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${5:# The username of the vSphere vCenter or ESXi server.}
	password=${6:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${7:yes}
	port=${8:443}
	proxy_host=${9:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${10:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_guest_move "Moves virtual machines in vCenter" b
vmware_guest_move: >
	dest_folder=${1:# Absolute path to move an existing guest}
	datacenter=${2:# Destination datacenter for the move operation}

	name=${3:# Name of the existing virtual machine to move.}
	uuid=${4:# UUID of the virtual machine to manage if known, this is VMware's unique identifier.}
	moid=${5:# Managed Object ID of the instance to manage if known, this is a unique identifier only within a single vCenter instance.}
	use_instance_uuid=${6:no}
	name_match=${7:#first|last}
	hostname=${8:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${9:# The username of the vSphere vCenter or ESXi server.}
	password=${10:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${11:yes}
	port=${12:443}
	proxy_host=${13:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${14:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_host_config_info "Gathers info about an ESXi host's advance configuration information" b
vmware_host_config_info: >
	cluster_name=${1:# Name of the cluster from which the ESXi host belong to.}
	esxi_hostname=${2:# ESXi hostname to gather information from.}
	hostname=${3:# The hostname or IP address of the vSphere vCenter or ESXi server.}
	username=${4:# The username of the vSphere vCenter or ESXi server.}
	password=${5:# The password of the vSphere vCenter or ESXi server.}
	validate_certs=${6:yes}
	port=${7:443}
	proxy_host=${8:# Address of a proxy that will receive all HTTPS requests and relay them.}
	proxy_port=${9:# Port of the HTTP proxy that will receive all HTTPS requests and relay them.}

endsnippet

snippet vmware_category "Manage VMware categories" b
vmware_category: >
	category_name=${1:# The name of category to manage.}

	category_description=${2:}
	category_cardinality=${3:#multiple|single}
	new_category_name=${4:# The new name for an existing category.}
	state=${5:#present|absent}
	hostname=${6:# The hostname or IP address of the vSphere vCenter server.}
	username=${7:# The username of the vSphere vCenter server.}
	password=${8:# The password of the vSphere vCenter server.}
	validate_certs=${9:yes}
	protocol=${10:http|#https}

endsnippet

snippet fetch "Fetch files from remote nodes" b
fetch: >
	src=${1:# The file on the remote system to fetch.}
	dest=${2:# A directory to save the file into.}

	fail_on_missing=${3:yes}
	validate_checksum=${4:yes}
	flat=${5:no}

endsnippet

snippet tempfile "Creates temporary files and directories" b
tempfile: >
	state=${1:directory|#file}
	path=${2:# Location where temporary file or directory should be created.}
	prefix=${3:ansible.}
	suffix=${4:}

endsnippet

snippet patch "Apply patch files using the GNU patch tool" b
patch: >
	src=${1:# Path of the patch file as accepted by the GNU patch tool. If C(remote_src) is 'no', the patch source file is looked up from the module's I(files) directory.}

	basedir=${2:# Path of a base directory in which the patch file will be applied.}
	dest=${3:# Path of the file on the remote machine to be patched.}
	state=${4:absent|#present}
	remote_src=${5:no}
	strip=${6:0}
	backup=${7:no}
	binary=${8:no}

endsnippet

snippet read_csv "Read a CSV file" b
read_csv: >
	path=${1:# The CSV filename to read data from.}

	key=${2:# The column name used as a key for the resulting dictionary.}
	dialect=${3:excel}
	fieldnames=${4:# A list of field names for every column.}
	unique=${5:yes}
	delimiter=${6:# A one-character string used to separate fields.}
	skipinitialspace=${7:# Whether to ignore any whitespaces immediately following the delimiter.}
	strict=${8:# Whether to raise an exception on bad CSV input.}

endsnippet

snippet xml "Manage bits and pieces of XML files or strings" b
xml: >
	path=${1:# Path to the file to operate on.}
	xmlstring=${2:# A string containing XML on which to operate.}

	xpath=${3:# A valid XPath expression describing the item(s) you want to manipulate.}
	namespaces=${4:# The namespace C(prefix:uri) mapping for the XPath expression.}
	state=${5:absent|#present}
	attribute=${6:# The attribute to select when using parameter C(value).}
	value=${7:# Desired state of the selected attribute.}
	add_children=${8:# Add additional child-element(s) to a selected element for a given C(xpath).}
	set_children=${9:# Set the child-element(s) of a selected element for a given C(xpath).}
	count=${10:no}
	print_match=${11:no}
	pretty_print=${12:no}
	content=${13:attribute|text}
	input_type=${14:xml|#yaml}
	backup=${15:no}
	strip_cdata_tags=${16:no}
	insertbefore=${17:no}
	insertafter=${18:no}

endsnippet

snippet copy "Copy files to remote locations" b
copy: >
	dest=${1:# Remote absolute path where the file should be copied to.}

	src=${2:# Local path to a file to copy to the remote server.}
	content=${3:# When used instead of C(src), sets the contents of a file directly to the specified value.}
	backup=${4:no}
	force=${5:yes}
	mode=${6:# The permissions of the destination file or directory.}
	directory_mode=${7:# When doing a recursive copy set the mode for the directories.}
	remote_src=${8:no}
	follow=${9:no}
	local_follow=${10:yes}
	checksum=${11:# SHA1 checksum of the file being transferred.}
	decrypt=${12:yes}
	owner=${13:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${14:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${15:# The user part of the SELinux file context.}
	serole=${16:# The role part of the SELinux file context.}
	setype=${17:# The type part of the SELinux file context.}
	selevel=${18:s0}
	unsafe_writes=${19:no}
	attributes=${20:# The attributes the resulting file or directory should have.}
	validate=${21:# The validation command to run before copying into place.}

endsnippet

snippet assemble "Assemble configuration files from fragments" b
assemble: >
	src=${1:# An already existing directory full of source files.}
	dest=${2:# A file to create using the concatenation of all of the source files.}

	backup=${3:no}
	delimiter=${4:# A delimiter to separate the file contents.}
	remote_src=${5:no}
	regexp=${6:# Assemble files only if C(regex) matches the filename.}
	ignore_hidden=${7:no}
	validate=${8:# The validation command to run before copying into place.}
	decrypt=${9:yes}
	mode=${10:# The permissions the resulting file or directory should have.}
	owner=${11:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${12:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${13:# The user part of the SELinux file context.}
	serole=${14:# The role part of the SELinux file context.}
	setype=${15:# The type part of the SELinux file context.}
	selevel=${16:s0}
	unsafe_writes=${17:no}
	attributes=${18:# The attributes the resulting file or directory should have.}

endsnippet

snippet file "Manage files and file properties" b
file: >
	path=${1:# Path to the file being managed.}

	state=${2:absent|directory|#file|hard|link|touch}
	src=${3:# Path of the file to link to.}
	recurse=${4:no}
	force=${5:no}
	follow=${6:yes}
	modification_time=${7:# This parameter indicates the time the file's modification time should be set to.}
	modification_time_format=${8:%Y%m%d%H%M.%S}
	access_time=${9:# This parameter indicates the time the file's access time should be set to.}
	access_time_format=${10:%Y%m%d%H%M.%S}
	mode=${11:# The permissions the resulting file or directory should have.}
	owner=${12:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${13:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${14:# The user part of the SELinux file context.}
	serole=${15:# The role part of the SELinux file context.}
	setype=${16:# The type part of the SELinux file context.}
	selevel=${17:s0}
	unsafe_writes=${18:no}
	attributes=${19:# The attributes the resulting file or directory should have.}

endsnippet

snippet acl "Set and retrieve file ACL information." b
acl: >
	path=${1:# The full path of the file or object.}

	state=${2:absent|present|#query}
	follow=${3:yes}
	default=${4:no}
	entity=${5:# The actual user or group that the ACL applies to when matching entity types user or group are selected.}
	etype=${6:group|mask|other|user}
	permissions=${7:# The permissions to apply/remove can be any combination of C(r), C(w) and C(x) (read, write and execute respectively)}
	entry=${8:# DEPRECATED.}
	recursive=${9:no}
	use_nfsv4_acls=${10:no}
	recalculate_mask=${11:#default|mask|no_mask}

endsnippet

snippet lineinfile "Manage lines in text files" b
lineinfile: >
	path=${1:# The file to modify.}

	regexp=${2:# The regular expression to look for in every line of the file.}
	state=${3:absent|#present}
	line=${4:# The line to insert/replace into the file.}
	backrefs=${5:no}
	insertafter=${6:#EOF|*regex*}
	insertbefore=${7:BOF|*regex*}
	create=${8:no}
	backup=${9:no}
	firstmatch=${10:no}
	others=${11:# All arguments accepted by the M(file) module also work here.}
	mode=${12:# The permissions the resulting file or directory should have.}
	owner=${13:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${14:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${15:# The user part of the SELinux file context.}
	serole=${16:# The role part of the SELinux file context.}
	setype=${17:# The type part of the SELinux file context.}
	selevel=${18:s0}
	unsafe_writes=${19:no}
	attributes=${20:# The attributes the resulting file or directory should have.}
	validate=${21:# The validation command to run before copying into place.}

endsnippet

snippet blockinfile "Insert/update/remove a text block surrounded by marker lines" b
blockinfile: >
	path=${1:# The file to modify.}

	state=${2:absent|#present}
	marker=${3:# {mark} ANSIBLE MANAGED BLOCK}
	block=${4:}
	insertafter=${5:#EOF|*regex*}
	insertbefore=${6:BOF|*regex*}
	create=${7:no}
	backup=${8:no}
	marker_begin=${9:BEGIN}
	marker_end=${10:END}
	mode=${11:# The permissions the resulting file or directory should have.}
	owner=${12:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${13:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${14:# The user part of the SELinux file context.}
	serole=${15:# The role part of the SELinux file context.}
	setype=${16:# The type part of the SELinux file context.}
	selevel=${17:s0}
	unsafe_writes=${18:no}
	attributes=${19:# The attributes the resulting file or directory should have.}
	validate=${20:# The validation command to run before copying into place.}

endsnippet

snippet stat "Retrieve file or file system status" b
stat: >
	path=${1:# The full path of the file/object to get the facts of.}

	follow=${2:no}
	get_checksum=${3:yes}
	checksum_algorithm=${4:md5|#sha1|sha224|sha256|sha384|sha512}
	get_mime=${5:yes}
	get_attributes=${6:yes}

endsnippet

snippet synchronize "A wrapper around rsync to make common tasks in your playbooks quick and easy" b
synchronize: >
	src=${1:# Path on the source host that will be synchronized to the destination.}
	dest=${2:# Path on the destination host that will be synchronized from the source.}

	dest_port=${3:# Port number for ssh on the destination host.}
	mode=${4:pull|#push}
	archive=${5:yes}
	checksum=${6:no}
	compress=${7:yes}
	existing_only=${8:no}
	delete=${9:no}
	dirs=${10:no}
	recursive=${11:# Recurse into directories.}
	links=${12:# Copy symlinks as symlinks.}
	copy_links=${13:no}
	perms=${14:# Preserve permissions.}
	times=${15:# Preserve modification times.}
	owner=${16:# Preserve owner (super user only).}
	group=${17:# Preserve group.}
	rsync_path=${18:# Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.}
	rsync_timeout=${19:0}
	set_remote_user=${20:yes}
	use_ssh_args=${21:no}
	rsync_opts=${22:# Specify additional rsync options by passing in an array.}
	partial=${23:no}
	verify_host=${24:no}
	private_key=${25:# Specify the private key to use for SSH-based rsync connections (e.g. C(~/.ssh/id_rsa)).}
	link_dest=${26:# Add a destination to hard link against during the rsync.}

endsnippet

snippet xattr "Manage user defined extended attributes" b
xattr: >
	path=${1:# The full path of the file/object to get the facts of.}

	namespace=${2:user}
	key=${3:# The name of a specific Extended attribute key to set/retrieve.}
	value=${4:# The value to set the named name/key to, it automatically sets the C(state) to 'set'.}
	state=${5:absent|all|keys|present|#read}
	follow=${6:yes}

endsnippet

snippet archive "Creates a compressed archive of one or more files or trees" b
archive: >
	path=${1:# Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.}

	format=${2:bz2|#gz|tar|xz|zip}
	dest=${3:# The file name of the destination archive.}
	exclude_path=${4:# Remote absolute path, glob, or list of paths or globs for the file or files to exclude from the archive.}
	force_archive=${5:no}
	remove=${6:no}
	mode=${7:# The permissions the resulting file or directory should have.}
	owner=${8:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${9:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${10:# The user part of the SELinux file context.}
	serole=${11:# The role part of the SELinux file context.}
	setype=${12:# The type part of the SELinux file context.}
	selevel=${13:s0}
	unsafe_writes=${14:no}
	attributes=${15:# The attributes the resulting file or directory should have.}

endsnippet

snippet template "Template a file out to a remote server" b
template: >
	src=${1:# Path of a Jinja2 formatted template on the Ansible controller.}
	dest=${2:# Location to render the template to on the remote machine.}

	follow=${3:no}
	backup=${4:no}
	mode=${5:# The permissions the resulting file or directory should have.}
	owner=${6:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${7:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${8:# The user part of the SELinux file context.}
	serole=${9:# The role part of the SELinux file context.}
	setype=${10:# The type part of the SELinux file context.}
	selevel=${11:s0}
	unsafe_writes=${12:no}
	attributes=${13:# The attributes the resulting file or directory should have.}
	newline_sequence=${14:#\n|\r|\r\n}
	block_start_string=${15:{%}
	block_end_string=${16:%}}
	variable_start_string=${17:{{}
	variable_end_string=${18:}}}
	trim_blocks=${19:yes}
	lstrip_blocks=${20:no}
	force=${21:yes}
	output_encoding=${22:utf-8}
	validate=${23:# The validation command to run before copying into place.}

endsnippet

snippet find "Return a list of files based on specific criteria" b
find: >
	paths=${1:# List of paths of directories to search. All paths must be fully qualified.}

	age=${2:# Select files whose age is equal to or greater than the specified time.}
	patterns=${3:*}
	excludes=${4:# One or more (shell or regex) patterns, which type is controlled by C(use_regex) option.}
	contains=${5:# A regular expression or pattern which should be matched against the file content.}
	file_type=${6:any|directory|#file|link}
	recurse=${7:no}
	size=${8:# Select files whose size is equal to or greater than the specified size.}
	age_stamp=${9:atime|ctime|#mtime}
	hidden=${10:no}
	follow=${11:no}
	get_checksum=${12:no}
	use_regex=${13:no}
	depth=${14:# Set the maximum number of levels to descend into.}

endsnippet

snippet iso_extract "Extract files from an ISO image" b
iso_extract: >
	image=${1:# The ISO image to extract files from.}
	dest=${2:# The destination directory to extract files to.}
	files=${3:# A list of files to extract from the image.}

	force=${4:yes}
	executable=${5:7z}

endsnippet

snippet unarchive "Unpacks an archive after (optionally) copying it from the local machine." b
unarchive: >
	src=${1:# If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.}
	dest=${2:# Remote absolute path where the archive should be unpacked.}

	copy=${3:yes}
	creates=${4:# If the specified absolute path (file or directory) already exists, this step will B(not) be run.}
	list_files=${5:no}
	exclude=${6:# List the directory and file entries that you would like to exclude from the unarchive action.}
	keep_newer=${7:no}
	extra_opts=${8:}
	remote_src=${9:no}
	validate_certs=${10:yes}
	decrypt=${11:yes}
	mode=${12:# The permissions the resulting file or directory should have.}
	owner=${13:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${14:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${15:# The user part of the SELinux file context.}
	serole=${16:# The role part of the SELinux file context.}
	setype=${17:# The type part of the SELinux file context.}
	selevel=${18:s0}
	unsafe_writes=${19:no}
	attributes=${20:# The attributes the resulting file or directory should have.}

endsnippet

snippet ini_file "Tweak settings in INI files" b
ini_file: >
	path=${1:# Path to the INI-style file; this file is created if required.}
	section=${2:# Section name in INI file. This is added if C(state=present) automatically when a single value is being set.}

	option=${3:# If set (required for changing a I(value)), this is the name of the option.}
	value=${4:# The string value to be associated with an I(option).}
	backup=${5:no}
	state=${6:absent|#present}
	no_extra_spaces=${7:no}
	create=${8:yes}
	allow_no_value=${9:no}
	mode=${10:# The permissions the resulting file or directory should have.}
	owner=${11:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${12:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${13:# The user part of the SELinux file context.}
	serole=${14:# The role part of the SELinux file context.}
	setype=${15:# The type part of the SELinux file context.}
	selevel=${16:s0}
	unsafe_writes=${17:no}
	attributes=${18:# The attributes the resulting file or directory should have.}

endsnippet

snippet replace "Replace all instances of a particular string in a file using a back-referenced regular expression" b
replace: >
	path=${1:# The file to modify.}
	regexp=${2:# The regular expression to look for in the contents of the file.}

	replace=${3:# The string to replace regexp matches.}
	after=${4:# If specified, only content after this match will be replaced/removed.}
	before=${5:# If specified, only content before this match will be replaced/removed.}
	backup=${6:no}
	others=${7:# All arguments accepted by the M(file) module also work here.}
	encoding=${8:utf-8}
	mode=${9:# The permissions the resulting file or directory should have.}
	owner=${10:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${11:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${12:# The user part of the SELinux file context.}
	serole=${13:# The role part of the SELinux file context.}
	setype=${14:# The type part of the SELinux file context.}
	selevel=${15:s0}
	unsafe_writes=${16:no}
	attributes=${17:# The attributes the resulting file or directory should have.}
	validate=${18:# The validation command to run before copying into place.}

endsnippet

snippet telnet "Executes a low-down and dirty telnet command" b
telnet: >
	command=${1:# List of commands to be executed in the telnet session.}

	host=${2:remote_addr}
	user=${3:remote_user}
	password=${4:# The password for login}
	port=${5:23}
	timeout=${6:120}
	prompts=${7:['$']}
	login_prompt=${8:login: }
	password_prompt=${9:Password: }
	pause=${10:1}
	send_newline=${11:no}

endsnippet

snippet expect "Executes a command and responds to prompts." b
expect: >
	command=${1:# The command module takes command to run.}
	responses=${2:# Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.}

	creates=${3:# A filename, when it already exists, this step will B(not) be run.}
	removes=${4:# A filename, when it does not exist, this step will B(not) be run.}
	chdir=${5:# Change into this directory before running the command.}
	timeout=${6:30}
	echo=${7:no}

endsnippet

snippet command "Execute commands on targets" b
command: >
	${1:free_form=# The command module takes a free form command to run.}
	cmd=${2:# The command to run.}
	argv=${3:# Passes the command as a list rather than a string.}
	creates=${4:# A filename or (since 2.0) glob pattern. If it already exists, this step B(won't) be run.}
	removes=${5:# A filename or (since 2.0) glob pattern. If it already exists, this step B(will) be run.}
	chdir=${6:# Change into this directory before running the command.}
	warn=${7:yes}
	stdin=${8:# Set the stdin of the command directly to the specified value.}
	stdin_add_newline=${9:yes}
	strip_empty_ends=${10:yes}

endsnippet

snippet raw "Executes a low-down and dirty command" b
raw: >
	${1:free_form=# The raw module takes a free form command to run.}

	executable=${2:# Change the shell used to execute the command. Should be an absolute path to the executable.}

endsnippet

snippet shell "Execute shell commands on targets" b
shell: >
	${1:free_form=# The shell module takes a free form command to run, as a string.}
	cmd=${2:# The command to run followed by optional arguments.}
	creates=${3:# A filename, when it already exists, this step will B(not) be run.}
	removes=${4:# A filename, when it does not exist, this step will B(not) be run.}
	chdir=${5:# Change into this directory before running the command.}
	executable=${6:# Change the shell used to execute the command.}
	warn=${7:yes}
	stdin=${8:# Set the stdin of the command directly to the specified value.}
	stdin_add_newline=${9:yes}

endsnippet

snippet script "Runs a local script on a remote node after transferring it" b
script: >
	${1:free_form=# Path to the local script file followed by optional arguments.}
	cmd=${2:# Path to the local script to run followed by optional arguments.}
	creates=${3:# A filename on the remote node, when it already exists, this step will B(not) be run.}
	removes=${4:# A filename on the remote node, when it does not exist, this step will B(not) be run.}
	chdir=${5:# Change into this directory on the remote node before running the script.}
	executable=${6:# Name or path of a executable to invoke the script with.}
	decrypt=${7:yes}

endsnippet

snippet psexec "Runs commands on a remote Windows host based on the PsExec model" b
psexec: >
	hostname=${1:# The remote Windows host to connect to, can be either an IP address or a hostname.}
	executable=${2:# The executable to run on the Windows host.}

	connection_username=${3:# The username to use when connecting to the remote Windows host.}
	connection_password=${4:# The password for I(connection_user).}
	port=${5:445}
	encrypt=${6:yes}
	connection_timeout=${7:60}
	arguments=${8:# Any arguments as a single string to use when running the executable.}
	working_directory=${9:C:\Windows\System32}
	asynchronous=${10:no}
	load_profile=${11:yes}
	process_username=${12:# The user to run the process as.}
	process_password=${13:# The password for I(process_username).}
	integrity_level=${14:limited|#default|elevated}
	interactive=${15:no}
	interactive_session=${16:0}
	priority=${17:above_normal|below_normal|high|idle|#normal|realtime}
	show_ui_on_logon_screen=${18:no}
	process_timeout=${19:0}
	stdin=${20:# Data to send on the stdin pipe once the process has started.}

endsnippet

snippet win_hosts "Manages hosts file entries on Windows." b
win_hosts: >
	state=${1:absent|#present}
	canonical_name=${2:# A canonical name for the host entry.}
	ip_address=${3:# The ip address for the host entry.}
	aliases=${4:# A list of additional names (cname records) for the host entry.}
	action=${5:add|remove|#set}

endsnippet

snippet win_dsc "Invokes a PowerShell DSC configuration" b
win_dsc: >
	resource_name=${1:# The name of the DSC Resource to use.}
	${2:free_form=# The M(win_dsc) module takes in multiple free form options based on the DSC resource being invoked by I(resource_name).}

	module_version=${3:latest}

endsnippet

snippet win_user_profile "Manages the Windows user profiles." b
win_user_profile: >
	name=${1:# Specifies the base name for the profile path.}
	remove_multiple=${2:no}
	state=${3:absent|#present}
	username=${4:# The account name of security identifier (SID) for the profile.}

endsnippet

snippet win_whoami "Get information about the current user and process" b
win_whoami:

endsnippet

snippet win_snmp "Configures the Windows SNMP service" b
win_snmp: >
	permitted_managers=${1:# The list of permitted SNMP managers.}
	community_strings=${2:# The list of read-only SNMP community strings.}
	action=${3:add|#set|remove}

endsnippet

snippet win_iis_webapppool "Configure IIS Web Application Pools" b
win_iis_webapppool: >
	name=${1:# Name of the application pool.}

	attributes=${2:# This field is a free form dictionary value for the application pool attributes.}
	state=${3:absent|#present|restarted|started|stopped}

endsnippet

snippet win_tempfile "Creates temporary files and directories" b
win_tempfile: >
	state=${1:directory|#file}
	path=${2:%TEMP%}
	prefix=${3:ansible.}
	suffix=${4:}

endsnippet

snippet win_stat "Get information about Windows files" b
win_stat: >
	path=${1:# The full path of the file/object to get the facts of; both forward and back slashes are accepted.}

	get_md5=${2:no}
	get_checksum=${3:yes}
	checksum_algorithm=${4:md5|#sha1|sha256|sha384|sha512}
	follow=${5:no}

endsnippet

snippet win_http_proxy "Manages proxy settings for WinHTTP" b
win_http_proxy: >
	bypass=${1:# A list of hosts that will bypass the set proxy when being accessed.}
	proxy=${2:# A string or dict that specifies the proxy to be set.}
	source=${3:ie}

endsnippet

snippet win_disk_facts "Show the attached disks and disk information of the target host" b
win_disk_facts:

endsnippet

snippet win_rds_settings "Manage main settings of a Remote Desktop Gateway server" b
win_rds_settings: >
	certificate_hash=${1:# Certificate hash (thumbprint) for the Remote Desktop Gateway server. The certificate hash is the unique identifier for the certificate.}
	max_connections=${2:# The maximum number of connections allowed.}
	ssl_bridging=${3:https_http|https_https|none}
	enable_only_messaging_capable_clients=${4:# If enabled, only clients that support logon messages and administrator messages can connect.}

endsnippet

snippet win_chocolatey_facts "Create a facts collection for Chocolatey" b
win_chocolatey_facts:

endsnippet

snippet win_chocolatey_config "Manages Chocolatey config settings" b
win_chocolatey_config: >
	name=${1:# The name of the config setting to manage.}

	state=${2:absent|#present}
	value=${3:# Used when C(state=present) that contains the value to set for the config setting.}

endsnippet

snippet win_find "Return a list of files based on specific criteria" b
win_find: >
	paths=${1:# List of paths of directories to search for files or folders in.}

	age=${2:# Select files or folders whose age is equal to or greater than the specified time.}
	age_stamp=${3:atime|ctime|#mtime}
	checksum_algorithm=${4:md5|#sha1|sha256|sha384|sha512}
	file_type=${5:directory|#file}
	follow=${6:no}
	get_checksum=${7:yes}
	hidden=${8:no}
	patterns=${9:# One or more (powershell or regex) patterns to compare filenames with.}
	recurse=${10:no}
	size=${11:# Select files or folders whose size is equal to or greater than the specified size.}
	use_regex=${12:no}

endsnippet

snippet win_xml "Manages XML file content on Windows hosts" b
win_xml: >
	path=${1:# Path to the file to operate on.}
	type=${2:attribute|#element|text}
	xpath=${3:# Xpath to select the node or nodes to operate on.}

	attribute=${4:# The attribute name if the type is 'attribute'.}
	count=${5:no}
	backup=${6:no}
	fragment=${7:# The string representation of the XML fragment expected at xpath.  Since ansible 2.9 not required when I(state=absent), or when I(count=yes).}
	state=${8:#present|absent}

endsnippet

snippet win_scheduled_task_stat "Get information about Windows Scheduled Tasks" b
win_scheduled_task_stat: >
	path=${1:\}
	name=${2:# The name of the scheduled task to get information for.}

endsnippet

snippet win_owner "Set owner" b
win_owner: >
	path=${1:# Path to be used for changing owner.}
	user=${2:# Name to be used for changing owner.}

	recurse=${3:no}

endsnippet

snippet win_reboot "Reboot a windows machine" b
win_reboot: >
	pre_reboot_delay=${1:2}
	post_reboot_delay=${2:0}
	shutdown_timeout=${3:600}
	reboot_timeout=${4:600}
	connect_timeout=${5:5}
	test_command=${6:whoami}
	msg=${7:Reboot initiated by Ansible}

endsnippet

snippet win_dns_client "Configures DNS lookup on Windows hosts" b
win_dns_client: >
	adapter_names=${1:# Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value).}
	ipv4_addresses=${2:# Single or ordered list of DNS server IPv4 addresses to configure for lookup. An empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections.}

endsnippet

snippet win_acl_inheritance "Change ACL inheritance" b
win_acl_inheritance: >
	path=${1:# Path to be used for changing inheritance}

	state=${2:#absent|present}
	reorganize=${3:no}

endsnippet

snippet win_wait_for "Waits for a condition before continuing" b
win_wait_for: >
	connect_timeout=${1:5}
	delay=${2:# The number of seconds to wait before starting to poll.}
	exclude_hosts=${3:# The list of hosts or IPs to ignore when looking for active TCP connections when C(state=drained).}
	host=${4:127.0.0.1}
	path=${5:# The path to a file on the filesystem to check.}
	port=${6:# The port number to poll on C(host).}
	regex=${7:# Can be used to match a string in a file.}
	sleep=${8:1}
	state=${9:absent|drained|present|#started|stopped}
	timeout=${10:300}

endsnippet

snippet win_domain_controller "Manage domain controller/member server state for a Windows host" b
win_domain_controller: >
	domain_admin_user=${1:# Username of a domain admin for the target domain (necessary to promote or demote a domain controller).}
	domain_admin_password=${2:# Password for the specified C(domain_admin_user).}

	dns_domain_name=${3:# When C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC.}
	safe_mode_password=${4:# Safe mode password for the domain controller (required when C(state) is C(domain_controller)).}
	local_admin_password=${5:# Password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server)).}
	read_only=${6:no}
	site_name=${7:# Specifies the name of an existing site where you can place the new domain controller.}
	state=${8:domain_controller|member_server}
	database_path=${9:# The path to a directory on a fixed disk of the Windows host where the domain database will be created..}
	sysvol_path=${10:# The path to a directory on a fixed disk of the Windows host where the Sysvol folder will be created.}

endsnippet

snippet win_unzip "Unzips compressed files and archives on the Windows node" b
win_unzip: >
	src=${1:# File to be unzipped (provide absolute path).}
	dest=${2:# Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created.}

	delete_archive=${3:no}
	recurse=${4:no}
	creates=${5:# If this file or directory exists the specified src will not be extracted.}

endsnippet

snippet win_say "Text to speech module for Windows to speak messages and optionally play sounds" b
win_say: >
	msg=${1:# The text to be spoken.}
	msg_file=${2:# Full path to a windows format text file containing the text to be spoken.}
	voice=${3:# Which voice to use. See notes for how to discover installed voices.}
	speech_speed=${4:0}
	start_sound_path=${5:# Full path to a C(.wav) file containing a sound to play before the text is spoken.}
	end_sound_path=${6:# Full path to a C(.wav) file containing a sound to play after the text has been spoken.}

endsnippet

snippet win_route "Add or remove a static route" b
win_route: >
	destination=${1:# Destination IP address in CIDR format (ip address/prefix length).}

	gateway=${2:# The gateway used by the static route.}
	metric=${3:1}
	state=${4:absent|#present}

endsnippet

snippet win_product_facts "Provides Windows product and license information" b
win_product_facts:

endsnippet

snippet win_shell "Execute shell commands on target hosts" b
win_shell: >
	${1:free_form=# The C(win_shell) module takes a free form command to run.}

	creates=${2:# A path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.}
	removes=${3:# A path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.}
	chdir=${4:# Set the specified path as the current working directory before executing a command}
	executable=${5:# Change the shell used to execute the command (eg, C(cmd)).}
	stdin=${6:# Set the stdin of the command directly to the specified value.}
	no_profile=${7:no}

endsnippet

snippet win_domain_group_membership "Manage Windows domain group membership" b
win_domain_group_membership: >
	name=${1:# Name of the domain group to manage membership on.}
	members=${2:# A list of members to ensure are present/absent from the group.}

	state=${3:absent|#present|pure}
	domain_username=${4:# The username to use when interacting with AD.}
	domain_password=${5:# The password for I(username).}
	domain_server=${6:# Specifies the Active Directory Domain Services instance to connect to.}

endsnippet

snippet win_firewall_rule "Windows firewall automation" b
win_firewall_rule: >
	name=${1:# The rule's display name.}

	enabled=${2:# Whether this firewall rule is enabled or disabled.}
	state=${3:absent|#present}
	group=${4:# The group name for the rule.}
	direction=${5:in|out}
	action=${6:allow|block}
	description=${7:# Description for the firewall rule.}
	localip=${8:# The local ip address this rule applies to.}
	remoteip=${9:# The remote ip address/range this rule applies to.}
	localport=${10:# The local port this rule applies to.}
	remoteport=${11:# The remote port this rule applies to.}
	program=${12:# The program this rule applies to.}
	service=${13:# The service this rule applies to.}
	protocol=${14:# The protocol this rule applies to.}
	profiles=${15:# The profile this rule applies to.}

endsnippet

snippet win_partition "Creates, changes and removes partitions on Windows Server" b
win_partition: >
	state=${1:absent|#present}
	drive_letter=${2:# Used for accessing partitions if I(disk_number) and I(partition_number) are not provided.}
	disk_number=${3:# Disk number is mandatory for creating new partitions.}
	partition_number=${4:# Used in conjunction with I(disk_number) to uniquely identify a partition.}
	partition_size=${5:# Specify size of the partition in B, KB, KiB, MB, MiB, GB, GiB, TB or TiB. Use -1 to specify maximum supported size.}
	read_only=${6:# Make the partition read only, restricting changes from being made to the partition.}
	active=${7:# Specifies if the partition is active and can be used to start the system. This property is only valid when the disk's partition style is MBR.}
	hidden=${8:# Hides the target partition, making it undetectable by the mount manager.}
	offline=${9:# Sets the partition offline.}
	mbr_type=${10:fat12|fat16|extended|huge|ifs|fat32}
	gpt_type=${11:system_partition|microsoft_reserved|basic_data|microsoft_recovery}

endsnippet

snippet win_security_policy "Change local security policy settings" b
win_security_policy: >
	section=${1:# The ini section the key exists in.}
	key=${2:# The ini key of the section or policy name to modify.}
	value=${3:# The value for the ini key or policy name.}

endsnippet

snippet win_file "Creates, touches or removes files or directories" b
win_file: >
	path=${1:# Path to the file being managed.}

	state=${2:absent|directory|file|touch}

endsnippet

snippet win_firewall "Enable or disable the Windows Firewall" b
win_firewall: >
	profiles=${1:[#'Domain', #'Private', #'Public'}
	state=${2:disabled|enabled}

endsnippet

snippet win_get_url "Downloads file from HTTP, HTTPS, or FTP to node" b
win_get_url: >
	url=${1:# The full URL of a file to download.}
	dest=${2:# The location to save the file at the URL.}

	force=${3:yes}
	checksum=${4:# If a I(checksum) is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully.}
	checksum_algorithm=${5:md5|#sha1|sha256|sha384|sha512}
	checksum_url=${6:# Specifies a URL that contains the checksum values for the resource at I(url).}
	proxy_url=${7:# An explicit proxy to use for the request.}
	proxy_username=${8:# The username to use for proxy authentication.}
	proxy_password=${9:# The password for I(proxy_username).}
	headers=${10:# Extra headers to set on the request.}
	use_proxy=${11:yes}
	follow_redirects=${12:all|none|#safe}
	maximum_redirection=${13:50}
	client_cert=${14:# The path to the client certificate (.pfx) that is used for X509 authentication. This path can either be the path to the C(pfx) on the filesystem or the PowerShell certificate path C(Cert:\CurrentUser\My\<thumbprint>).}
	client_cert_password=${15:# The password for I(client_cert) if the cert is password protected.}
	method=${16:# This option is not for use with C(win_get_url) and should be ignored.}
	http_agent=${17:ansible-httpget}
	timeout=${18:30}
	validate_certs=${19:yes}
	force_basic_auth=${20:no}
	url_username=${21:# The username to use for authentication.}
	url_password=${22:# The password for I(url_username).}
	use_default_credential=${23:no}
	proxy_use_default_credential=${24:no}

endsnippet

snippet win_rds_cap "Manage Connection Authorization Policies (CAP) on a Remote Desktop Gateway server" b
win_rds_cap: >
	name=${1:# Name of the connection authorization policy.}

	state=${2:absent|enabled|disabled|#present}
	auth_method=${3:both|none|password|smartcard}
	order=${4:# Evaluation order of the policy.}
	session_timeout=${5:# The maximum time, in minutes, that a session can be idle.}
	session_timeout_action=${6:#disconnect|reauth}
	idle_timeout=${7:# Specifies the time interval, in minutes, after which an idle session is disconnected.}
	allow_only_sdrts_servers=${8:# Specifies whether connections are allowed only to Remote Desktop Session Host servers that enforce Remote Desktop Gateway redirection policy.}
	user_groups=${9:# A list of user groups that is allowed to connect to the Remote Gateway server.}
	computer_groups=${10:# A list of computer groups that is allowed to connect to the Remote Gateway server.}
	redirect_clipboard=${11:# Allow clipboard redirection.}
	redirect_drives=${12:# Allow disk drive redirection.}
	redirect_printers=${13:# Allow printers redirection.}
	redirect_serial=${14:# Allow serial port redirection.}
	redirect_pnp=${15:# Allow Plug and Play devices redirection.}

endsnippet

snippet win_netbios "Manage NetBIOS over TCP/IP settings on Windows." b
win_netbios: >
	state=${1:enabled|disabled|default}

	adapter_names=${2:# List of adapter names for which to manage NetBIOS settings. If this option is omitted then configuration is applied to all adapters on the system.}

endsnippet

snippet win_nssm "Install a service using NSSM" b
win_nssm: >
	name=${1:# Name of the service to operate on.}

	state=${2:absent|#present|started|stopped|restarted}
	application=${3:# The application binary to run as a service}
	executable=${4:nssm.exe}
	description=${5:# The description to set for the service.}
	display_name=${6:# The display name to set for the service.}
	working_directory=${7:# The working directory to run the service executable from (defaults to the directory containing the application binary)}
	stdout_file=${8:# Path to receive output.}
	stderr_file=${9:# Path to receive error output.}
	app_parameters=${10:# A string representing a dictionary of parameters to be passed to the application when it starts.}
	arguments=${11:# Parameters to be passed to the application when it starts.}
	dependencies=${12:# Service dependencies that has to be started to trigger startup, separated by comma.}
	user=${13:# User to be used for service startup.}
	password=${14:# Password to be used for service startup.}
	start_mode=${15:#auto|delayed|disabled|manual}

endsnippet

snippet win_path "Manage Windows path environment variables" b
win_path: >
	elements=${1:# A single path element, or a list of path elements (ie, directories) to add or remove.}

	name=${2:PATH}
	state=${3:absent|present}
	scope=${4:#machine|user}

endsnippet

snippet win_inet_proxy "Manages proxy settings for WinINet and Internet Explorer" b
win_inet_proxy: >
	auto_detect=${1:yes}
	auto_config_url=${2:# The URL of a proxy configuration script.}
	bypass=${3:# A list of hosts that will bypass the set proxy when being accessed.}
	connection=${4:# The name of the IE connection to set the proxy settings for.}
	proxy=${5:# A string or dict that specifies the proxy to be set.}

endsnippet

snippet win_rabbitmq_plugin "Manage RabbitMQ plugins" b
win_rabbitmq_plugin: >
	names=${1:# Comma-separated list of plugin names.}

	new_only=${2:no}
	state=${3:disabled|#enabled}
	prefix=${4:# Specify a custom install prefix to a Rabbit.}

endsnippet

snippet win_psmodule "Adds or removes a Windows PowerShell module" b
win_psmodule: >
	name=${1:# Name of the Windows PowerShell module that has to be installed.}

	state=${2:absent|latest|#present}
	required_version=${3:# The exact version of the PowerShell module that has to be installed.}
	minimum_version=${4:# The minimum version of the PowerShell module that has to be installed.}
	maximum_version=${5:# The maximum version of the PowerShell module that has to be installed.}
	allow_clobber=${6:no}
	skip_publisher_check=${7:no}
	allow_prerelease=${8:no}
	repository=${9:# Name of the custom repository to use.}
	url=${10:# URL of the custom repository to register.}

endsnippet

snippet win_ping "A windows version of the classic ping module" b
win_ping: >
	data=${1:pong}

endsnippet

snippet win_defrag "Consolidate fragmented files on local volumes" b
win_defrag: >
	include_volumes=${1:# A list of drive letters or mount point paths of the volumes to be defragmented.}
	exclude_volumes=${2:# A list of drive letters or mount point paths to exclude from defragmentation.}
	freespace_consolidation=${3:no}
	priority=${4:#low|normal}
	parallel=${5:no}

endsnippet

snippet win_pester "Run Pester tests on Windows hosts" b
win_pester: >
	path=${1:# Path to a pester test file or a folder where tests can be found.}

	tags=${2:# Runs only tests in Describe blocks with specified Tags values.}
	test_parameters=${3:# Allows to specify parameters to the test script.}
	version=${4:# Minimum version of the pester module that has to be available on the remote host.}

endsnippet

snippet win_dotnet_ngen "Runs ngen to recompile DLLs after .NET  updates" b
win_dotnet_ngen:

endsnippet

snippet win_domain_computer "Manage computers in Active Directory" b
win_domain_computer: >
	name=${1:# Specifies the name of the object.}

	sam_account_name=${2:# Specifies the Security Account Manager (SAM) account name of the computer.}
	enabled=${3:yes}
	ou=${4:# Specifies the X.500 path of the Organizational Unit (OU) or container where the new object is created. Required when I(state=present).}
	description=${5:}
	dns_hostname=${6:# Specifies the fully qualified domain name (FQDN) of the computer.}
	domain_username=${7:# The username to use when interacting with AD.}
	domain_password=${8:# The password for I(username).}
	domain_server=${9:# Specifies the Active Directory Domain Services instance to connect to.}
	state=${10:absent|#present}

endsnippet

snippet win_domain_user "Manages Windows Active Directory user accounts" b
win_domain_user: >
	name=${1:# Name of the user to create, remove or modify.}

	state=${2:absent|#present|query}
	enabled=${3:yes}
	account_locked=${4:False}
	description=${5:# Description of the user}
	groups=${6:# Adds or removes the user from this list of groups, depending on the value of I(groups_action).}
	groups_action=${7:add|remove|#replace}
	password=${8:# Optionally set the user's password to this (plain text) value.}
	update_password=${9:#always|on_create|when_changed}
	password_expired=${10:# C(yes) will require the user to change their password at next login.}
	password_never_expires=${11:# C(yes) will set the password to never expire.}
	user_cannot_change_password=${12:# C(yes) will prevent the user from changing their password.}
	firstname=${13:# Configures the user's first name (given name).}
	surname=${14:# Configures the user's last name (surname).}
	company=${15:# Configures the user's company name.}
	upn=${16:# Configures the User Principal Name (UPN) for the account.}
	email=${17:# Configures the user's email address.}
	street=${18:# Configures the user's street address.}
	city=${19:# Configures the user's city.}
	state_province=${20:# Configures the user's state or province.}
	postal_code=${21:# Configures the user's postal code / zip code.}
	country=${22:# Configures the user's country code.}
	path=${23:# Container or OU for the new user; if you do not specify this, the user will be placed in the default container for users in the domain.}
	attributes=${24:# A dict of custom LDAP attributes to set on the user.}
	domain_username=${25:# The username to use when interacting with AD.}
	domain_password=${26:# The password for I(username).}
	domain_server=${27:# Specifies the Active Directory Domain Services instance to connect to.}

endsnippet

snippet win_eventlog "Manage Windows event logs" b
win_eventlog: >
	name=${1:# Name of the event log to manage.}

	state=${2:absent|clear|#present}
	sources=${3:# A list of one or more sources to ensure are present/absent in the log.}
	category_file=${4:# For one or more sources specified, the path to a custom category resource file.}
	message_file=${5:# For one or more sources specified, the path to a custom event message resource file.}
	parameter_file=${6:# For one or more sources specified, the path to a custom parameter resource file.}
	maximum_size=${7:# The maximum size of the event log.}
	overflow_action=${8:DoNotOverwrite|OverwriteAsNeeded|OverwriteOlder}
	retention_days=${9:# The minimum number of days event entries must remain in the log.}

endsnippet

snippet win_psexec "Runs commands (remotely) as another (privileged) user" b
win_psexec: >
	command=${1:# The command line to run through PsExec (limited to 260 characters).}

	executable=${2:psexec.exe}
	extra_opts=${3:# Specify additional options to add onto the PsExec invocation.}
	hostnames=${4:# The hostnames to run the command.}
	username=${5:# The (remote) user to run the command as.}
	password=${6:# The password for the (remote) user to run the command as.}
	chdir=${7:# Run the command from this (remote) directory.}
	nobanner=${8:no}
	noprofile=${9:no}
	elevated=${10:no}
	interactive=${11:no}
	session=${12:# Specifies the session ID to use.}
	limited=${13:no}
	system=${14:no}
	priority=${15:abovenormal|background|belownormal|high|low|realtime}
	timeout=${16:# The connection timeout in seconds}
	wait=${17:yes}

endsnippet

snippet win_hotfix "Install and uninstalls Windows hotfixes" b
win_hotfix: >
	hotfix_identifier=${1:# The name of the hotfix as shown in DISM, see examples for details.}
	hotfix_kb=${2:# The name of the KB the hotfix relates to, see examples for details.}
	state=${3:absent|#present}
	source=${4:# The path to the downloaded hotfix .msu file.}

endsnippet

snippet win_reg_stat "Get information about Windows registry keys" b
win_reg_stat: >
	path=${1:# T}

	name=${2:# The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.}

endsnippet

snippet win_service "Manage and query Windows services" b
win_service: >
	name=${1:# Name of the service.}

	dependencies=${2:# A list of service dependencies to set for this particular service.}
	dependency_action=${3:add|remove|#set}
	desktop_interact=${4:no}
	description=${5:# The description to set for the service.}
	display_name=${6:# The display name to set for the service.}
	force_dependent_services=${7:no}
	path=${8:# The path to the executable to set for the service.}
	password=${9:# The password to set the service to start as.}
	start_mode=${10:auto|delayed|disabled|manual}
	state=${11:absent|paused|started|stopped|restarted}
	username=${12:# The username to set the service to start as.}

endsnippet

snippet win_user_right "Manage Windows User Rights" b
win_user_right: >
	name=${1:# The name of the User Right as shown by the C(Constant Name) value from U(https://technet.microsoft.com/en-us/library/dd349804.aspx).}
	users=${2:# A list of users or groups to add/remove on the User Right.}

	action=${3:add|remove|#set}

endsnippet

snippet win_regedit "Add, change, or remove registry keys and values" b
win_regedit: >
	path=${1:# Name of the registry path.}

	name=${2:# Name of the registry entry in the above C(path) parameters.}
	data=${3:# Value of the registry entry C(name) in C(path).}
	type=${4:binary|dword|expandstring|multistring|#string|qword}
	state=${5:absent|#present}
	delete_key=${6:yes}
	hive=${7:# A path to a hive key like C:\Users\Default\NTUSER.DAT to load in the registry.}

endsnippet

snippet win_iis_webbinding "Configures a IIS Web site binding" b
win_iis_webbinding: >
	name=${1:# Names of web site.}

	state=${2:absent|#present}
	port=${3:80}
	ip=${4:*}
	host_header=${5:# The host header to bind to / use for the new site.}
	protocol=${6:http}
	certificate_hash=${7:# Certificate hash (thumbprint) for the SSL binding. The certificate hash is the unique identifier for the certificate.}
	certificate_store_name=${8:my}
	ssl_flags=${9:# This parameter is only valid on Server 2012 and newer.}

endsnippet

snippet win_audit_policy_system "Used to make changes to the system wide Audit Policy" b
win_audit_policy_system: >
	audit_type=${1:failure|none|success}

	category=${2:# Single string value for the category you would like to adjust the policy on.}
	subcategory=${3:# Single string value for the subcategory you would like to adjust the policy on.}

endsnippet

snippet win_package "Installs/uninstalls an installable package" b
win_package: >
	arguments=${1:# Any arguments the installer needs to either install or uninstall the package.}
	chdir=${2:# Set the specified path as the current working directory before installing or uninstalling a package.}
	creates_path=${3:# Will check the existence of the path specified and use the result to determine whether the package is already installed.}
	creates_service=${4:# Will check the existing of the service specified and use the result to determine whether the package is already installed.}
	creates_version=${5:# Will check the file version property of the file at C(creates_path) and use the result to determine whether the package is already installed.}
	expected_return_code=${6:[0, 3010]}
	password=${7:# The password for C(user_name), must be set when C(user_name) is.}
	path=${8:# Location of the package to be installed or uninstalled.}
	product_id=${9:# The product id of the installed packaged.}
	state=${10:absent|#present}
	username=${11:# Username of an account with access to the package if it is located on a file share.}
	validate_certs=${12:yes}
	log_path=${13:# Specifies the path to a log file that is persisted after an MSI package is installed or uninstalled.}

endsnippet

snippet win_chocolatey_feature "Manages Chocolatey features" b
win_chocolatey_feature: >
	name=${1:# The name of the feature to manage.}

	state=${2:disabled|#enabled}

endsnippet

snippet win_certificate_store "Manages the certificate store" b
win_certificate_store: >
	state=${1:absent|exported|#present}
	path=${2:# The path to a certificate file.}
	thumbprint=${3:# The thumbprint as a hex string to either export or remove.}
	store_name=${4:AddressBook|AuthRoot|CertificateAuthority|Disallowed|#My|Root|TrustedPeople|TrustedPublisher}
	store_location=${5:CurrentUser|#LocalMachine}
	password=${6:# The password of the pkcs12 certificate key.}
	key_exportable=${7:yes}
	key_storage=${8:#default|machine|user}
	file_type=${9:#der|pem|pkcs12}

endsnippet

snippet win_wakeonlan "Send a magic Wake-on-LAN (WoL) broadcast packet" b
win_wakeonlan: >
	mac=${1:# MAC address to send Wake-on-LAN broadcast packet for.}

	broadcast=${2:255.255.255.255}
	port=${3:7}

endsnippet

snippet win_domain_group "Creates, modifies or removes domain groups" b
win_domain_group: >
	name=${1:# The name of the group to create, modify or remove.}

	attributes=${2:# A dict of custom LDAP attributes to set on the group.}
	category=${3:distribution|security}
	description=${4:# The value to be assigned to the LDAP C(description) attribute.}
	display_name=${5:# The value to assign to the LDAP C(displayName) attribute.}
	domain_username=${6:# The username to use when interacting with AD.}
	domain_password=${7:# The password for C(username).}
	domain_server=${8:# Specifies the Active Directory Domain Services instance to connect to.}
	ignore_protection=${9:no}
	managed_by=${10:# The value to be assigned to the LDAP C(managedBy) attribute.}
	organizational_unit=${11:# The full LDAP path to create or move the group to.}
	protect=${12:# Will set the C(ProtectedFromAccidentalDeletion) flag based on this value.}
	scope=${13:domainlocal|global|universal}
	state=${14:absent|#present}

endsnippet

snippet win_msg "Sends a message to logged in users on Windows hosts" b
win_msg: >
	to=${1:*}
	display_seconds=${2:10}
	wait=${3:no}
	msg=${4:Hello world!}

endsnippet

snippet win_eventlog_entry "Write entries to Windows event logs" b
win_eventlog_entry: >
	log=${1:# Name of the event log to write an entry to.}
	source=${2:# Name of the log source to indicate where the entry is from.}
	event_id=${3:# The numeric event identifier for the entry.}
	message=${4:# The message for the given log entry.}

	entry_type=${5:Error|FailureAudit|Information|SuccessAudit|Warning}
	category=${6:# A numeric task category associated with the category message file for the log source.}
	raw_data=${7:# Binary data associated with the log entry.}

endsnippet

snippet win_iis_webapplication "Configures IIS web applications" b
win_iis_webapplication: >
	name=${1:# Name of the web application.}
	site=${2:# Name of the site on which the application is created.}

	state=${3:absent|#present}
	physical_path=${4:# The physical path on the remote host to use for the new application.}
	application_pool=${5:# The application pool in which the new site executes.}

endsnippet

snippet win_chocolatey "Manage packages using chocolatey" b
win_chocolatey: >
	name=${1:# Name of the package(s) to be installed.}

	allow_empty_checksums=${2:no}
	allow_multiple=${3:no}
	allow_prerelease=${4:no}
	architecture=${5:#default|x86}
	force=${6:no}
	install_args=${7:# Arguments to pass to the native installer.}
	ignore_checksums=${8:no}
	ignore_dependencies=${9:no}
	package_params=${10:# Parameters to pass to the package.}
	pinned=${11:# Whether to pin the Chocolatey package or not.}
	proxy_url=${12:# Proxy URL used to install chocolatey and the package.}
	proxy_username=${13:# Proxy username used to install Chocolatey and the package.}
	proxy_password=${14:# Proxy password used to install Chocolatey and the package.}
	skip_scripts=${15:no}
	source=${16:# Specify the source to retrieve the package from.}
	source_username=${17:# A username to use with I(source) when accessing a feed that requires authentication.}
	source_password=${18:# The password for I(source_username).}
	state=${19:absent|downgrade|latest|#present|reinstalled}
	timeout=${20:2700}
	validate_certs=${21:yes}
	version=${22:# Specific version of the package to be installed.}

endsnippet

snippet win_optional_feature "Manage optional Windows features" b
win_optional_feature: >
	name=${1:# The name(s) of the feature to install.}

	state=${2:absent|#present}
	include_parent=${3:no}
	source=${4:# Specify a source to install the feature from.}

endsnippet

snippet win_pagefile "Query or change pagefile configuration" b
win_pagefile: >
	drive=${1:# The drive of the pagefile.}
	initial_size=${2:# The initial size of the pagefile in megabytes.}
	maximum_size=${3:# The maximum size of the pagefile in megabytes.}
	override=${4:yes}
	system_managed=${5:no}
	automatic=${6:# Configures AutomaticManagedPagefile for the entire system.}
	remove_all=${7:no}
	test_path=${8:yes}
	state=${9:absent|present|#query}

endsnippet

snippet win_scheduled_task "Manage scheduled tasks" b
win_scheduled_task: >
	name=${1:# The name of the scheduled task without the path.}

	path=${2:\}
	state=${3:absent|#present}
	actions=${4:# A list of action to configure for the task.}
	triggers=${5:# A list of triggers to configure for the task.}
	display_name=${6:# The name of the user/group that is displayed in the Task Scheduler UI.}
	group=${7:# The group that will run the task.}
	logon_type=${8:none|password|s4u|interactive_token|group|service_account|token_or_password}
	run_level=${9:limited|highest}
	username=${10:# The user to run the scheduled task as.}
	password=${11:# The password for the user account to run the scheduled task as.}
	update_password=${12:yes}
	author=${13:# The author of the task.}
	date=${14:# The date when the task was registered.}
	description=${15:# The description of the task.}
	source=${16:# The source of the task.}
	version=${17:# The version number of the task.}
	allow_demand_start=${18:# Whether the task can be started by using either the Run command or the Context menu.}
	allow_hard_terminate=${19:# Whether the task can be terminated by using TerminateProcess.}
	compatibility=${20:0|1|2}
	delete_expired_task_after=${21:# The amount of time that the Task Scheduler will wait before deleting the task after it expires.}
	disallow_start_if_on_batteries=${22:# Whether the task will not be started if the computer is running on battery power.}
	enabled=${23:# Whether the task is enabled, the task can only run when C(yes).}
	execution_time_limit=${24:# The amount of time allowed to complete the task.}
	hidden=${25:# Whether the task will be hidden in the UI.}
	multiple_instances=${26:0|1|2|3}
	priority=${27:# The priority level (0-10) of the task.}
	restart_count=${28:# The number of times that the Task Scheduler will attempt to restart the task.}
	restart_interval=${29:# How long the Task Scheduler will attempt to restart the task.}
	run_only_if_idle=${30:# Whether the task will run the task only if the computer is in an idle state.}
	run_only_if_network_available=${31:# Whether the task will run only when a network is available.}
	start_when_available=${32:# Whether the task can start at any time after its scheduled time has passed.}
	stop_if_going_on_batteries=${33:# Whether the task will be stopped if the computer begins to run on battery power.}
	wake_to_run=${34:# Whether the task will wake the computer when it is time to run the task.}

endsnippet

snippet win_audit_rule "Adds an audit rule to files, folders, or registry keys" b
win_audit_rule: >
	path=${1:# Path to the file, folder, or registry key.}
	user=${2:# The user or group to adjust rules for.}
	rights=${3:# Comma separated list of the rights desired. Only required for adding a rule.}
	audit_flags=${4:Failure|Success}

	inheritance_flags=${5:ContainerInherit|ObjectInherit}
	propagation_flags=${6:#None|InherityOnly|NoPropagateInherit}
	state=${7:absent|#present}

endsnippet

snippet win_command "Executes a command on a remote Windows node" b
win_command: >
	${1:free_form=# The C(win_command) module takes a free form command to run.}

	creates=${2:# A path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.}
	removes=${3:# A path or path filter pattern; when the referenced path B(does not) exist on the target host, the task will be skipped.}
	chdir=${4:# Set the specified path as the current working directory before executing a command.}
	stdin=${5:# Set the stdin of the command directly to the specified value.}

endsnippet

snippet win_credential "Manages Windows Credentials in the Credential Manager" b
win_credential: >
	name=${1:# The target that identifies the server or servers that the credential is to be used for.}
	type=${2:domain_certificate|domain_password|generic_certificate|generic_password}

	alias=${3:# Adds an alias for the credential.}
	attributes=${4:# A list of dicts that set application specific attributes for a credential.}
	comment=${5:# A user defined comment for the credential.}
	persistence=${6:enterprise|#local}
	secret=${7:# The secret for the credential.}
	secret_format=${8:base64|#text}
	state=${9:absent|#present}
	update_secret=${10:#always|on_create}
	username=${11:# When I(type) is a password type, then this is the username to store for the credential.}

endsnippet

snippet win_power_plan "Changes the power plan of a Windows system" b
win_power_plan: >
	name=${1:# String value that indicates the desired power plan.}

endsnippet

snippet win_webpicmd "Installs packages using Web Platform Installer command-line" b
win_webpicmd: >
	name=${1:# Name of the package to be installed.}

endsnippet

snippet win_user "Manages local Windows user accounts" b
win_user: >
	name=${1:# Name of the user to create, remove or modify.}

	fullname=${2:# Full name of the user.}
	description=${3:# Description of the user.}
	password=${4:# Optionally set the user's password to this (plain text) value.}
	update_password=${5:#always|on_create}
	password_expired=${6:# C(yes) will require the user to change their password at next login.}
	password_never_expires=${7:# C(yes) will set the password to never expire.}
	user_cannot_change_password=${8:# C(yes) will prevent the user from changing their password.}
	account_disabled=${9:# C(yes) will disable the user account.}
	account_locked=${10:no}
	groups=${11:# Adds or removes the user from this comma-separated list of groups, depending on the value of I(groups_action).}
	groups_action=${12:add|#replace|remove}
	state=${13:absent|#present|query}

endsnippet

snippet win_domain "Ensures the existence of a Windows domain" b
win_domain: >
	dns_domain_name=${1:# The DNS name of the domain which should exist and be reachable or reside on the target Windows host.}
	safe_mode_password=${2:# Safe mode password for the domain controller.}

	domain_netbios_name=${3:# The NetBIOS name for the root domain in the new forest.}
	database_path=${4:# The path to a directory on a fixed disk of the Windows host where the domain database will be created.}
	sysvol_path=${5:# The path to a directory on a fixed disk of the Windows host where the Sysvol file will be created.}
	create_dns_delegation=${6:# Whether to create a DNS delegation that references the new DNS server that you install along with the domain controller.}
	domain_mode=${7:Win2003|Win2008|Win2008R2|Win2012|Win2012R2|WinThreshold}
	forest_mode=${8:Win2003|Win2008|Win2008R2|Win2012|Win2012R2|WinThreshold}

endsnippet

snippet win_group_membership "Manage Windows local group membership" b
win_group_membership: >
	name=${1:# Name of the local group to manage membership on.}
	members=${2:# A list of members to ensure are present/absent from the group.}

	state=${3:absent|#present|pure}

endsnippet

snippet win_template "Template a file out to a remote server" b
win_template: >
	src=${1:# Path of a Jinja2 formatted template on the Ansible controller.}
	dest=${2:# Location to render the template to on the remote machine.}

	backup=${3:no}
	newline_sequence=${4:\n|\r|#\r\n}
	force=${5:yes}
	block_start_string=${6:{%}
	block_end_string=${7:%}}
	variable_start_string=${8:{{}
	variable_end_string=${9:}}}
	trim_blocks=${10:yes}
	lstrip_blocks=${11:no}
	output_encoding=${12:utf-8}

endsnippet

snippet win_robocopy "Synchronizes the contents of two directories using Robocopy" b
win_robocopy: >
	src=${1:# Source file/directory to sync.}
	dest=${2:# Destination file/directory to sync (Will receive contents of src).}

	recurse=${3:no}
	purge=${4:no}
	flags=${5:# Directly supply Robocopy flags.}

endsnippet

snippet win_region "Set the region and format settings" b
win_region: >
	location=${1:# The location to set for the current user, see U(https://msdn.microsoft.com/en-us/library/dd374073.aspx) for a list of GeoIDs you can use and what location it relates to.}
	format=${2:# The language format to set for the current user, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use.}
	unicode_language=${3:# The unicode language format to set for all users, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use.}
	copy_settings=${4:no}

endsnippet

snippet win_psrepository "Adds, removes or updates a Windows PowerShell repository." b
win_psrepository: >
	name=${1:# Name of the repository to work with.}

	source=${2:# Specifies the URI for discovering and installing modules from this repository.}
	state=${3:absent|#present}
	installation_policy=${4:trusted|untrusted}

endsnippet

snippet win_environment "Modify environment variables on windows hosts" b
win_environment: >
	name=${1:# The name of the environment variable.}
	level=${2:machine|process|user}

	state=${3:absent|#present}
	value=${4:# The value to store in the environment variable.}

endsnippet

snippet win_dns_record "Manage Windows Server DNS records" b
win_dns_record: >
	name=${1:# The name of the record.}
	type=${2:A|AAAA|CNAME|PTR}
	zone=${3:# The name of the zone to manage (eg C(example.com)).}

	state=${4:absent|#present}
	ttl=${5:3600}
	value=${6:# The value(s) to specify. Required when C(state=present).}
	computer_name=${7:# Specifies a DNS server.}

endsnippet

snippet win_copy "Copies files to remote locations on windows hosts" b
win_copy: >
	dest=${1:# Remote absolute path where the file should be copied to.}

	content=${2:# When used instead of C(src), sets the contents of a file directly to the specified value.}
	decrypt=${3:yes}
	backup=${4:no}
	force=${5:yes}
	local_follow=${6:yes}
	remote_src=${7:no}
	src=${8:# Local path to a file to copy to the remote server; can be absolute or relative.}

endsnippet

snippet win_share "Manage Windows shares" b
win_share: >
	name=${1:# Share name.}
	path=${2:# Share directory.}

	state=${3:absent|#present}
	description=${4:# Share description.}
	list=${5:no}
	read=${6:# Specify user list that should get read access on share, separated by comma.}
	change=${7:# Specify user list that should get read and write access on share, separated by comma.}
	full=${8:# Specify user list that should get full access on share, separated by comma.}
	deny=${9:# Specify user list that should get no access, regardless of implied access on share, separated by comma.}
	caching_mode=${10:BranchCache|Documents|#Manual|None|Programs|Unknown}
	encrypt=${11:no}

endsnippet

snippet win_lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression" b
win_lineinfile: >
	path=${1:# The path of the file to modify.}

	backup=${2:no}
	regex=${3:# The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx).}
	state=${4:absent|#present}
	line=${5:# Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.}
	backrefs=${6:no}
	insertafter=${7:#EOF|*regex*}
	insertbefore=${8:BOF|*regex*}
	create=${9:no}
	validate=${10:# Validation to run before copying into place. Use %s in the command to indicate the current file to validate.}
	encoding=${11:auto}
	newline=${12:unix|#windows}

endsnippet

snippet win_timezone "Sets Windows machine timezone" b
win_timezone: >
	timezone=${1:# Timezone to set to.}

endsnippet

snippet win_iis_virtualdirectory "Configures a virtual directory in IIS" b
win_iis_virtualdirectory: >
	name=${1:# The name of the virtual directory to create or remove.}
	site=${2:# The site name under which the virtual directory is created or exists.}

	state=${3:absent|#present}
	application=${4:# The application under which the virtual directory is created or exists.}
	physical_path=${5:# The physical path to the folder in which the new virtual directory is created.}

endsnippet

snippet win_rds_rap "Manage Resource Authorization Policies (RAP) on a Remote Desktop Gateway server" b
win_rds_rap: >
	name=${1:# Name of the resource authorization policy.}

	state=${2:absent|disabled|enabled|#present}
	description=${3:# Optional description of the resource authorization policy.}
	user_groups=${4:# List of user groups that are associated with this resource authorization policy (RAP). A user must belong to one of these groups to access the RD Gateway server.}
	allowed_ports=${5:# List of port numbers through which connections are allowed for this policy.}
	computer_group_type=${6:rdg_group|ad_network_resource_group|allow_any}
	computer_group=${7:# The computer group name that is associated with this resource authorization policy (RAP).}

endsnippet

snippet win_shortcut "Manage shortcuts on Windows" b
win_shortcut: >
	dest=${1:# Destination file for the shortcuting file.}

	src=${2:# Executable or URL the shortcut points to.}
	description=${3:# Description for the shortcut.}
	arguments=${4:# Additional arguments for the executable defined in C(src).}
	directory=${5:# Working directory for executable defined in C(src).}
	icon=${6:# Icon used for the shortcut.}
	hotkey=${7:# Key combination for the shortcut.}
	windowstyle=${8:maximized|minimized|normal}
	state=${9:absent|#present}
	run_as_admin=${10:no}

endsnippet

snippet win_mapped_drive "Map network drives for users" b
win_mapped_drive: >
	letter=${1:# The letter of the network path to map to.}

	password=${2:# The password for C(username) that is used when testing the initial connection.}
	path=${3:# The UNC path to map the drive to.}
	state=${4:absent|#present}
	username=${5:# The username that is used when testing the initial connection.}

endsnippet

snippet win_updates "Download and install Windows updates" b
win_updates: >
	blacklist=${1:# A list of update titles or KB numbers that can be used to specify which updates are to be excluded from installation.}
	category_names=${2:['CriticalUpdates', 'SecurityUpdates', 'UpdateRollups']}
	reboot=${3:no}
	reboot_timeout=${4:1200}
	server_selection=${5:#default|managed_server|windows_update}
	state=${6:#installed|searched|downloaded}
	log_path=${7:# If set, C(win_updates) will append update progress to the specified file. The directory must already exist.}
	whitelist=${8:# A list of update titles or KB numbers that can be used to specify which updates are to be searched or installed.}
	use_scheduled_task=${9:no}

endsnippet

snippet win_uri "Interacts with webservices" b
win_uri: >
	url=${1:# Supports FTP, HTTP or HTTPS URLs in the form of (ftp|http|https)://host.domain:port/path.}

	method=${2:GET}
	content_type=${3:# Sets the "Content-Type" header.}
	body=${4:# The body of the HTTP request/response to the web service.}
	dest=${5:# Output the response body to a file.}
	creates=${6:# A filename, when it already exists, this step will be skipped.}
	removes=${7:# A filename, when it does not exist, this step will be skipped.}
	return_content=${8:no}
	status_code=${9:[200]}
	url_username=${10:# The username to use for authentication.}
	url_password=${11:# The password for I(url_username).}
	follow_redirects=${12:all|none|#safe}
	maximum_redirection=${13:50}
	client_cert=${14:# The path to the client certificate (.pfx) that is used for X509 authentication. This path can either be the path to the C(pfx) on the filesystem or the PowerShell certificate path C(Cert:\CurrentUser\My\<thumbprint>).}
	client_cert_password=${15:# The password for I(client_cert) if the cert is password protected.}
	use_proxy=${16:yes}
	proxy_url=${17:# An explicit proxy to use for the request.}
	proxy_username=${18:# The username to use for proxy authentication.}
	proxy_password=${19:# The password for I(proxy_username).}
	headers=${20:# Extra headers to set on the request.}
	http_agent=${21:ansible-httpget}
	timeout=${22:30}
	validate_certs=${23:yes}
	force_basic_auth=${24:no}
	use_default_credential=${25:no}
	proxy_use_default_credential=${26:no}

endsnippet

snippet win_file_version "Get DLL or EXE file build version" b
win_file_version: >
	path=${1:# File to get version.}

endsnippet

snippet win_regmerge "Merges the contents of a registry file into the Windows registry" b
win_regmerge: >
	path=${1:# The full path including file name to the registry file on the remote machine to be merged}

	compare_key=${2:# The parent key to use when comparing the contents of the registry to the contents of the file.  Needs to be in HKLM or HKCU part of registry. Use a PS-Drive style path for example HKLM:\SOFTWARE not HKEY_LOCAL_MACHINE\SOFTWARE If not supplied, or the registry key is not found, no comparison will be made, and the module will report changed.}

endsnippet

snippet win_group "Add and remove local groups" b
win_group: >
	name=${1:# Name of the group.}

	description=${2:# Description of the group.}
	state=${3:absent|#present}

endsnippet

snippet win_toast "Sends Toast windows notification to logged in users on Windows 10 or later hosts" b
win_toast: >
	expire=${1:45}
	group=${2:Powershell}
	msg=${3:Hello, World!}
	popup=${4:yes}
	tag=${5:Ansible}
	title=${6:Notification HH:mm}

endsnippet

snippet win_chocolatey_source "Manages Chocolatey sources" b
win_chocolatey_source: >
	name=${1:# The name of the source to configure.}

	admin_only=${2:# Makes the source visible to Administrators only.}
	allow_self_service=${3:# Allow the source to be used with self-service}
	bypass_proxy=${4:# Bypass the proxy when using this source.}
	certificate=${5:# The path to a .pfx file to use for X509 authenticated feeds.}
	certificate_password=${6:# The password for I(certificate) if required.}
	priority=${7:# The priority order of this source compared to other sources, lower is better.}
	source=${8:# The file/folder/url of the source.}
	source_username=${9:# The username used to access I(source).}
	source_password=${10:# The password for I(source_username).}
	state=${11:absent|disabled|#present}
	update_password=${12:#always|on_create}

endsnippet

snippet win_feature "Installs and uninstalls Windows Features on Windows Server" b
win_feature: >
	name=${1:# Names of roles or features to install as a single feature or a comma-separated list of features.}

	state=${2:absent|#present}
	include_sub_features=${3:no}
	include_management_tools=${4:no}
	source=${5:# Specify a source to install the feature from.}

endsnippet

snippet win_format "Formats an existing volume or a new volume on an existing partition on Windows" b
win_format: >
	drive_letter=${1:# Used to specify the drive letter of the volume to be formatted.}
	path=${2:# Used to specify the path to the volume to be formatted.}
	label=${3:# Used to specify the label of the volume to be formatted.}
	new_label=${4:# Used to specify the new file system label of the formatted volume.}
	file_system=${5:ntfs|refs|exfat|fat32|fat}
	allocation_unit_size=${6:# Specifies the cluster size to use when formatting the volume.}
	large_frs=${7:# Specifies that large File Record System (FRS) should be used.}
	compress=${8:# Enable compression on the resulting NTFS volume.}
	integrity_streams=${9:# Enable integrity streams on the resulting ReFS volume.}
	full=${10:# A full format writes to every sector of the disk, takes much longer to perform than the default (quick) format, and is not recommended on storage that is thinly provisioned.}
	force=${11:# Specify if formatting should be forced for volumes that are not created from new partitions or if the source and target file system are different.}

endsnippet

snippet win_acl "Set file/directory/registry permissions for a system user or group" b
win_acl: >
	path=${1:# The path to the file or directory.}
	user=${2:# User or Group to add specified rights to act on src file/folder or registry key.}
	type=${3:allow|deny}
	rights=${4:# The rights/permissions that are to be allowed/denied for the specified user or group for the item at C(path).}

	state=${5:absent|#present}
	inherit=${6:ContainerInherit|ObjectInherit}
	propagation=${7:InheritOnly|#None|NoPropagateInherit}

endsnippet

snippet win_domain_membership "Manage domain/workgroup membership for a Windows host" b
win_domain_membership: >
	domain_admin_user=${1:# Username of a domain admin for the target domain (required to join or leave the domain).}

	dns_domain_name=${2:# When C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined.}
	domain_admin_password=${3:# Password for the specified C(domain_admin_user).}
	hostname=${4:# The desired hostname for the Windows host.}
	domain_ou_path=${5:# The desired OU path for adding the computer object.}
	state=${6:domain|workgroup}
	workgroup_name=${7:# When C(state) is C(workgroup), the name of the workgroup that the Windows host should be in.}

endsnippet

snippet win_disk_image "Manage ISO/VHD/VHDX mounts on Windows hosts" b
win_disk_image: >
	image_path=${1:# Path to an ISO, VHD, or VHDX image on the target Windows host (the file cannot reside on a network share)}

	state=${2:absent|#present}

endsnippet

snippet win_iis_website "Configures a IIS Web site" b
win_iis_website: >
	name=${1:# Names of web site.}

	site_id=${2:# Explicitly set the IIS numeric ID for a site.}
	state=${3:absent|started|stopped|restarted}
	physical_path=${4:# The physical path on the remote host to use for the new site.}
	application_pool=${5:# The application pool in which the new site executes.}
	port=${6:# The port to bind to / use for the new site.}
	ip=${7:# The IP address to bind to / use for the new site.}
	hostname=${8:# The host header to bind to / use for the new site.}
	ssl=${9:# Enables HTTPS binding on the site..}
	parameters=${10:# Custom site Parameters from string where properties are separated by a pipe and property name/values by colon Ex. "foo:1|bar:2"}

endsnippet

snippet win_wait_for_process "Waits for a process to exist or not exist before continuing." b
win_wait_for_process: >
	process_name_exact=${1:# The name of the process(es) for which to wait.  The name of the process(es) should not include the file extension suffix.}
	process_name_pattern=${2:# RegEx pattern matching desired process(es).}
	sleep=${3:1}
	process_min_count=${4:1}
	pid=${5:# The PID of the process.}
	owner=${6:# The owner of the process.}
	pre_wait_delay=${7:0}
	post_wait_delay=${8:0}
	state=${9:absent|#present}
	timeout=${10:300}

endsnippet

snippet win_hostname "Manages local Windows computer name" b
win_hostname: >
	name=${1:# The hostname to set for the computer.}

endsnippet

snippet sensu_check "Manage Sensu checks" b
sensu_check: >
	name=${1:# The name of the check}
	command=${2:# Path to the sensu check to run (not required when I(state=absent))}

	state=${3:#present|absent}
	path=${4:/etc/sensu/conf.d/checks.json}
	backup=${5:no}
	handlers=${6:[]}
	subscribers=${7:[]}
	interval=${8:# Check interval in seconds}
	timeout=${9:10}
	ttl=${10:# Time to live in seconds until the check is considered stale}
	handle=${11:yes}
	subdue_begin=${12:# When to disable handling of check failures}
	subdue_end=${13:# When to enable handling of check failures}
	dependencies=${14:[]}
	metric=${15:no}
	standalone=${16:no}
	publish=${17:yes}
	occurrences=${18:1}
	refresh=${19:# Number of seconds handlers should wait before taking second action}
	aggregate=${20:no}
	low_flap_threshold=${21:# The low threshold for flap detection}
	high_flap_threshold=${22:# The high threshold for flap detection}
	custom=${23:{}}
	source=${24:# The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).}

endsnippet

snippet nagios "Perform common tasks in Nagios related to downtime and notifications." b
nagios: >
	action=${1:downtime|delete_downtime|enable_alerts|disable_alerts|silence|unsilence|silence_nagios|unsilence_nagios|command|servicegroup_service_downtime|servicegroup_host_downtime}
	services=${2:# What to manage downtime/alerts for. Separate multiple services with commas. C(service) is an alias for C(services). B(Required) option when using the C(downtime), C(enable_alerts), and C(disable_alerts) actions.}
	command=${3:# The raw command to send to nagios, which should not include the submitted time header or the line-feed B(Required) option when using the C(command) action.}

	host=${4:# Host to operate on in Nagios.}
	cmdfile=${5:auto-detected}
	author=${6:Ansible}
	comment=${7:Scheduling downtime}
	minutes=${8:30}
	servicegroup=${9:# The Servicegroup we want to set downtimes/alerts for. B(Required) option when using the C(servicegroup_service_downtime) amd C(servicegroup_host_downtime).}

endsnippet

snippet grafana_dashboard "Manage Grafana dashboards" b
grafana_dashboard: >
	url=${1:# The Grafana URL.}
	state=${2:absent|export|#present}

	url_username=${3:admin}
	url_password=${4:admin}
	grafana_api_key=${5:# The Grafana API key.}
	org_id=${6:1}
	slug=${7:# Deprecated since Grafana 5. Use grafana dashboard uid instead.}
	uid=${8:# uid of the dashboard to export when C(state) is C(export) or C(absent).}
	path=${9:# The path to the json file containing the Grafana dashboard to import or export.}
	overwrite=${10:no}
	message=${11:# Set a commit message for the version history.}
	validate_certs=${12:yes}
	client_cert=${13:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${14:# PEM formatted file that contains your private key to be used for SSL client}
	use_proxy=${15:yes}

endsnippet

snippet circonus_annotation "create an annotation in circonus" b
circonus_annotation: >
	api_key=${1:# Circonus API key}
	category=${2:# Annotation Category}
	description=${3:# Description of annotation}
	title=${4:# Title of annotation}

	start=${5:I(now)}
	stop=${6:I(now) + I(duration)}
	duration=${7:0}

endsnippet

snippet datadog_monitor "Manages Datadog monitors" b
datadog_monitor: >
	api_key=${1:# Your Datadog API key.}
	app_key=${2:# Your Datadog app key.}
	state=${3:present|absent|mute|unmute}
	name=${4:# The name of the alert.}

	tags=${5:# A list of tags to associate with your monitor when creating or updating.}
	type=${6:metric alert|service check|event alert}
	query=${7:# The monitor query to notify on.}
	message=${8:# A message to include with notifications for this monitor.}
	silenced=${9:}
	notify_no_data=${10:no}
	no_data_timeframe=${11:2x timeframe for metric, 2 minutes for service}
	timeout_h=${12:# The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.}
	renotify_interval=${13:# The number of minutes after the last notification before a monitor will re-notify on the current status.}
	escalation_message=${14:# A message to include with a re-notification. Supports the '@username' notification we allow elsewhere.}
	notify_audit=${15:no}
	thresholds=${16:{'ok': 1, 'critical': 1, 'warning': 1}}
	locked=${17:no}
	require_full_window=${18:# Whether this monitor needs a full window of data before it gets evaluated.}
	new_host_delay=${19:# A positive integer representing the number of seconds to wait before evaluating the monitor for new hosts.}
	evaluation_delay=${20:# Time to delay evaluation (in seconds).}
	id=${21:# The ID of the alert.}

endsnippet

snippet bigpanda "Notify BigPanda about deployments" b
bigpanda: >
	component=${1:# The name of the component being deployed. Ex: billing}
	version=${2:# The deployment version.}
	token=${3:# API token.}
	state=${4:started|finished|failed}

	hosts=${5:machine's hostname}
	env=${6:# The environment name, typically 'production', 'staging', etc.}
	owner=${7:# The person responsible for the deployment.}
	description=${8:# Free text description of the deployment.}
	url=${9:https://api.bigpanda.io}
	validate_certs=${10:yes}

endsnippet

snippet statusio_maintenance "Create maintenance windows for your status.io dashboard" b
statusio_maintenance: >
	api_id=${1:# Your unique API ID from status.io}
	api_key=${2:# Your unique API Key from status.io}
	statuspage=${3:# Your unique StatusPage ID from status.io}

	title=${4:A new maintenance window}
	desc=${5:Created by Ansible}
	state=${6:#present|absent}
	url=${7:https://api.status.io}
	components=${8:# The given name of your component (server name)}
	containers=${9:# The given name of your container (data center)}
	all_infrastructure_affected=${10:no}
	automation=${11:no}
	maintenance_notify_now=${12:no}
	maintenance_notify_72_hr=${13:no}
	maintenance_notify_24_hr=${14:no}
	maintenance_notify_1_hr=${15:no}
	maintenance_id=${16:# The maintenance id number when deleting a maintenance window}
	minutes=${17:10}
	start_date=${18:# Date maintenance is expected to start (Month/Day/Year) (UTC)}
	start_time=${19:# Time maintenance is expected to start (Hour:Minutes) (UTC)}

endsnippet

snippet monit "Manage the state of a program monitored via Monit" b
monit: >
	name=${1:# The name of the I(monit) program/process to manage}
	state=${2:present|started|stopped|restarted|monitored|unmonitored|reloaded}

	timeout=${3:300}

endsnippet

snippet honeybadger_deployment "Notify Honeybadger.io about app deployments" b
honeybadger_deployment: >
	token=${1:# API token.}
	environment=${2:# The environment name, typically 'production', 'staging', etc.}

	user=${3:# The username of the person doing the deployment}
	repo=${4:# URL of the project repository}
	revision=${5:# A hash, number, tag, or other identifier showing what revision was deployed}
	url=${6:https://api.honeybadger.io/v1/deploys}
	validate_certs=${7:yes}

endsnippet

snippet icinga2_host "Manage a host in Icinga2" b
icinga2_host: >
	url=${1:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	name=${2:# Name used to create / delete the host. This does not need to be the FQDN, but does needs to be unique.}
	ip=${3:# The IP address of the host.}

	use_proxy=${4:yes}
	validate_certs=${5:yes}
	url_username=${6:# The username for use in HTTP basic authentication.}
	url_password=${7:# The password for use in HTTP basic authentication.}
	force_basic_auth=${8:no}
	client_cert=${9:# PEM formatted certificate chain file to be used for SSL client authentication. This file can also include the key as well, and if the key is included, C(client_key) is not required.}
	client_key=${10:# PEM formatted file that contains your private key to be used for SSL client authentication. If C(client_cert) contains both the certificate and key, this option is not required.}
	state=${11:#present|absent}
	zone=${12:# The zone from where this host should be polled.}
	template=${13:# The template used to define the host.}
	check_command=${14:hostalive}
	display_name=${15:if none is give it is the value of the <name> parameter}
	variables=${16:# List of variables.}

endsnippet

snippet sensu_handler "Manages Sensu handler configuration" b
sensu_handler: >
	name=${1:# A unique name for the handler. The name cannot contain special characters or spaces.}
	type=${2:pipe|tcp|udp|transport|set}

	state=${3:#present|absent}
	filter=${4:# The Sensu event filter (name) to use when filtering events for the handler.}
	filters=${5:# An array of Sensu event filters (names) to use when filtering events for the handler.}
	severities=${6:warning|critical|unknown}
	mutator=${7:# The Sensu event mutator (name) to use to mutate event data for the handler.}
	timeout=${8:10}
	handle_silenced=${9:no}
	handle_flapping=${10:no}
	command=${11:# The handler command to be executed.}
	socket=${12:# The socket definition scope, used to configure the TCP/UDP handler socket.}
	pipe=${13:# The pipe definition scope, used to configure the Sensu transport pipe.}
	handlers=${14:# An array of Sensu event handlers (names) to use for events using the handler set.}

endsnippet

snippet datadog_event "Posts events to Datadog  service" b
datadog_event: >
	api_key=${1:# Your DataDog API key.}
	app_key=${2:# Your DataDog app key.}
	title=${3:# The event title.}
	text=${4:# The body of the event.}

	date_happened=${5:now}
	priority=${6:#normal|low}
	host=${7:{{ ansible_hostname }}}
	tags=${8:# Comma separated list of tags to apply to the event.}
	alert_type=${9:error|warning|#info|success}
	aggregation_key=${10:# An arbitrary string to use for aggregation.}
	validate_certs=${11:yes}

endsnippet

snippet grafana_datasource "Manage Grafana datasources" b
grafana_datasource: >
	grafana_url=${1:# The Grafana URL.}
	name=${2:# The name of the datasource.}
	ds_type=${3:graphite|prometheus|elasticsearch|influxdb|opentsdb|mysql|postgres|cloudwatch|alexanderzobnin-zabbix-datasource}
	url=${4:# The URL of the datasource.}

	access=${5:direct|#proxy}
	url_username=${6:admin}
	url_password=${7:admin}
	grafana_api_key=${8:# The Grafana API key.}
	database=${9:# Name of the database for the datasource.}
	user=${10:# The datasource login user for influxdb datasources.}
	password=${11:# The datasource password}
	basic_auth_user=${12:# The datasource basic auth user.}
	basic_auth_password=${13:# The datasource basic auth password, when C(basic auth) is C(yes).}
	with_credentials=${14:no}
	tls_client_cert=${15:# The client TLS certificate.}
	tls_client_key=${16:# The client TLS private key}
	tls_ca_cert=${17:# The TLS CA certificate for self signed certificates.}
	tls_skip_verify=${18:no}
	is_default=${19:no}
	org_id=${20:1}
	state=${21:absent|#present}
	es_version=${22:2|#5|56}
	max_concurrent_shard_requests=${23:256}
	time_field=${24:timestamp}
	time_interval=${25:# Minimum group by interval for C(influxdb) or C(elasticsearch) datasources.}
	interval=${26:|Hourly|Daily|Weekly|Monthly|Yearly}
	tsdb_version=${27:#1|2|3}
	tsdb_resolution=${28:millisecond|#second}
	sslmode=${29:disable|require|verify-ca|verify-full}
	trends=${30:# Use trends or not for zabbix datasource type}
	client_cert=${31:# TLS certificate path used by ansible to query grafana api}
	client_key=${32:# TLS private key path used by ansible to query grafana api}
	validate_certs=${33:yes}
	use_proxy=${34:yes}
	aws_auth_type=${35:#keys|credentials|arn}
	aws_default_region=${36:ap-northeast-1|ap-northeast-2|ap-southeast-1|ap-southeast-2|ap-south-1|ca-central-1|cn-north-1|cn-northwest-1|eu-central-1|eu-west-1|eu-west-2|eu-west-3|sa-east-1|#us-east-1|us-east-2|us-gov-west-1|us-west-1|us-west-2}
	aws_credentials_profile=${37:}
	aws_access_key=${38:}
	aws_secret_key=${39:}
	aws_assume_role_arn=${40:}
	aws_custom_metrics_namespaces=${41:}

endsnippet

snippet logstash_plugin "Manage Logstash plugins" b
logstash_plugin: >
	name=${1:# Install plugin with that name.}

	state=${2:#present|absent}
	plugin_bin=${3:/usr/share/logstash/bin/logstash-plugin}
	proxy_host=${4:# Proxy host to use during plugin installation.}
	proxy_port=${5:# Proxy port to use during plugin installation.}
	version=${6:# Specify plugin Version of the plugin to install. If plugin exists with previous version, it will NOT be updated.}

endsnippet

snippet logicmonitor "Manage your LogicMonitor account through Ansible Playbooks" b
logicmonitor: >
	target=${1:collector|host|datasource|hostgroup}
	action=${2:add|remove|update|sdt}
	company=${3:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes."}
	user=${4:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
	password=${5:# The password of the specified LogicMonitor user}

	collector=${6:# The fully qualified domain name of a collector in your LogicMonitor account.}
	hostname=${7:hostname -f}
	displayname=${8:hostname -f}
	description=${9:}
	properties=${10:{}}
	groups=${11:[]}
	id=${12:# ID of the datasource to target.}
	fullpath=${13:# The fullpath of the host group object you would like to manage.}
	alertenable=${14:yes}
	starttime=${15:Now}
	duration=${16:30}

endsnippet

snippet logicmonitor_facts "Collect facts about LogicMonitor objects" b
logicmonitor_facts: >
	target=${1:host|hostgroup}
	company=${2:# The LogicMonitor account company name. If you would log in to your account at "superheroes.logicmonitor.com" you would use "superheroes".}
	user=${3:# A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.}
	password=${4:# The password for the chosen LogicMonitor User.}

	collector=${5:# The fully qualified domain name of a collector in your LogicMonitor account.}
	hostname=${6:hostname -f}
	displayname=${7:hostname -f}
	fullpath=${8:# The fullpath of the hostgroup object you would like to manage.}

endsnippet

snippet sensu_silence "Manage Sensu silence entries" b
sensu_silence: >
	state=${1:#present|absent}
	subscription=${2:[]}

	check=${3:# Specifies the check which the silence entry applies to.}
	creator=${4:# Specifies the entity responsible for this entry.}
	expire=${5:# If specified, the silence entry will be automatically cleared after this number of seconds.}
	expire_on_resolve=${6:# If specified as true, the silence entry will be automatically cleared once the condition it is silencing is resolved.}
	reason=${7:# If specified, this free-form string is used to provide context or rationale for the reason this silence entry was created.}
	url=${8:http://127.0.01:4567}

endsnippet

snippet logentries "Module for tracking logs via logentries.com" b
logentries: >
	path=${1:# path to a log file}

	state=${2:#present|absent}
	name=${3:# name of the log}
	logtype=${4:# type of the log}

endsnippet

snippet pagerduty_alert "Trigger, acknowledge or resolve PagerDuty incidents" b
pagerduty_alert: >
	service_id=${1:# ID of PagerDuty service when incidents will be triggered, acknowledged or resolved.}
	integration_key=${2:# The GUID of one of your "Generic API" services.}
	state=${3:triggered|acknowledged|resolved}
	api_key=${4:# The pagerduty API key (readonly access), generated on the pagerduty site.}

	name=${5:# PagerDuty unique subdomain. Obsolete. It is not used with PagerDuty REST v2 API.}
	service_key=${6:# The GUID of one of your "Generic API" services. Obsolete. Please use I(integration_key).}
	desc=${7:Created via Ansible}
	incident_key=${8:# Identifies the incident to which this I(state) should be applied.}
	client=${9:# The name of the monitoring client that is triggering this event.}
	client_url=${10:# The URL of the monitoring client that is triggering this event.}

endsnippet

snippet grafana_plugin "Manage Grafana plugins via grafana-cli" b
grafana_plugin: >
	name=${1:# Name of the plugin.}

	version=${2:# Version of the plugin to install.}
	grafana_plugins_dir=${3:# Directory where the Grafana plugin will be installed.}
	grafana_repo=${4:# URL to the Grafana plugin repository.}
	grafana_plugin_url=${5:# Full URL to the plugin zip file instead of downloading the file from U(https://grafana.com/api/plugins).}
	state=${6:#present|absent}

endsnippet

snippet newrelic_deployment "Notify newrelic about app deployments" b
newrelic_deployment: >
	token=${1:# API token, to place in the x-api-key header.}

	app_name=${2:# (one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application}
	application_id=${3:# (one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM}
	changelog=${4:# A list of changes for this deployment}
	description=${5:# Text annotation for the deployment - notes for you}
	revision=${6:# A revision number (e.g., git commit SHA)}
	user=${7:# The name of the user/process that triggered this deployment}
	appname=${8:# Name of the application}
	environment=${9:# The environment for this deployment}
	validate_certs=${10:yes}

endsnippet

snippet uptimerobot "Pause and start Uptime Robot monitoring" b
uptimerobot: >
	state=${1:started|paused}
	monitorid=${2:# ID of the monitor to check.}
	apikey=${3:# Uptime Robot API key.}

endsnippet

snippet sensu_client "Manages Sensu client configuration" b
sensu_client: >
	subscriptions=${1:# An array of client subscriptions, a list of roles and/or responsibilities assigned to the system (e.g. webserver).}

	state=${2:#present|absent}
	name=${3:System hostname as determined by Ruby Socket.gethostname (provided by Sensu)}
	address=${4:Non-loopback IPv4 address as determined by Ruby Socket.ip_address_list (provided by Sensu)}
	safe_mode=${5:no}
	redact=${6:# Client definition attributes to redact (values) when logging and sending client keepalives.}
	socket=${7:# The socket definition scope, used to configure the Sensu client socket.}
	keepalives=${8:yes}
	keepalive=${9:# The keepalive definition scope, used to configure Sensu client keepalives behavior (e.g. keepalive thresholds, etc).}
	registration=${10:# The registration definition scope, used to configure Sensu registration event handlers.}
	deregister=${11:no}
	deregistration=${12:# The deregistration definition scope, used to configure automated Sensu client de-registration.}
	ec2=${13:# The ec2 definition scope, used to configure the Sensu Enterprise AWS EC2 integration (Sensu Enterprise users only).}
	chef=${14:# The chef definition scope, used to configure the Sensu Enterprise Chef integration (Sensu Enterprise users only).}
	puppet=${15:# The puppet definition scope, used to configure the Sensu Enterprise Puppet integration (Sensu Enterprise users only).}
	servicenow=${16:# The servicenow definition scope, used to configure the Sensu Enterprise ServiceNow integration (Sensu Enterprise users only).}

endsnippet

snippet librato_annotation "create an annotation in librato" b
librato_annotation: >
	user=${1:# Librato account username}
	api_key=${2:# Librato account api key}
	title=${3:# The title of an annotation is a string and may contain spaces}
	links=${4:# See examples}

	name=${5:# The annotation stream name}
	source=${6:# A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population}
	description=${7:# The description contains extra metadata about a particular annotation}
	start_time=${8:# The unix timestamp indicating the time at which the event referenced by this annotation started}
	end_time=${9:# The unix timestamp indicating the time at which the event referenced by this annotation ended}

endsnippet

snippet sensu_subscription "Manage Sensu subscriptions" b
sensu_subscription: >
	name=${1:# The name of the channel}

	state=${2:#present|absent}
	path=${3:/etc/sensu/conf.d/subscriptions.json}
	backup=${4:no}

endsnippet

snippet icinga2_feature "Manage Icinga2 feature" b
icinga2_feature: >
	name=${1:# This is the feature name to enable or disable.}

	state=${2:#present|absent}

endsnippet

snippet rollbar_deployment "Notify Rollbar about app deployments" b
rollbar_deployment: >
	token=${1:# Your project access token.}
	environment=${2:# Name of the environment being deployed, e.g. 'production'.}
	revision=${3:# Revision number/sha being deployed.}

	user=${4:# User who deployed.}
	rollbar_user=${5:# Rollbar username of the user who deployed.}
	comment=${6:# Deploy comment (e.g. what is being deployed).}
	url=${7:https://api.rollbar.com/api/1/deploy/}
	validate_certs=${8:yes}

endsnippet

snippet airbrake_deployment "Notify airbrake about app deployments" b
airbrake_deployment: >
	token=${1:# API token.}
	environment=${2:# The airbrake environment name, typically 'production', 'staging', etc.}

	user=${3:# The username of the person doing the deployment}
	repo=${4:# URL of the project repository}
	revision=${5:# A hash, number, tag, or other identifier showing what revision was deployed}
	url=${6:https://airbrake.io/deploys.txt}
	validate_certs=${7:yes}

endsnippet

snippet pingdom "Pause/unpause Pingdom alerts" b
pingdom: >
	state=${1:running|paused}
	checkid=${2:# Pingdom ID of the check.}
	uid=${3:# Pingdom user ID.}
	passwd=${4:# Pingdom user password.}
	key=${5:# Pingdom API key.}

endsnippet

snippet pagerduty "Create PagerDuty maintenance windows" b
pagerduty: >
	state=${1:running|started|ongoing|absent}
	token=${2:# A pagerduty token, generated on the pagerduty site. It is used for authorization.}

	name=${3:# PagerDuty unique subdomain. Obsolete. It is not used with PagerDuty REST v2 API.}
	user=${4:# PagerDuty user ID. Obsolete. Please, use I(token) for authorization.}
	requester_id=${5:# ID of user making the request. Only needed when creating a maintenance_window.}
	service=${6:# A comma separated list of PagerDuty service IDs.}
	window_id=${7:# ID of maintenance window. Only needed when absent a maintenance_window.}
	hours=${8:1}
	minutes=${9:0}
	desc=${10:Created by Ansible}
	validate_certs=${11:yes}

endsnippet

snippet stackdriver "Send code deploy and annotation events to stackdriver" b
stackdriver: >
	key=${1:# API key.}

	event=${2:annotation|deploy}
	revision_id=${3:# The revision of the code that was deployed. Required for deploy events}
	deployed_by=${4:Ansible}
	deployed_to=${5:# The environment code was deployed to. (ie: development, staging, production)}
	repository=${6:# The repository (or project) deployed}
	msg=${7:# The contents of the annotation message, in plain text. Limited to 256 characters. Required for annotation.}
	annotated_by=${8:Ansible}
	level=${9:#INFO|WARN|ERROR}
	instance_id=${10:# id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown}
	event_epoch=${11:# Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.}

endsnippet

snippet spectrum_device "Creates/deletes devices in CA Spectrum." b
spectrum_device: >
	device=${1:# IP address of the device.}
	landscape=${2:# Landscape handle of the SpectroServer to which add or remove the device.}
	url=${3:# HTTP, HTTPS URL of the Oneclick server in the form (http|https)://host.domain[:port]}
	url_username=${4:# Oneclick user name.}
	url_password=${5:# Oneclick user password.}

	community=${6:# SNMP community used for device discovery.}
	state=${7:#present|absent}
	use_proxy=${8:yes}
	validate_certs=${9:yes}
	agentport=${10:161}

endsnippet

snippet zabbix_template "Create/update/delete/dump Zabbix template" b
zabbix_template: >
	server_url=${1:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${2:# Zabbix user name.}
	login_password=${3:# Zabbix user password.}
	http_login_user=${4:# Basic Auth login}

	template_name=${5:# Name of Zabbix template.}
	template_json=${6:# JSON dump of templates to import.}
	template_xml=${7:# XML dump of templates to import.}
	template_groups=${8:# List of host groups to add template to when template is created.}
	link_templates=${9:# List of template names to be linked to the template.}
	clear_templates=${10:# List of template names to be unlinked and cleared from the template.}
	macros=${11:# List of user macros to create for the template.}
	dump_format=${12:#json|xml}
	state=${13:#present|absent|dump}
	http_login_password=${14:# Basic Auth password}
	timeout=${15:10}
	validate_certs=${16:yes}

endsnippet

snippet zabbix_mediatype "Create/Update/Delete Zabbix media types" b
zabbix_mediatype: >
	name=${1:# Name of the media type.}
	type=${2:email|script|sms|jabber|ez_texting}
	server_url=${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${4:# Zabbix user name.}
	login_password=${5:# Zabbix user password.}
	http_login_user=${6:# Basic Auth login}

	state=${7:#present|absent}
	status=${8:#enabled|disabled}
	max_sessions=${9:1}
	max_attempts=${10:3}
	attempt_interval=${11:10}
	script_name=${12:# The name of the executed script.}
	script_params=${13:# List of script parameters.}
	gsm_modem=${14:# Serial device name of the gsm modem.}
	username=${15:# Username or Jabber identifier.}
	password=${16:# Authentication password.}
	smtp_server=${17:localhost}
	smtp_server_port=${18:25}
	smtp_helo=${19:localhost}
	smtp_email=${20:# Email address from which notifications will be sent.}
	smtp_authentication=${21:no}
	smtp_security=${22:None|STARTTLS|SSL/TLS}
	smtp_verify_host=${23:no}
	smtp_verify_peer=${24:no}
	message_text_limit=${25:USA|Canada}
	http_login_password=${26:# Basic Auth password}
	timeout=${27:10}
	validate_certs=${28:yes}

endsnippet

snippet zabbix_group "Create/delete Zabbix host groups" b
zabbix_group: >
	host_groups=${1:# List of host groups to create or delete.}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	state=${6:#present|absent}
	http_login_password=${7:# Basic Auth password}
	timeout=${8:10}
	validate_certs=${9:yes}

endsnippet

snippet zabbix_host "Create/update/delete Zabbix hosts" b
zabbix_host: >
	host_name=${1:# Name of the host in Zabbix.}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	visible_name=${6:# Visible name of the host in Zabbix.}
	description=${7:# Description of the host in Zabbix.}
	host_groups=${8:# List of host groups the host is part of.}
	link_templates=${9:# List of templates linked to the host.}
	inventory_mode=${10:automatic|manual|disabled}
	inventory_zabbix=${11:# Add Facts for a zabbix inventory (e.g. Tag) (see example below).}
	status=${12:#enabled|disabled}
	state=${13:#present|absent}
	proxy=${14:# The name of the Zabbix proxy to be used.}
	interfaces=${15:[]}
	tls_connect=${16:1}
	tls_accept=${17:1}
	tls_psk_identity=${18:# It is a unique name by which this specific PSK is referred to by Zabbix components}
	tls_psk=${19:# PSK value is a hard to guess string of hexadecimal digits.}
	ca_cert=${20:# Required certificate issuer.}
	tls_subject=${21:# Required certificate subject.}
	ipmi_authtype=${22:# IPMI authentication algorithm.}
	ipmi_privilege=${23:# IPMI privilege level.}
	ipmi_username=${24:# IPMI username.}
	ipmi_password=${25:# IPMI password.}
	force=${26:yes}
	http_login_password=${27:# Basic Auth password}
	timeout=${28:10}
	validate_certs=${29:yes}

endsnippet

snippet zabbix_host_info "Gather information about Zabbix host" b
zabbix_host_info: >
	server_url=${1:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${2:# Zabbix user name.}
	login_password=${3:# Zabbix user password.}
	http_login_user=${4:# Basic Auth login}

	host_name=${5:# Name of the host in Zabbix.}
	host_ip=${6:# Host interface IP of the host in Zabbix.}
	exact_match=${7:no}
	remove_duplicate=${8:yes}
	host_inventory=${9:# List of host inventory keys to display in result.}
	http_login_password=${10:# Basic Auth password}
	timeout=${11:10}
	validate_certs=${12:yes}

endsnippet

snippet zabbix_map "Create/update/delete Zabbix maps" b
zabbix_map: >
	name=${1:# Name of the map.}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	data=${6:# Graph written in DOT language.}
	state=${7:#present|absent}
	width=${8:800}
	height=${9:600}
	margin=${10:40}
	expand_problem=${11:yes}
	highlight=${12:yes}
	label_type=${13:label|ip|#name|status|nothing|custom}
	default_image=${14:# Name of the Zabbix image used to display the element if this element doesn't have the C(zbx_image) attribute defined.}
	http_login_password=${15:# Basic Auth password}
	timeout=${16:10}
	validate_certs=${17:yes}

endsnippet

snippet zabbix_group_info "Gather information about Zabbix hostgroup" b
zabbix_group_info: >
	hostgroup_name=${1:# Name of the hostgroup in Zabbix.}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	http_login_password=${6:# Basic Auth password}
	timeout=${7:10}
	validate_certs=${8:yes}

endsnippet

snippet zabbix_hostmacro "Create/update/delete Zabbix host macros" b
zabbix_hostmacro: >
	host_name=${1:# Name of the host.}
	macro_name=${2:# Name of the host macro without the enclosing curly braces and the leading dollar sign.}
	server_url=${3:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${4:# Zabbix user name.}
	login_password=${5:# Zabbix user password.}
	http_login_user=${6:# Basic Auth login}

	macro_value=${7:# Value of the host macro.}
	state=${8:#present|absent}
	force=${9:yes}
	http_login_password=${10:# Basic Auth password}
	timeout=${11:10}
	validate_certs=${12:yes}

endsnippet

snippet zabbix_action "Create/Delete/Update Zabbix actions" b
zabbix_action: >
	name=${1:# Name of the action}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	event_source=${6:trigger|discovery|auto_registration|internal}
	state=${7:#present|absent}
	status=${8:#enabled|disabled}
	pause_in_maintenance=${9:yes}
	esc_period=${10:# Default operation step duration. Must be greater than 60 seconds. Accepts seconds, time unit with suffix and user macro.}
	conditions=${11:# List of dictionaries of conditions to evaluate.}
	eval_type=${12:andor|and|or|custom_expression}
	formula=${13:# User-defined expression to be used for evaluating conditions of filters with a custom expression.}
	default_message=${14:# Problem message default text.}
	default_subject=${15:# Problem message default subject.}
	recovery_default_message=${16:# Recovery message text.}
	recovery_default_subject=${17:# Recovery message subject.}
	acknowledge_default_message=${18:# Update operation (known as "Acknowledge operation" before Zabbix 4.0) message text.}
	acknowledge_default_subject=${19:# Update operation (known as "Acknowledge operation" before Zabbix 4.0) message subject.}
	operations=${20:# List of action operations}
	recovery_operations=${21:# List of recovery operations.}
	acknowledge_operations=${22:# List of acknowledge operations.}
	http_login_password=${23:# Basic Auth password}
	timeout=${24:10}
	validate_certs=${25:yes}

endsnippet

snippet zabbix_group_info "Gather information about Zabbix hostgroup" b
zabbix_group_info: >
	hostgroup_name=${1:# Name of the hostgroup in Zabbix.}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	http_login_password=${6:# Basic Auth password}
	timeout=${7:10}
	validate_certs=${8:yes}

endsnippet

snippet zabbix_maintenance "Create Zabbix maintenance windows" b
zabbix_maintenance: >
	name=${1:# Unique name of maintenance window.}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	state=${6:#present|absent}
	host_names=${7:# Hosts to manage maintenance window for.}
	host_groups=${8:# Host groups to manage maintenance window for.}
	minutes=${9:10}
	desc=${10:Created by Ansible}
	collect_data=${11:yes}
	http_login_password=${12:# Basic Auth password}
	timeout=${13:10}
	validate_certs=${14:yes}

endsnippet

snippet zabbix_proxy "Create/delete/get/update Zabbix proxies" b
zabbix_proxy: >
	proxy_name=${1:# Name of the proxy in Zabbix.}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	description=${6:# Description of the proxy.}
	status=${7:#active|passive}
	tls_connect=${8:#no_encryption|PSK|certificate}
	tls_accept=${9:#no_encryption|PSK|certificate}
	ca_cert=${10:# Certificate issuer.}
	tls_subject=${11:# Certificate subject.}
	tls_psk_identity=${12:# PSK identity. Required if either I(tls_connect) or I(tls_accept) has PSK enabled.}
	tls_psk=${13:# The preshared key, at least 32 hex digits. Required if either I(tls_connect) or I(tls_accept) has PSK enabled.}
	state=${14:#present|absent}
	interface=${15:{}}
	http_login_password=${16:# Basic Auth password}
	timeout=${17:10}
	validate_certs=${18:yes}

endsnippet

snippet zabbix_host_info "Gather information about Zabbix host" b
zabbix_host_info: >
	server_url=${1:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${2:# Zabbix user name.}
	login_password=${3:# Zabbix user password.}
	http_login_user=${4:# Basic Auth login}

	host_name=${5:# Name of the host in Zabbix.}
	host_ip=${6:# Host interface IP of the host in Zabbix.}
	exact_match=${7:no}
	remove_duplicate=${8:yes}
	host_inventory=${9:# List of host inventory keys to display in result.}
	http_login_password=${10:# Basic Auth password}
	timeout=${11:10}
	validate_certs=${12:yes}

endsnippet

snippet zabbix_screen "Create/update/delete Zabbix screens" b
zabbix_screen: >
	screens=${1:# List of screens to be created/updated/deleted (see example).}
	server_url=${2:# URL of Zabbix server, with protocol (http or https). C(url) is an alias for C(server_url).}
	login_user=${3:# Zabbix user name.}
	login_password=${4:# Zabbix user password.}
	http_login_user=${5:# Basic Auth login}

	http_login_password=${6:# Basic Auth password}
	timeout=${7:10}
	validate_certs=${8:yes}

endsnippet

snippet hetzner_failover_ip "Manage Hetzner's failover IPs" b
hetzner_failover_ip: >
	failover_ip=${1:# T}
	hetzner_user=${2:# T}
	hetzner_password=${3:# T}

	state=${4:#routed|unrouted}
	value=${5:# The new value for the failover IP address.}
	timeout=${6:180}

endsnippet

snippet hetzner_failover_ip_info "Retrieve information on Hetzner's failover IPs" b
hetzner_failover_ip_info: >
	failover_ip=${1:# T}
	hetzner_user=${2:# T}
	hetzner_password=${3:# T}

endsnippet

snippet netcup_dns "manage Netcup DNS records" b
netcup_dns: >
	api_key=${1:# API key for authentification, must be obtained via the netcup CCP (U(https://ccp.netcup.net))}
	api_password=${2:# API password for authentification, must be obtained via the netcup CCP (https://ccp.netcup.net)}
	customer_id=${3:# Netcup customer id}
	domain=${4:# Domainname the records should be added / removed}
	type=${5:A|AAAA|MX|CNAME|CAA|SRV|TXT|TLSA|NS|DS}
	value=${6:# Record value}

	record=${7:@}
	solo=${8:no}
	priority=${9:# Record priority. Required for C(type=MX)}
	state=${10:#present|absent}

endsnippet

snippet snmp_facts "Retrieve facts for a device using SNMP" b
snmp_facts: >
	host=${1:# Set to target snmp server (normally C({{ inventory_hostname }})).}
	version=${2:v2|v2c|v3}

	community=${3:# The SNMP community string, required if version is v2/v2c.}
	level=${4:authNoPriv|authPriv}
	username=${5:# Username for SNMPv3.}
	integrity=${6:md5|sha}
	authkey=${7:# Authentication key.}
	privacy=${8:aes|des}
	privkey=${9:# Encryption key.}

endsnippet

snippet ipinfoio_facts "Retrieve IP geolocation facts of a host's IP address" b
ipinfoio_facts: >
	timeout=${1:10}
	http_agent=${2:ansible-ipinfoio-module/0.0.1}

endsnippet

snippet ip_netns "Manage network namespaces" b
ip_netns: >
	name=${1:# Name of the namespace}
	state=${2:#present|absent}

endsnippet

snippet cloudflare_dns "Manage Cloudflare DNS records" b
cloudflare_dns: >
	account_api_token=${1:# Account API token.}
	account_email=${2:# Account email.}
	zone=${3:# The name of the Zone to work with (e.g. "example.com").}

	algorithm=${4:# Algorithm number.}
	cert_usage=${5:0|1|2|3}
	hash_type=${6:1|2}
	key_tag=${7:# DNSSEC key tag.}
	port=${8:# Service port.}
	priority=${9:1}
	proto=${10:# Service protocol. Required for C(type=SRV) and C(type=TLSA).}
	proxied=${11:no}
	record=${12:@}
	selector=${13:0|1}
	service=${14:# Record service.}
	solo=${15:# Whether the record should be the only one for that record type and record name.}
	state=${16:absent|#present}
	timeout=${17:30}
	ttl=${18:1}
	type=${19:A|AAAA|CNAME|DS|MX|NS|SPF|SRV|SSHFP|TLSA|TXT}
	value=${20:# The record value.}
	weight=${21:1}

endsnippet

snippet haproxy "Enable, disable, and set weights for HAProxy backend servers using socket commands" b
haproxy: >
	host=${1:# Name of the backend host to change.}
	state=${2:disabled|drain|enabled}

	backend=${3:# Name of the HAProxy backend pool.}
	drain=${4:# Wait until the server has no active connections or until the timeout determined by wait_interval and wait_retries is reached.}
	shutdown_sessions=${5:no}
	socket=${6:/var/run/haproxy.sock}
	fail_on_not_found=${7:no}
	wait=${8:no}
	wait_interval=${9:5}
	wait_retries=${10:25}
	weight=${11:# The value passed in argument.}

endsnippet

snippet dnsimple "Interface with dnsimple.com (a DNS hosting service)" b
dnsimple: >
	account_email=${1:# Account email. If omitted, the environment variables C(DNSIMPLE_EMAIL) and C(DNSIMPLE_API_TOKEN) will be looked for.}
	account_api_token=${2:# Account API token. See I(account_email) for more information.}
	domain=${3:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNSimple.}
	record=${4:# Record to add, if blank a record for the domain will be created, supports the wildcard (*).}
	record_ids=${5:# List of records to ensure they either exist or do not exist.}
	type=${6:A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL}
	ttl=${7:3600}
	value=${8:# Record value.}
	priority=${9:# Record priority.}
	state=${10:#present|absent}
	solo=${11:no}

endsnippet

snippet omapi_host "Setup OMAPI hosts." b
omapi_host: >
	state=${1:absent|present}
	key_name=${2:# Sets the TSIG key name for authenticating against OMAPI server.}
	key=${3:# Sets the TSIG key content for authenticating against OMAPI server.}
	macaddr=${4:# Sets the lease host MAC address.}

	hostname=${5:# Sets the host lease hostname (mandatory if state=present).}
	host=${6:localhost}
	port=${7:7911}
	ip=${8:# Sets the lease host IP address.}
	statements=${9:[]}
	ddns=${10:no}

endsnippet

snippet lldp "get details reported by lldp" b
lldp:

endsnippet

snippet nsupdate "Manage DNS records." b
nsupdate: >
	server=${1:# Apply DNS modification on this server.}
	record=${2:# Sets the DNS record to modify. When zone is omitted this has to be absolute (ending with a dot).}

	state=${3:#present|absent}
	port=${4:53}
	key_name=${5:# Use TSIG key name to authenticate against DNS C(server)}
	key_secret=${6:# Use TSIG key secret, associated with C(key_name), to authenticate against C(server)}
	key_algorithm=${7:HMAC-MD5.SIG-ALG.REG.INT|#hmac-md5|hmac-sha1|hmac-sha224|hmac-sha256|hmac-sha384|hmac-sha512}
	zone=${8:# DNS record will be modified on this C(zone).}
	type=${9:A}
	ttl=${10:3600}
	value=${11:# Sets the record value.}
	protocol=${12:#tcp|udp}

endsnippet

snippet ipify_facts "Retrieve the public IP of your internet gateway" b
ipify_facts: >
	api_url=${1:https://api.ipify.org/}
	timeout=${2:10}
	validate_certs=${3:yes}

endsnippet

snippet nmcli "Manage Networking" b
nmcli: >
	state=${1:absent|present}
	conn_name=${2:# The name used to call the connection. Pattern is <type>[-<ifname>][-<num>].}

	autoconnect=${3:yes}
	ifname=${4:# The interface to bind the connection to.}
	type=${5:bond|bond-slave|bridge|bridge-slave|ethernet|generic|ipip|sit|team|team-slave|vlan|vxlan}
	mode=${6:802.3ad|active-backup|balance-alb|#balance-rr|balance-tlb|balance-xor|broadcast}
	master=${7:# Master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.}
	ip4=${8:# The IPv4 address to this interface.}
	gw4=${9:# The IPv4 gateway for this interface.}
	dns4=${10:# A list of up to 3 dns servers.}
	dns4_search=${11:# A list of DNS search domains.}
	ip6=${12:# The IPv6 address to this interface.}
	gw6=${13:# The IPv6 gateway for this interface.}
	dns6=${14:# A list of up to 3 dns servers.}
	dns6_search=${15:# A list of DNS search domains.}
	mtu=${16:# The connection MTU, e.g. 9000. This can't be applied when creating the interface and is done once the interface has been created.}
	dhcp_client_id=${17:# DHCP Client Identifier sent to the DHCP server.}
	primary=${18:# This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'.}
	miimon=${19:# This is only used with bond - miimon.}
	downdelay=${20:# This is only used with bond - downdelay.}
	updelay=${21:# This is only used with bond - updelay.}
	arp_interval=${22:# This is only used with bond - ARP interval.}
	arp_ip_target=${23:# This is only used with bond - ARP IP target.}
	stp=${24:yes}
	priority=${25:128}
	forwarddelay=${26:15}
	hellotime=${27:2}
	maxage=${28:20}
	ageingtime=${29:300}
	mac=${30:# This is only used with bridge - MAC address of the bridge.}
	slavepriority=${31:32}
	path_cost=${32:100}
	hairpin=${33:yes}
	vlanid=${34:# This is only used with VLAN - VLAN ID in range <0-4095>.}
	vlandev=${35:# This is only used with VLAN - parent device this VLAN is on, can use ifname.}
	flags=${36:# This is only used with VLAN - flags.}
	ingress=${37:# This is only used with VLAN - VLAN ingress priority mapping.}
	egress=${38:# This is only used with VLAN - VLAN egress priority mapping.}
	vxlan_id=${39:# This is only used with VXLAN - VXLAN ID.}
	vxlan_remote=${40:# This is only used with VXLAN - VXLAN destination IP address.}
	vxlan_local=${41:# This is only used with VXLAN - VXLAN local IP address.}
	ip_tunnel_dev=${42:# This is used with IPIP/SIT - parent device this IPIP/SIT tunnel, can use ifname.}
	ip_tunnel_remote=${43:# This is used with IPIP/SIT - IPIP/SIT destination IP address.}
	ip_tunnel_local=${44:# This is used with IPIP/SIT - IPIP/SIT local IP address.}

endsnippet

snippet dnsmadeeasy "Interface with dnsmadeeasy.com (a DNS hosting service)." b
dnsmadeeasy: >
	account_key=${1:# Account API Key.}
	account_secret=${2:# Account Secret Key.}
	domain=${3:# Domain to work with. Can be the domain name (e.g. "mydomain.com") or the numeric ID of the domain in DNS Made Easy (e.g. "839989") for faster resolution}
	state=${4:present|absent}
	systemDescription=${5:}
	maxEmails=${6:1}
	protocol=${7:TCP|UDP|#HTTP|DNS|SMTP|HTTPS}
	port=${8:80}
	sensitivity=${9:Low|#Medium|High}
	contactList=${10:}

	sandbox=${11:no}
	record_name=${12:# Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in "result" regardless of the state argument.}
	record_type=${13:A|AAAA|CNAME|ANAME|HTTPRED|MX|NS|PTR|SRV|TXT}
	record_value=${14:# Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value>"
}
	record_ttl=${15:1800}
	validate_certs=${16:yes}
	monitor=${17:no}
	httpFqdn=${18:# The fully qualified domain name used by the monitor.}
	httpFile=${19:# The file at the Fqdn that the monitor queries for HTTP or HTTPS.}
	httpQueryString=${20:# The string in the httpFile that the monitor queries for HTTP or HTTPS.}
	failover=${21:no}
	autoFailover=${22:no}
	ip1=${23:# Primary IP address for the failover.}
	ip2=${24:# Secondary IP address for the failover.}
	ip3=${25:# Tertiary IP address for the failover.}
	ip4=${26:# Quaternary IP address for the failover.}
	ip5=${27:# Quinary IP address for the failover.}

endsnippet

snippet slurp "Slurps a file from remote nodes" b
slurp: >
	src=${1:# The file on the remote system to fetch. This I(must) be a file, not a directory.}

endsnippet

snippet uri "Interacts with webservices" b
uri: >
	url=${1:# HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path}

	dest=${2:# A path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.}
	url_username=${3:# A username for the module to use for Digest, Basic or WSSE authentication.}
	url_password=${4:# A password for the module to use for Digest, Basic or WSSE authentication.}
	body=${5:# The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON. If C(body_format) is set to 'form-urlencoded' it will convert a dictionary or list of tuples into an 'application/x-www-form-urlencoded' string. (Added in v2.7)}
	body_format=${6:form-urlencoded|json|#raw}
	method=${7:GET}
	return_content=${8:no}
	force_basic_auth=${9:no}
	follow_redirects=${10:all|no|none|#safe|urllib2|yes}
	creates=${11:# A filename, when it already exists, this step will not be run.}
	removes=${12:# A filename, when it does not exist, this step will not be run.}
	status_code=${13:[200]}
	timeout=${14:30}
	headers=${15:# Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) or C(form-urlencoded) for I(body_format).}
	validate_certs=${16:yes}
	client_cert=${17:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${18:# PEM formatted file that contains your private key to be used for SSL client authentication.}
	src=${19:# Path to file to be submitted to the remote server.}
	remote_src=${20:no}
	force=${21:no}
	use_proxy=${22:yes}
	unix_socket=${23:# Path to Unix domain socket to use for connection}
	http_agent=${24:ansible-httpget}
	mode=${25:# The permissions the resulting file or directory should have.}
	owner=${26:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${27:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${28:# The user part of the SELinux file context.}
	serole=${29:# The role part of the SELinux file context.}
	setype=${30:# The type part of the SELinux file context.}
	selevel=${31:s0}
	unsafe_writes=${32:no}
	attributes=${33:# The attributes the resulting file or directory should have.}

endsnippet

snippet get_url "Downloads files from HTTP, HTTPS, or FTP to node" b
get_url: >
	url=${1:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}
	dest=${2:# Absolute path of where to download the file to.}

	tmp_dest=${3:# Absolute path of where temporary file is downloaded to.}
	force=${4:no}
	backup=${5:no}
	sha256sum=${6:}
	checksum=${7:}
	use_proxy=${8:yes}
	validate_certs=${9:yes}
	timeout=${10:10}
	headers=${11:# Add custom HTTP headers to a request in hash/dict format.}
	url_username=${12:# The username for use in HTTP basic authentication.}
	url_password=${13:# The password for use in HTTP basic authentication.}
	force_basic_auth=${14:no}
	client_cert=${15:# PEM formatted certificate chain file to be used for SSL client authentication.}
	client_key=${16:# PEM formatted file that contains your private key to be used for SSL client authentication.}
	http_agent=${17:ansible-httpget}
	mode=${18:# The permissions the resulting file or directory should have.}
	owner=${19:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group=${20:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	seuser=${21:# The user part of the SELinux file context.}
	serole=${22:# The role part of the SELinux file context.}
	setype=${23:# The type part of the SELinux file context.}
	selevel=${24:s0}
	unsafe_writes=${25:no}
	attributes=${26:# The attributes the resulting file or directory should have.}

endsnippet

snippet exo_dns_domain "Manages domain records on Exoscale DNS API." b
exo_dns_domain: >
	name=${1:# Name of the record.}

	state=${2:#present|absent}
	api_key=${3:# API key of the Exoscale DNS API.}
	api_secret=${4:# Secret key of the Exoscale DNS API.}
	api_timeout=${5:10}
	api_region=${6:cloudstack}
	validate_certs=${7:yes}

endsnippet

snippet exo_dns_record "Manages DNS records on Exoscale DNS." b
exo_dns_record: >
	domain=${1:# Domain the record is related to.}

	name=${2:}
	record_type=${3:#A|ALIAS|CNAME|MX|SPF|URL|TXT|NS|SRV|NAPTR|PTR|AAAA|SSHFP|HINFO|POOL}
	content=${4:# Content of the record.}
	ttl=${5:3600}
	prio=${6:# Priority of the record.}
	multiple=${7:no}
	state=${8:#present|absent}
	api_key=${9:# API key of the Exoscale DNS API.}
	api_secret=${10:# Secret key of the Exoscale DNS API.}
	api_timeout=${11:10}
	api_region=${12:cloudstack}
	validate_certs=${13:yes}

endsnippet

snippet netbox_site "Creates or removes sites from Netbox" b
netbox_site: >
	netbox_url=${1:# URL of the Netbox instance resolvable by Ansible control host}
	netbox_token=${2:# The token created within Netbox to authorize API access}
	data=${3:# Defines the site configuration}

	state=${4:absent|#present}
	validate_certs=${5:yes}

endsnippet

snippet netbox_interface "Creates or removes interfaces from Netbox" b
netbox_interface: >
	netbox_url=${1:# URL of the Netbox instance resolvable by Ansible control host}
	netbox_token=${2:# The token created within Netbox to authorize API access}
	data=${3:# Defines the prefix configuration}

	state=${4:absent|#present}
	validate_certs=${5:yes}

endsnippet

snippet netbox_ip_address "Creates or removes IP addresses from Netbox" b
netbox_ip_address: >
	netbox_url=${1:# URL of the Netbox instance resolvable by Ansible control host}
	netbox_token=${2:# The token created within Netbox to authorize API access}
	data=${3:# Defines the IP address configuration}

	state=${4:absent|new|#present}
	validate_certs=${5:yes}

endsnippet

snippet netbox_device "Create, update or delete devices within Netbox" b
netbox_device: >
	netbox_url=${1:# URL of the Netbox instance resolvable by Ansible control host}
	netbox_token=${2:# The token created within Netbox to authorize API access}
	data=${3:# Defines the device configuration}

	state=${4:absent|#present}
	validate_certs=${5:yes}

endsnippet

snippet netbox_prefix "Creates or removes prefixes from Netbox" b
netbox_prefix: >
	netbox_url=${1:# URL of the Netbox instance resolvable by Ansible control host}
	netbox_token=${2:# The token created within Netbox to authorize API access}
	data=${3:# Defines the prefix configuration}

	state=${4:absent|#present}
	first_available=${5:no}
	validate_certs=${6:yes}

endsnippet

snippet nios_member "Configure Infoblox NIOS members" b
nios_member: >
	host_name=${1:# Specifies the host name of the member to either add or remove from the NIOS instance.}
	vip_setting=${2:# Configures the network settings for the grid member.}
	ipv6_setting=${3:# Configures the IPv6 settings for the grid member.}

	config_addr_type=${4:IPV4}
	comment=${5:# A descriptive comment of the Grid member.}
	extattrs=${6:# Extensible attributes associated with the object.}
	enable_ha=${7:# If set to True, the member has two physical nodes (HA pair).}
	router_id=${8:# Virtual router identifier. Provide this ID if "ha_enabled" is set to "true". This is a unique VRID number (from 1 to 255) for the local subnet.}
	lan2_enabled=${9:# When set to "true", the LAN2 port is enabled as an independent port or as a port for failover purposes.}
	lan2_port_setting=${10:# Settings for the Grid member LAN2 port if 'lan2_enabled' is set to "true".}
	platform=${11:INFOBLOX}
	node_info=${12:# Configures the node information list with detailed status report on the operations of the Grid Member.}
	mgmt_port_setting=${13:# Settings for the member MGMT port.}
	upgrade_group=${14:Default}
	use_syslog_proxy_setting=${15:# Use flag for external_syslog_server_enable , syslog_servers, syslog_proxy_setting, syslog_size}
	external_syslog_server_enable=${16:# Determines if external syslog servers should be enabled}
	syslog_servers=${17:# The list of external syslog servers.}
	pre_provisioning=${18:# Pre-provisioning information.}
	create_token=${19:no}
	state=${20:#present|absent}
	provider=${21:# A dict object containing connection details.}

endsnippet

snippet nios_dns_view "Configure Infoblox NIOS DNS views" b
nios_dns_view: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system. User can also update the hostname as it is possible to pass a dict containing I(new_name), I(old_name). See examples.}
	network_view=${2:default}

	extattrs=${3:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${4:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${5:#present|absent}
	provider=${6:# A dict object containing connection details.}

endsnippet

snippet nios_zone "Configure Infoblox NIOS DNS zones" b
nios_zone: >
	fqdn=${1:# Specifies the qualified domain name to either add or remove from the NIOS instance based on the configured C(state) value.}
	view=${2:default}

	grid_primary=${3:# Configures the grid primary servers for this zone.}
	grid_secondaries=${4:# Configures the grid secondary servers for this zone.}
	ns_group=${5:# Configures the name server group for this zone. Name server group is mutually exclusive with grid primary and grid secondaries.}
	restart_if_needed=${6:# If set to true, causes the NIOS DNS service to restart and load the new zone configuration}
	zone_format=${7:FORWARD}
	extattrs=${8:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${9:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet nios_network "Configure Infoblox NIOS network object" b
nios_network: >
	network=${1:# Specifies the network to add or remove from the system.  The value should use CIDR notation.}
	network_view=${2:default}

	options=${3:# Configures the set of DHCP options to be included as part of the configured network instance.  This argument accepts a list of values (see suboptions).  When configuring suboptions at least one of C(name) or C(num) must be specified.}
	extattrs=${4:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${5:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	container=${6:# If set to true it'll create the network container to be added or removed from the system.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet nios_txt_record "Configure Infoblox NIOS txt records" b
nios_txt_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system}
	view=${2:default}

	text=${3:# Text associated with the record. It can contain up to 255 bytes per substring, up to a total of 512 bytes. To enter leading, trailing, or embedded spaces in the text, add quotes around the text to preserve the spaces.}
	ttl=${4:# Configures the TTL to be associated with this tst record}
	extattrs=${5:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${6:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet nios_naptr_record "Configure Infoblox NIOS NAPTR records" b
nios_naptr_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system}
	view=${2:default}
	order=${3:# Configures the order (0-65535) for this NAPTR record. This parameter specifies the order in which the NAPTR rules are applied when multiple rules are present.}
	preference=${4:# Configures the preference (0-65535) for this NAPTR record. The preference field determines the order NAPTR records are processed when multiple records with the same order parameter are present.}
	replacement=${5:# Configures the replacement field for this NAPTR record. For nonterminal NAPTR records, this field specifies the next domain name to look up.}

	services=${6:# Configures the services field (128 characters maximum) for this NAPTR record. The services field contains protocol and service identifiers, such as "http+E2U" or "SIPS+D2T".}
	flags=${7:# Configures the flags field for this NAPTR record. These control the interpretation of the fields for an NAPTR record object. Supported values for the flags field are "U", "S", "P" and "A".}
	regexp=${8:# Configures the regexp field for this NAPTR record. This is the regular expression-based rewriting rule of the NAPTR record. This should be a POSIX compliant regular expression, including the substitution rule and flags. Refer to RFC 2915 for the field syntax details.}
	ttl=${9:# Configures the TTL to be associated with this NAPTR record}
	extattrs=${10:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${11:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${12:#present|absent}
	provider=${13:# A dict object containing connection details.}

endsnippet

snippet nios_ptr_record "Configure Infoblox NIOS PTR records" b
nios_ptr_record: >
	ipv4addr=${1:# The IPv4 Address of the record. Mutually exclusive with the ipv6addr.}
	ipv6addr=${2:# The IPv6 Address of the record. Mutually exclusive with the ipv4addr.}
	ptrdname=${3:# The domain name of the DNS PTR record in FQDN format.}

	name=${4:# The name of the DNS PTR record in FQDN format to add or remove from the system. The field is required only for an PTR object in Forward Mapping Zone.}
	view=${5:# Sets the DNS view to associate this a record with. The DNS view must already be configured on the system}
	ttl=${6:# Time To Live (TTL) value for the record. A 32-bit unsigned integer that represents the duration, in seconds, that the record is valid (cached). Zero indicates that the record should not be cached.}
	extattrs=${7:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${8:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance. Maximum 256 characters.}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet nios_host_record "Configure Infoblox NIOS host records" b
nios_host_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system. User can also update the hostname as it is possible to pass a dict containing I(new_name), I(old_name). See examples.}
	view=${2:default}

	configure_for_dns=${3:yes}
	ipv4addrs=${4:# Configures the IPv4 addresses for this host record.  This argument accepts a list of values (see suboptions)}
	ipv6addrs=${5:# Configures the IPv6 addresses for the host record.  This argument accepts a list of values (see options)}
	aliases=${6:# Configures an optional list of additional aliases to add to the host record. These are equivalent to CNAMEs but held within a host record. Must be in list format.}
	ttl=${7:# Configures the TTL to be associated with this host record}
	extattrs=${8:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${9:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet nios_network_view "Configure Infoblox NIOS network views" b
nios_network_view: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system. User can also update the hostname as it is possible to pass a dict containing I(new_name), I(old_name). See examples.}

	extattrs=${2:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${3:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${4:#present|absent}
	provider=${5:# A dict object containing connection details.}

endsnippet

snippet nios_srv_record "Configure Infoblox NIOS SRV records" b
nios_srv_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system}
	view=${2:default}
	port=${3:# Configures the port (0-65535) of this SRV record.}
	priority=${4:# Configures the priority (0-65535) for this SRV record.}
	target=${5:# Configures the target FQDN for this SRV record.}
	weight=${6:# Configures the weight (0-65535) for this SRV record.}

	ttl=${7:# Configures the TTL to be associated with this host record}
	extattrs=${8:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${9:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet nios_nsgroup "Configure InfoBlox DNS Nameserver Groups" b
nios_nsgroup: >
	name=${1:# Specifies the name of the NIOS nameserver group to be managed.}

	grid_primary=${2:# This host is to be used as primary server in this nameserver group. It must be a grid member. This option is required when setting I(use_external_primaries) to C(false).}
	grid_secondaries=${3:# Configures the list of grid member hosts that act as secondary nameservers. This option is required when setting I(use_external_primaries) to C(true).}
	is_grid_default=${4:no}
	use_external_primary=${5:no}
	external_primaries=${6:# Configures a list of external nameservers (non-members of the grid). This option is required when setting I(use_external_primaries) to C(true).}
	external_secondaries=${7:# Allows to provide a list of external secondary nameservers, that are not members of the grid.}
	extattrs=${8:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${9:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${10:#present|absent}
	provider=${11:# A dict object containing connection details.}

endsnippet

snippet nios_mx_record "Configure Infoblox NIOS MX records" b
nios_mx_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system}
	view=${2:default}
	mail_exchanger=${3:# Configures the mail exchanger FQDN for this MX record.}
	preference=${4:# Configures the preference (0-65535) for this MX record.}

	ttl=${5:# Configures the TTL to be associated with this host record}
	extattrs=${6:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${7:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${8:#present|absent}
	provider=${9:# A dict object containing connection details.}

endsnippet

snippet nios_cname_record "Configure Infoblox NIOS CNAME records" b
nios_cname_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system}
	view=${2:default}
	canonical=${3:# Configures the canonical name for this CNAME record.}

	ttl=${4:# Configures the TTL to be associated with this CNAME record}
	extattrs=${5:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${6:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet nios_a_record "Configure Infoblox NIOS A records" b
nios_a_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system}
	view=${2:default}
	ipv4addr=${3:# Configures the IPv4 address for this A record. Users can dynamically allocate ipv4 address to A record by passing dictionary containing, I(nios_next_ip) and I(CIDR network range). See example}

	ttl=${4:# Configures the TTL to be associated with this A record}
	extattrs=${5:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${6:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet nios_aaaa_record "Configure Infoblox NIOS AAAA records" b
nios_aaaa_record: >
	name=${1:# Specifies the fully qualified hostname to add or remove from the system}
	view=${2:default}
	ipv6addr=${3:# Configures the IPv6 address for this AAAA record.}

	ttl=${4:# Configures the TTL to be associated with this AAAA record}
	extattrs=${5:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${6:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${7:#present|absent}
	provider=${8:# A dict object containing connection details.}

endsnippet

snippet nios_fixed_address "Configure Infoblox NIOS DHCP Fixed Address" b
nios_fixed_address: >
	ipaddr=${1:# IPV4/V6 address of the fixed address.}
	mac=${2:# The MAC address of the interface.}
	network=${3:# Specifies the network range in which ipaddr exists.}

	name=${4:# Specifies the hostname with which fixed DHCP ip-address is stored for respective mac.}
	network_view=${5:default}
	options=${6:# Configures the set of DHCP options to be included as part of the configured network instance.  This argument accepts a list of values (see suboptions).  When configuring suboptions at least one of C(name) or C(num) must be specified.}
	extattrs=${7:# Allows for the configuration of Extensible Attributes on the instance of the object.  This argument accepts a set of key / value pairs for configuration.}
	comment=${8:# Configures a text string comment to be associated with the instance of this object.  The provided text string will be configured on the object instance.}
	state=${9:#present|absent}
	provider=${10:# A dict object containing connection details.}

endsnippet

snippet ldap_passwd "Set passwords in LDAP." b
ldap_passwd: >
	passwd=${1:# The (plaintext) password to be set for I(dn).}
	dn=${2:# The DN of the entry to add or remove.}

	bind_dn=${3:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism.}
	bind_pw=${4:# The password to use with I(bind_dn).}
	server_uri=${5:ldapi:///}
	start_tls=${6:no}
	validate_certs=${7:yes}

endsnippet

snippet ldap_attr "Add or remove LDAP attribute values" b
ldap_attr: >
	name=${1:# The name of the attribute to modify.}
	values=${2:# The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples).}
	dn=${3:# The DN of the entry to add or remove.}

	state=${4:absent|exact|#present}
	params=${5:# Additional module parameters.}
	bind_dn=${6:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism.}
	bind_pw=${7:# The password to use with I(bind_dn).}
	server_uri=${8:ldapi:///}
	start_tls=${9:no}
	validate_certs=${10:yes}

endsnippet

snippet ldap_entry "Add or remove LDAP entries." b
ldap_entry: >
	dn=${1:# The DN of the entry to add or remove.}

	attributes=${2:# If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead.}
	objectClass=${3:# If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.}
	params=${4:# List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null).}
	state=${5:#present|absent}
	bind_dn=${6:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism.}
	bind_pw=${7:# The password to use with I(bind_dn).}
	server_uri=${8:ldapi:///}
	start_tls=${9:no}
	validate_certs=${10:yes}

endsnippet

snippet infinity "Manage Infinity IPAM using Rest API" b
infinity: >
	server_ip=${1:# Infinity server_ip with IP address.}
	username=${2:# Username to access Infinity.}
	password=${3:# Infinity password.}
	action=${4:add_network|delete_network|get_network|get_network_id|release_ip|release_network|reserve_network|reserve_next_available_ip}

	network_id=${5:}
	ip_address=${6:}
	network_address=${7:}
	network_size=${8:}
	network_name=${9:}
	network_location=${10:-1}
	network_type=${11:#lan|shared_lan|supernet}
	network_family=${12:#4|6|dual}

endsnippet

snippet rabbitmq_exchange "Manage rabbitMQ exchanges" b
rabbitmq_exchange: >
	name=${1:# Name of the exchange to create}

	state=${2:#present|absent}
	durable=${3:yes}
	exchange_type=${4:fanout|#direct|headers|topic}
	auto_delete=${5:no}
	internal=${6:no}
	arguments=${7:{}}
	login_user=${8:guest}
	login_password=${9:# RabbitMQ password for connection.}
	login_host=${10:localhost}
	login_port=${11:15672}
	login_protocol=${12:#http|https}
	ca_cert=${13:# CA certificate to verify SSL connection to management API.}
	client_cert=${14:# Client certificate to send on SSL connections to management API.}
	client_key=${15:# Private key matching the client certificate.}
	vhost=${16:/}

endsnippet

snippet rabbitmq_policy "Manage the state of policies in RabbitMQ" b
rabbitmq_policy: >
	name=${1:# The name of the policy to manage.}

	vhost=${2:/}
	apply_to=${3:#all|exchanges|queues}
	pattern=${4:# A regex of queues to apply the policy to. Required when C(state=present). This option is no longer required as of Ansible 2.9.}
	tags=${5:# A dict or string describing the policy. Required when C(state=present). This option is no longer required as of Ansible 2.9.}
	priority=${6:0}
	node=${7:rabbit}
	state=${8:#present|absent}

endsnippet

snippet rabbitmq_user "Manage RabbitMQ users" b
rabbitmq_user: >
	user=${1:# Name of user to add}

	password=${2:# Password of user to add.}
	tags=${3:# User tags specified as comma delimited}
	permissions=${4:[]}
	vhost=${5:/}
	node=${6:rabbit}
	configure_priv=${7:^$}
	write_priv=${8:^$}
	read_priv=${9:^$}
	force=${10:no}
	state=${11:#present|absent}
	update_password=${12:#on_create|always}

endsnippet

snippet rabbitmq_binding "Manage rabbitMQ bindings" b
rabbitmq_binding: >
	name=${1:# source exchange to create binding on.}
	destination=${2:# destination exchange or queue for the binding.}
	destination_type=${3:queue|exchange}

	state=${4:#present|absent}
	routing_key=${5:#}
	arguments=${6:{}}
	login_user=${7:guest}
	login_password=${8:# RabbitMQ password for connection.}
	login_host=${9:localhost}
	login_port=${10:15672}
	login_protocol=${11:#http|https}
	ca_cert=${12:# CA certificate to verify SSL connection to management API.}
	client_cert=${13:# Client certificate to send on SSL connections to management API.}
	client_key=${14:# Private key matching the client certificate.}
	vhost=${15:/}

endsnippet

snippet rabbitmq_vhost_limits "Manage the state of virtual host limits in RabbitMQ" b
rabbitmq_vhost_limits: >
	max_connections=${1:-1}
	max_queues=${2:-1}
	node=${3:# Name of the RabbitMQ Erlang node to manage.}
	state=${4:#present|absent}
	vhost=${5:/}

endsnippet

snippet rabbitmq_vhost "Manage the state of a virtual host in RabbitMQ" b
rabbitmq_vhost: >
	name=${1:# The name of the vhost to manage}

	node=${2:rabbit}
	tracing=${3:no}
	state=${4:#present|absent}

endsnippet

snippet rabbitmq_queue "Manage rabbitMQ queues" b
rabbitmq_queue: >
	name=${1:# Name of the queue}

	state=${2:#present|absent}
	durable=${3:yes}
	auto_delete=${4:no}
	message_ttl=${5:forever}
	auto_expires=${6:forever}
	max_length=${7:no limit}
	dead_letter_exchange=${8:# Optional name of an exchange to which messages will be republished if they}
	dead_letter_routing_key=${9:# Optional replacement routing key to use when a message is dead-lettered.}
	max_priority=${10:# Maximum number of priority levels for the queue to support.}
	arguments=${11:{}}
	login_user=${12:guest}
	login_password=${13:# RabbitMQ password for connection.}
	login_host=${14:localhost}
	login_port=${15:15672}
	login_protocol=${16:#http|https}
	ca_cert=${17:# CA certificate to verify SSL connection to management API.}
	client_cert=${18:# Client certificate to send on SSL connections to management API.}
	client_key=${19:# Private key matching the client certificate.}
	vhost=${20:/}

endsnippet

snippet rabbitmq_parameter "Manage RabbitMQ parameters" b
rabbitmq_parameter: >
	component=${1:# Name of the component of which the parameter is being set}
	name=${2:# Name of the parameter being set}

	value=${3:# Value of the parameter, as a JSON term}
	vhost=${4:/}
	node=${5:rabbit}
	state=${6:#present|absent}

endsnippet

snippet rabbitmq_plugin "Manage RabbitMQ plugins" b
rabbitmq_plugin: >
	names=${1:# Comma-separated list of plugin names. Also, accepts plugin name.}

	new_only=${2:no}
	state=${3:#enabled|disabled}
	prefix=${4:# Specify a custom install prefix to a Rabbit.}

endsnippet

snippet rabbitmq_global_parameter "Manage RabbitMQ global parameters" b
rabbitmq_global_parameter: >
	name=${1:# Name of the global parameter being set}

	value=${2:# Value of the global parameter, as a JSON term}
	node=${3:rabbit}
	state=${4:#present|absent}

endsnippet

snippet git "Deploy software (or files) from git checkouts" b
git: >
	repo=${1:# git, SSH, or HTTP(S) protocol address of the git repository.}
	dest=${2:# The path of where the repository should be checked out. This parameter is required, unless C(clone) is set to C(no).}

	version=${3:HEAD}
	accept_hostkey=${4:no}
	ssh_opts=${5:# Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be "-o StrictHostKeyChecking=no" (although this particular option is better set via C(accept_hostkey)).}
	key_file=${6:# Specify an optional private key file path, on the target host, to use for the checkout.}
	reference=${7:# Reference repository (see "git clone --reference ...")}
	remote=${8:origin}
	refspec=${9:# Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be "refs/meta/config".}
	force=${10:no}
	depth=${11:# Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.}
	clone=${12:yes}
	update=${13:yes}
	executable=${14:# Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
	bare=${15:no}
	umask=${16:# The umask to set before doing any checkouts, or any other repository maintenance.}
	recursive=${17:yes}
	track_submodules=${18:no}
	verify_commit=${19:no}
	archive=${20:# Specify archive file path with extension. If specified, creates an archive file of the specified format containing the tree structure for the source tree. Allowed archive formats ["zip", "tar.gz", "tar", "tgz"]}
	separate_git_dir=${21:# The path to place the cloned repository. If specified, Git repository can be separated from working tree.}
	gpg_whitelist=${22:[]}

endsnippet

snippet github_deploy_key "Manages deploy keys for GitHub repositories." b
github_deploy_key: >
	owner=${1:# The name of the individual account or organization that owns the GitHub repository.}
	repo=${2:# The name of the GitHub repository.}
	name=${3:# The name for the deploy key.}
	key=${4:# The SSH public key to add to the repository as a deploy key.}

	read_only=${5:yes}
	state=${6:#present|absent}
	force=${7:no}
	username=${8:# The username to authenticate with. Should not be set when using personal access token}
	password=${9:# The password to authenticate with. Alternatively, a personal access token can be used instead of I(username) and I(password) combination.}
	token=${10:# The OAuth2 token or personal access token to authenticate with. Mutually exclusive with I(password).}
	otp=${11:# The 6 digit One Time Password for 2-Factor Authentication. Required together with I(username) and I(password).}

endsnippet

snippet github_webhook_info "Query information about GitHub webhooks" b
github_webhook_info: >
	repository=${1:# Full name of the repository to configure a hook for}
	user=${2:# User to authenticate to GitHub as}

	password=${3:# Password to authenticate to GitHub with}
	token=${4:# Token to authenticate to GitHub with}
	github_url=${5:https://api.github.com}

endsnippet

snippet github_issue "View GitHub issue." b
github_issue: >
	repo=${1:# Name of repository from which issue needs to be retrieved.}
	organization=${2:# Name of the GitHub organization in which the repository is hosted.}
	issue=${3:# Issue number for which information is required.}

	action=${4:#get_status}

endsnippet

snippet github_release "Interact with GitHub Releases" b
github_release: >
	user=${1:# The GitHub account that owns the repository}
	repo=${2:# Repository name}
	action=${3:latest_release|create_release}

	token=${4:# GitHub Personal Access Token for authenticating. Mutually exclusive with C(password).}
	password=${5:# The GitHub account password for the user. Mutually exclusive with C(token).}
	tag=${6:# Tag name when creating a release. Required when using action is set to C(create_release).}
	target=${7:# Target of release when creating a release}
	name=${8:# Name of release when creating a release}
	body=${9:# Description of the release when creating a release}
	draft=${10:no}
	prerelease=${11:no}

endsnippet

snippet github_webhook_info "Query information about GitHub webhooks" b
github_webhook_info: >
	repository=${1:# Full name of the repository to configure a hook for}
	user=${2:# User to authenticate to GitHub as}

	password=${3:# Password to authenticate to GitHub with}
	token=${4:# Token to authenticate to GitHub with}
	github_url=${5:https://api.github.com}

endsnippet

snippet github_webhook "Manage GitHub webhooks" b
github_webhook: >
	repository=${1:# Full name of the repository to configure a hook for}
	url=${2:# URL to which payloads will be delivered}
	user=${3:# User to authenticate to GitHub as}

	content_type=${4:#form|json}
	secret=${5:# The shared secret between GitHub and the payload URL.}
	insecure_ssl=${6:no}
	events=${7:# A list of GitHub events the hook is triggered for. Events are listed at U(https://developer.github.com/v3/activity/events/types/). Required unless C(state) is C(absent)
}
	active=${8:yes}
	state=${9:absent|#present}
	password=${10:# Password to authenticate to GitHub with}
	token=${11:# Token to authenticate to GitHub with}
	github_url=${12:https://api.github.com}

endsnippet

snippet bzr "Deploy software (or files) from bzr branches" b
bzr: >
	name=${1:# SSH or HTTP protocol address of the parent branch.}
	dest=${2:# Absolute path of where the branch should be cloned to.}

	version=${3:head}
	force=${4:no}
	executable=${5:# Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}

endsnippet

snippet gitlab_deploy_key "Manages GitLab project deploy keys." b
gitlab_deploy_key: >
	project=${1:# Id or Full path of project in the form of group/name}
	title=${2:# Deploy key's title}
	key=${3:# Deploy key}
	state=${4:#present|absent}

	api_token=${5:# GitLab token for logging in.}
	can_push=${6:no}
	api_url=${7:# The resolvable endpoint for the API}
	api_username=${8:# The username to use for authentication against the API}
	api_password=${9:# The password to use for authentication against the API}
	validate_certs=${10:yes}

endsnippet

snippet gitlab_project_variable "Creates/updates/deletes GitLab Projects Variables" b
gitlab_project_variable: >
	api_token=${1:# GitLab access token with API permissions.}
	project=${2:# The path and name of the project.}

	state=${3:#present|absent}
	purge=${4:no}
	vars=${5:{}}
	api_url=${6:# The resolvable endpoint for the API}
	api_username=${7:# The username to use for authentication against the API}
	api_password=${8:# The password to use for authentication against the API}
	validate_certs=${9:yes}

endsnippet

snippet git_config "Read and write git configuration" b
git_config: >
	list_all=${1:no}
	name=${2:# The name of the setting. If no value is supplied, the value will be read from the config if it has been set.}
	repo=${3:# Path to a git repository for reading and writing values from a specific repo.}
	scope=${4:local|global|system}
	state=${5:#present|absent}
	value=${6:# When specifying the name of a single setting, supply a value to set that setting to the given value.}

endsnippet

snippet gitlab_runner "Create, modify and delete GitLab Runners." b
gitlab_runner: >
	api_token=${1:# Your private token to interact with the GitLab API.}
	description=${2:# The unique name of the runner.}
	registration_token=${3:# The registration token is used to register new runners.}

	url=${4:# The URL of the GitLab server, with protocol (i.e. http or https).}
	state=${5:#present|absent}
	active=${6:yes}
	locked=${7:no}
	access_level=${8:#ref_protected|not_protected}
	maximum_timeout=${9:3600}
	run_untagged=${10:yes}
	tag_list=${11:[]}
	api_url=${12:# The resolvable endpoint for the API}
	api_username=${13:# The username to use for authentication against the API}
	api_password=${14:# The password to use for authentication against the API}
	validate_certs=${15:yes}

endsnippet

snippet gitlab_hook "Manages GitLab project hooks." b
gitlab_hook: >
	project=${1:# Id or Full path of the project in the form of group/name.}
	hook_url=${2:# The url that you want GitLab to post to, this is used as the primary key for updates and deletion.}
	state=${3:#present|absent}

	api_token=${4:# GitLab token for logging in.}
	push_events=${5:yes}
	issues_events=${6:no}
	merge_requests_events=${7:no}
	tag_push_events=${8:no}
	note_events=${9:no}
	job_events=${10:no}
	pipeline_events=${11:no}
	wiki_page_events=${12:no}
	hook_validate_certs=${13:no}
	token=${14:# Secret token to validate hook messages at the receiver.}
	api_url=${15:# The resolvable endpoint for the API}
	api_username=${16:# The username to use for authentication against the API}
	api_password=${17:# The password to use for authentication against the API}
	validate_certs=${18:yes}

endsnippet

snippet gitlab_group "Creates/updates/deletes GitLab Groups" b
gitlab_group: >
	name=${1:# Name of the group you want to create.}

	server_url=${2:# The URL of the GitLab server, with protocol (i.e. http or https).}
	login_user=${3:# GitLab user name.}
	login_password=${4:# GitLab password for login_user}
	api_token=${5:# GitLab token for logging in.}
	path=${6:# The path of the group you want to create, this will be server_url/group_path}
	description=${7:# A description for the group.}
	state=${8:#present|absent}
	parent=${9:# Allow to create subgroups}
	visibility=${10:#private|internal|public}
	api_url=${11:# The resolvable endpoint for the API}
	api_username=${12:# The username to use for authentication against the API}
	api_password=${13:# The password to use for authentication against the API}
	validate_certs=${14:yes}

endsnippet

snippet github_key "Manage GitHub access keys." b
github_key: >
	token=${1:# GitHub Access Token with permission to list and create public keys.}
	name=${2:# SSH key name}

	pubkey=${3:# SSH public key value. Required when C(state=present).}
	state=${4:#present|absent}
	force=${5:yes}

endsnippet

snippet gitlab_user "Creates/updates/deletes GitLab Users" b
gitlab_user: >
	name=${1:# Name of the user you want to create}
	username=${2:# The username of the user.}
	password=${3:# The password of the user.}
	email=${4:# The email that belongs to the user.}

	server_url=${5:# The URL of the GitLab server, with protocol (i.e. http or https).}
	login_user=${6:# GitLab user name.}
	login_password=${7:# GitLab password for login_user}
	api_token=${8:# GitLab token for logging in.}
	sshkey_name=${9:# The name of the sshkey}
	sshkey_file=${10:# The ssh key itself.}
	group=${11:# Id or Full path of parent group in the form of group/name}
	access_level=${12:#guest|reporter|developer|master|maintainer|owner}
	state=${13:#present|absent}
	confirm=${14:yes}
	isadmin=${15:no}
	external=${16:no}
	api_url=${17:# The resolvable endpoint for the API}
	api_username=${18:# The username to use for authentication against the API}
	api_password=${19:# The password to use for authentication against the API}
	validate_certs=${20:yes}

endsnippet

snippet hg "Manages Mercurial (hg) repositories" b
hg: >
	repo=${1:# The repository address.}
	dest=${2:# Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no}

	revision=${3:# Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag.}
	force=${4:no}
	purge=${5:no}
	update=${6:yes}
	clone=${7:yes}
	executable=${8:# Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}

endsnippet

snippet subversion "Deploys a subversion repository" b
subversion: >
	repo=${1:# The subversion URL to the repository.}
	dest=${2:# Absolute path where the repository should be deployed.}

	revision=${3:HEAD}
	force=${4:no}
	in_place=${5:no}
	username=${6:# C(--username) parameter passed to svn.}
	password=${7:# C(--password) parameter passed to svn.}
	executable=${8:# Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
	checkout=${9:yes}
	update=${10:yes}
	export=${11:no}
	switch=${12:yes}

endsnippet

snippet gitlab_hook "Manages GitLab project hooks." b
gitlab_hook: >
	project=${1:# Id or Full path of the project in the form of group/name.}
	hook_url=${2:# The url that you want GitLab to post to, this is used as the primary key for updates and deletion.}
	state=${3:#present|absent}

	api_token=${4:# GitLab token for logging in.}
	push_events=${5:yes}
	issues_events=${6:no}
	merge_requests_events=${7:no}
	tag_push_events=${8:no}
	note_events=${9:no}
	job_events=${10:no}
	pipeline_events=${11:no}
	wiki_page_events=${12:no}
	hook_validate_certs=${13:no}
	token=${14:# Secret token to validate hook messages at the receiver.}
	api_url=${15:# The resolvable endpoint for the API}
	api_username=${16:# The username to use for authentication against the API}
	api_password=${17:# The password to use for authentication against the API}
	validate_certs=${18:yes}

endsnippet

snippet gitlab_project "Creates/updates/deletes GitLab Projects" b
gitlab_project: >
	name=${1:# The name of the project}

	server_url=${2:# The URL of the GitLab server, with protocol (i.e. http or https).}
	login_user=${3:# GitLab user name.}
	login_password=${4:# GitLab password for login_user}
	api_token=${5:# GitLab token for logging in.}
	group=${6:# Id or The full path of the group of which this projects belongs to.}
	path=${7:# The path of the project you want to create, this will be server_url/<group>/path}
	description=${8:# An description for the project.}
	issues_enabled=${9:yes}
	merge_requests_enabled=${10:yes}
	wiki_enabled=${11:yes}
	snippets_enabled=${12:yes}
	visibility=${13:#private|internal|public}
	import_url=${14:# Git repository which will be imported into gitlab.}
	state=${15:#present|absent}
	api_url=${16:# The resolvable endpoint for the API}
	api_username=${17:# The username to use for authentication against the API}
	api_password=${18:# The password to use for authentication against the API}
	validate_certs=${19:yes}

endsnippet

snippet bitbucket_pipeline_variable "Manages Bitbucket pipeline variables" b
bitbucket_pipeline_variable: >
	repository=${1:# The repository name.}
	username=${2:# The repository owner.}
	name=${3:# The pipeline variable name.}
	state=${4:absent|present}

	client_id=${5:# The OAuth consumer key.}
	client_secret=${6:# The OAuth consumer secret.}
	value=${7:# The pipeline variable value.}
	secured=${8:no}

endsnippet

snippet bitbucket_pipeline_key_pair "Manages Bitbucket pipeline SSH key pair" b
bitbucket_pipeline_key_pair: >
	repository=${1:# The repository name.}
	username=${2:# The repository owner.}
	state=${3:absent|present}

	client_id=${4:# OAuth consumer key.}
	client_secret=${5:# OAuth consumer secret.}
	public_key=${6:# The public key.}
	private_key=${7:# The private key.}

endsnippet

snippet bitbucket_access_key "Manages Bitbucket repository access keys" b
bitbucket_access_key: >
	repository=${1:# The repository name.}
	username=${2:# The repository owner.}
	label=${3:# The key label.}
	state=${4:absent|present}

	client_id=${5:# The OAuth consumer key.}
	client_secret=${6:# The OAuth consumer secret.}
	key=${7:# The SSH public key.}

endsnippet

snippet bitbucket_pipeline_known_host "Manages Bitbucket pipeline known hosts" b
bitbucket_pipeline_known_host: >
	repository=${1:# The repository name.}
	username=${2:# The repository owner.}
	name=${3:# The FQDN of the known host.}
	state=${4:absent|present}

	client_id=${5:# The OAuth consumer key.}
	client_secret=${6:# The OAuth consumer secret.}
	key=${7:# The public key.}

endsnippet

